<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HaloBank ‚Äî Solar System Calendar</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<style>
  :root {
    --bg:#0b0f18; --panel:#0f1422; --ink:#e8eefc; --muted:#97a3c0;
    --accent:#7bdcf3; --accent2:#8d9bff; --sun:#ffd26a; --earth:#69f; --ok:#43d1a0;
  }
  html,body {background:var(--bg); color:var(--ink); margin:0; font:14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
  .page {display:grid; grid-template-rows:auto 1fr auto; min-height:100vh;}
  header {display:flex; gap:16px; align-items:center; padding:12px 16px; background:linear-gradient(180deg, #0f1526 0, #0b0f18 100%); border-bottom:1px solid #18223d;}
  header h1 {font-size:16px; margin:0; letter-spacing:.02em;}
  header .pill {display:flex; gap:8px; align-items:center; background:#0f162b; border:1px solid #1c2746; padding:6px 10px; border-radius:9px;}
  header .pill label {color:var(--muted);}
  header input[type=file] {display:none;}
  header .btn, .pill .btn {background:#141b31; border:1px solid #202a4a; color:var(--ink); padding:6px 10px; border-radius:8px; cursor:pointer;}
  header .btn:hover,.pill .btn:hover {border-color:#314377;}
  #scene {position:relative; background:radial-gradient(1200px 600px at 50% -200px, #15224c55, #0b0f18 60%); min-height:300px;}
  #renderer {width:100%; height:100%; display:block; min-height:300px;}
  .legend {position:absolute; top:10px; right:10px; background:#0f162b; border:1px solid #1c2746; padding:8px 10px; border-radius:10px; color:var(--muted);}
  .legend .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:-1px;}
  .legend .sun{background:var(--sun);} .legend .earth{background:var(--earth);}
  .toolbar {position:absolute; left:10px; top:10px; display:flex; flex-direction:column; gap:8px;}
  .toolbar .toggle {background:#0f162b; border:1px solid #1c2746; border-radius:10px; padding:6px 8px; display:flex; gap:6px; align-items:center;}
  .toggle button{background:#141b31;color:var(--ink);border:1px solid #202a4a;border-radius:8px;padding:6px 8px;cursor:pointer}
  .toggle button.active{background:#1a2850;border-color:#2e3f72}
  .footnote {position:absolute; right:10px; bottom:10px; color:var(--muted); font-size:12px;}
  .tray {display:grid; grid-template-columns:320px 1fr; gap:14px; padding:12px 16px; border-top:1px solid #18223d; background:var(--panel); min-height:fit-content;}
  .card {background:#0f162b; border:1px solid #1c2746; border-radius:12px; overflow:hidden;}
  .card h3 {font-size:13px; color:#c8d6ff; margin:0; padding:10px 12px; border-bottom:1px solid #1c2746;}
  .card .body {padding:10px 12px; color:var(--ink); max-height:70vh; overflow-y:auto;}
  .card .body::-webkit-scrollbar {width:6px;}
  .card .body::-webkit-scrollbar-track {background:#0f162b;}
  .card .body::-webkit-scrollbar-thumb {background:#1c2746; border-radius:3px;}
  .card .body::-webkit-scrollbar-thumb:hover {background:#2a3856;}
  .row {display:flex; justify-content:space-between; gap:10px; padding:4px 0; color:var(--muted); word-wrap:break-word; align-items:flex-start;}
  .row b {color:var(--ink)}
  .row span {flex-shrink:1; min-width:0; text-align:right;}
  .chips {display:flex; gap:6px; flex-wrap:wrap; margin-top:6px;}
  .chip {font-size:12px; padding:4px 8px; border-radius:999px; background:#121a32; border:1px solid #23335f; color:#bfc9e6;}
  .filelist {max-height:220px; overflow:auto;}
  .filelist .item {padding:8px; border-bottom:1px solid #1a2544; cursor:pointer;}
  .filelist .item:hover {background:#121a2e;}
  .filelist .item.active {background:#1a2647;}
  .diff {font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; color:#bfead9;}
  .ok {color:var(--ok);}
  .warn {color:#ffcc66;}

  .hidden { display: none !important; }
  .collapsed {
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
    pointer-events: none;
  }
  .expanded {
    max-height: 2000px;
    opacity: 1;
    transition: max-height 0.3s ease-in, opacity 0.3s ease-in;
  }

  /* ‚ñº Inline dropdown rows */
  .row.toggle { cursor:pointer; user-select:none; }
  .row.toggle:hover { background:#121a2e; }
  .row .arrow { display:inline-block; width:12px; height:12px; margin-right:6px; transition:transform .15s ease; }
  .row.open .arrow { transform:rotate(90deg); }
  .row .desc { grid-column:1 / -1; color:#9fb0d9; padding:6px 2px 10px 18px; display:none; }
  .row.open + .desc { display:block; }

  /* Narrative story styling */
  .story { margin-top:10px; padding:12px 14px; background:#0e1324; border:1px solid #1b2547;
           border-radius:10px; color:#cfe1ff; line-height:1.45; }
  .story .lead { color:#fff; }

  /* Responsive layout for smaller screens */
  @media (max-width: 1024px) {
    .tray { grid-template-columns: 280px 1fr; gap: 10px; padding: 8px; }
    .card .body { max-height: 50vh; }
  }
  
  @media (max-width: 768px) {
    .tray { grid-template-columns: 1fr; }
    .card .body { max-height: 40vh; }
    header { flex-wrap: wrap; gap: 8px; }
    header .pill { flex: 1 1 auto; min-width: 200px; }
  }</style>
</head>
<body>
<div class="page">
  <header>
    <h1>HaloBank ‚Äî Solar-System Calendar</h1>
    <div class="pill">
      <label for="file">Upload</label>
      <button class="btn" id="btnUpload">Files‚Ä¶</button>
      <input id="file" type="file" multiple accept="image/*,video/*,.json,.txt,.heic,.heif,.mov,.mp4,.jpg,.jpeg,.png,.webp,.avif" />
      <button class="btn" id="btnSample">Load Sample</button>
    </div>
    <div class="pill">
      <label>Halo mode</label>
      <button class="btn" id="btnHaloOwn">Own ellipse</button>
      <button class="btn" id="btnHaloYear" class="active">Shared per year</button>
    </div>
    <div class="pill">
      <label>Site</label>
      <button class="btn" id="btnSetSite">Set location‚Ä¶</button>
    </div>
    <div class="pill">
      <label>Frame</label>
      <button class="btn active" id="btnHome">Home</button>
      <button class="btn" id="btnCosmic">Cosmic</button>
    </div>
    <div class="pill">
      <label>Filters</label>
      <button class="btn" id="btnFilterDay">Day-phase</button>
      <button class="btn" id="btnFilterSeason">Season</button>
      <button class="btn" id="btnFilterLunar">Lunar</button>
      <button class="btn" id="btnResetFilters">Reset</button>
    </div>
    <div class="pill pill-search">
      <label for="hbSearch">Search</label>
      <input class="search-input" type="search" id="hbSearch" placeholder="#hashtag" autocomplete="off" />
    </div>
    
  </header>

  <section id="scene">
    <canvas id="renderer"></canvas>
    <div class="toolbar">
      <div class="toggle">
        <button id="btnZoomIn">Ôºã</button>
        <button id="btnZoomOut">Ôºç</button>
        <button id="btnResetCam">Reset</button>
      </div>
    </div>
    <div class="legend">
      <div><span class="dot sun"></span> Sun</div>
      <div><span class="dot earth"></span> Year halos (Earth orbit)</div>
    </div>
  </section>

  <!-- Light-time dial -->
  <div id="ltDial" style="padding:8px 16px; color:#9fb0d9;">
    <canvas id="ltDialCanvas" width="540" height="70" style="width:100%; max-width:680px; display:block; margin:auto; background:#0e1426; border:1px solid #1c2746; border-radius:10px"></canvas>
  </div>

  <section class="tray">
    <div class="card">
      <h3>Memories</h3>
      <div class="body filelist" id="fileList"></div>
    </div>
    <div class="card">
      <h3>Relative States</h3>
      <div class="body" id="statesBody">
        <div class="chips" id="chips"></div>
        <div id="single"></div>
        <hr style="border:0;border-top:1px solid #1c2746;margin:10px 0;">
        <div id="multi">
          <div class="row"><b>Differences</b><span class="muted">Select multiple markers</span></div>
          <div class="diff" id="diffText">‚Äî</div>
        </div>
      </div>
    </div>
  </section>
</div>

<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exifr/dist/full.umd.js"></script>

<script>
/* =========================
   Minimal data store
========================= */

/* =========================
   Utilities
========================= */
// Adaptively increase decimals if rounding would show 0.0 even when the value is non-zero
function fixedAdaptive(x, baseDp=1, maxDp=6){
  if (x==null || isNaN(x)) return 'n/a';
  const v = +x;
  let d = baseDp;
  let s = v.toFixed(d);
  while (d < maxDp && Math.abs(+s) === 0 && v !== 0){
    d++;
    s = v.toFixed(d);
  }
  if (Math.abs(+s) === 0) s = (0).toFixed(d);
  return s;
}
const fmt = {
  deg: v => {
    const val = +v; if (!isFinite(val)) return 'n/a';
    // If 1dp would render 0.0 but val is not zero, increase decimals; if extremely small, show arcseconds
    const ad = Math.abs(val);
    if (ad < 1e-3 && ad > 0) return `${(val*3600).toFixed(1)}‚Ä≥`;
    const s = fixedAdaptive(val, 1, 6);
    return `${s}¬∞`;
  },
  min: v => Math.round(v) + ' min',
  pct: v => {
    const val = +v; if (!isFinite(val)) return 'n/a';
    const sign = val>=0?'+':'';
    const s = fixedAdaptive(val, 1, 6);
    return `${sign}${s}%`;
  },
  date: ts => new Date(ts).toLocaleString(),
  // Timezone-aware formatter that respects per-record capture zone
  dateLocal: (ts, tz) => {
    try {
      // show date + time + short zone (e.g., CEST, EDT). Fallback if tz missing.
      return new Intl.DateTimeFormat(undefined, {
        year: 'numeric', month: 'numeric', day: 'numeric',
        hour: 'numeric', minute: '2-digit', second: '2-digit',
        hour12: false, timeZone: tz, timeZoneName: 'short'
      }).format(new Date(ts));
    } catch {
      return new Date(ts).toLocaleString(); // fallback
    }
  }
};
function uid() { return Math.random().toString(36).slice(2,9); }

function makeDashedMat(color) {
  return new THREE.LineDashedMaterial({
    color,
    linewidth: 1,     // (Line2 needed for real widths; fine for now)
    dashSize: 0.04,   // tune to taste (AU units along path)
    gapSize: 0.02,
    transparent: true,
    opacity: 0.85
  });
}

// ---- Precise per-year orbit provider ----
const HORIZONS = {
  endpoint: '/api/horizons', // server proxy endpoint
  muSun_AU3_per_d2: 0.00029591220828559104 // GM‚òâ (Gaussian k^2) in AU^3/day^2
};

const halosPrecise = new Map();  // year -> THREE.Line (precise)
const yearElements = new Map();  // year -> {a,e,i,Omega,omega,M,epochJD, perihelionISO}

const orbitGradientLines = new Set();
window.__orbitGradientLines = orbitGradientLines;

function createOrbitLineMaterial(opacity = 0.75) {
  return new THREE.LineBasicMaterial({
    transparent: true,
    opacity,
    depthWrite: false,
    vertexColors: true,
    toneMapped: false
  });
}

function prepareOrbitGradientLine(line) {
  if (!line || !line.geometry) return;
  const geo = line.geometry;
  const posAttr = geo.getAttribute && geo.getAttribute('position');
  if (!posAttr || !posAttr.count) return;
  const count = posAttr.count;
  const fractions = new Float32Array(count);
  const colors = new Float32Array(count * 3);
  const divisor = Math.max(1, count - 1);
  for (let i = 0; i < count; i++) {
    fractions[i] = i / divisor;
  }
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geo.attributes.color.needsUpdate = true;
  line.userData = line.userData || {};
  line.userData.orbitFractions = fractions;
  if (line.material) {
    line.material.vertexColors = true;
    line.material.needsUpdate = true;
  }
  orbitGradientLines.add(line);
  if (typeof window.__updateOrbitGradientColors === 'function') {
    try {
      window.__updateOrbitGradientColors();
    } catch (err) {
      console.warn('Orbit gradient update failed', err);
    }
  }
}

function releaseOrbitGradientLine(line) {
  if (!line) return;
  orbitGradientLines.delete(line);
}

function toJD(dateISO) {
  // minimalist UTC->JD; ok for our ephemeris stamps
  const t = new Date(dateISO).getTime() / 86400000 + 2440587.5;
  return t;
}

async function fetchElementsForYear(year){
  if (yearElements.has(year)) return yearElements.get(year);
  
  console.log(`Fetching precise orbit for ${year}...`);
  const tsISO = `${year}-01-04T12:00:00Z`; // near perihelion

  // Prefer your server proxy (prevents CORS/rate-limit HTML)
  const proxyUrl = `/api/horizons/vectors?ts=${encodeURIComponent(tsISO)}`;
  try {
    const r = await fetch(proxyUrl, { headers: { "Accept": "application/json" }});
    const text = await r.text();

    // Some gateways return HTML on error; detect before JSON parse
    if (!text.trim().startsWith("{")) {
      console.warn("Horizons proxy returned non-JSON; falling back.\n", text.slice(0,200));
      throw new Error("non-json");
    }

    const data = JSON.parse(text);
    // extract what you need (Earth heliocentric state + perihelion from your server payload)
    const earth = data.earth;
    
    // Convert BCRS vectors to approximate orbital elements for visualization
    const el = {
      a: earth?.r_AU?.[0] ? Math.sqrt(earth.r_AU[0]**2 + earth.r_AU[1]**2 + earth.r_AU[2]**2) : 1.0,
      e: 0.0167, // Use standard eccentricity for now
      i: 0,
      Omega: 0,
      omega: 102.9 * Math.PI/180,
      M: 0,
      epochISO: tsISO,
      epochJD: toJD(tsISO),
      perihelionISO: null
    };
    
    yearElements.set(year, el);
    console.log(`Horizons fetched for ${year}.`);
    return el;

  } catch (e) {
    console.warn(`Horizons fetch failed for ${year}:`, e.message || e);
    // Fallback: analytic Kepler ellipse using J2000 elements (labels as approximate)
    const approx = {
      a: 1.0,
      e: 0.0167,
      i: 0,
      Omega: 0,
      omega: 102.9 * Math.PI/180,
      M: 0,
      epochISO: `${year}-01-01T00:00`,
      epochJD: toJD(`${year}-01-01T00:00`),
      perihelionISO: null
    };
    
    yearElements.set(year, approx);
    
    // mark UI
    (window.uiFlags ||= {}).orbitsApprox = true;
    console.log(`üìä Added approximate orbit for ${year}`);
    return approx;
  }
}

function elementsToEllipseGeometry(el, samples=720){
  const a = Number.isFinite(el?.a) ? el.a : 1;
  const e = Number.isFinite(el?.e) ? el.e : 0;
  const argPeri = Number.isFinite(el?.omega) ? el.omega : 0;
  const ascNode = Number.isFinite(el?.Omega) ? el.Omega : 0;
  const inPlaneRotation = argPeri + ascNode;
  const pts = [];
  for (let k = 0; k <= samples; k++) {
    const nu = 2 * Math.PI * (k / samples);
    const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
    const angle = nu + inPlaneRotation;
    const x = r * Math.cos(angle);
    const z = r * Math.sin(angle);
    pts.push(new THREE.Vector3(x, 0, z));
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const tmp = new THREE.Line(geo, new THREE.LineBasicMaterial());
  tmp.computeLineDistances();
  return geo;
}
function hashColor(str){
  let h=0; for(let i=0;i<str.length;i++){ h = (h<<5)-h + str.charCodeAt(i); h|=0; }
  const r = (h>>16 & 255), g=(h>>8 & 255), b=(h & 255);
  return new THREE.Color(`rgb(${(r&127)+80}, ${(g&127)+80}, ${(b&127)+80})`);
}

function makeLabelSprite(text){
  const pad = 6, fs = 13;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = `500 ${fs}px Inter, ui-sans-serif`;
  const w = Math.ceil(ctx.measureText(text).width) + pad*2;
  const h = fs + pad*2;
  canvas.width = w*2; canvas.height = h*2; // retina
  ctx.scale(2,2);
  // pill
  ctx.fillStyle = '#101733cc';
  ctx.strokeStyle = '#23335f';
  ctx.lineWidth = 1;
  ctx.beginPath(); const r=8;
  ctx.moveTo(r,0); ctx.lineTo(w-r,0); ctx.quadraticCurveTo(w,0,w,r);
  ctx.lineTo(w,h-r); ctx.quadraticCurveTo(w,h,w-r,h);
  ctx.lineTo(r,h); ctx.quadraticCurveTo(0,h,0,h-r);
  ctx.lineTo(0,r); ctx.quadraticCurveTo(0,0,r,0); ctx.closePath();
  ctx.fill(); ctx.stroke();
  // text
  ctx.fillStyle = '#dfe6ff'; ctx.fillText(text, pad, fs+pad-2);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: tex, depthWrite:false, transparent:true });
  const spr = new THREE.Sprite(mat);
  const scale = 0.18; // size in AU units
  spr.scale.set(scale * (w/h), scale, 1);
  spr.renderOrder = 999;
  spr.visible = false; // show on hover/selection
  return spr;
}

/* =========================
   Approximate ephemerides (demo)
   Replace with SPICE/Horizons for production.
========================= */
// Sun-Earth orbital basics
const AU = 1;                   // rendering units: 1 = 1 AU
const RAD = Math.PI/180;
const eEarth = 0.0167;          // eccentricity
const aEarth = 1;               // AU

// ---- Light-time bands along Earth's surface ----
const C_km_per_s = 299792.458;
const EARTH_EQ_CIRC_km = 40075.017;         // equatorial circumference
const LT_full_ms = (EARTH_EQ_CIRC_km / C_km_per_s) * 1000; // ‚âà 133.7 ms
const LT_zone_ms = LT_full_ms / 24;         // ‚âà 5.57 ms per 15¬∞ time zone
const KM_PER_DEG_EQ = EARTH_EQ_CIRC_km/360; // ‚âà 111.32 km

// Convert a longitude (deg, east+) to light-time offset from Greenwich in ms (wrap to [-LT_zone_ms*12, +...])
function longToLightMs(longDeg, latDeg=0){
  // Use *local parallel* length: scale by cos(lat) so high latitudes compress correctly
  const kmPerDeg = KM_PER_DEG_EQ * Math.max(0.2, Math.cos(latDeg * Math.PI/180)); // clamp so polar sites still render
  const km = longDeg * kmPerDeg;
  return (km / C_km_per_s) * 1000;  // ms
}

// Wrap ms to a symmetric window (nice for "distance" reporting)
function wrapMs(ms, halfWindow = LT_full_ms/2){
  let x = ms;
  while (x >  halfWindow) x -= LT_full_ms;
  while (x < -halfWindow) x += LT_full_ms;
  return x;
}

const perihelionApprox = new Date(Date.UTC(2025,0,4,0,0,0)); // ~Jan 4, 2025

function daysSince(t0, t) { return (t - t0)/86400000; }

// Earth heliocentric longitude (very rough): mean anomaly + correction
function heliocentricLongitude(ts) {
  const d = daysSince(perihelionApprox, ts);
  const M = (2*Math.PI/365.25)*d; // mean anomaly
  // solve Kepler (one Newton step ok for demo)
  let E = M + eEarth*Math.sin(M);
  E = E - (E - eEarth*Math.sin(E) - M)/(1 - eEarth*Math.cos(E));
  const v = 2*Math.atan(Math.sqrt((1+eEarth)/(1-eEarth))*Math.tan(E/2)); // true anomaly
  let L = v; // argument of periapsis ~ 0 in this rough frame
  if (L < 0) L += 2*Math.PI;
  return L; // radians
}

// Earth-Sun distance in AU
function earthSunDistance(ts) {
  const d = daysSince(perihelionApprox, ts);
  const M = (2*Math.PI/365.25)*d;
  let E = M + eEarth*Math.sin(M);
  E = E - (E - eEarth*Math.sin(E) - M)/(1 - eEarth*Math.cos(E));
  const r = aEarth*(1 - eEarth*Math.cos(E));
  return r;
}

// Very rough solar "tide proxy" relative % (‚àù 1/r^3 vs annual mean)
function solarTideRelPct(ts) {
  const r = earthSunDistance(ts);
  const tNow = Date.UTC(new Date(ts).getUTCFullYear(), 6, 3); // midyear ref
  const rRef = earthSunDistance(tNow);
  const rel = Math.pow(rRef/r, 3) - 1;
  return rel*100;
}

// Low-accuracy Moon (Meeus-style, good to ~1¬∞/few thousand km)
// Returns { altDeg, distance_km, phasePct, perigeeProx, lunarRelPct }
function moonContext(ts, latDeg, lonDeg) {
  const d = (ts - Date.UTC(2000,0,1,12,0,0)) / 86400000; // days since J2000.0
  const T = d / 36525;

  // Mean elements (deg)
  const L0 = (218.3164477 + 481267.88123421*T - 0.0015786*T*T) % 360; // mean longitude
  const M  = (134.9633964 + 477198.8675055*T   + 0.0087414*T*T) % 360; // Moon's mean anomaly
  const Ms = (357.5291092 + 35999.0502909*T    - 0.0001535*T*T) % 360; // Sun's mean anomaly
  const D  = (297.8501921 + 445267.1114034*T   - 0.0018819*T*T) % 360; // mean elongation
  const F  = (93.2720950  + 483202.0175233*T   - 0.0036539*T*T) % 360; // argument of latitude

  const toRad = Math.PI/180;
  const sin = Math.sin, cos = Math.cos;

  // Ecliptic longitude/latitude (deg), distance (km) ‚Äî simplified series
  const lon = L0
    + 6.289 * sin(M*toRad)
    + 1.274 * sin((2*D - M)*toRad)
    + 0.658 * sin((2*D)*toRad)
    + 0.214 * sin((2*M)*toRad)
    + 0.110 * sin(D*toRad);
  const lat = 5.128 * sin(F*toRad)
    + 0.280 * sin((M + F)*toRad)
    + 0.277 * sin((M - F)*toRad)
    + 0.173 * sin((2*D - F)*toRad);

  const dist_km = 385000.56
    - 20905.355 * cos(M*toRad)
    - 3699.111  * cos((2*D - M)*toRad)
    - 2955.968  * cos((2*D)*toRad)
    - 569.925   * cos((2*M)*toRad);

  // Obliquity & to RA/Dec
  const eps = (23.439291 - 0.0130042*T); // deg
  const lonR = lon*toRad, latR = lat*toRad, epsR = eps*toRad;
  const x = cos(lonR)*cos(latR);
  const y = sin(lonR)*cos(latR)*cos(epsR) - sin(latR)*sin(epsR);
  const z = sin(lonR)*cos(latR)*sin(epsR) + sin(latR)*cos(epsR);
  const ra  = Math.atan2(y, x);               // rad
  const dec = Math.asin(z);                   // rad

  // Local hour angle
  const date = new Date(ts);
  const jd = (ts/86400000) + 2440587.5;
  const T0 = (jd - 2451545.0)/36525;
  const GMST = (280.46061837 + 360.98564736629*(jd-2451545) + 0.000387933*T0*T0 - (T0*T0*T0)/38710000) % 360;
  const LST = ((GMST + lonDeg) % 360) * toRad; // local sidereal
  const H = LST - ra;

  const phi = latDeg*toRad;
  const alt = Math.asin(Math.sin(phi)*Math.sin(dec) + Math.cos(phi)*Math.cos(dec)*Math.cos(H)); // rad

  // Illumination (phase) from elongation approx
  const elong = (180/Math.PI) * Math.acos(Math.cos((lon - (L0 - D))*toRad)*Math.cos(latR));
  const phasePct = Math.round(50*(1 - Math.cos(elong*toRad))*2);

  const mean = 384400;
  const lunarRel = Math.pow(mean/dist_km, 3) - 1;
  const perigeeProx = Math.max(0, 1 - Math.abs(dist_km-363300) / (405500-363300));

  return {
    altDeg: alt*180/Math.PI,
    distance_km: dist_km,
    phasePct,
    perigeeProx: +perigeeProx.toFixed(2),
    lunarRelPct: +(lunarRel*100).toFixed(1)
  };
}

// Day-phase tag using simple Sun altitude estimate (needs lat/lon)
function sunAltDeg(ts, lat, lon) {
  // Approximate solar declination/HA (NOAA-ish shortcut)
  const date = new Date(ts);
  const n = Math.floor((Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()) - Date.UTC(date.getUTCFullYear(),0,0))/86400000);
  const L = (280.46 + 0.9856474*n) % 360;
  const g = (357.528 + 0.9856003*n) % 360;
  const lambda = L + 1.915*Math.sin(g*RAD) + 0.020*Math.sin(2*g*RAD);
  const epsilon = 23.439 - 0.0000004*n;
  const delta = Math.asin(Math.sin(epsilon*RAD)*Math.sin(lambda*RAD)); // declination
  const timeUTC = date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600;
  const eqTime =  - (1.915*Math.sin(g*RAD) + 0.020*Math.sin(2*g*RAD) - 2.466*Math.sin(2*lambda*RAD) + 0.053*Math.sin(4*lambda*RAD)); // ~minutes (very rough)
  const tst = (timeUTC*60 + eqTime + lon*4) / 4; // true solar time in hours
  const H = ((tst - 12)*15) * RAD; // hour angle (rad)
  const phi = lat*RAD;
  const alt = Math.asin(Math.sin(phi)*Math.sin(delta) + Math.cos(phi)*Math.cos(delta)*Math.cos(H));
  return alt * 180/Math.PI;
}
function dayPhaseTag(altDeg) {
  if (altDeg >= 45) return 'daytime';
  if (altDeg >= 0)  return 'golden hour';
  if (altDeg >= -6) return 'civil twilight';
  if (altDeg >= -12)return 'nautical twilight';
  if (altDeg >= -18)return 'astro twilight';
  return 'night';
}

// Vertical tidal acceleration ~ A0 * (r0/r)^3 * (3 cos^2 z - 1)
// We'll show ¬µGal magnitude (1 ¬µGal = 1e-8 m/s^2) as context.
const TIDE = {
  A_sun_uGal: 52,         // canonical peak near zenith at mean distance
  A_moon_uGal: 110,
  rSunRef_AU: 1.0,
  rMoonRef_km: 384400
};
function zenithFactor(altDeg){
  const z = Math.max(0, 90 - altDeg); // zenith distance
  const cz = Math.cos(z*Math.PI/180);
  return Math.abs(3*cz*cz - 1);       // magnitude of (3 cos^2 z - 1)
}

// --- Similarity feature helpers ---
const clamp01 = x => Math.max(0, Math.min(1, x));

function cycDeltaDeg(a, b) { // shortest angular diff in [0,180]
  let d = Math.abs(((b - a + 540) % 360) - 180);
  return d;
}

// ---- Causal / envelope helpers ----
const C_LIGHT = 299792.458; // km/s

// Simple P2(cos z) factor used in tidal potential
const P2 = (zRad) => 0.5*(3*Math.cos(zRad)**2 - 1);

// P2 from altitude (deg) ‚Äî strictly in [-0.5, 1]
function P2_fromAltDeg(altDeg){
  const altClamped = Math.max(altDeg, -0.5);               // avoid below-horizon blowups
  const zRad = (90 - altClamped) * Math.PI/180;            // zenith angle in radians
  return Math.max(-0.5, Math.min(1, 0.5*(3*Math.cos(zRad)**2 - 1)));
}

// Pretty printer for tiny proper-time shifts (ns/s)
function niceNsPerS(x){
  if (x==null || isNaN(x)) return 'n/a';
  const v = +x;
  if (Math.abs(v) < 1e-3) return '‚âà0 ns/s';
  return `${v.toFixed(3)} ns/s`;
}

// Normalize angle to [0, 360)
function norm360(deg){ let x = deg % 360; if (x < 0) x += 360; return x; }

// Ecliptic longitudes (rough but consistent with your solar/moon models)
function sunEclipticLongitudeDeg(ts){
  // reuse the 'sunAltDeg' internals: L,g,lambda
  const d = new Date(ts);
  const n = Math.floor((Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()) - Date.UTC(d.getUTCFullYear(),0,0))/86400000);
  const L = (280.46 + 0.9856474*n) % 360;
  const g = (357.528 + 0.9856003*n) % 360;
  const lambda = L + 1.915*Math.sin(g*RAD) + 0.020*Math.sin(2*g*RAD);
  return (lambda + 180) % 360; // heliocentric ‚Üí geocentric correction (~+180¬∞)
}
function moonEclipticLongitudeDeg_fast(ts){
  const mc = moonContext(ts, 0, 0); // we only need the longitude term; mc used the series L0 + ...
  // Recompute L0 quickly (same T as moonContext):
  const d = (ts - Date.UTC(2000,0,1,12,0,0)) / 86400000;
  const T = d / 36525;
  const L0 = (218.3164477 + 481267.88123421*T - 0.0015786*T*T) % 360;
  // Use L0 as a proxy for ecliptic longitude (good enough for phase offset UI)
  return (L0+360)%360;
}

// Rolling envelope average of our tide proxy over window W seconds (centered)
// Daily span of the (proxy) tidal potential for normalization
function envelopeDailySpan_sync(ts, lat, lon){
  // sample every 10 min across ¬±12 h window
  const step = 600; // s
  const half = 12*3600; // s
  let Umin = +Infinity, Umax = -Infinity;
  for (let s=-half; s<=half; s+=step){
    const t = ts + s*1000;
    const sAlt = sunAltDeg(t, lat, lon);
    const zS = (90 - sAlt)*RAD;
    const m = moonContext(t, lat, lon);
    const zM = (90 - m.altDeg)*RAD;
    const KS = 0.5, KM = 1.1;
    const rS = earthSunDistance(t);
    const U = KS*Math.pow(1/rS,3)*P2(zS) + KM*Math.pow(384400/m.distance_km,3)*P2(zM);
    if (U<Umin) Umin = U;
    if (U>Umax) Umax = U;
  }
  return Math.max(1e-9, Umax - Umin);
}

// Daily span of the (proxy) tidal potential for normalization
async function envelopeDailySpan(ts, lat, lon){
  // sample every 10 min across ¬±12 h window
  const step = 600; // s
  const half = 12*3600; // s
  let Umin = +Infinity, Umax = -Infinity;
  for (let s=-half; s<=half; s+=step){
    const t = ts + s*1000;
    const sAlt = sunAltDeg(t, lat, lon);
    const zS = (90 - sAlt)*RAD;
    const m = moonContext(t, lat, lon);
    const zM = (90 - m.altDeg)*RAD;
    const KS = 0.5, KM = 1.1;
    const rS = earthSunDistance(t);
    const U = KS*Math.pow(1/rS,3)*P2(zS) + KM*Math.pow(384400/m.distance_km,3)*P2(zM);
    if (U<Umin) Umin = U;
    if (U>Umax) Umax = U;
  }
  return Math.max(1e-9, Umax - Umin);
}

function envelopeAverage_U(ts, lat, lon, Wsec=60){
  const step = 5; // 5 s steps
  const N = Math.max(1, Math.floor(Wsec/step));
  let sum=0;
  for(let k=-N/2; k<=N/2; k++){
    const t = ts + k*step*1000;
    const sAlt = sunAltDeg(t, lat, lon);
    const zS = (90 - sAlt)*RAD;
    const m = moonContext(t, lat, lon);
    const zM = (90 - m.altDeg)*RAD;
    // scale constants match oneSecondTidalPotential()
    const KS = 0.5, KM = 1.1;
    const rS = earthSunDistance(t);
    const U = KS*Math.pow(1/rS,3)*P2(zS) + KM*Math.pow(384400/m.distance_km,3)*P2(zM);
    sum += U;
  }
  const Ubar = sum/(N+1);
  return Ubar;
}

// Long-cycle lunar phases (very coarse, J2000 reference)
function lunarLongCyclePhases(ts){
  const d = (ts - Date.UTC(2000,0,1,12,0,0))/86400000;
  const nodalPeriod = 6798.383;     // days ~18.6 yr
  const perigeePeriod = 3232.605;   // days ~8.85 yr
  const nodalPhaseDeg = ((d / nodalPeriod)*360) % 360;
  const perigeePhaseDeg = ((d / perigeePeriod)*360) % 360;
  return { nodalPhaseDeg: (nodalPhaseDeg+360)%360, perigeePhaseDeg:(perigeePhaseDeg+360)%360 };
}

// normalize differences ‚Üí [0,1] similarity
function simAngle(aDeg, bDeg) {
  return 1 - (cycDeltaDeg(aDeg, bDeg) / 180);           // 0 (opposite) .. 1 (same)
}
function simLinear(a, b, span) {
  return 1 - clamp01(Math.abs(a - b) / span);           // within "span" counts as good
}
function simCategory(a, b) {
  return a === b ? 1 : 0.4;                              // soft credit if not identical
}

// Roll everything into one score (0..100)
function similarityScore(A, B, diffsObj = null) {
  // features + suggested spans (tune to taste)
  const sPhase   = simCategory(A.states.dayPhase, B.states.dayPhase);      // weight 0.18
  const sAlt     = simLinear(A.states.sunAltDeg, B.states.sunAltDeg, 15);  // 15¬∞ is "close"
  const sAngle   = simAngle(A.homeAngleDeg, B.homeAngleDeg);
  const sIndex   = simLinear(A.states.tides.index0to100, B.states.tides.index0to100, 20);
  const sSolar   = simLinear(A.states.tides.solarRelPct, B.states.tides.solarRelPct, 5);
  const sLunar   = simLinear(A.states.tides.lunarRelPct, B.states.tides.lunarRelPct, 10);
  const sMoonPh  = simLinear(A.states.lunar.phasePct, B.states.lunar.phasePct, 20);

  // weights sum to 1
  const w = {
    phase:0.18, alt:0.12, angle:0.18, index:0.18, solar:0.10, lunar:0.14, moon:0.10
  };

  const S =
    w.phase*sPhase + w.alt*sAlt + w.angle*sAngle + w.index*sIndex +
    w.solar*sSolar + w.lunar*sLunar + w.moon*sMoonPh;

  // NEW causal/averaging similarities (small weights)
  if (diffsObj && A.states.envelope && B.states.envelope) {
    const sCausalSun  = 1 - clamp01( Math.abs(diffsObj.dSunCausal_s || 0) / 2 );  // within 2 s is "good"
    const sCausalMoon = 1 - clamp01( Math.abs(diffsObj.dMoonCausal_s || 0) / 2 );
    const sEnv1m = (typeof diffsObj.envPct_1m === 'number')
      ? 1 - clamp01(diffsObj.envPct_1m / 30)  // <30% of daily span ‚âà "good"
      : 0.5;
    const sVecDir = 1 - ( Math.abs(diffsObj.dNetBearing || 0) / 180 );
    const sVecMag = 1 - clamp01( Math.abs(diffsObj.dNetMag || 0) / 20 ); // 20 ¬µGal span

    // Enhanced similarity with refined causal/envelope weights
    const add = 0.12; // total extra influence
    const Splus = 0.03*sCausalSun + 0.02*sCausalMoon + 0.03*sEnv1m + 0.03*sVecDir + 0.01*sVecMag;
    return Math.round((S + add*Splus) * 100);
  }

  return Math.round(S * 100);
}

// Complete narrative system covering ALL difference fields
// Narrative number formatting
function narrNumber(v, {abs=false, unit='', dp=1, sig=null} = {}) {
    if (v == null || isNaN(v)) return 'n/a';
    const x = abs ? Math.abs(v) : v;
    const s = sig ? Number(x).toExponential(sig-1) : x.toFixed(dp);
    return unit ? `${s} ${unit}` : s;
}

// Angle description helper
function anglePhrase(d) {
    const a = Math.abs(((d+540)%360)-180); // wrap to [0,180]
    if (a < 1) return 'the same spot on the ring';
    if (Math.abs(a-90) < 2) return 'a quarter-orbit apart';
    if (Math.abs(a-180) < 2) return 'opposite sides of the Sun';
    return `separated by ${a.toFixed(1)}¬∞ around the orbit`;
}

// Tidal field mood description
function tidalFieldMood(idx) { 
    return idx>=70 ? 'strong solar‚Äìlunar tidal field' : 
           idx>=40 ? 'moderate tidal field' : 'quiet tidal field'; 
}

// Solar/lunar tidal field contribution description
function leanPhrase(rel, who) {
    if (rel >= 4)  return `field from the ${who.toLowerCase()} stronger than its annual average (+${rel.toFixed(1)}%)`;
    if (rel <= -4) return `field from the ${who.toLowerCase()} weaker than average (‚àí${Math.abs(rel).toFixed(1)}%)`;
    return null;
}

// Complete narrative generator covering ALL difference fields
function makeNarrative(A, B, score, diffs) {
    const state = score>=70 ? 'almost the same sky and pull' : 
                 score>=40 ? 'similar light, gently different pull' : 
                 'very different light and pull';
    const angle = anglePhrase(diffs.dAngle || 0);
    const years = (diffs.dYear > 0) ? `, ${diffs.dYear} lap${diffs.dYear > 1 ? 's' : ''} later` : '';

    // A-state context
    const aMood = tidalFieldMood(A.states?.tides?.index0to100 || 50);
    const aSolar = leanPhrase(A.states?.tides?.solarRelPct || 0, 'Sun');
    const aLunar = (() => {
        const r = A.states?.tides?.lunarRelPct || 0;
        if (r >= 8)  return `field from the Moon closer/more effective (+${r.toFixed(1)}%)`;
        if (r <= -8) return `field from the Moon farther/less effective (‚àí${Math.abs(r).toFixed(1)}%)`;
        return null;
    })();

    // Build change parts with thresholds
    const parts = [];
    
    // Always show light-time
    parts.push(`Sun light-time changed ${narrNumber(diffs.dLightTime_s, {dp:1, unit:'s'})}`);
    
    // Cosmic drift (if significant)
    if (Math.abs(diffs.dDrift_AU || 0) >= 0.1) {
        parts.push(`cosmic drift grew by ${narrNumber(diffs.dDrift_AU, {dp:1, unit:'AU'})}`);
    }
    
    // Tidal field changes
    if (Math.abs(diffs.dIndex || 0) >= 10) {
        const tfDesc = [`combined tidal field index shifted ${Math.round(diffs.dIndex)}/100`];
        if (Math.abs(diffs.dSolarPct || 0) >= 2) tfDesc.push(`solar contribution ${diffs.dSolarPct.toFixed(1)}%`);
        if (Math.abs(diffs.dLunarPct || 0) >= 5) tfDesc.push(`lunar contribution ${diffs.dLunarPct.toFixed(1)}%`);
        parts.push(`the ${tfDesc.join(', ')}`);
    } else {
        parts.push(`combined tidal field stayed similar (${Math.round(diffs.dIndex || 0)}/100)`);
    }
    
    // Sun altitude (if significant)
    if (Math.abs(diffs.dSunAltDeg || 0) >= 10) {
        parts.push(`Sun altitude moved ${narrNumber(diffs.dSunAltDeg, {dp:1, unit:'¬∞'})}`);
    }
    
    // Voxel and time-bias changes (grouped)
    const physParts = [];
    if (Math.abs(diffs.dVoxelFrac || 0) >= 1e-6) {
        physParts.push(`we traversed ${Number(diffs.dVoxelFrac).toExponential(2)} of a light-second`);
    }
    if (Math.abs(diffs.dNs_grav || 0) >= 1e-3) {
        physParts.push(`the 1-s tidal time-bias changed ${narrNumber(diffs.dNs_grav, {sig:3, unit:'ns/s'})}`);
    }
    if (physParts.length > 0) parts.push(physParts.join(' and '));
    
    // Kinematic changes
    const kinParts = [];
    if (Math.abs(diffs.dNs_kin || 0) >= 1e-3) {
        kinParts.push(`the rotation/latitude rate changed ${narrNumber(diffs.dNs_kin, {sig:3, unit:'ns/s'})}`);
    }
    if (Math.abs(diffs.dNs_comb || 0) >= 1e-3) {
        kinParts.push(`giving a combined rate shift of ${narrNumber(diffs.dNs_comb, {sig:3, unit:'ns/s'})}`);
    }
    if (kinParts.length > 0) parts.push(`kinematically, ${kinParts.join(', ')}`);
    
    // Orbital geometry
    const geomParts = [];
    if (typeof diffs.dOmegaDeg === 'number') geomParts.push(`Œîœâ = ${angleSmartDeg(diffs.dOmegaDeg)}`);
    if (typeof diffs.dVarpiDeg === 'number') geomParts.push(`Œîœñ = ${angleSmartDeg(diffs.dVarpiDeg)}`);
    if (geomParts.length > 0) parts.push(`year geometry rotated: ${geomParts.join(', ')}`);
    
    // Perihelion info (always show if available)
    if (diffs.periA || diffs.periB) {
        parts.push(`perihelion A: ${diffs.periA || 'n/a'} ‚Üí B: ${diffs.periB || 'n/a'}`);
    }

    // Assemble complete narrative
    const dayInfo = A.states?.dayPhase || 'unknown';
    const sunAlt = A.states?.sunAltDeg ? A.states.sunAltDeg.toFixed(1) : 'n/a';
    const clockRate = A.states?.voxel?.combined_ns_per_1s || 'n/a';
    const leans = [aSolar, aLunar].filter(Boolean);
    const leanText = leans.length > 0 ? leans.join(' and ') : 'solar‚Äìlunar contributions near their averages';

    return [
        `"${A.name}" was captured in ${state} to "${B.name}", ${angle}${years}.`,
        `At A the sky was ${dayInfo} (${sunAlt}¬∞) with a ${aMood}; ${leanText}.`,
        `The local clock ran at ~${clockRate} ns/s (grav+kin).`,
        `Since then, ${parts.join('; ')}.`
    ].join(' ');
}

// Zen sentences for similarity scoring
const zenSentences = [
  // [90+ range] Almost identical moments
  'Time flows like a river returning to its source.',
  'The cosmos breathes the same breath twice.',
  'What was, is, in the eternal dance of spheres.',
  
  // [70-89 range] Very similar
  'Shadows shift, but the light remains constant.',
  'The wheel turns, yet the spoke remembers its place.',
  'Echoes of the same celestial song.',
  
  // [50-69 range] Moderately similar  
  'The tide ebbs and flows, following ancient rhythms.',
  'Stars align in familiar, yet distant patterns.',
  'Time weaves similar threads in its tapestry.',
  
  // [30-49 range] Somewhat different
  'The sun climbs different peaks of the same mountain.',
  'Seasons change, carrying whispers of what was.',
  'The cosmic dance steps to a varied rhythm.',
  
  // [10-29 range] Quite different
  'New currents flow where old rivers once ran.',
  'The celestial wheel finds unfamiliar ground.',
  'Time carves fresh paths through the void.',
  
  // [0-9 range] Very different
  'The cosmos dreams a completely different dream.',
  'New stars rise where others have set.',
  'Time begins a fresh chapter in its eternal book.'
];

// Zen line generator
function zenSentence(score, A, B) {
  const angle = cycDeltaDeg(A.homeAngleDeg, B.homeAngleDeg).toFixed(1);
  const tideDiff = Math.abs(A.states.tides.index0to100 - B.states.tides.index0to100);
  const phaseA = A.states.dayPhase, phaseB = B.states.dayPhase;
  const moonGap = Math.abs(A.states.lunar.phasePct - B.states.lunar.phasePct);

  if (score >= 70) {
    return `Same light, same tidal pull: ${phaseA} echoes ${phaseB}; only ${angle}¬∞ apart and field indices within ${tideDiff}‚Äîthe moments rhyme.`;
  } else if (score >= 40) {
    return `The sky rhymes but doesn't repeat: ${phaseA} vs ${phaseB}, ${angle}¬∞ around the Sun, lunar face Œî${moonGap}%.`;
  } else {
    return `Different rooms of the same house: ${phaseA} ‚Üí ${phaseB}, ${angle}¬∞ apart; tidal field and Moon keep their own counsel.`;
  }
}

// Horizons proxy endpoint and BCRS/GCRS helpers
const API = { VECTORS: '/api/horizons/vectors' };

// Fetch BCRS (Sun/Earth/Moon/Planets) + GCRS RA/Dec for a timestamp
async function fetchBCRS(tsISO){
  // Try extended endpoint with planets first, fallback to basic Sun/Earth/Moon
  try {
    const res = await fetch(`${API.VECTORS}?ts=${encodeURIComponent(tsISO)}&targets=199,299,499,599,699,799,899`);
    if (res.ok) return res.json();
  } catch {}
  
  // Fallback to basic endpoint
  const res = await fetch(`${API.VECTORS}?ts=${encodeURIComponent(tsISO)}`);
  if (!res.ok) throw new Error('Horizons vectors failed');
  return res.json();
}

// RA/Dec -> Alt/Az at site (deg). Uses UTC ts.
function raDecToAltAz(ts, latDeg, lonDeg, raDeg, decDeg){
  const RAD=Math.PI/180;
  const jd = ts/86400000 + 2440587.5;
  const T0 = (jd - 2451545.0)/36525;
  const GMST = (280.46061837 + 360.98564736629*(jd-2451545) + 0.000387933*T0*T0 - (T0*T0*T0)/38710000) % 360;
  const LST = ((GMST + lonDeg) % 360) * RAD;
  const H = LST - (raDeg*RAD);
  const phi = latDeg*RAD;
  const dec = decDeg*RAD;
  const alt = Math.asin(Math.sin(phi)*Math.sin(dec) + Math.cos(phi)*Math.cos(dec)*Math.cos(H));
  const az  = Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(phi) - Math.tan(dec)*Math.cos(phi));
  let azDeg = az*180/Math.PI; if (azDeg<0) azDeg+=360;
  return { altDeg: alt*180/Math.PI, azDeg };
}

// Speed & light-second voxel helpers
const C_kms = 299792.458;
const V_Earth_orbit_kms = 29.78; // mean barycentric orbital speed (ok for UI)
const V_surface_kms_eq   = 0.465; // rotation at equator (optional component)
function voxelFraction(speed_kms){ return +(speed_kms / C_kms); } // unitless fraction of 1 ls in 1 s

// Retarded-time event badges (optional user events)
const userEvents = [ /* { name:'X-class flare', when:'2025-09-24T12:00:00Z' } */ ];

function retardedBadge(tsISO, sunLt_s){
  const t = Date.parse(tsISO), arrived = userEvents
    .map(e => ({ name:e.name, dt_s: (t - Date.parse(e.when))/1000 - sunLt_s }))
    .filter(x => Math.abs(x.dt_s) < 3600); // within ¬±1h of arrival
  return arrived;
}

// ---------- narrative helpers ----------
function relState(score){
  return score>=70 ? 'almost the same light and tidal pull'
       : score>=40 ? 'similar light, gently different pull'
                   : 'very different light and pull';
}
function anglePhrase(dAngle){
  const a = cycDeltaDeg(0, dAngle);
  if (a < 1) return 'the same spot on the ring';
  if (Math.abs(a-90) < 2) return 'a quarter-orbit apart';
  if (Math.abs(a-180) < 2) return 'opposite sides of the Sun';
  return `separated by ${a.toFixed(1)}¬∞ around the orbit`;
}
function tidalFieldMood(idx){
  return idx>=70 ? 'a strong solar‚Äìlunar tidal field'
       : idx>=40 ? 'a moderate tidal field'
                 : 'a quiet tidal field';
}
function leanPhrase(rel, who){
  if (rel>=4)  return `field from the ${who} stronger than its average (+${rel.toFixed(1)}%)`;
  if (rel<=-4) return `field from the ${who} weaker than average (‚àí${Math.abs(rel).toFixed(1)}%)`;
  return null;
}
function num(x, dp=1, unit=''){
  if (x==null || isNaN(x)) return 'n/a';
  const v = +x;
  const maxDp = 6;
  let d = dp;
  let s = v.toFixed(d);
  // If rounding to "0.0" but value isn't zero, increase decimals until a non-zero digit appears or maxDp reached
  while (d < maxDp && Math.abs(+s) === 0 && v !== 0){
    d++;
    s = v.toFixed(d);
  }
  // Normalize -0.0 to 0 with the chosen precision
  if (Math.abs(+s) === 0) s = (0).toFixed(d);
  return `${s}${unit}`;
}
function numSig(x, sig=3, unit=''){ return (x==null||isNaN(x))?'n/a':`${(+x).toExponential(sig)}${unit}`; }

// Nice number formatting (fixed for readable range, exponential for extremes)
function nice(x, unit=''){
  if (x==null||isNaN(x)) return 'n/a';
  const v = +x;
  const s = (Math.abs(v) >= 1e-3 && Math.abs(v) < 1e4) 
    ? v.toFixed(3).replace(/\.?0+$/,'')
    : v.toExponential(2);
  return `${s}${unit}`;
}

// Angle smart formatter: use arcseconds for tiny angles, else degrees with 3 dp
function angleSmartDeg(deg){
  if (deg==null || isNaN(deg)) return 'n/a';
  const v = +deg; const ad = Math.abs(v);
  if (ad < 1e-3){
    const as = v*3600; // arcseconds
    const aas = Math.abs(as);
    const dp = aas >= 0.1 ? 1 : (aas >= 0.01 ? 2 : 3);
    // Avoid "-0.0" and ensure visibility of tiny non-zero values
    let s = as.toFixed(dp);
    if (Math.abs(+s) === 0 && as !== 0){
      const dp2 = Math.min(dp+1, 4);
      s = as.toFixed(dp2);
    }
    if (Math.abs(+s) === 0) s = (0).toFixed(dp);
    return `${s}‚Ä≥`;
  }
  return `${v.toFixed(3)}¬∞`;
}

// Accurate day-phase classification by sun altitude
function dayPhaseTag(alt){
  if (alt >= 6)  return 'daytime';
  if (alt >= 0)  return 'golden hour';
  if (alt >= -6) return 'civil twilight';
  if (alt >= -12) return 'nautical twilight';
  if (alt >= -18) return 'astro twilight';
  return 'night';
}

// Build a timestamp for local *wall clock* time (no UTC 'Z' shift)
function tsLocal(y, m, d, hh=13, mm=0, ss=0){
  // y, m=1..12, d are calendar numbers; returns ms since epoch
  return new Date(y, m-1, d, hh, mm, ss).getTime();
}

// Guard against mixed inputs (number vs ISO string)
function toTs(input){
  if (typeof input === 'number') return input;
  return new Date(input).getTime(); // ISO with ¬±HH:MM offset ‚Üí correct UTC epoch
}

// Build a human paragraph from two records + similarity score + diffs you already compute
function makeNarrative(A, B, score, diffs, extras={}){
  // Lead
  const lead = `"${A.name}" was captured in ${relState(score)} to "${B.name}", ` +
               `${anglePhrase(diffs.dAngle)}${diffs.dYear>0?`, ${diffs.dYear} lap${diffs.dYear>1?'s':''} later`:''}.`;

  // A-moment context
  const mood = tidalFieldMood(A.states.tides.index0to100);
  const leanS = leanPhrase(A.states.tides.solarRelPct, 'Sun');
  const leanM = (()=>{
    const r = A.states.tides.lunarRelPct;
    if (r>=8)  return `field from the Moon closer/more effective (+${r.toFixed(1)}%)`;
    if (r<=-8) return `field from the Moon farther/less effective (‚àí${Math.abs(r).toFixed(1)}%)`;
    return null;
  })();
  const leans = [leanS, leanM].filter(Boolean).join(' and ') || 'solar‚Äìlunar contributions near their averages';
  const aLine = `At A the sky was ${dayPhaseTag(A.states.sunAltDeg)} (${A.states.sunAltDeg.toFixed(1)}¬∞) with ${mood}; ${leans}. ` +
                `The local clock ran at ~${nice(A.states.voxel.combined_ns_per_1s,' ns/s')} (grav+kin). `;

  // Changes A‚ÜíB (use thresholds to avoid clutter)
  const parts = [];
  parts.push(`Sun light-time changed ${num(diffs.dLightTime_s,1,' s')}`);
  const driftMag = Math.abs(diffs.dDrift_AU||0);
  if (driftMag >= 0.1) parts.push(`cosmic drift grew by ${driftMag.toFixed(1)} AU`);
  if (Math.abs(diffs.dIndex||0) >= 10) parts.push(`combined tidal-field index shifted ${Math.round(diffs.dIndex)}/100`);
  else parts.push(`combined tidal-field index stayed similar (${Math.round(diffs.dIndex||0)}/100)`);
  if (Math.abs(diffs.dSolarPct||0) >= 2) parts.push(`solar contribution ${num(diffs.dSolarPct,1,'%')}`);
  if (Math.abs(diffs.dLunarPct||0) >= 5) parts.push(`lunar contribution ${num(diffs.dLunarPct,1,'%')}`);
  if (Math.abs(diffs.dSunAltDeg||0) >= 10) parts.push(`Sun altitude moved ${num(diffs.dSunAltDeg,1,'¬∞')}`);
  if (Math.abs(diffs.dVoxelFrac||0) >= 1e-6) parts.push(`we traversed ${nice(diffs.dVoxelFrac)} of a light-second`);
  if (Math.abs(diffs.dNs_grav||0) >= 1e-3) parts.push(`1-s tidal time-bias changed ${nice(diffs.dNs_grav,' ns/s')}`);
  if (Math.abs(diffs.dNs_kin||0) >= 1e-3) parts.push(`rotation/latitude rate changed ${nice(diffs.dNs_kin,' ns/s')}`);
  if (Math.abs(diffs.dNs_comb||0) >= 1e-3) parts.push(`combined rate shifted ${nice(diffs.dNs_comb,' ns/s')}`);
  if (typeof diffs.dOmegaDeg === 'number') parts.push(`Œîœâ = ${angleSmartDeg(diffs.dOmegaDeg)}`);
  if (typeof diffs.dVarpiDeg === 'number') parts.push(`Œîœñ = ${angleSmartDeg(diffs.dVarpiDeg)}`);
  if (extras.periA || extras.periB) parts.push(`perihelion A: ${extras.periA||'n/a'} ‚Üí B: ${extras.periB||'n/a'}`);

  // 1) Causal/envelope line (bounded % or n/a)
  let envBits = [];
  if (diffs.overSun!=null)  envBits.push(`Sun overlap ${(diffs.overSun*100).toFixed(0)}%`);
  if (diffs.overMoon!=null) envBits.push(`Moon ${(diffs.overMoon*100).toFixed(0)}%`);
  if (typeof diffs.envPct_1m === 'number') envBits.push(`1-min envelope Œî ${diffs.envPct_1m.toFixed(1)}% (of daily span)`);
  const envLine = envBits.length ? ` Their causal/envelope match: ${envBits.join(', ')}.` : '';

  // 2) Direction/phase line (only if meaningful)
  const vecBits = [];
  if (typeof diffs.dNetBearing === 'number') vecBits.push(`net push rotated ${diffs.dNetBearing.toFixed(1)}¬∞`);
  if (typeof diffs.dNetMag === 'number' && Math.abs(diffs.dNetMag) >= 0.5) vecBits.push(`magnitude changed ${diffs.dNetMag.toFixed(1)} ¬µGal`);
  if (typeof diffs.dPhaseSyn === 'number') vecBits.push(`Sun‚ÄìMoon phase shifted ${diffs.dPhaseSyn.toFixed(1)}¬∞`);
  if (typeof diffs.dP2sun === 'number' || typeof diffs.dP2moon === 'number')
    vecBits.push(`geometry P‚ÇÇ: Sun ${(diffs.dP2sun||0).toFixed(3)}, Moon ${(diffs.dP2moon||0).toFixed(3)}`);
  const vecLine = vecBits.length ? ` Their tide's direction/phase changed: ${vecBits.join(', ')}.` : '';

  // 3) Slow background line
  const longBits = [];
  if (typeof diffs.dNodal === 'number' || typeof diffs.dPerigee === 'number')
    longBits.push(`lunar long cycles: nodes Œî${(diffs.dNodal||0).toFixed(1)}¬∞, perigee Œî${(diffs.dPerigee||0).toFixed(1)}¬∞`);
  if (typeof diffs.dEqElev_mm === 'number' && Math.abs(diffs.dEqElev_mm) >= 0.1)
    longBits.push(`equivalent elevation ${Math.abs(diffs.dEqElev_mm).toFixed(2)} mm`);
  if (typeof diffs.planetary_nGal === 'number' && Math.abs(diffs.planetary_nGal) >= 0.1)
    longBits.push(`planetary add-ons ‚âà ${Math.abs(diffs.planetary_nGal).toExponential(2)} nGal`);
  if (typeof diffs.dSSB_km === 'number' || typeof diffs.dReflex_mps === 'number')
    longBits.push(`Sun‚ÄìSSB: offset Œî${Math.abs(diffs.dSSB_km||0).toFixed(0)} km, reflex Œî${Math.abs(diffs.dReflex_mps||0).toFixed(2)} m/s`);
  const longLine = longBits.length ? ` Slow background shifted too: ${longBits.join(', ')}.` : '';

  // 4) Light-band one-liner
  let bandsLine = '';
  if (A.states.lightBands && B.states.lightBands){
    const dMs = wrapMs(B.states.lightBands.msFromGreenwich - A.states.lightBands.msFromGreenwich);
    const km = dMs * C_km_per_s / 1000;
    const zA = A.states.lightBands.zoneIndex, zB = B.states.lightBands.zoneIndex;
    const dz = (zB - zA);
    bandsLine = ` On the Earth dial (light-time bands), their longitudes differ by ${dMs.toFixed(2)} ms (‚âà ${km.toFixed(0)} km) ‚Äî time zones ${dz>=0?'+':''}${dz} in ms-units.`;
  }

  const change = `Since A ‚Üí B, ${parts.join(', ')}.`;
  return `<div class="story"><span class="lead">${lead}</span> ${aLine}${change}${envLine}${vecLine}${longLine}${bandsLine}</div>`;
}

// Planetary tidal context - tiny but real contributions
// Constants
const AU_km = 149_597_870.7;
const AUperDay_to_mps = (AU_km*1000) / 86400;  // ‚âà 1.731456836e6 m/s

// GM (Œº = G*M) in SI (m^3/s^2). Using Œº cancels G; ratios == mass ratios.
const MU = {
  sun:     1.32712440018e20,
  moon:    4.9048695e12,
  mercury: 2.2032e13,
  venus:   3.24859e14,
  earth:   3.986004354e14,
  mars:    4.282837e13,
  jupiter: 1.26686534e17,
  saturn:  3.7931187e16,
  uranus:  5.793939e15,
  neptune: 6.836529e15
};

// Map Horizons numeric IDs to labels & Œº
const MU_BY_ID = new Map([
  [199, MU.mercury], [299, MU.venus], [399, MU.earth], [499, MU.mars],
  [599, MU.jupiter], [699, MU.saturn], [799, MU.uranus], [899, MU.neptune]
]);

/**
 * Compute tiny planetary tidal add-ons at Earth (nGal) and the Sun's barycentric reflex.
 * @param {Object} args
 * @param {{r_AU:number[], v_AUperD:number[]}} args.earth  // heliocentric
 * @param {{name:string, id:number, r_AU:number[], v_AUperD:number[]}[]} args.planets // heliocentric
 * @param {{r_AU:number[]}?} args.moon    // optional heliocentric Moon
 * @param {number?} args.moonDistance_km  // if you already have Earth‚ÄìMoon distance
 */
function planetaryContext({ earth, planets, moon=null, moonDistance_km=null }) {
  // 1) Earth‚ÄìMoon distance for scaling (km)
  let rMoon_km;
  if (moonDistance_km) {
    rMoon_km = moonDistance_km;
  } else if (moon?.r_AU) {
    const d_AU = Math.hypot(
      moon.r_AU[0] - earth.r_AU[0],
      moon.r_AU[1] - earth.r_AU[1],
      moon.r_AU[2] - earth.r_AU[2]
    );
    rMoon_km = d_AU * AU_km;
  } else {
    // Fallback to mean distance if nothing is provided
    rMoon_km = 384400;
  }

  // 2) Planetary tidal add-ons at Earth (peak-equivalent, nGal)
  // Reference: Moon peak ‚âà 110 ¬µGal at mean distance.
  const moonPeak_uGal = 110.0;

  const list = planets.map(p => {
    const mu_p = MU_BY_ID.get(p.id);
    if (!mu_p) return { name: p.name, nGal: 0, relMoonPct: 0 };

    // Earth‚Äìplanet distance (AU -> km)
    const dE_AU = Math.hypot(
      p.r_AU[0] - earth.r_AU[0],
      p.r_AU[1] - earth.r_AU[1],
      p.r_AU[2] - earth.r_AU[2]
    );
    const r_pk_km = dE_AU * AU_km;

    // Peak-equivalent tidal amplitude scales as (Œº_p/Œº_moon)*(r_moon/r_p)^3 times the Moon's peak
    const ratio = (mu_p / MU.moon) * Math.pow(rMoon_km / r_pk_km, 3);
    const uGal = moonPeak_uGal * ratio;
    const nGal = uGal * 1000; // 1 ¬µGal = 1000 nGal

    return {
      name: p.name,
      nGal: +nGal.toExponential(2),
      relMoonPct: +(ratio * 100).toFixed(3)   // % of Moon's peak
    };
  });

  const total_nGal = +list.reduce((s,x)=>s + (isFinite(x.nGal)? +x.nGal : 0), 0).toExponential(2);

  // 3) Sun‚ÄìSSB offset & Sun reflex speed (use Œº-weighted sums in heliocentric frame)
  // R_ssb = Œ£ Œº_i r_i / (Œº_sun + Œ£ Œº_i), V_ssb = Œ£ Œº_i v_i / (Œº_sun + Œ£ Œº_i)
  const sumMu = planets.reduce((s,p)=> s + (MU_BY_ID.get(p.id) || 0), 0);
  const denom = MU.sun + sumMu;

  let Rx=0, Ry=0, Rz=0, Vx=0, Vy=0, Vz=0;
  for (const p of planets) {
    const mu = MU_BY_ID.get(p.id) || 0;
    Rx += mu * p.r_AU[0];
    Ry += mu * p.r_AU[1];
    Rz += mu * p.r_AU[2];
    Vx += mu * p.v_AUperD[0];
    Vy += mu * p.v_AUperD[1];
    Vz += mu * p.v_AUperD[2];
  }
  // Position in AU relative to Sun
  const R_AU = Math.hypot(Rx/denom, Ry/denom, Rz/denom);
  const ssbOffset_km = +(R_AU * AU_km).toFixed(0);

  // Velocity in AU/day -> m/s
  const V_AUperD = Math.hypot(Vx/denom, Vy/denom, Vz/denom);
  const sunReflex_mps = +((V_AUperD) * AUperDay_to_mps).toFixed(3);

  return { tidalAddons_nGal: { total_nGal, list }, ssbOffset_km, sunReflex_mps };
}

// Horizontal tide & bearing from alt/az (we already compute vertical via zenithFactor)
function tideVectorComponents(uGalScale, rRef, rNow, altDeg, azDeg){
  const k = uGalScale * Math.pow(rRef / rNow, 3);
  const z = (90 - altDeg) * Math.PI/180;
  const av = k * Math.abs(3*Math.cos(z)**2 - 1);           // vertical magnitude (¬µGal)
  const ah = k * Math.abs(3*Math.cos(z)*Math.sin(z));      // horizontal magnitude (¬µGal)
  const bearing = (azDeg + (Math.cos(z) >= 0 ? 0 : 180)) % 360; // toward body or opposite if below horizon
  return { av_uGal:+av.toFixed(1), ah_uGal:+ah.toFixed(1), bearing:+bearing.toFixed(0) };
}

// Solar azimuth (rough; consistent with your sunAltDeg model)
function sunAzDeg(ts, lat, lon){
  // reuse the internals of sunAltDeg to get H, delta
  const date = new Date(ts);
  const n = Math.floor((Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()) - Date.UTC(date.getUTCFullYear(),0,0))/86400000);
  const RAD = Math.PI/180;
  const L = (280.46 + 0.9856474*n) % 360;
  const g = (357.528 + 0.9856003*n) % 360;
  const lambda = L + 1.915*Math.sin(g*RAD) + 0.020*Math.sin(2*g*RAD);
  const epsilon = 23.439 - 0.0000004*n;
  const delta = Math.asin(Math.sin(epsilon*RAD)*Math.sin(lambda*RAD)); // declination
  const timeUTC = date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600;
  const eqTime =  - (1.915*Math.sin(g*RAD) + 0.020*Math.sin(2*g*RAD) - 2.466*Math.sin(2*lambda*RAD) + 0.053*Math.sin(4*lambda*RAD)); // ~min
  const tst = (timeUTC*60 + eqTime + lon*4) / 4;
  const H = ((tst - 12)*15) * RAD; // hour angle
  const phi = lat*RAD;
  const az = Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(phi) - Math.tan(delta)*Math.cos(phi)); // rad
  let deg = az*180/Math.PI;
  if (deg < 0) deg += 360;
  return deg;
}

// Tidal potential proxy and 1-second average around timestamp
// Returns {Ubar, nsPerSecond} where nsPerSecond = Ubar/c^2 * 1s in nanoseconds
function oneSecondTidalPotential(ts, lat, lon){
  const rSun_AU_now = earthSunDistance(ts);
  const sunAlt_now  = sunAltDeg(ts, lat, lon);
  const sunAz_now   = sunAzDeg(ts, lat, lon);

  const mc_now = moonContext(ts, lat, lon);

  // Simple normalized potential pieces with relative scalings so Moon dominates tide
  const P2 = z => (3*Math.cos(z)**2 - 1)/2;
  function Ut_at(time){
    const rS = earthSunDistance(time);
    const sAlt = sunAltDeg(time, lat, lon);
    const zS = (90 - sAlt) * Math.PI/180;

    const mC  = moonContext(time, lat, lon);
    const zM  = (90 - mC.altDeg) * Math.PI/180;

    const KS = 0.5;  // Sun scale
    const KM = 1.1;  // Moon scale (dominates)
    return KS*Math.pow(1/rS,3)*P2(zS) + KM*Math.pow(384400/mC.distance_km,3)*P2(zM); // arbitrary J/kg scale
  }

  const U1 = Ut_at(ts - 500); // t-0.5 s
  const U2 = Ut_at(ts + 500); // t+0.5 s
  const Ubar = 0.5*(U1+U2);

  const nsPerSecond = Ubar / (299792458**2) * 1e9; // ns over 1 s
  return { Ubar, nsPerSecond: +nsPerSecond.toExponential(3) };
}

// Kinematic dilation (ns over 1 s) from speed v (m/s)
function kinematic_ns_per_1s(latDeg){
  const v_orb = 29780;                      // m/s
  const v_rot = 465 * Math.cos(latDeg*Math.PI/180); // m/s
  const v2 = v_orb*v_orb + v_rot*v_rot;
  const ns = (v2/(2*299792458**2)) * 1e9;   // ns per second
  return +ns.toFixed(3);
}

/* =========================
   Record build from a file name or timestamp
========================= */
const store = {
  items: [],            // array of records (see example schema)
  selected: new Set(),  // ids of selected items
  view: { haloMode: 'year', frame: 'home' },
  refs: {},             // runtime refs (scene objects)
  defaultSite: null     // user-set default location
};

async function buildRecordFromTimestamp(name, ts, opts={}) {
  const id = uid();
  const year = new Date(ts).getUTCFullYear();
  const angle = heliocentricLongitude(ts); // radians
  const r = earthSunDistance(ts);
  const angleDeg = angle*180/Math.PI;
  const dist = r; // AU

  // location defaults (user can set a global location)
  const lat = (opts.lat ?? store.defaultSite?.lat ?? 34.05);
  const lon = (opts.lon ?? store.defaultSite?.lon ?? -118.25);
  const tz = opts.tz || store.defaultSite?.tz; // Store capture timezone

  // Try precise ephemerides (BCRS/GCRS); fallback to approximations on failure
  let eph = null;
  try { eph = await fetchBCRS(new Date(ts).toISOString()); } catch { /* keep null */ }

  // SUN distance & light-time
  let rSun_AU, sunLight_s, sunAlt, sunAz;
  if (eph){
    rSun_AU   = Math.hypot(...eph.earth.r_AU); // heliocentric Earth distance (‚âà1 AU)
    sunLight_s= eph.sunObs.lt_s;               // Earth observer to Sun light-time
    const aa  = raDecToAltAz(ts, lat, lon, eph.sunObs.ra_deg, eph.sunObs.dec_deg);
    sunAlt = aa.altDeg; sunAz = aa.azDeg;
  } else {
    rSun_AU   = earthSunDistance(ts);
    sunLight_s= +(rSun_AU * 149597870.7 / 299792.458); // km / (km/s)
    sunAlt    = sunAltDeg(ts, lat, lon);
    sunAz     = sunAzDeg(ts, lat, lon);
  }

  // MOON distance, light-time, alt/az
  let rMoon_km, moonLight_s, moonAlt, moonAz, moonPhasePct, moonPerigeeProx, moonRelPct;
  if (eph){
    rMoon_km   = eph.moonObs.range_AU * 149597870.7;
    moonLight_s= eph.moonObs.lt_s;
    const aa   = raDecToAltAz(ts, lat, lon, eph.moonObs.ra_deg, eph.moonObs.dec_deg);
    moonAlt = aa.altDeg; moonAz = aa.azDeg;
    // Keep your existing illumination estimates
    const mctx = moonContext(ts, lat, lon);
    moonPhasePct = mctx.phasePct; moonPerigeeProx = mctx.perigeeProx; moonRelPct = mctx.lunarRelPct;
  } else {
    const mctx = moonContext(ts, lat, lon);
    rMoon_km = mctx.distance_km; moonLight_s = rMoon_km/299792.458;
    moonAlt  = mctx.altDeg; moonAz = 0; // (approx omitted earlier)
    moonPhasePct = mctx.phasePct; moonPerigeeProx = mctx.perigeeProx; moonRelPct = mctx.lunarRelPct;
  }

  // Solar tide: relative % and ¬µGal, now with proper alt/az
  const sunZenF = zenithFactor(sunAlt);
  const aSunNow = TIDE.A_sun_uGal * Math.pow(TIDE.rSunRef_AU / rSun_AU, 3) * sunZenF;
  const solarRelPct = +((Math.pow(TIDE.rSunRef_AU / rSun_AU, 3) - 1)*100).toFixed(1);

  // Lunar tide:
  const moonZenF = zenithFactor(moonAlt);
  const aMoonNow = TIDE.A_moon_uGal * Math.pow(TIDE.rMoonRef_km / rMoon_km, 3) * moonZenF;

  // Build a daily sample to normalize index to that day's local max
  const startUTC = Date.UTC(new Date(ts).getUTCFullYear(), new Date(ts).getUTCMonth(), new Date(ts).getUTCDate(), 0,0,0);
  let maxDay = 1;
  for (let minutes=0; minutes<1440; minutes+=10){
    const t = startUTC + minutes*60000;
    const sAlt = eph ? sunAlt : sunAltDeg(t, lat, lon); // Use BCRS data if available
    const sZF  = zenithFactor(sAlt);
    const rS   = eph ? rSun_AU : earthSunDistance(t);
    const aS   = TIDE.A_sun_uGal * Math.pow(TIDE.rSunRef_AU / rS, 3) * sZF;

    const mc   = eph ? {altDeg: moonAlt, distance_km: rMoon_km} : moonContext(t, lat, lon);
    const mZF  = zenithFactor(mc.altDeg);
    const aM   = TIDE.A_moon_uGal * Math.pow(TIDE.rMoonRef_km / mc.distance_km, 3) * mZF;

    maxDay = Math.max(maxDay, Math.abs(aS + aM));
  }
  const tideIndex = Math.round(100 * Math.min(1, Math.abs(aSunNow + aMoonNow) / maxDay));

  // --- Light-second voxel context ---
  const AU = 149597870.7; // km per AU
  // crude barycentric speed: orbital + optional surface rotation projection (keep orbital for clarity)
  const v_kms = V_Earth_orbit_kms; // you can add a few 0.1 km/s for rotation if you like
  const voxelFrac = +voxelFraction(v_kms).toExponential(2); // fraction of 1 light-second in 1 s

  // 1-second tidal potential average and clock bias
  const oneSec = oneSecondTidalPotential(ts, lat, lon);

  // Kinematic dilation and combined rate
  const kinNS = kinematic_ns_per_1s(lat);
  const combNS = +(kinNS + parseFloat(oneSec.nsPerSecond)).toFixed(3);

  // Full vector components for both bodies
  const tvSun  = tideVectorComponents(TIDE.A_sun_uGal,  TIDE.rSunRef_AU,   rSun_AU,   sunAlt,  sunAz || 0);
  const tvMoon = tideVectorComponents(TIDE.A_moon_uGal, TIDE.rMoonRef_km,  rMoon_km,  moonAlt, moonAz || 0);

  // Planetary context (if available)
  let planetaryCtx = null;
  if (eph && eph.planets && eph.planets.length > 0) {
    planetaryCtx = planetaryContext({
      earth: eph.earth,
      moon: eph.moon,
      moonDistance_km: rMoon_km,
      planets: eph.planets
    });
  }

  const record = {
    id, name, when: new Date(ts).toISOString(), tz: tz || Intl.DateTimeFormat().resolvedOptions().timeZone,
    where: { lat, lon, alt_m: (opts.alt_m ?? 120) },
    year,
    homeAngleDeg: +angleDeg.toFixed(2),
    cosmic: { x_AU: +(Math.cos(angle)*dist).toFixed(3), y_AU: +(Math.sin(angle)*dist).toFixed(3), z_AU: 0,
              drift_since_AU: +(((Date.now()-ts)/86400000/365.25) * 46 /* AU/yr */).toFixed(1) },
    states: {
      dayPhase: dayPhaseTag(sunAlt),
      sunAltDeg: +sunAlt.toFixed(1),
      moonAltDeg: +moonAlt.toFixed(1),
      dayLengthMin: null,
      season: { daysFromSolstice: null, sunDeclDeg: null },
      equationOfTimeMin: null,
      lunar: { phasePct: moonPhasePct, perigeeProx: moonPerigeeProx },
      tides: {
        solarRelPct,
        lunarRelPct: moonRelPct,
        sun_uGal: +aSunNow.toFixed(1),
        moon_uGal: +aMoonNow.toFixed(1),
        index0to100: tideIndex
      },
      voxel: {
        sunLightTime_s: +sunLight_s.toFixed(1),
        moonLightTime_s: +moonLight_s.toFixed(1),
        voxelFraction: voxelFrac,
        ns_per_1s: oneSec.nsPerSecond,
        kin_ns_per_1s: kinNS,
        combined_ns_per_1s: combNS
      },
      tideVec: {
        sun: tvSun,    // {av_uGal, ah_uGal, bearing}
        moon: tvMoon
      },
      frames: { 
        geometry: eph ? 'BCRS/ICRF (Sun-centered via Horizons)' : 'Approx heliocentric',
        site: 'GCRS (local site sky/tides)' 
      },
      planetary: planetaryCtx ? {
        tidalAddons_nGal: planetaryCtx.tidalAddons_nGal,
        ssbOffset_km: planetaryCtx.ssbOffset_km,
        sunReflex_mps: planetaryCtx.sunReflex_mps
      } : null
    }
  };

  // --- Causal & envelope metrics ---
  // Retarded-time inputs already exist: states.voxel.sunLightTime_s / moonLightTime_s
  const Ubar_1m = envelopeAverage_U(ts, lat, lon, 60);
  const Ubar_1h = envelopeAverage_U(ts, lat, lon, 3600);
  const TS_envelope_1m = +(60 / Math.max(sunLight_s, moonLight_s)).toFixed(2);
  const TS_envelope_1h = +(3600 / Math.max(sunLight_s, moonLight_s)).toFixed(2);

  // P2 factors (geometry, not just altitude) - safe with altitude clamping
  const P2sun  = +P2_fromAltDeg(sunAlt).toFixed(3);
  const P2moon = +P2_fromAltDeg(moonAlt).toFixed(3);

  // Sun‚ÄìMoon synodic phase and long-cycle tags
  const lamS = sunEclipticLongitudeDeg(ts);
  const lamM = moonEclipticLongitudeDeg_fast(ts);
  const sunMoonPhaseDeg = (((lamM - lamS)+540)%360) - 180; // ‚àí180..+180
  const longCycles = lunarLongCyclePhases(ts);

  // Net horizontal tidal vector (you already compute components; sum them)
  const netAh_uGal = +(tvSun.ah_uGal + tvMoon.ah_uGal).toFixed(1);
  const netBearingDeg = (() => {
    // simple weighted average by ah magnitude
    const wS = tvSun.ah_uGal, wM = tvMoon.ah_uGal;
    const x = wS*Math.cos(tvSun.bearing*RAD) + wM*Math.cos(tvMoon.bearing*RAD);
    const y = wS*Math.sin(tvSun.bearing*RAD) + wM*Math.sin(tvMoon.bearing*RAD);
    let ang = Math.atan2(y,x)*180/Math.PI; if (ang<0) ang+=360; return +ang.toFixed(0);
  })();

  // Equivalent elevation from average potential (1 s window used)
  // If your U is a proxy (not J/kg), mark as normalized.
  // Set IS_PHYSICAL_U = true only after you calibrate KS/KM to physical potential.
  const IS_PHYSICAL_U = false;

  // Light-time band metrics for this memory
  const msFromGreenwich = wrapMs( longToLightMs(lon || 0, lat || 0) );
  const zoneIndex = Math.round((msFromGreenwich / LT_zone_ms)); // nearest 15¬∞ zone (in ms-units)
  const msToNearestZoneEdge = wrapMs(msFromGreenwich % LT_zone_ms, LT_zone_ms/2);

  record.states.lightBands = {
    msFromGreenwich,        // where this memory sits on the dial, in light milliseconds
    zoneIndex,              // integer index of nearest time zone (0=Greenwich)
    msToNearestZoneEdge,    // distance to zone edge, ms
    msPerZone: LT_zone_ms,  // ~5.56 ms
    msFull: LT_full_ms      // ~133.7 ms
  };
  const eqElev_mm = IS_PHYSICAL_U ? +((oneSec.Ubar / 9.80665) * 1000).toFixed(3) : null;

  // Store new fields
  record.states.envelope = {
    Ubar_1m, Ubar_1h, TS_envelope_1m, TS_envelope_1h
  };
  record.states.geometryP2 = { P2sun, P2moon };
  record.states.sunMoon = {
    phaseDeg: +sunMoonPhaseDeg.toFixed(1),
    lambdaSunDeg: +lamS.toFixed(1),
    lambdaMoonDeg: +lamM.toFixed(1),
    nodalPhaseDeg: +longCycles.nodalPhaseDeg.toFixed(1),
    perigeePhaseDeg: +longCycles.perigeePhaseDeg.toFixed(1)
  };
  record.states.tideNet = { ah_uGal: netAh_uGal, bearingDeg: netBearingDeg };
  record.states.eqElevation_mm = eqElev_mm;           // null ‚Üí hidden in UI
  record.states.eqElevation_norm = +((oneSec.Ubar) * 1000).toFixed(2); // "normalized mm-equiv"
  
  return record;
}

/* =========================
   Three.js scene
========================= */
let scene, camera, renderer, sunMesh;
const halos = new Map(); // year -> THREE.Line (shared)
const markers = new Map(); // id -> Mesh
const labels = new Map(); // id -> THREE.Sprite
const ownHalos = new Map(); // id -> THREE.Line (one per file)

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(-2, -2); // off-screen
let hoverId = null;

// Orbit controls (sun-centered)
const ORBIT = {
  target: new THREE.Vector3(0,0,0),
  spherical: new THREE.Spherical(4.0, Math.PI/2.6, 0), // r, phi, theta
  isDrag:false, lastX:0, lastY:0,
  rotateSpeed: 0.008,  // mouse/touch rotate
  zoomSpeed: 0.95,     // wheel/pinch scaling per step (<1 zoom in)
  minR: 0.5, maxR: 8.0,
  minPhi: 0.15, maxPhi: Math.PI-0.15,
  touches: new Map(), lastPinchDist: null
};
function applyOrbit() {
  const s = ORBIT.spherical;
  s.radius = Math.min(ORBIT.maxR, Math.max(ORBIT.minR, s.radius));
  s.phi    = Math.min(ORBIT.maxPhi, Math.max(ORBIT.minPhi, s.phi));
  const p = new THREE.Vector3().setFromSpherical(s).add(ORBIT.target);
  camera.position.copy(p);
  camera.lookAt(ORBIT.target);
}
function syncOrbitFromCamera() {
  const v = camera.position.clone().sub(ORBIT.target);
  ORBIT.spherical.setFromVector3(v);
}

function initScene() {
  const canvas = document.getElementById('renderer');
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2)); // crisp, safe
  resize();
  window.addEventListener('resize', resize);

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    45,
    canvas.clientWidth / canvas.clientHeight,
    0.01,
    2000
  );
  camera.position.set(0, 2.4, 4.0);
  camera.lookAt(0, 0, 0);             // üëà ensure we face the orbit center

  // Initialize orbit controls
  syncOrbitFromCamera();
  applyOrbit();

  // Lights
  const amb = new THREE.AmbientLight(0x223355, 0.7);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(3, 3, 2);
  scene.add(dir);

  // Sun
  const sunGeo = new THREE.SphereGeometry(0.08, 32, 32);
  const sunMat = new THREE.MeshBasicMaterial({ color: 0xffd26a });
  sunMesh = new THREE.Mesh(sunGeo, sunMat);
  scene.add(sunMesh);

  // Add orbital plane ring for reference
  addOrbitalPlane();

  // draw at least one halo so the canvas isn't empty
  ensureYearHalo(new Date().getUTCFullYear());   // üëà base ellipse

  animate();

  // Mouse hover listeners for labels
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  });
  canvas.addEventListener('mouseleave', ()=>{ mouse.set(-2,-2); hoverId=null; updateLabelVisibility(); });

  // Orbit controls - Mouse rotate
  canvas.addEventListener('mousedown', (e)=>{
    ORBIT.isDrag = true; ORBIT.lastX = e.clientX; ORBIT.lastY = e.clientY;
  });
  window.addEventListener('mouseup', ()=> ORBIT.isDrag = false);
  window.addEventListener('mousemove', (e)=>{
    if(!ORBIT.isDrag) return;
    const dx = e.clientX - ORBIT.lastX;
    const dy = e.clientY - ORBIT.lastY;
    ORBIT.lastX = e.clientX; ORBIT.lastY = e.clientY;
    ORBIT.spherical.theta -= dx * ORBIT.rotateSpeed;        // azimuth
    ORBIT.spherical.phi   -= dy * ORBIT.rotateSpeed;        // polar
    applyOrbit();
  });

  // Wheel zoom
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const f = e.deltaY > 0 ? 1/ORBIT.zoomSpeed : ORBIT.zoomSpeed;
    ORBIT.spherical.radius *= f;
    applyOrbit();
  }, { passive:false });

  // Touch support helpers
  function pinchDistance(touches){
    const a = touches[0], b = touches[1];
    const dx = a.clientX - b.clientX, dy = a.clientY - b.clientY;
    return Math.hypot(dx, dy);
  }

  // Touch events
  canvas.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    for(const t of e.changedTouches) ORBIT.touches.set(t.identifier, {x:t.clientX, y:t.clientY});
    if (ORBIT.touches.size === 2) {
      ORBIT.lastPinchDist = pinchDistance([...e.touches]);
    }
  },{passive:false});

  canvas.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    const points = [...e.touches];
    if (points.length === 1) {
      // rotate
      const t = points[0];
      const prev = ORBIT.touches.get(t.identifier) || {x:t.clientX, y:t.clientY};
      const dx = t.clientX - prev.x;
      const dy = t.clientY - prev.y;
      ORBIT.touches.set(t.identifier, {x:t.clientX, y:t.clientY});
      ORBIT.spherical.theta -= dx * ORBIT.rotateSpeed;
      ORBIT.spherical.phi   -= dy * ORBIT.rotateSpeed;
      applyOrbit();
    } else if (points.length === 2) {
      // pinch zoom
      const d = pinchDistance(points);
      if (ORBIT.lastPinchDist != null) {
        const scale = d > ORBIT.lastPinchDist ? ORBIT.zoomSpeed : 1/ORBIT.zoomSpeed;
        ORBIT.spherical.radius *= scale;
        applyOrbit();
      }
      ORBIT.lastPinchDist = d;
    }
  },{passive:false});

  canvas.addEventListener('touchend', (e)=>{
    for(const t of e.changedTouches) ORBIT.touches.delete(t.identifier);
    if (ORBIT.touches.size < 2) ORBIT.lastPinchDist = null;
  },{passive:false});
}
function resize() {
  const host = document.getElementById('scene');
  const canvasEl = renderer?.domElement || document.getElementById('renderer');
  const w = host.clientWidth;
  const h = Math.max(360, window.innerHeight - host.getBoundingClientRect().top - 240);
  canvasEl.style.width = w + 'px';
  canvasEl.style.height = h + 'px';
  if (renderer) renderer.setSize(w, h, false);
  if (camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); }
}
function animate(){
  requestAnimationFrame(animate);
  
  // hover picking
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects([...markers.values()], false);
  hoverId = intersects.length ? intersects[0].object.userData.id : null;
  updateLabelVisibility();
  
  window.ColorDirector?.tick?.(performance.now());

  renderer.render(scene, camera);
}

/* Orbit (ellipse) by year - precise from Horizons */
async function getHalo(year){
  if (halosPrecise.has(year)) return halosPrecise.get(year);     // precise ready
  if (halos.has(year)) return halos.get(year);                   // fallback (approx)

  // show an immediate approx ring so canvas isn't empty
  const approx = (function(){
    const pts= [];
    const a=1.0, b=Math.sqrt(1-eEarth*eEarth)*a;
    for(let i=0;i<=360;i++){
      const th = i*RAD; pts.push(new THREE.Vector3(a*Math.cos(th),0,b*Math.sin(th)));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    geo.computeBoundingSphere();
    const mat = createOrbitLineMaterial(0.62);
    const line = new THREE.Line(geo, mat);
    line.computeLineDistances();
    prepareOrbitGradientLine(line);
    scene.add(line);
    halos.set(year, line);
    return line;
  })();

  // fetch precise elements and hot-swap the geometry when ready
  try{
    const el = await fetchElementsForYear(year);
    const geo = elementsToEllipseGeometry(el, 960);
    const mat = createOrbitLineMaterial(0.85);
    const precise = new THREE.Line(geo, mat);
    precise.computeLineDistances();
    prepareOrbitGradientLine(precise);
    precise.visible = approx.visible;           // respect current mode
    scene.add(precise);
    halosPrecise.set(year, precise);

    // remove approx
    releaseOrbitGradientLine(approx);
    scene.remove(approx);
    halos.delete(year);

    return precise;
  }catch(err){
    console.warn('Precise orbit fetch failed for year', year, err);
    return approx;
  }
}

async function ensureYearHalo(year){
  const line = await getHalo(year);
  const visible = (store.view.haloMode === 'year');
  line.visible = visible;
}

async function warmYears(){
  const years = [...new Set(store.items.map(r=>r.year))];
  console.log('Pre-fetching precise orbits for years:', years);
  await Promise.allSettled(years.map(y=>ensureYearHalo(y)));
  console.log('Orbit pre-fetch complete');
}

/* Marker */
function addMarker(rec){
  // marker sphere
  const geom = new THREE.SphereGeometry(0.015, 16, 16);
  const mat = new THREE.MeshStandardMaterial({ color:0x9ad1ff, emissive:0x0, metalness:0.1, roughness:0.4 });
  const m = new THREE.Mesh(geom, mat);
  const ang = rec.homeAngleDeg * RAD;
  const a = 1.0, b = Math.sqrt(1 - eEarth*eEarth) * a;
  const x = a*Math.cos(ang), z = b*Math.sin(ang);
  m.position.set(x, 0, z);
  m.userData.id = rec.id;
  scene.add(m);
  markers.set(rec.id, m);

  // label sprite
  const spr = makeLabelSprite(rec.name);
  spr.position.copy(m.position).add(new THREE.Vector3(0.04, 0.04, 0)); // slight offset
  scene.add(spr);
  labels.set(rec.id, spr);

  // own ellipse: EXACTLY the same path as the shared year halo (no scaling),
  // but with a unique dashed color so it's visually distinct without being misleading.
  (async function addOwnEllipse(){
    const yearLine = await getHalo(rec.year);              // ensure year halo exists
    const baseGeo  = yearLine.geometry;                    // reuse exact geometry
    const geoClone = baseGeo.clone();                      // clone to keep materials separate
    // Make sure dashed distances are present
    const tmp = new THREE.Line(geoClone, new THREE.LineBasicMaterial());
    tmp.computeLineDistances();

    const color = hashColor(rec.name + rec.when);          // stable per-file color
    const mat   = makeDashedMat(color);
    const line  = new THREE.Line(geoClone, mat);
    line.position.y = 0.0001; // 0.1 mm in our AU units‚Äîpurely visual to prevent z-fighting
    line.visible = (store.view.haloMode === 'own');
    scene.add(line);
    ownHalos.set(rec.id, line);
  })();
}

/* Orbital plane ring for reference */
function addOrbitalPlane() {
  const ring = new THREE.RingGeometry(0.98, 1.02, 128);
  const mat = new THREE.MeshBasicMaterial({ 
    color: 0x2b3e7a, 
    transparent: true, 
    opacity: 0.15, 
    side: THREE.DoubleSide, 
    depthWrite: false 
  });
  const mesh = new THREE.Mesh(ring, mat);
  mesh.rotation.x = -Math.PI / 2; // lie in XZ plane
  scene.add(mesh);
}

/* =========================
   UI bindings
========================= */
const elFile = document.getElementById('file');
document.getElementById('btnUpload').onclick = ()=> elFile.click();
elFile.addEventListener('change', async (e)=>{
  const files = [...e.target.files];
  for (const f of files) {
    // For demo: use file lastModified as timestamp (EXIF parsing optional)
    const rec = await buildRecordFromTimestamp(f.name, f.lastModified);
    store.items.push(rec);
    await ensureYearHalo(rec.year);
    addMarker(rec);
  }
  renderList();
  warmYears(); // pre-fetch precise orbits
});


document.getElementById('btnSample').onclick = async ()=>{
  // Seed with a few demo items including equinox samples at exact wall-clock times
  const base = Date.UTC(2023,5,21,9,14);
  const samples = await Promise.all([
    buildRecordFromTimestamp('Solstice Sunrise.jpg', base, {lat:34.05, lon:-118.25}),
    buildRecordFromTimestamp('Equinox Noon.jpg', Date.UTC(2023,2,20,19,0), {lat:40.71, lon:-74.00}),
    buildRecordFromTimestamp('Perigee Moon.mp4', Date.UTC(2023,7,30,3,10), {lat:51.50, lon:-0.12}),
    buildRecordFromTimestamp('Aphelion Walk.png', Date.UTC(2023,6,6,1,0), {lat:35.68, lon:139.69}),
    buildRecordFromTimestamp('Equinox Noon-Blue', toTs('2016-09-22T13:41:00+02:00'), {lat:45.0, lon:-120.0, tz:'Europe/Paris'}),
    buildRecordFromTimestamp('Equinox Noon-Orange', toTs('2025-09-22T07:29:00-04:00'), {lat:45.0, lon:-120.0, tz:'America/New_York'}),
  ]);
  for (const rec of samples) {
    store.items.push(rec);
    await ensureYearHalo(rec.year);
    addMarker(rec);
  }
  renderList();
  warmYears(); // pre-fetch precise orbits
};

document.getElementById('btnHaloOwn').onclick = ()=>{
  store.view.haloMode = 'own';
  setActive('btnHaloOwn', true); setActive('btnHaloYear', false);
  // show own halos, hide shared
  ownHalos.forEach(l=> l.visible = true);
  halos.forEach(l=> l.visible = false);
  halosPrecise.forEach(l=> l.visible = false);
};
document.getElementById('btnHaloYear').onclick = ()=>{
  store.view.haloMode = 'year';
  setActive('btnHaloOwn', false); setActive('btnHaloYear', true);
  ownHalos.forEach(l=> l.visible = false);
  halos.forEach(l=> l.visible = true);
  halosPrecise.forEach(l=> l.visible = true);
};
document.getElementById('btnSetSite').onclick = ()=>{
  const lat = prompt('Latitude (deg, north positive):', '34.05');
  const lon = prompt('Longitude (deg, east positive):', '-118.25');
  if(lat!=null && lon!=null){
    const site = { lat: +lat, lon: +lon };
    store.defaultSite = site;
    window.ColorDirector?.setSite?.(site);
    alert('Default site set. New uploads will use this unless EXIF GPS is present.');
  }
};

document.getElementById('btnHome').onclick = ()=>{
  store.view.frame = 'home';
  setActive('btnHome', true); setActive('btnCosmic', false);
};
document.getElementById('btnCosmic').onclick = ()=>{
  store.view.frame = 'cosmic';
  setActive('btnHome', false); setActive('btnCosmic', true);
};

document.getElementById('btnZoomIn').onclick = ()=> { camera.position.multiplyScalar(0.9); };
document.getElementById('btnZoomOut').onclick = ()=> { camera.position.multiplyScalar(1.1); };
document.getElementById('btnResetCam').onclick = () => {
  camera.position.set(0, 2.4, 4.0);
  camera.lookAt(0, 0, 0);     // üëà keep target correct
};

function setActive(id, on){ const el = document.getElementById(id); if(on) el.classList.add('active'); else el.classList.remove('active'); }

function makeToggleRow(label, value, help) {
  const wrap = document.createElement('div');
  const r = document.createElement('div');
  r.className = 'row toggle';
  r.innerHTML = `<span><span class="arrow">‚ñ∂</span><b>${label}</b></span><span>${value ?? ''}</span>`;
  r.onclick = () => r.classList.toggle('open');

  const desc = document.createElement('div');
  desc.className = 'desc';
  desc.textContent = help;

  wrap.appendChild(r);
  wrap.appendChild(desc);
  return wrap;
}

/* File list + selection tray */
function renderList(){
  const list = document.getElementById('fileList');
  list.innerHTML = '';
  for(const rec of store.items){
    const row = document.createElement('div');
    row.className = 'item' + (store.selected.has(rec.id)?' active':'');
    // Use timezone-aware formatting: memory's capture zone, not viewer's local
    const labelTime = fmt.dateLocal(Date.parse(rec.when), rec.tz);
    row.textContent = `${rec.name} ‚Äì ${labelTime}`;
    row.onclick = ()=> toggleSelect(rec.id);
    list.appendChild(row);
  }
  renderStates();
}
function toggleSelect(id){
  if (store.selected.has(id)) store.selected.delete(id);
  else store.selected.add(id);
  renderList(); highlightSelection();
}

function highlightSelection(){
  markers.forEach((mesh,id)=>{
    const sel = store.selected.has(id);
    mesh.material.emissive = new THREE.Color(sel ? 0x224488 : 0x000000);
    mesh.scale.setScalar(sel? 1.6 : 1.0);
  });
  updateLabelVisibility();
}

function updateLabelVisibility(){
  labels.forEach((spr, id)=>{
    const sel = store.selected.has(id);
    spr.visible = sel || id === hoverId;
  });
}

// Light-time dial renderer
function renderLightTimeDial(){
  const cvs = document.getElementById('ltDialCanvas');
  if (!cvs) return;
  const ctx = cvs.getContext('2d');
  const W = cvs.width, H = cvs.height;
  ctx.clearRect(0,0,W,H);

  // Track span: full 133.7 ms mapped to width
  const msFull = LT_full_ms;
  const xOf = ms => ( (ms + msFull/2) / msFull ) * (W-40) + 20;

  // Base bar
  ctx.fillStyle = '#122044'; ctx.fillRect(20, H/2-8, W-40, 16);

  // 1 ms ticks
  ctx.strokeStyle = '#203364'; ctx.lineWidth = 1;
  for (let ms=-msFull/2; ms<=msFull/2; ms+=1){
    const x = xOf(ms);
    const h = (Math.abs(ms%5)<1e-6) ? 10 : 6;
    ctx.beginPath(); ctx.moveTo(x, H/2-8); ctx.lineTo(x, H/2-8-h); ctx.stroke();
  }

  // Zone separators (~5.56 ms)
  ctx.strokeStyle = '#3a4e86'; ctx.lineWidth = 2;
  for (let ms=-msFull/2; ms<=msFull/2; ms+=LT_zone_ms){
    const x = xOf(ms); ctx.beginPath(); ctx.moveTo(x, H/2-14); ctx.lineTo(x, H/2+14); ctx.stroke();
  }

  // Labels
  ctx.fillStyle = '#9fb0d9'; ctx.font = '12px Inter';
  ctx.fillText('Light-time along Earth (ms)', 20, 18);
  ctx.fillText('Zones = 15¬∞ ‚âà 5.56 ms; small ticks = 1 ms', 20, H-10);

  // Markers for selected records
  const sel = [...store.selected].map(id => store.items.find(r => r.id===id)).filter(Boolean);
  const palette = ['#7bdcf3','#8d9bff','#ffd26a','#43d1a0','#ff9aa2'];
  sel.forEach((rec, i) => {
    const ms = rec.states?.lightBands?.msFromGreenwich; if (typeof ms!=='number') return;
    const x = xOf(ms);
    ctx.fillStyle = palette[i % palette.length];
    ctx.beginPath(); ctx.arc(x, H/2, 6, 0, Math.PI*2); ctx.fill();
    ctx.fillText(`${rec.name}: ${ms.toFixed(2)} ms`, Math.min(Math.max(20, x+8), W-220), 34+i*14);
  });
}

function renderStates(){
  const chips = document.getElementById('chips');
  const single = document.getElementById('single');
  const diff = document.getElementById('diffText');
  const multi = document.getElementById('multi');
  chips.innerHTML = ''; single.innerHTML = ''; diff.innerHTML = '‚Äî';

  const sel = [...store.selected].map(id=>store.items.find(x=>x.id===id));
  
  // Visibility rules: 0 -> hint, 1 -> show single/collapse multi, 2+ -> collapse single/show multi
  if (sel.length === 0) {
    single.classList.remove('collapsed');
    single.classList.add('expanded');
    multi.classList.add('collapsed');
    multi.classList.remove('expanded');
  } else if (sel.length === 1) {
    single.classList.remove('collapsed');
    single.classList.add('expanded');
    multi.classList.add('collapsed');
    multi.classList.remove('expanded');
    diff.innerHTML = '‚Äî';
  } else {
    single.classList.add('collapsed');
    single.classList.remove('expanded');
    multi.classList.remove('collapsed');
    multi.classList.add('expanded');
  }
  sel.forEach(rec=>{
    const chip = document.createElement('div'); chip.className='chip';
    chip.textContent = rec.name;
    chips.appendChild(chip);
  });

  // Optional: expose compact similarity chip
  if (sel.length >= 2) {
    const a = sel[sel.length-2], b = sel[sel.length-1];
    const score = similarityScore(a, b);
    const stateLabel = (score >= 70) ? 'Alike' : (score >= 40) ? 'Close' : 'Not alike';
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = `Similarity: ${score} ‚Ä¢ ${stateLabel}`;
    chips.appendChild(chip);
  }

  if (sel.length === 0) { single.innerHTML = '<div class="row"><span>Select a marker to see its states.</span></div>'; return; }

  // Single (show the most recent selection)
  const rec = sel[sel.length-1];
  single.innerHTML = ''; // we'll append rows

  const rows = [
    ['When', new Date(rec.when).toLocaleString(),
      'The file\'s timestamp (converted to your local time). It anchors the memory to a specific point on the orbit.'],

    ['Frame', store.view.frame==='home' ? 'Home (co-moving)' : 'Cosmic (pinned)',
      'Home: memories move with our Solar-System rest patch. Cosmic: memories are pinned where the Solar System was in inertial space.'],

    ['Day-phase', `${rec.states.dayPhase} (${rec.states.sunAltDeg.toFixed(1)}¬∞)`,
      'What the Sun was doing at the capture location‚Äînight/twilights/golden hour/daytime‚Äîbased on Sun altitude. Pure sky geometry.'],

    ['Season', `Year ${rec.year}`,
      'Where this moment sits in Earth\'s seasonal cycle (solstice/equinox context when enabled).'],

    ['Solar contribution (relative)', `${(rec.states.tides.solarRelPct>=0?'+':'')}${rec.states.tides.solarRelPct}%  ‚Ä¢  ${rec.states.tides.sun_uGal} ¬µGal`,
      'Change in solar tidal strength relative to annual mean (‚àù 1/r‚òâ¬≥) and instantaneous vertical gravitational tidal acceleration in microgals.'],

    ['Lunar contribution (relative)', `${(rec.states.tides.lunarRelPct>=0?'+':'')}${rec.states.tides.lunarRelPct}%  ‚Ä¢  ${rec.states.tides.moon_uGal} ¬µGal`,
      'Change in lunar tidal strength relative to monthly mean (‚àù 1/rüåô¬≥, modulated by phase) and vertical tidal acceleration in microgals.'],

    ['Solar‚Äìlunar tidal field (index)', `${rec.states.tides.index0to100}/100`,
      'Dimensionless index of the local gravitational tidal field from Sun+Moon at capture (normalized to that day\'s range).'],

    ['Lunar phase', `${rec.states.lunar.phasePct}% ‚Ä¢ perigee ${Math.round(rec.states.lunar.perigeeProx*100)}%`,
      'Illumination percentage and a hint of how close the Moon was to perigee (closer ‚Üí stronger lunar tide).'],

    ['Home angle', `${rec.homeAngleDeg.toFixed(2)}¬∞`,
      'The memory\'s angle on the Home ellipse (heliocentric longitude)‚Äîi.e., where on the ring it sits.'],

    ['Cosmic drift', `${rec.cosmic.drift_since_AU} AU (approx)`,
      'How far we have traveled through space since that memory in the Cosmic frame (assumes ~46 AU/yr galactic speed).'],

    ['Reference frame', `${rec.states.frames.geometry}; ${rec.states.frames.site}`,
      'Geometry & light-time from the barycenter (BCRS/ICRF); local sky and tides in the site\'s geocentric frame (GCRS).'],

    ['Light-time', `Sun ${rec.states.voxel.sunLightTime_s}s ‚Ä¢ Moon ${rec.states.voxel.moonLightTime_s}s`,
      'Retarded-time markers: how long light takes from Sun/Moon at capture time.'],

    ['Voxel fraction (1 s)', `${rec.states.voxel.voxelFraction} of 1 light-second`,
      'How much of a 1-light-second causal cube Earth traversed during this second (v/c).'],

    ['Clock bias (1 s)', niceNsPerS(rec.states.voxel.ns_per_1s),
      'Cycle-averaged tidal potential converted to a tiny gravitational time shift over this 1-second voxel.'],

    ['Kinematic rate (1 s)', niceNsPerS(rec.states.voxel.kin_ns_per_1s),
      'Special-relativistic time shift from orbital + rotational speed at this latitude over 1 second.'],

    ['Combined rate (1 s)', niceNsPerS(rec.states.voxel.combined_ns_per_1s),
      'Sum of gravitational (tidal potential) + kinematic dilation for this 1-second voxel.'],

    ['Tide vector (Sun)', `V ${rec.states.tideVec.sun.av_uGal} ¬µGal ‚Ä¢ |H| ${Math.abs(rec.states.tideVec.sun.ah_uGal)} ¬µGal ‚Ä¢ bearing ${norm360(rec.states.tideVec.sun.bearing).toFixed(0)}¬∞`,
      'Vertical and horizontal magnitude of the solar gravitational tidal acceleration (¬µGal); bearing is the horizontal push direction.'],

    ['Tide vector (Moon)', `V ${rec.states.tideVec.moon.av_uGal} ¬µGal ‚Ä¢ |H| ${Math.abs(rec.states.tideVec.moon.ah_uGal)} ¬µGal ‚Ä¢ bearing ${norm360(rec.states.tideVec.moon.bearing).toFixed(0)}¬∞`,
      'Vertical and horizontal magnitude of the lunar gravitational tidal acceleration (¬µGal).']
  ];

  // Add envelope normalization for single selection display
  let envelopeRow = null;
  if (rec.states.envelope) {
    const spanDay = envelopeDailySpan_sync(new Date(rec.when).getTime(), rec.where?.lat||0, rec.where?.lon||0);
    const pct1m = 100 * Math.abs(rec.states.envelope?.Ubar_1m || 0) / Math.max(1e-9, spanDay);
    const pct1h = 100 * Math.abs(rec.states.envelope?.Ubar_1h || 0) / Math.max(1e-9, spanDay);
    envelopeRow = ['Envelope similarity', 
      `Rolling-average potential (1 min / 1 hr): ${pct1m.toFixed(1)}% / ${pct1h.toFixed(1)}% of daily span`,
      'Time-averaged tidal potential variations expressed as percentage of the day\'s total tidal range.'];
  }

  // Add planetary context if available (collapsed by default)
  if (rec.states.planetary) {
    const p = rec.states.planetary;
    rows.push(
      ['Planetary tidal add-ons', `${p.tidalAddons_nGal.total_nGal} nGal total`,
        'Tiny but real gravitational tidal contributions from all planets combined (nanogals). Venus dominates at a few nGal when close.'],
      ['Solar System Barycenter', `Sun offset: ${p.ssbOffset_km} km ‚Ä¢ reflex: ${p.sunReflex_mps} m/s`,
        'Sun\'s displacement and velocity about the Solar System Barycenter, dominated by Jupiter with Saturn adding refinement.']
    );
  }

  rows.forEach(([label, value, help]) => {
    single.appendChild(makeToggleRow(label, value, help));
  });

  // Add envelope row if available
  if (envelopeRow) {
    single.appendChild(makeToggleRow(envelopeRow[0], envelopeRow[1], envelopeRow[2]));
  }

  // Add light bands info to single selection
  if (rec.states.lightBands) {
    const lb = rec.states.lightBands;
    const kmAlongParallel = (lb.msFromGreenwich * C_km_per_s / 1000);
    const lightBandRow = makeToggleRow(
      'Earth light-time band', 
      `longitude offset ${lb.msFromGreenwich.toFixed(2)} ms from Greenwich (‚âà ${kmAlongParallel.toFixed(0)} km along your parallel); nearest time-zone band ${lb.zoneIndex} (¬±5.56 ms edges)`,
      'Position on Earth expressed in light travel time along the surface. Shows how longitude relates to causal time scales.'
    );
    single.appendChild(lightBandRow);
  }

  // Add retarded-time badges if any events coincide
  const badges = retardedBadge(rec.when, rec.states.voxel.sunLightTime_s);
  if (badges.length){
    single.appendChild(makeToggleRow('Causal events', 
      badges.map(b=>`${b.name} (¬±${Math.round(b.dt_s)} s)`).join(', '),
      'Events whose retarded-time arrival coincides with this moment (Sun light-cone).'));
  }

  // Add detailed planetary breakdown (if available)
  if (rec.states.planetary?.tidalAddons_nGal?.list?.length > 0) {
    const planetDetails = rec.states.planetary.tidalAddons_nGal.list
      .filter(p => p.nGal !== 0)
      .map(p => `${p.name}: ${p.nGal} nGal (${p.relMoonPct}% of Moon peak)`)
      .join('; ');
    
    if (planetDetails) {
      single.appendChild(makeToggleRow('Planetary breakdown', planetDetails,
        'Individual planetary tidal contributions. Venus can reach ~10 nGal at inferior conjunction; Jupiter ~0.1 nGal.'));
    }
  }

  // Multi (differences)
  if (sel.length >= 2){
    const a = sel[sel.length-2], b = sel[sel.length-1];
    
    // Calculate ALL difference fields for narrative
    const dSolar = (b.states.tides.solarRelPct - a.states.tides.solarRelPct);
    const dLunar = (b.states.tides.lunarRelPct - a.states.tides.lunarRelPct);
    const dAlt   = (b.states.sunAltDeg - a.states.sunAltDeg);
    const dYear  = b.year - a.year;
    const dAngle = (b.homeAngleDeg - a.homeAngleDeg);
    const dDrift = (b.cosmic.drift_since_AU - a.cosmic.drift_since_AU);
    const dIndex = (b.states.tides.index0to100 - a.states.tides.index0to100);

    const dLt   = (b.states.voxel.sunLightTime_s - a.states.voxel.sunLightTime_s);
    const dMoonLt = (b.states.voxel.moonLightTime_s - a.states.voxel.moonLightTime_s);
    const dFrac = (b.states.voxel.voxelFraction - a.states.voxel.voxelFraction);
    const dNS   = (parseFloat(b.states.voxel.ns_per_1s) - parseFloat(a.states.voxel.ns_per_1s));
    const dKinNS = (b.states.voxel.kin_ns_per_1s - a.states.voxel.kin_ns_per_1s);
    const dCombNS = (b.states.voxel.combined_ns_per_1s - a.states.voxel.combined_ns_per_1s);

    // Tide vector differences
    const dSunVec = {
      v: (b.states.tideVec.sun.av_uGal - a.states.tideVec.sun.av_uGal),
      h: (b.states.tideVec.sun.ah_uGal - a.states.tideVec.sun.ah_uGal),
      br: ((b.states.tideVec.sun.bearing - a.states.tideVec.sun.bearing + 540)%360 - 180)
    };
    const dMoonVec = {
      v: (b.states.tideVec.moon.av_uGal - a.states.tideVec.moon.av_uGal),
      h: (b.states.tideVec.moon.ah_uGal - a.states.tideVec.moon.ah_uGal),
      br: ((b.states.tideVec.moon.bearing - a.states.tideVec.moon.bearing + 540)%360 - 180)
    };

    // Orbital elements for narrative: prefer GR module; fallback to Horizons elements if present
    const elA_narr = yearElements.get(a.year), elB_narr = yearElements.get(b.year);
    let dOmega = null, dVarpi = null, periA = null, periB = null;
    try {
      const HP = window.HaloPeri;
      if (HP && typeof HP.stateAt==='function' && typeof HP.delta==='function'){
        const Aperi = HP.stateAt(Date.parse(a.when), ['earth']);
        const Bperi = HP.stateAt(Date.parse(b.when), ['earth']);
        const Dperi = HP.delta(Aperi, Bperi);
        dVarpi = +(Dperi?.dVarpiDeg?.earth ?? null);
        // Without Œ©,œâ split, expose œâ as approximate using œñ
        dOmega = dVarpi;
        periA = Aperi.earth?.lastPerihelionISO || null;
        periB = Bperi.earth?.lastPerihelionISO || null;
      }
    } catch {}
    if (dVarpi==null && elA_narr && elB_narr) {
      const deg = x => (x*180/Math.PI);
      const wrapDeg = d => ((d+540)%360)-180; // wrap to [-180,180)
      const omegaA = deg(elA_narr.omega), omegaB = deg(elB_narr.omega);
      const bigOmegaA = deg(elA_narr.Omega), bigOmegaB = deg(elB_narr.Omega);
      const varpiA = omegaA + bigOmegaA; // œñ = Œ© + œâ
      const varpiB = omegaB + bigOmegaB;
      dOmega = wrapDeg(omegaB - omegaA);
      dVarpi = wrapDeg(varpiB - varpiA);
      periA = elA_narr.perihelionISO || null;
      periB = elB_narr.perihelionISO || null;
    }

    // Complete difference object for narrative
    const diffData = {
      dSolarPct: dSolar,
      dLunarPct: dLunar,
      dSunAltDeg: dAlt,
      dYear: dYear,
      dAngle: dAngle,
      dDrift_AU: dDrift,
      dIndex: dIndex,
      dLightTime_s: dLt,
      dVoxelFrac: dFrac,
      dNs_grav: dNS,
      dNs_kin: dKinNS,
      dNs_comb: dCombNS,
      dOmegaDeg: dOmega,
      dVarpiDeg: dVarpi,
      // --- NEW causal/averaging differences ---
      dSunCausal_s: Math.abs( (b.states.voxel.sunLightTime_s - a.states.voxel.sunLightTime_s) - ((Date.parse(b.when)-Date.parse(a.when))/1000) ),
      dMoonCausal_s: Math.abs( (b.states.voxel.moonLightTime_s - a.states.voxel.moonLightTime_s) - ((Date.parse(b.when)-Date.parse(a.when))/1000) ),
      dUbar1m: (b.states.envelope?.Ubar_1m || 0) - (a.states.envelope?.Ubar_1m || 0),
      dUbar1h: (b.states.envelope?.Ubar_1h || 0) - (a.states.envelope?.Ubar_1h || 0),
      dTS1m: (b.states.envelope?.TS_envelope_1m || 0) - (a.states.envelope?.TS_envelope_1m || 0),
      dTS1h: (b.states.envelope?.TS_envelope_1h || 0) - (a.states.envelope?.TS_envelope_1h || 0),
      dNetBearing: ((b.states.tideNet?.bearingDeg || 0) - (a.states.tideNet?.bearingDeg || 0) + 540)%360 - 180,
      dNetMag: (b.states.tideNet?.ah_uGal || 0) - (a.states.tideNet?.ah_uGal || 0),
      dP2sun: (b.states.geometryP2?.P2sun || 0) - (a.states.geometryP2?.P2sun || 0),
      dP2moon: (b.states.geometryP2?.P2moon || 0) - (a.states.geometryP2?.P2moon || 0),
      dPhaseSyn: (((b.states.sunMoon?.phaseDeg || 0) - (a.states.sunMoon?.phaseDeg || 0))+540)%360-180,
      dNodal: (((b.states.sunMoon?.nodalPhaseDeg || 0) - (a.states.sunMoon?.nodalPhaseDeg || 0)) + 540)%360 - 180,
      dPerigee: (((b.states.sunMoon?.perigeePhaseDeg || 0) - (a.states.sunMoon?.perigeePhaseDeg || 0)) + 540)%360 - 180,
      dEqElev_mm: (b.states.eqElevation_mm !== null && a.states.eqElevation_mm !== null) 
        ? (b.states.eqElevation_mm - a.states.eqElevation_mm) : null,
      dEqElev_norm: (b.states.eqElevation_norm || 0) - (a.states.eqElevation_norm || 0)
    };

    // Stash planetary context for narrative longLine
    if (a.states.planetary && b.states.planetary) {
      const nA = a.states.planetary.tidalAddons_nGal?.total_nGal || 0;
      const nB = b.states.planetary.tidalAddons_nGal?.total_nGal || 0;
      diffData.planetary_nGal = nB - nA;
      diffData.dSSB_km = (b.states.planetary.ssbOffset_km - a.states.planetary.ssbOffset_km);
      diffData.dReflex_mps = (b.states.planetary.sunReflex_mps - a.states.planetary.sunReflex_mps);
    }

    // --- Similarity meter + Complete Narrative ---
    // Compute normalized envelope percentages for narrative
    const spanA = envelopeDailySpan_sync(new Date(a.when).getTime(), a.where?.lat||0, a.where?.lon||0);
    const spanB = envelopeDailySpan_sync(new Date(b.when).getTime(), b.where?.lat||0, b.where?.lon||0);
    const normSpan = Math.max(spanA, spanB, 1e-9);
    const envDeltaPct_1m = 100 * Math.abs(diffData.dUbar1m || 0) / normSpan;
    const envDeltaPct_1h = 100 * Math.abs(diffData.dUbar1h || 0) / normSpan;
    diffData.envPct_1m = envDeltaPct_1m;
    diffData.envPct_1h = envDeltaPct_1h;

    const score = similarityScore(a, b, diffData);
    const stateLabel = (score >= 70) ? 'Alike' : (score >= 40) ? 'Close' : 'Not alike';
    // Perihelion data for narrative
    const extraData = { periA: periA, periB: periB };

    // Generate zen sentence based on score
    const zenIdx = Math.floor(clamp01(score/100) * zenSentences.length);
    const zenQuote = zenSentences[Math.min(zenIdx, zenSentences.length-1)];

    // Add similarity meter with zen quote
    const simRow = document.createElement('div');
    simRow.className = 'row';
    simRow.innerHTML = `<b>Similarity</b><span>${score.toFixed(1)}/100 ‚Ä¢ ${stateLabel}</span>`;
    diff.appendChild(simRow);
    
    const zenRow = document.createElement('div');
    zenRow.className = 'row';
    zenRow.innerHTML = `<span style="grid-column:1/-1;color:#9fb0d9;font-style:italic;padding:4px 0;">${zenQuote}</span>`;
    diff.appendChild(zenRow);
    
    // Add Complete Story narrative
    const storyRow = document.createElement('div');
    storyRow.style.marginTop = '10px';
    storyRow.innerHTML = makeNarrative(a, b, score, diffData, extraData);
    diff.appendChild(storyRow);

    const diffs = [
      ['Œî Solar contribution', `${dSolar.toFixed(1)}%`,
        'Change in the Sun\'s gravitational tidal contribution (relative to its annual mean).'],
      ['Œî Lunar contribution', `${dLunar.toFixed(1)}%`,
        'Change in the Moon\'s gravitational tidal contribution (relative to its monthly mean and phase).'],
      ['Œî Sun altitude', `${dAlt.toFixed(1)}¬∞`,
        'How different the Sun\'s height in the sky was (lighting/phase of day).'],
      ['Œî Year', `${dYear}`,
        'How many laps around the Sun separate the two memories.'],
      ['Œî Home angle', `${dAngle.toFixed(2)}¬∞`,
        'Angular separation around the Home ellipse‚Äîhow far apart on the ring they are.'],
      ['Œî Cosmic drift', `${dDrift.toFixed(1)} AU`,
        'How much farther we are in inertial space between the two times.'],
      ['Œî Light-time to Sun', `${dLt.toFixed(1)} s`,
        'Change in Sun‚ÄìEarth light travel time‚Äîties directly to the voxel scale.'],
      ['Œî Moon light-time', `${dMoonLt.toFixed(1)} s`,
        'Change in Earth‚ÄìMoon light travel time between the two moments.'],
      ['Œî Voxel fraction', `${dFrac.toExponential(2)}`,
        'Change in how much of a light-second we traversed during the capture second.'],
      ['Œî Clock bias (1 s)', niceNsPerS(dNS),
        'Change in 1-second gravitational time-shift from the cycle-averaged tidal potential (ns/s).'],
      ['Œî Kinematic rate (1 s)', niceNsPerS(dKinNS),
        'Change from latitude/rotation differences (orbital term is common).'],
      ['Œî Combined rate (1 s)', niceNsPerS(dCombNS),
        'Overall change in proper-time rate over the 1-s voxel.'],
      // NEW causal/averaging rows
      ['Causal overlap (Sun)',
        diffData.overSun==null ? 'n/a (moments far apart)' :
        `overlap ${(diffData.overSun*100).toFixed(0)}% ‚Ä¢ Œî(retarded) = ${Math.abs(diffData.dSunCausal_s).toFixed(2)} s`,
        'Causal coherence between observation moments for solar gravitational influence.'],
      ['Causal overlap (Moon)',
        diffData.overMoon==null ? 'n/a (moments far apart)' :
        `overlap ${(diffData.overMoon*100).toFixed(0)}% ‚Ä¢ Œî(retarded) = ${Math.abs(diffData.dMoonCausal_s).toFixed(2)} s`,
        'Causal coherence between observation moments for lunar gravitational influence.'],
      ['Envelope similarity',
        `Rolling-average potential Œî (1 min / 1 hr): ${(diffData.envPct_1m||0).toFixed(1)}% / ${(diffData.envPct_1h||0).toFixed(1)}% of daily span`,
        'Comparison of time-averaged gravitational potential variations expressed as percentage of daily tidal range.'],
      ['TS_envelope', `W/lt (1 min / 1 hr): ${a.states.envelope?.TS_envelope_1m?.toFixed(2)||'?'}‚Üí${b.states.envelope?.TS_envelope_1m?.toFixed(2)||'?'} / ${a.states.envelope?.TS_envelope_1h?.toFixed(2)||'?'}‚Üí${b.states.envelope?.TS_envelope_1h?.toFixed(2)||'?'}`,
        'Ratio of averaging window to light-time‚Äîshows time-scale separation for causal analysis.'],
      ['Œî Net tidal vector', `Œîbearing ${diffData.dNetBearing.toFixed(1)}¬∞, Œîmag ${diffData.dNetMag.toFixed(1)} ¬µGal`,
        'Change in combined Sun+Moon horizontal tidal acceleration vector (magnitude and direction).'],
      ['ŒîP‚ÇÇ factors', `Sun ${(P2_fromAltDeg(b.states.sunAltDeg) - P2_fromAltDeg(a.states.sunAltDeg)).toFixed(3)}, Moon ${(P2_fromAltDeg(b.states.moonAltDeg) - P2_fromAltDeg(a.states.moonAltDeg)).toFixed(3)}`,
        'Change in Legendre P‚ÇÇ geometry factors (3cos¬≤Œ∏-1)/2 used in tidal potential calculations.'],
      ['Œî Sun‚ÄìMoon phase', `${diffData.dPhaseSyn.toFixed(1)}¬∞ (toward/away from spring tide)`,
        'Change in synodic phase angle between Sun and Moon (spring tides at 0¬∞, neap at ¬±90¬∞).'],
      ['Œî nodal / perigee phase', `${diffData.dNodal.toFixed(1)}¬∞ / ${diffData.dPerigee.toFixed(1)}¬∞`,
        'Change in long-cycle lunar phases: nodal (18.6 yr) affects ecliptic inclination; perigee (8.85 yr) affects distance variation.'],
      // Equivalent elevation
      ['Equivalent elevation', 
        (a.states.eqElevation_mm!=null && b.states.eqElevation_mm!=null) 
          ? `${(b.states.eqElevation_mm - a.states.eqElevation_mm).toFixed(2)} mm`
          : `normalized mm-equivalent Œî ${( (b.states.eqElevation_norm||0) - (a.states.eqElevation_norm||0) ).toFixed(2)} (calibration TBD)`,
        'Change in gravitational potential expressed as equivalent height above geoid (U/g). Normalized values require calibration.'],
      
      // Light-time bands along Earth's surface
      ...(a.states.lightBands && b.states.lightBands ? [
        ['Light-time along Earth', `Œî ${wrapMs(b.states.lightBands.msFromGreenwich - a.states.lightBands.msFromGreenwich).toFixed(2)} ms (‚âà ${(wrapMs(b.states.lightBands.msFromGreenwich - a.states.lightBands.msFromGreenwich)*C_km_per_s/1000).toFixed(0)} km along the parallel)`,
          'Distance between observation points in light travel time along Earth\'s surface.'],
        ['Time zone (light units)', `Œî zones ${(b.states.lightBands.zoneIndex - a.states.lightBands.zoneIndex)>=0?'+':''}${b.states.lightBands.zoneIndex - a.states.lightBands.zoneIndex} ‚Ä¢ 1 zone ‚âà ${a.states.lightBands.msPerZone.toFixed(2)} ms`,
          'Time zone separation measured in light-time milliseconds (15¬∞ ‚âà 5.56 ms).']
      ] : []),
    ];
    diffs.forEach(([label,value,help])=>{
      diff.appendChild(makeToggleRow(label, value, help));
    });
    
    // Add planetary add-ons if both records have them
    if (a.states.planetary && b.states.planetary){
      const pa = a.states.planetary.tidalAddons_nGal?.total_nGal || 0;
      const pb = b.states.planetary.tidalAddons_nGal?.total_nGal || 0;
      diff.appendChild(makeToggleRow('Planetary add-ons', `Œî total ${ (pb-pa).toExponential(2) } nGal (Venus/Jupiter etc.)`,
        'Change in total planetary tidal contributions beyond Sun/Moon (Venus ~10 nGal max, Jupiter ~0.1 nGal).'));
      diff.appendChild(makeToggleRow('SSB context', `Œî Sun‚ÄìSSB offset ${(b.states.planetary.ssbOffset_km - a.states.planetary.ssbOffset_km).toFixed(0)} km ‚Ä¢ Œî reflex ${(b.states.planetary.sunReflex_mps - a.states.planetary.sunReflex_mps).toFixed(2)} m/s`,
        'Change in Solar System Barycenter context: Sun offset from SSB and Earth\'s reflex motion due to planetary perturbations.'));
    }

    // Add tide vector differences
    diff.appendChild(makeToggleRow('Œî Solar tide vector', `V ${dSunVec.v.toFixed(1)} ¬µGal ‚Ä¢ H ${dSunVec.h.toFixed(1)} ¬µGal ‚Ä¢ Œîbearing ${dSunVec.br.toFixed(0)}¬∞`,
      'Change in vertical/horizontal solar gravitational tidal acceleration components and bearing.'));
    diff.appendChild(makeToggleRow('Œî Lunar tide vector', `V ${dMoonVec.v.toFixed(1)} ¬µGal ‚Ä¢ H ${dMoonVec.h.toFixed(1)} ¬µGal ‚Ä¢ Œîbearing ${dMoonVec.br.toFixed(0)}¬∞`,
      'Change in vertical/horizontal lunar gravitational tidal acceleration components and bearing.'));

    // Add orbital mechanics comparison if elements available
    // Prefer GR perihelion module if available for robust values; fallback to yearElements
    try {
      const tAms = Date.parse(a.when), tBms = Date.parse(b.when);
      const HP = window.HaloPeri;
      if (HP && typeof HP.stateAt === 'function' && typeof HP.delta === 'function'){
        const Aperi = HP.stateAt(tAms, ['earth']);
        const Bperi = HP.stateAt(tBms, ['earth']);
        const Dperi = HP.delta(Aperi, Bperi);
        const dVarpiEarthNum = +(Dperi?.dVarpiDeg?.earth ?? 0);
        const wrap = d => ((d+540)%360)-180;
        // We do not have Œ©,œâ split from HaloPeri; keep Œîœñ from GR and omit Œîœâ specific unless Horizons elements exist.
        const elA = yearElements.get(a.year), elB = yearElements.get(b.year);
        let dOmegaNum = dVarpiEarthNum; // fallback: with i‚âà0, treat Œîœâ‚âàŒîœñ (approx)
        if (elA && elB) {
          const degf = x => (x*180/Math.PI);
          const omegaA = degf(elA.omega), omegaB = degf(elB.omega);
          dOmegaNum = wrap(omegaB - omegaA);
        }
        // Perihelion timestamps from HaloPeri proximity cycles
        const periADisp = Aperi.earth?.lastPerihelionISO || '(n/a)';
        const periBDisp = Bperi.earth?.lastPerihelionISO || '(n/a)';

        diff.appendChild(makeToggleRow('Œî Argument of perihelion (œâ)', `${angleSmartDeg(dOmegaNum)}`,
          'Change in the ellipse\'s orientation within its orbital plane (year B ‚àí year A). Fallback uses GR Œîœñ (i‚âà0 assumption).'));
        diff.appendChild(makeToggleRow('Œî Longitude of perihelion (œñ = Œ©+œâ)', `${angleSmartDeg(dVarpiEarthNum)}`,
          'Change in the ellipse\'s absolute orientation against the reference frame (year B ‚àí year A).'));
        diff.appendChild(makeToggleRow('Perihelion (A ‚Üí B)', `${periADisp} ‚Üí ${periBDisp}`,
          'The date/time of closest approach to the Sun for each year\'s osculating orbit (GR-secular, approximate).'));
      } else {
        const elA = yearElements.get(a.year), elB = yearElements.get(b.year);
        if (elA && elB){
          const deg = x => (x*180/Math.PI);
          const wrapDeg = d => ((d+540)%360)-180; // wrap to [-180,180)
          const omegaA = deg(elA.omega), omegaB = deg(elB.omega);
          const bigOmegaA = deg(elA.Omega), bigOmegaB = deg(elB.Omega);
          const varpiA = omegaA + bigOmegaA; // œñ = Œ© + œâ
          const varpiB = omegaB + bigOmegaB;

          const dOmegaDisp = angleSmartDeg(wrapDeg(omegaB - omegaA));
          const dVarpiDisp = angleSmartDeg(wrapDeg(varpiB - varpiA));
          const periADisp = elA.perihelionISO || '(n/a)';
          const periBDisp = elB.perihelionISO || '(n/a)';

          diff.appendChild(makeToggleRow('Œî Argument of perihelion (œâ)', `${dOmegaDisp}`,
            'Change in the ellipse\'s orientation within its orbital plane (year B ‚àí year A).'));
          diff.appendChild(makeToggleRow('Œî Longitude of perihelion (œñ = Œ©+œâ)', `${dVarpiDisp}`,
            'Change in the ellipse\'s absolute orientation against the reference frame (year B ‚àí year A).'));
          diff.appendChild(makeToggleRow('Perihelion (A ‚Üí B)', `${periADisp} ‚Üí ${periBDisp}`,
            'The date/time of closest approach to the Sun for each year\'s osculating orbit (from Horizons).'));
        }
      }
    } catch (e) {
      // Silent fallback if anything goes wrong
    }
  }
}

/* =========================
   Boot
========================= */
initScene();
renderList();

// Update light-time dial when render state changes
const originalRenderStatesOld = renderStates;

/* =========================
   Methods Appendix Implementation
   Academic-style equation solutions for each selected record
========================= */

// 1. Time and Indexing Diagnostics
function showTimeIndexing(ts, rec) {
  const jd = ts/86400000 + 2440587.5; // Same as existing toJD logic
  const daysSinceEpoch = (ts - Date.UTC(2000,0,1,12,0,0)) / 86400000;
  
  return {
    julianDay: jd,
    daysSinceJ2000: daysSinceEpoch,
    equation: `JD = t_ms/86,400,000 + 2,440,587.5 = ${jd.toFixed(5)}`,
    localTime: `Local timestamp: ${new Date(ts).toLocaleString()}`
  };
}

// 2. Earth-Sun Geometry Diagnostics
function showEarthSunGeometry(ts) {
  const d = (ts - perihelionApprox) / 86400000;
  const n = 2*Math.PI/365.25; // mean motion
  const M = n * d; // mean anomaly
  let E = M + eEarth*Math.sin(M); // eccentric anomaly (first approximation)
  E = E - (E - eEarth*Math.sin(E) - M)/(1 - eEarth*Math.cos(E)); // Newton correction
  const v = 2*Math.atan(Math.sqrt((1+eEarth)/(1-eEarth))*Math.tan(E/2)); // true anomaly
  const r = 1.0*(1 - eEarth*Math.cos(E)); // distance in AU
  
  // Normalize angles to [0, 360¬∞) range for display
  const M_deg = ((M * 180/Math.PI) % 360 + 360) % 360;
  const E_deg = ((E * 180/Math.PI) % 360 + 360) % 360;
  const v_deg = ((v * 180/Math.PI) % 360 + 360) % 360;
  
  return {
    meanAnomaly_deg: M_deg,
    eccentricAnomaly_deg: E_deg,
    trueAnomaly_deg: v_deg,
    distance_AU: r,
    equations: [
      `M = n √ó d = ${n.toFixed(8)} √ó ${d.toFixed(2)} = ${M.toFixed(4)} rad`,
      `E - e sin E = M ‚Üí E = ${E.toFixed(4)} rad (Newton iteration)`,
      `ŒΩ = 2 arctan[‚àö((1+e)/(1-e)) tan(E/2)] = ${v.toFixed(4)} rad`,
      `r = a(1 - e cos E) = ${r.toFixed(6)} AU`
    ]
  };
}

// 3. Solar Position Diagnostics
function showSolarPosition(ts, lat, lon) {
  const date = new Date(ts);
  const n = Math.floor((Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()) - Date.UTC(date.getUTCFullYear(),0,0))/86400000);
  const L = (280.46 + 0.9856474*n) % 360;
  const g = (357.528 + 0.9856003*n) % 360;
  const lambda = L + 1.915*Math.sin(g*RAD) + 0.020*Math.sin(2*g*RAD);
  const epsilon = 23.439 - 0.0000004*n;
  const delta = Math.asin(Math.sin(epsilon*RAD)*Math.sin(lambda*RAD)); // declination
  
  // Use existing sunAltDeg function result
  const alt = sunAltDeg(ts, lat, lon);
  
  return {
    meanLongitude_deg: L,
    meanAnomaly_deg: g,
    trueLongitude_deg: lambda,
    declination_deg: delta * 180/Math.PI,
    altitude_deg: alt,
    equations: [
      `Œª = L + 1.915 sin g + 0.020 sin 2g = ${lambda.toFixed(3)}¬∞`,
      `Œ¥ = arcsin(sin Œµ sin Œª) = ${(delta*180/Math.PI).toFixed(3)}¬∞`,
      `h = arcsin(sin œÜ sin Œ¥ + cos œÜ cos Œ¥ cos H) = ${alt.toFixed(3)}¬∞`
    ]
  };
}

// 4. Lunar Model Diagnostics
function showLunarModel(ts, lat, lon) {
  const d = (ts - Date.UTC(2000,0,1,12,0,0)) / 86400000;
  const T = d / 36525;
  
  // Mean elements (from existing moonContext function)
  const L0 = (218.3164477 + 481267.88123421*T - 0.0015786*T*T) % 360;
  const M  = (134.9633964 + 477198.8675055*T   + 0.0087414*T*T) % 360;
  const Ms = (357.5291092 + 35999.0502909*T    - 0.0001535*T*T) % 360;
  const D  = (297.8501921 + 445267.1114034*T   - 0.0018819*T*T) % 360;
  const F  = (93.2720950  + 483202.0175233*T   - 0.0036539*T*T) % 360;
  
  // Use existing moonContext result
  const mc = moonContext(ts, lat, lon);
  
  return {
    meanLongitude_deg: L0,
    meanAnomaly_deg: M,
    meanElongation_deg: D,
    argumentLatitude_deg: F,
    distance_km: mc.distance_km,
    altitude_deg: mc.altDeg,
    phase_pct: mc.phasePct,
    equations: [
      `L‚ÇÄ = 218.32¬∞ + 481267.88¬∞T = ${L0.toFixed(3)}¬∞`,
      `Œª_M ‚âà L‚ÇÄ + 6.289 sin M + 1.274 sin(2D-M) + ...`,
      `r_M = 385,001 - 20,905 cos M - 3,699 cos(2D-M) + ... = ${mc.distance_km.toFixed(0)} km`,
      `Illumination = (1 - cos œà)/2 √ó 100% = ${mc.phasePct}%`
    ]
  };
}

// 5. Light-Time Band Diagnostics
function showLightTimeBands(rec) {
  if (!rec.states.lightBands) return null;
  
  const lb = rec.states.lightBands;
  const kmPerDeg = KM_PER_DEG_EQ * Math.max(0.2, Math.cos((rec.where?.lat || 0) * Math.PI/180));
  const offsetKm = (rec.where?.lon || 0) * kmPerDeg;
  
  return {
    msFromGreenwich: lb.msFromGreenwich,
    zoneIndex: lb.zoneIndex,
    kmOffset: offsetKm,
    equations: [
      `T‚ÇÄ = 40,075 km / (299,792.458 km/s) = ${LT_full_ms.toFixed(2)} ms`,
      `Zone width = T‚ÇÄ/24 = ${LT_zone_ms.toFixed(2)} ms`,
      `km/deg = 111.32 √ó cos(lat) = ${kmPerDeg.toFixed(2)} km/deg`,
      `Œît_ms = (lon √ó km/deg) / c √ó 10¬≥ = ${lb.msFromGreenwich.toFixed(3)} ms`
    ]
  };
}

// 6. Tidal Proxies Diagnostics
function showTidalProxies(rec, ts) {
  const sunAlt = rec.states.sunAltDeg;
  const moonAlt = rec.states.moonAltDeg;
  const zSun = (90 - sunAlt) * Math.PI/180;
  const zMoon = (90 - moonAlt) * Math.PI/180;
  const P2sun = 0.5 * (3 * Math.cos(zSun)**2 - 1);
  const P2moon = 0.5 * (3 * Math.cos(zMoon)**2 - 1);
  
  // Use existing calculation results
  const rSun = earthSunDistance(ts);
  const mc = moonContext(ts, rec.where?.lat || 0, rec.where?.lon || 0);
  
  const Ks = 0.5, Km = 1.1; // same as in existing code
  const Usun = Ks * Math.pow(1/rSun, 3) * P2sun;
  const Umoon = Km * Math.pow(384400/mc.distance_km, 3) * P2moon;
  const Utotal = Usun + Umoon;
  
  return {
    P2sun: P2sun,
    P2moon: P2moon,
    zenithSun_deg: zSun * 180/Math.PI,
    zenithMoon_deg: zMoon * 180/Math.PI,
    potentialSun: Usun,
    potentialMoon: Umoon,
    potentialTotal: Utotal,
    eqElevation_norm: rec.states.eqElevation_norm,
    equations: [
      `P‚ÇÇ(z) = ¬Ω(3 cos¬≤z - 1)`,
      `P‚ÇÇ_sun = ${P2sun.toFixed(4)} (z = ${(zSun*180/Math.PI).toFixed(1)}¬∞)`,
      `P‚ÇÇ_moon = ${P2moon.toFixed(4)} (z = ${(zMoon*180/Math.PI).toFixed(1)}¬∞)`,
      `U = K_S r_S‚Åª¬≥ P‚ÇÇ(z_S) + K_M r_M‚Åª¬≥ P‚ÇÇ(z_M) = ${Utotal.toFixed(4)}`,
      `Equiv. elevation = ≈™/g √ó 10¬≥ = ${rec.states.eqElevation_norm} mm (normalized)`
    ]
  };
}

// 7. Voxel Fraction Diagnostics
function showVoxelFraction(rec) {
  const vEarth = V_Earth_orbit_kms; // 29.78 km/s
  const vRot = 0.465 * Math.cos((rec.where?.lat || 0) * Math.PI/180);
  const vTotal = Math.sqrt(vEarth**2 + vRot**2);
  const fraction = vTotal / C_kms;
  
  return {
    orbitalSpeed_kms: vEarth,
    rotationalSpeed_kms: vRot,
    totalSpeed_kms: vTotal,
    voxelFraction: fraction,
    equations: [
      `v_orbital = ${vEarth} km/s`,
      `v_rotational = 0.465 √ó cos(lat) = ${vRot.toFixed(3)} km/s`,
      `v_total = ‚àö(v_orb¬≤ + v_rot¬≤) = ${vTotal.toFixed(3)} km/s`,
      `f = v/c = ${fraction.toExponential(3)}`
    ]
  };
}

// 8. Similarity Metrics (for pairs)
function showSimilarityMetrics(recA, recB) {
  const dAngle = cycDeltaDeg(recA.homeAngleDeg, recB.homeAngleDeg);
  const dAlt = Math.abs(recA.states.sunAltDeg - recB.states.sunAltDeg);
  const dIndex = Math.abs(recA.states.tides.index0to100 - recB.states.tides.index0to100);
  
  const sAngle = 1 - (dAngle / 180);
  const sAlt = 1 - Math.min(1, dAlt / 15); // 15¬∞ span
  const sIndex = 1 - Math.min(1, dIndex / 20); // 20 point span
  const sPhase = recA.states.dayPhase === recB.states.dayPhase ? 1 : 0.4;
  
  const score = 0.18*sPhase + 0.12*sAlt + 0.18*sAngle + 0.18*sIndex + 0.34; // simplified
  
  return {
    angularDelta_deg: dAngle,
    altitudeDelta_deg: dAlt,
    indexDelta: dIndex,
    simAngle: sAngle,
    simAltitude: sAlt,
    simIndex: sIndex,
    simPhase: sPhase,
    totalScore: score * 100,
    equations: [
      `Œî_angle = |((b-a+540)%360) - 180| = ${dAngle.toFixed(2)}¬∞`,
      `s_angle = 1 - Œî/180 = ${sAngle.toFixed(3)}`,
      `s_altitude = 1 - min(1,|Œîalt|/15) = ${sAlt.toFixed(3)}`,
      `Score = Œ£w_i √ó s_i = ${(score*100).toFixed(1)}/100`
    ]
  };
}

// 9. Planetary Add-ons Diagnostics
function showPlanetaryAddons(rec) {
  if (!rec.states.planetary) return null;
  
  const p = rec.states.planetary;
  const moonPeak_uGal = 110.0;
  
  return {
    totalTidal_nGal: p.tidalAddons_nGal?.total_nGal || 0,
    ssbOffset_km: p.ssbOffset_km,
    sunReflex_mps: p.sunReflex_mps,
    equations: [
      `a_p ‚âÉ a_Moon √ó (Œº_p/Œº_Moon) √ó (r_M/r_p)¬≥`,
      `Total = ${p.tidalAddons_nGal?.total_nGal || 0} nGal`,
      `R_ssb = (Œ£Œº_i r_i)/Œ£Œº_i ‚Üí |R| = ${p.ssbOffset_km} km`,
      `|V_ssb| = ${p.sunReflex_mps} m/s`
    ]
  };
}

// Main diagnostics renderer for single records
function renderMethodsDiagnostics(rec) {
  const ts = Date.parse(rec.when);
  const lat = rec.where?.lat || 0;
  const lon = rec.where?.lon || 0;
  
  const diagnostics = {
    timeIndexing: showTimeIndexing(ts, rec),
    earthSunGeometry: showEarthSunGeometry(ts),
    solarPosition: showSolarPosition(ts, lat, lon),
    lunarModel: showLunarModel(ts, lat, lon),
    lightTimeBands: showLightTimeBands(rec),
    tidalProxies: showTidalProxies(rec, ts),
    voxelFraction: showVoxelFraction(rec),
    planetaryAddons: showPlanetaryAddons(rec)
  };
  
  return diagnostics;
}

// Methods comparison for pairs
function renderMethodsComparison(recA, recB) {
  const similarity = showSimilarityMetrics(recA, recB);
  
  // Causal overlap diagnostics
  const dtCapture = (Date.parse(recB.when) - Date.parse(recA.when)) / 1000; // seconds
  const dtSunLight = (recB.states.voxel?.sunLightTime_s || 0) - (recA.states.voxel?.sunLightTime_s || 0);
  const dtMoonLight = (recB.states.voxel?.moonLightTime_s || 0) - (recA.states.voxel?.moonLightTime_s || 0);
  
  const causalSun = Math.abs(dtCapture - dtSunLight);
  const causalMoon = Math.abs(dtCapture - dtMoonLight);
  
  return {
    similarity,
    causalOverlap: {
      captureInterval_s: dtCapture,
      sunLightDelta_s: dtSunLight,
      moonLightDelta_s: dtMoonLight,
      sunCausalError_s: causalSun,
      moonCausalError_s: causalMoon,
      equations: [
        `dSunCausal_s = |Œît_capture - Œît_light| = ${causalSun.toFixed(3)} s`,
        `dMoonCausal_s = |Œît_capture - Œît_light| = ${causalMoon.toFixed(3)} s`,
        `Overlap_sun = 1 - clamp(|d|/2) = ${(1 - Math.min(1, causalSun/2)).toFixed(3)}`,
        `Overlap_moon = 1 - clamp(|d|/2) = ${(1 - Math.min(1, causalMoon/2)).toFixed(3)}`
      ]
    }
  };
}

// Create Methods Appendix UI section
function createMethodsSection(methodsDiag) {
  const methodsSection = document.createElement('div');
  methodsSection.style.marginTop = '15px';
  methodsSection.style.border = '1px solid #2a3856';
  methodsSection.style.borderRadius = '8px';
  methodsSection.style.backgroundColor = '#0a1018';
  // Mark for easy cleanup on re-render
  methodsSection.setAttribute('data-methods-section', '');
  
  const methodsHeader = document.createElement('div');
  methodsHeader.className = 'row toggle';
  methodsHeader.style.background = '#121a32';
  methodsHeader.style.padding = '8px 12px';
  methodsHeader.innerHTML = `<span><span class="arrow">‚ñ∂</span><b>Methods Appendix: Equation Solutions</b></span><span>Academic algorithms & diagnostics</span>`;
  
  const methodsBody = document.createElement('div');
  methodsBody.className = 'collapsed';
  methodsBody.style.padding = '12px';
  methodsBody.style.fontSize = '12px';
  methodsBody.style.fontFamily = 'ui-monospace, monospace';
  methodsBody.style.color = '#bfead9';
  methodsBody.style.lineHeight = '1.4';
  
  // Fill methods body with diagnostics
  let methodsHTML = '';
  
  if (methodsDiag.timeIndexing) {
    methodsHTML += `<div style="margin-bottom:12px;"><strong>1. Time & Indexing</strong><br>`;
    methodsHTML += `${methodsDiag.timeIndexing.equation}<br>`;
    methodsHTML += `Julian Day: ${methodsDiag.timeIndexing.julianDay.toFixed(5)}<br>`;
    methodsHTML += `Days since J2000.0: ${methodsDiag.timeIndexing.daysSinceJ2000.toFixed(2)}</div>`;
  }
  
  if (methodsDiag.earthSunGeometry) {
    const esg = methodsDiag.earthSunGeometry;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>2. Earth-Sun Geometry</strong><br>`;
    esg.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `Final: L = ${esg.trueAnomaly_deg.toFixed(3)}¬∞ (normalized), r = ${esg.distance_AU.toFixed(6)} AU</div>`;
  }
  
  if (methodsDiag.solarPosition) {
    const sp = methodsDiag.solarPosition;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>3. Solar Apparent Position</strong><br>`;
    sp.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `Day-phase: ${dayPhaseTag(sp.altitude_deg)} (alt = ${sp.altitude_deg.toFixed(2)}¬∞)</div>`;
  }
  
  if (methodsDiag.lunarModel) {
    const lm = methodsDiag.lunarModel;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>4. Lunar Quick Model</strong><br>`;
    lm.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `Result: alt = ${lm.altitude_deg.toFixed(2)}¬∞, dist = ${lm.distance_km.toFixed(0)} km, phase = ${lm.phase_pct}%</div>`;
  }
  
  if (methodsDiag.lightTimeBands) {
    const ltb = methodsDiag.lightTimeBands;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>5. Light-Time Band Dial</strong><br>`;
    ltb.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `Position: ${ltb.msFromGreenwich.toFixed(3)} ms from Greenwich, zone ${ltb.zoneIndex}</div>`;
  }
  
  if (methodsDiag.tidalProxies) {
    const tp = methodsDiag.tidalProxies;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>6. Tidal Proxies & Envelope</strong><br>`;
    tp.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `P‚ÇÇ factors: Sun = ${tp.P2sun.toFixed(4)}, Moon = ${tp.P2moon.toFixed(4)}<br>`;
    methodsHTML += `Combined potential: U = ${tp.potentialTotal.toFixed(4)} (normalized units)</div>`;
  }
  
  if (methodsDiag.voxelFraction) {
    const vf = methodsDiag.voxelFraction;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>8. Voxel Fraction</strong><br>`;
    vf.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `Comparison: calculated = ${vf.voxelFraction.toExponential(3)}</div>`;
  }
  
  if (methodsDiag.planetaryAddons) {
    const pa = methodsDiag.planetaryAddons;
    methodsHTML += `<div style="margin-bottom:12px;"><strong>11. Planetary Add-ons & Barycenter</strong><br>`;
    pa.equations.forEach(eq => methodsHTML += `${eq}<br>`);
    methodsHTML += `Context: Planetary tides are real but tiny (nGal scale)</div>`;
  }
  
  methodsBody.innerHTML = methodsHTML;
  
  methodsHeader.onclick = () => {
    const isOpen = methodsHeader.classList.contains('open');
    methodsHeader.classList.toggle('open');
    if (isOpen) {
      methodsBody.classList.add('collapsed');
      methodsBody.classList.remove('expanded');
    } else {
      methodsBody.classList.remove('collapsed');
      methodsBody.classList.add('expanded');
    }
  };
  
  methodsSection.appendChild(methodsHeader);
  methodsSection.appendChild(methodsBody);
  
  return methodsSection;
}

// Create Methods Comparison UI section
function createMethodsComparisonSection(methodsComp) {
  const methodsCompSection = document.createElement('div');
  methodsCompSection.style.marginTop = '15px';
  methodsCompSection.style.border = '1px solid #2a3856';
  methodsCompSection.style.borderRadius = '8px';
  methodsCompSection.style.backgroundColor = '#0a1018';
  // Mark for easy cleanup on re-render
  methodsCompSection.setAttribute('data-methods-comparison', '');
  
  const methodsCompHeader = document.createElement('div');
  methodsCompHeader.className = 'row toggle';
  methodsCompHeader.style.background = '#121a32';
  methodsCompHeader.style.padding = '8px 12px';
  methodsCompHeader.innerHTML = `<span><span class="arrow">‚ñ∂</span><b>Methods Comparison: A ‚Üî B</b></span><span>Similarity algorithms & causal diagnostics</span>`;
  
  const methodsCompBody = document.createElement('div');
  methodsCompBody.className = 'collapsed';
  methodsCompBody.style.padding = '12px';
  methodsCompBody.style.fontSize = '12px';
  methodsCompBody.style.fontFamily = 'ui-monospace, monospace';
  methodsCompBody.style.color = '#bfead9';
  methodsCompBody.style.lineHeight = '1.4';
  
  let compHTML = '';
  
  if (methodsComp.similarity) {
    const sim = methodsComp.similarity;
    compHTML += `<div style="margin-bottom:12px;"><strong>10. Similarity Metrics</strong><br>`;
    sim.equations.forEach(eq => compHTML += `${eq}<br>`);
    compHTML += `Components: angle=${sim.simAngle.toFixed(3)}, alt=${sim.simAltitude.toFixed(3)}, phase=${sim.simPhase.toFixed(3)}<br>`;
    compHTML += `Final similarity: ${sim.totalScore.toFixed(1)}/100</div>`;
  }
  
  if (methodsComp.causalOverlap) {
    const co = methodsComp.causalOverlap;
    compHTML += `<div style="margin-bottom:12px;"><strong>12. Causal Overlap Diagnostics</strong><br>`;
    co.equations.forEach(eq => compHTML += `${eq}<br>`);
    compHTML += `Capture interval: ${co.captureInterval_s.toFixed(1)} s<br>`;
    compHTML += `Light-time changes: Sun ${co.sunLightDelta_s.toFixed(3)} s, Moon ${co.moonLightDelta_s.toFixed(3)} s<br>`;
    compHTML += `Causal coherence: Sun ${(1-Math.min(1,co.sunCausalError_s/2)).toFixed(3)}, Moon ${(1-Math.min(1,co.moonCausalError_s/2)).toFixed(3)}</div>`;
  }
  
  methodsCompBody.innerHTML = compHTML;
  
  methodsCompHeader.onclick = () => {
    const isOpen = methodsCompHeader.classList.contains('open');
    methodsCompHeader.classList.toggle('open');
    if (isOpen) {
      methodsCompBody.classList.add('collapsed');
      methodsCompBody.classList.remove('expanded');
    } else {
      methodsCompBody.classList.remove('collapsed');
      methodsCompBody.classList.add('expanded');
    }
  };
  
  methodsCompSection.appendChild(methodsCompHeader);
  methodsCompSection.appendChild(methodsCompBody);
  
  return methodsCompSection;
}

// Override the existing renderStates function to add Methods Appendix
renderStates = function() {
  // Call the original renderStates first to do all calculations
  originalRenderStatesOld();
  
  // Now add Methods Appendix sections
  const sel = [...store.selected].map(id=>store.items.find(x=>x.id===id)).filter(Boolean);
  // Clean up previously injected Methods sections so content refreshes
  try {
    const singleHost = document.getElementById('single');
    const diffHost = document.getElementById('diffText');
    if (singleHost) singleHost.querySelectorAll('[data-methods-section]').forEach(n=>n.remove());
    if (diffHost) diffHost.querySelectorAll('[data-methods-comparison]').forEach(n=>n.remove());
  } catch {}
  
  // Add Methods section for single selection
  if (sel.length === 1) {
    const rec = sel[0];
    const single = document.getElementById('single');
    const methodsDiag = renderMethodsDiagnostics(rec);
    const methodsSection = createMethodsSection(methodsDiag);
    single.appendChild(methodsSection);
  }
  
  // Add Methods comparison for pairs
  if (sel.length >= 2) {
    const a = sel[sel.length-2], b = sel[sel.length-1];
    const diff = document.getElementById('diffText');
    const methodsComp = renderMethodsComparison(a, b);
    const methodsCompSection = createMethodsComparisonSection(methodsComp);
    diff.appendChild(methodsCompSection);
  }
  
  // Keep the light-time dial update
  renderLightTimeDial();
  
  // Notify GR Perihelion panel to refresh using current A/B timestamps
  try {
    let tA = null, tB = null;
    if (sel.length === 1) {
      tA = Date.parse(sel[0]?.when) || Date.now();
      tB = tA;
    } else if (sel.length >= 2) {
      const a = sel[sel.length-2], b = sel[sel.length-1];
      tA = Date.parse(a?.when) || Date.now();
      tB = Date.parse(b?.when) || tA;
    } else {
      tA = Date.now();
      tB = tA;
    }
    // Also pass diffs for optional post-processors; stash globally for convenience
    const detail = { tA, tB };
    try { if (typeof diffData === 'object') { detail.diffs = diffData; window.lastDiffs = diffData; } } catch {}
    window.dispatchEvent(new CustomEvent('states:updated', { detail }));
  } catch {}
};

/* End Methods Appendix Implementation */

// When the GR perihelion module becomes ready, re-render so Methods uses it (not the fallback)
window.addEventListener('perihelion:ready', () => {
  try { renderStates(); } catch {}
});

</script>
  
  <!-- Make Relative States text selectable -->
  <style id="relative-states-selectable">
    #statesBody, #single, #diffText, #relative-states, [data-relativestates], .relative-states,
    #chips,
    #statesBody *, #single *, #diffText *, #relative-states *, [data-relativestates] *, .relative-states *,
    .row, .row *, .toggle, .toggle * {
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
      user-select: text !important;
      cursor: text;
    }
  </style>
  <!-- ========================== -->
  <!-- GR Perihelion module START -->
  <!-- ========================== -->
  <style id="perihelion-gr-styles">
    .peri-chip{display:inline-flex;align-items:center;gap:.5rem;padding:.35rem .6rem;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);font:600 12px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .peri-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:.75rem;margin-top:.5rem}
    .peri-card{border:1px solid rgba(255,255,255,.12);border-radius:1rem;padding:.75rem;background:rgba(0,0,0,.25);backdrop-filter:saturate(120%) blur(2px)}
    .peri-kv{display:flex;justify-content:space-between;gap:.75rem;font:500 12px/1.35 ui-sans-serif,system-ui}
    .peri-kv b{font-weight:700}
    .peri-muted{opacity:.7}
    .peri-badge{display:inline-flex;align-items:center;gap:.35rem;padding:.25rem .5rem;border-radius:.5rem;background:#0f172a;color:#cbd5e1;border:1px solid #1e293b}
    .peri-badge svg{width:14px;height:14px}
  </style>
  <script id="perihelion-gr" type="module">
  (() => {
    // ------------------------------
    // Numerics & tiny helpers
    // ------------------------------
    const C = 299_792_458;                        // m/s
    const GM_SUN = 1.327_124_400_18e20;          // m^3/s^2
    const AU = 149_597_870_700;                  // m
    const TAU = Math.PI*2;
    const deg = r => r*180/Math.PI;
    const rad = d => d*Math.PI/180;
    const normRad = x => (x%TAU + TAU)%TAU;
    const normDeg = d => (d%360 + 360)%360;
    const cycDeltaDeg = (a,b) => {
      let d = normDeg(b) - normDeg(a);
      if (d>180) d-=360;
      if (d<-180) d+=360;
      return d;
    };
    const toISO = t => new Date(t).toISOString().replace('.000','');

    // ------------------------------
    // Minimal planet catalog
    // J2000 approximate mean elements sufficient for analytics & UI
    // Source: standard astro refs (values rounded); extend as needed.
    // a in AU, e dimensionless, P in days, varpi0 in deg @ J2000 (ICRS)
    // ------------------------------
    const PLANETS = {
      earth:   { label:"Earth",   a_AU: 1.00000011, e:0.01671022, P_days:365.256363004, varpi0_deg:102.937348 },
      mercury: { label:"Mercury", a_AU: 0.38709893, e:0.20563069, P_days:87.9691,       varpi0_deg: 77.456119 },
      // venus: { a_AU:0.72333199,e:0.00677323,P_days:224.701, varpi0_deg:131.53298 },
      // mars:  { a_AU:1.52366231,e:0.09341233,P_days:686.98,  varpi0_deg:336.04084 },
      // (feel free to uncomment/extend)
    };

    // ------------------------------
    // GR perihelion advance per orbit: Œîœñ = 6œÄ GM / [a(1-e¬≤)c¬≤]
    // a in meters
    // ------------------------------
    function grPerOrbitRad({a_m,e}) {
      return 6*Math.PI*GM_SUN/(a_m*(1-e*e)*C*C);
    }

    // Kepler solver (for proximity % calculation)
    function keplerSolveE(M,e, tol=1e-8){
      // M in rad
      let E = e < 0.8 ? M : Math.PI;
      for (let i=0;i<30;i++){
        const f = E - e*Math.sin(E) - M;
        const fp = 1 - e*Math.cos(E);
        const dE = -f/fp;
        E += dE;
        if (Math.abs(dE) < tol) break;
      }
      return E;
    }
    function trueAnomalyFromM(M,e){
      const E = keplerSolveE(M,e);
      const cosE = Math.cos(E), sinE = Math.sin(E);
      const sqrt = Math.sqrt((1+e)/(1-e));
      const tanNu2 = sqrt * (sinE/(1 - e*cosE));
      return 2*Math.atan(tanNu2);
    }

    // Mean motion (rad/s) from period (days)
    const n_from_P = P_days => TAU / (P_days*86400);

    // Reference epoch (J2000.0 TT ~ UTC proxy); OK for analytics/UI
    const T0 = Date.UTC(2000,0,1,12,0,0);

    // Mean longitude at J2000 for Earth (deg); used to estimate M0.
    // We keep this local to Earth because we only compute proximity% for Earth by default.
    const L0_earth_deg = 100.46435; // approx mean longitude Earth @J2000

    // Compute instantaneous œñ(t) with GR advance (rad) using per-orbit increment
    function varpiAt(tms, body){
      const { a_AU, e, P_days, varpi0_deg } = body;
      const a_m = a_AU*AU;
      const dvarpi = grPerOrbitRad({a_m,e});
      const nOrbits = (tms - T0)/(P_days*86400*1000);
      const varpi0 = rad(varpi0_deg);
      return normRad(varpi0 + nOrbits*dvarpi);
    }

    // Proximity to perihelion for Earth (0..100%)
    // Based on mean anomaly evolution since J2000; independent of GR (which rotates the ellipse).
    function perihelionProximityPct_Earth(tms){
      const E = PLANETS.earth;
      const n = n_from_P(E.P_days);
      // Mean anomaly @J2000: M0 = L0 - œñ0
      const M0 = rad(L0_earth_deg - E.varpi0_deg);
      const M = normRad(M0 + n*((tms - T0)/1000));
      const nu = trueAnomalyFromM(M, E.e); // radians
      // distance ratio: r_p = a(1-e); r = a(1-e^2)/(1+e cos nu)
      // proximity: 0 at aphelion (nu=œÄ), 1 at perihelion (nu=0)
      // map cos(nu) to [0..1]: prox = (1+cos nu)/2 weighted by eccentricity
      const prox = (1 + Math.cos(nu))/2;
      return Math.round(prox*1000)/10; // one decimal %
    }

    // Find last/next perihelion timestamps for Earth (by scanning around now)
    function nearestPerihelionTimes_Earth(tms){
      const E = PLANETS.earth;
      const Pms = E.P_days*86400*1000;
      // Estimate k such that J2000 + k*P ‚âà tms with k integer
      const k = Math.round((tms - T0)/Pms);
      // Perihelion around cycle k occurs when M ‚âà 0 (nu‚âà0). We'll just return centers of cycles as proxies.
      const cand = T0 + k*Pms;
      const prev = cand - Pms;
      const next = cand + Pms;
      // Choose prev/next around tms
      const last = cand <= tms ? cand : prev;
      const upcoming = cand > tms ? cand : next;
      return { last, next: upcoming };
    }

    // Build a state object for a planet at time t
    function periState(tms, key){
      const body = PLANETS[key];
      if (!body) return null;
      const varpi = varpiAt(tms, body);
      const res = {
        key, label: body.label,
        varpiDeg: deg(varpi),
        varpiRad: varpi,
        source: "GR-secular+J2000",
      };
      if (key === "earth"){
        res.proximityPct = perihelionProximityPct_Earth(tms);
        const {last, next} = nearestPerihelionTimes_Earth(tms);
        res.lastPerihelionISO = toISO(last);
        res.nextPerihelionISO = toISO(next);
      }
      return res;
    }

    // Public API
    const HaloPeri = {
      version: "0.4.0",
      stateAt: (tms, keys=["earth","mercury"]) => {
        const out = {};
        keys.forEach(k => out[k] = periState(tms,k));
        return out;
      },
      delta: (A,B) => {
        // returns Œîœñ (deg) per key + Earth proximity delta
        const keys = Object.keys(A).filter(k => B[k]);
        const d = { keys, dVarpiDeg:{} };
        for (const k of keys){
          // Preserve full precision; formatting will handle visibility (arcseconds if tiny)
          d.dVarpiDeg[k] = cycDeltaDeg(A[k].varpiDeg, B[k].varpiDeg);
        }
        if (A.earth?.proximityPct!=null && B.earth?.proximityPct!=null){
          d.dProxPct = Math.round((B.earth.proximityPct - A.earth.proximityPct)*10)/10;
        }
        return d;
      },
      // similarity feature in [0..1], tiny weight: compare Earth's œñ and proximity
      similarityFeature: (A,B) => {
        if (!A?.earth || !B?.earth) return 0;
        const dVarpi = Math.abs(cycDeltaDeg(A.earth.varpiDeg, B.earth.varpiDeg)); // 0..180
        const sVarpi = 1 - (dVarpi/180); // 1 when equal
        const proxA = A.earth.proximityPct ?? 0, proxB = B.earth.proximityPct ?? 0;
        const sProx = 1 - Math.min(1, Math.abs(proxA - proxB)/100);
        // Mercury echo (very small)
        let sMerc = 0;
        if (A.mercury && B.mercury){
          const dM = Math.abs(cycDeltaDeg(A.mercury.varpiDeg, B.mercury.varpiDeg));
          sMerc = 1 - (dM/180);
        }
        // Weighted blend; capped to [0..1]
        const s = Math.max(0, Math.min(1, 0.5*sVarpi + 0.4*sProx + 0.1*sMerc));
        return s;
      }
    };
    // Expose globally (non-enumerable to keep consoles tidy)
    Object.defineProperty(window, "HaloPeri", { value: HaloPeri, writable:false });

    // ============================================================
    // NEW: GR Compliance (PPN) + Warp Exterior (defaults only)
    // ============================================================
    // Defaults (no sliders): beta=gamma=1 ‚Üí F_PPN=1
    const PPN = { beta: 1.0, gamma: 1.0 };
    function F_PPN(beta=PPN.beta, gamma=PPN.gamma){
      // F = (2 - beta + 2*gamma)/3; equals 1 in GR
      return (2 - beta + 2*gamma)/3;
    }
    // Predict Œîvarpi over span (A‚ÜíB) for planet key with PPN scaling (SIGNED arcsec)
    function predictAdvancePPN_arcsec(tA, tB, key){
      const body = PLANETS[key]; if(!body) return 0;
      // Use SIGNED number of orbits so prediction follows A‚ÜíB direction
      const dOrbit = (tB - tA)/(body.P_days*86400*1000);
      const perOrbit = grPerOrbitRad({ a_m: body.a_AU*AU, e: body.e }); // radians/orbit
      const dPPN = F_PPN()*perOrbit*dOrbit; // radians over span (signed)
      return dPPN * (180/Math.PI) * 3600; // arcsec
    }
    // Observed Œîvarpi from state objects (degrees) ‚Üí arcsec
    function observedAdvance_arcsec(A,B,key){
      const a = A[key]?.varpiDeg, b = B[key]?.varpiDeg;
      if (typeof a !== 'number' || typeof b !== 'number') return 0;
      return cycDeltaDeg(a,b) * 3600; // arcsec
    }
    // Convert arcsec over span to arcsec/century equivalent
    function toArcsecPerCentury(arcsecSpan, tA, tB){
      const dt_years = Math.abs(tB - tA)/(365.25*86400*1000);
      return dt_years>0 ? arcsecSpan * (100/dt_years) : 0;
    }
    // Implied exterior deviation Œµ from residual (toy: scale factor 1+Œµ)
    function impliedEpsilonFromResidual(residual_arcsec, gr_arcsec){
      // If prediction is effectively zero for this span, don‚Äôt blow up Œµ
      if (!isFinite(gr_arcsec) || Math.abs(gr_arcsec) < 1e-6) return 0;
      return residual_arcsec / gr_arcsec;
    }
    // Verdicts (conservative)
    const TOL = { mercury: 1.0, earth: 0.2 }; // ‚Ä≥/century
    function verdictFromResidual(rate_arcsec_per_century, key){
      const lim = (key==='mercury')?TOL.mercury:TOL.earth;
      const mag = Math.abs(rate_arcsec_per_century);
      if (!isFinite(mag)) return 'n/a';
      // Treat tiny residuals as ‚Äúconsistent / below resolution‚Äù
      if (mag <= lim) {
        return mag < 0.05 ? 'OK (consistent; below resolution)' : 'OK (GR-consistent)';
      }
      return 'Ruled-out';
    }

    // -----------------------------------------------
    // NEW helpers for refined perihelion timing
    // -----------------------------------------------
    function meanAnomalyAt(tms, body){
      const n = n_from_P(body.P_days);                 // rad/s
      const M0 = rad(L0_earth_deg - body.varpi0_deg);  // deg->rad (Earth uses L0)
      const dt = (tms - T0)/1000;                      // s
      return normRad(M0 + n*dt);
    }
    function trueAnomalyAt(tms, body){
      const M = meanAnomalyAt(tms, body);
      return trueAnomalyFromM(M, body.e);
    }
    function rOf(tms, body){
      const { a_AU, e } = body;
      const a = a_AU; // AU, cancels in min search; absolute unit not needed
      const nu = trueAnomalyAt(tms, body);
      return a*(1 - e*e)/(1 + e*Math.cos(nu)); // proportional to distance; fine for argmin
    }
    // Golden-section search for argmin in [t0, t1]
    function goldenSectionArgmin(f, t0, t1, iters=42){
      const gr = (Math.sqrt(5)-1)/2; // ~0.618
      let a=t0, b=t1;
      let c=b - gr*(b-a), d=a + gr*(b-a);
      let fc=f(c), fd=f(d);
      for (let i=0;i<iters;i++){
        if (fc < fd){ b=d; d=c; fd=fc; c=b - gr*(b-a); fc=f(c); }
        else { a=c; c=d; fc=fd; d=a + gr*(b-a); fd=f(d); }
      }
      return (a+b)/2;
    }

    // Refined Earth perihelion finder: search for min r(t) near cycle centers
    function nearestPerihelionTimes_Earth_refined(tms){
      const E = PLANETS.earth;
      const Pms = E.P_days*86400*1000;
      // center indices near the target time
      const k = Math.round((tms - T0)/Pms);
      const centers = [k-1, k, k+1].map(j => T0 + j*Pms);
      // search window around each center (¬±0.6 P covers drift and ensures bracket)
      const span = 0.6*Pms;
      const peris = centers.map(c => goldenSectionArgmin(t => rOf(t, E), c - span, c + span, 48));
      peris.sort((a,b)=>a-b);
      // pick last <= tms and next > tms
      let last = peris[0], next = peris[peris.length-1];
      for (let i=0;i<peris.length;i++){
        if (peris[i] <= tms) last = peris[i];
        if (peris[i] > tms){ next = peris[i]; break; }
      }
      return { last, next };
    }

    // Optional Sun altitude check (uses app-provided hooks if available)
    function sunAltAtMaybe(tms){
      // Try common hooks: app may expose one of these
      const hook = (window.SunAlt && typeof window.SunAlt.at === "function")
                    ? window.SunAlt.at
                    : (typeof window.getSunAlt === "function" ? window.getSunAlt : null);
      if (!hook) return null;
      try {
        const alt = hook(tms); // expect degrees
        if (typeof alt === "number" && isFinite(alt)) return alt;
      } catch {}
      return null;
    }

    // Small UI helpers for "‚ìò" tooltips and badges
    const periUI = {
      // Note: role=button + tabindex=0 for keyboard/touch access. We keep title for desktop hover,
      // and add a JS popover for touch/click (see initInfoPopovers below).
      infoIcon: `<span class="peri-info" role="button" tabindex="0" aria-expanded="false" title=""><svg viewBox="0 0 24 24" width="13" height="13" aria-hidden="true"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="1.2" fill="none"/><circle cx="12" cy="7.2" r="1.1" fill="currentColor"/><rect x="11" y="10" width="2" height="7" rx="1" fill="currentColor"/></svg></span>`,
      badge(status){
        const cls = /OK/.test(status) ? 'ok' : (/Ruled/.test(status)?'warn':'peri-muted');
        return `<span class="peri-badge ${cls}">${status}</span>`;
      },
      fmtArcsec(x){
        const ax = Math.abs(x);
        if (ax >= 0.1) return `${x.toFixed(1)}‚Ä≥`;
        return `${(x*1000).toFixed(1)} mas`;
      },
      fmtRate(x){
        const ax = Math.abs(x);
        if (ax >= 0.1) return `${x.toFixed(1)}‚Ä≥/century`;
        return `${(x*1000).toFixed(1)} mas/century`;
      }
    };

    // Minimal CSS for info icon hover + touch popover (reuses existing palette)
    (function injectInfoStyles(){
      if (document.getElementById('perihelion-gr-info-styles')) return;
      const css = `
        .peri-info{display:inline-flex;align-items:center;justify-content:center;margin-left:.35rem;color:#9fb0d9;opacity:.9;cursor:pointer;outline:none}
        .peri-info:hover{color:#cfe1ff}
        .peri-info:focus-visible{box-shadow:0 0 0 2px #9fb0d980;border-radius:999px}
        .peri-badge.ok{border-color:#1a4836;background:#103528;color:#a6ffd8}
        .peri-badge.warn{border-color:#5b3d12;background:#2b200f;color:#ffd38a}
        .peri-popover{position:absolute;z-index:99999;max-width:min(80vw,340px);padding:.5rem .6rem;border-radius:.5rem;border:1px solid #1e293b;background:#0f172a;color:#cbd5e1;font:500 12px/1.35 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;box-shadow:0 8px 24px rgba(0,0,0,.4)}
        .peri-popover[data-placement="top"]::after,.peri-popover[data-placement="bottom"]::after{content:"";position:absolute;left:12px;border:6px solid transparent}
        .peri-popover[data-placement="top"]::after{bottom:-12px;border-top-color:#1e293b}
        .peri-popover[data-placement="bottom"]::after{top:-12px;border-bottom-color:#1e293b}
        @media (hover:none){ .peri-info{opacity:1} }
      `;
      const el = document.createElement('style');
      el.id='perihelion-gr-info-styles'; el.textContent=css; document.head.appendChild(el);
    })();

    // Touch-friendly, accessible popovers for info icons
    (function initInfoPopovers(){
      if (window.__periInfoInit) return; window.__periInfoInit = true;
      let open = null; let openIcon = null;
      function close(){
        if (open){ try { open.remove(); } catch {} open = null; }
        if (openIcon){ try { openIcon.setAttribute('aria-expanded','false'); openIcon.classList.remove('open'); } catch {} openIcon = null; }
      }
      function makePopover(text, anchor){
        const tip = document.createElement('div');
        tip.className = 'peri-popover';
        tip.textContent = text;
        document.body.appendChild(tip);
        // Position near anchor
        const r = anchor.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const scrollX = window.scrollX || window.pageXOffset, scrollY = window.scrollY || window.pageYOffset;
        const preferBottom = r.top < vh*0.6;
        tip.setAttribute('data-placement', preferBottom ? 'bottom' : 'top');
        // compute size after adding
        const tw = tip.offsetWidth, th = tip.offsetHeight;
        let left = r.left + scrollX;
        let top = (preferBottom ? (r.bottom + 8 + scrollY) : (r.top - th - 8 + scrollY));
        // keep within viewport
        if (left + tw + 8 > scrollX + vw) left = Math.max(8 + scrollX, vw + scrollX - tw - 8);
        if (left < 8 + scrollX) left = 8 + scrollX;
        if (top < 8 + scrollY) top = r.bottom + 8 + scrollY, tip.setAttribute('data-placement','bottom');
        tip.style.left = left + 'px'; tip.style.top = top + 'px';
        return tip;
      }
      function toggleIcon(el){
        const text = (el.getAttribute('title') || '').trim();
        if (!text) return;
        if (open && openIcon === el){ close(); return; }
        close();
        open = makePopover(text, el);
        openIcon = el; el.setAttribute('aria-expanded','true'); el.classList.add('open');
      }
      document.addEventListener('click', (ev)=>{
        const icon = ev.target && ev.target.closest && ev.target.closest('.peri-info');
        if (icon){
          ev.preventDefault(); ev.stopPropagation();
          toggleIcon(icon);
        } else {
          close();
        }
      }, { capture:true });
      document.addEventListener('keydown', (ev)=>{
        const tgt = ev.target && ev.target.closest && ev.target.closest('.peri-info');
        if (!tgt) { if (ev.key === 'Escape') close(); return; }
        if (ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); toggleIcon(tgt); }
        if (ev.key === 'Escape'){ close(); }
      });
      window.addEventListener('scroll', ()=>{ close(); }, { passive:true });
      window.addEventListener('resize', ()=>{ close(); });
    })();

    // -----------------------------------------------
    // Integration hooks (progressive enhancement)
    // -----------------------------------------------
    function nowMs(){ return Date.now(); }
    function safeContainer(){
      // Prefer explicit mount if provided, else fall back to existing app containers
      return document.querySelector('[data-peri-mount], #statesBody, #single, #diffText, #relative-states, [data-relativestates], .relative-states') || null;
    }

    // 1) UI injector: add a small "Perihelion (GR)" card into Relative States if present
    function injectPeriUI(tsA=null, tsB=null){
      const mount = safeContainer();
      if (!mount) return; // app may render its own panels; no-op
      const existing = mount.querySelector("[data-peri-panel]");
      const raw_tA = tsA ?? nowMs();
      const raw_tB = tsB ?? raw_tA;
      const swapped = raw_tA > raw_tB;
      const tA = swapped ? raw_tB : raw_tA;
      const tB = swapped ? raw_tA : raw_tB;
  // Persist chronology for async renderers or external callers
  HaloPeri.lastChrono = { tA, tB };
  const A = HaloPeri.stateAt(tA);
  const B = HaloPeri.stateAt(tB);
      const Œî = HaloPeri.delta(A,B);
      const s = HaloPeri.similarityFeature(A,B);

      const fmtAng = (degVal) => {
        const v = +degVal;
        if (!isFinite(v)) return 'n/a';
        if (typeof window.angleSmartDeg === 'function') return window.angleSmartDeg(v);
        const ad = Math.abs(v);
        if (ad < 1e-3){
          const as = v*3600; const aas = Math.abs(as);
          let dp = aas >= 0.1 ? 1 : (aas >= 0.01 ? 2 : 3);
          let s = as.toFixed(dp);
          let tries = dp;
          while (tries < 6 && Math.abs(+s) === 0 && as !== 0){ tries++; s = as.toFixed(tries); }
          if (Math.abs(+s) === 0) s = (0).toFixed(dp);
          return `${s}‚Ä≥`;
        }
        return `${v.toFixed(3)}¬∞`;
      };

      // Replace placeholder perihelion with refined timings
      try {
        const { last: lastA, next: nextA } = nearestPerihelionTimes_Earth_refined(tA);
        const { last: lastB, next: nextB } = nearestPerihelionTimes_Earth_refined(tB);
        A.earth.lastPerihelionISO = toISO(lastA);
        A.earth.nextPerihelionISO = toISO(nextA);
        B.earth.lastPerihelionISO = toISO(lastB);
        B.earth.nextPerihelionISO = toISO(nextB);
      } catch {}

      // Optional Sun altitude info if available
      const altA = sunAltAtMaybe(tA);
      const altB = sunAltAtMaybe(tB);
      const altBlock = (altA!=null || altB!=null) ? `
        <div class="peri-card">
          <div class="peri-kv"><span>Sun altitude (A)</span><b>${altA!=null ? altA.toFixed(1)+'¬∞' : 'n/a'}</b></div>
          <div class="peri-kv"><span>Sun altitude (B)</span><b>${altB!=null ? altB.toFixed(1)+'¬∞' : 'n/a'}</b></div>
          ${(altA!=null && (altA<-6 || altA>88)) || (altB!=null && (altB<-6 || altB>88)) ? `
            <div class="peri-kv peri-muted"><span>Note</span><b>not near local noon</b></div>` : ``}
        </div>` : ``;

      // ---- NEW: GR Compliance (PPN) & Warp Exterior blocks ----
      const keys = ["mercury","earth"].filter(k => A[k] && B[k]);
      const rows = keys.map(k => {
        const obs = observedAdvance_arcsec(A,B,k);
        const pred = predictAdvancePPN_arcsec(tA,tB,k); // GR with defaults (signed)
        const res  = obs - pred;
        const rateObs  = toArcsecPerCentury(obs, tA, tB);
        const ratePred = toArcsecPerCentury(pred, tA, tB);
        const rateRes  = toArcsecPerCentury(res,  tA, tB);
        const ver = verdictFromResidual(rateRes, k);
        const eps = impliedEpsilonFromResidual(res, Math.abs(pred) < 1e-9 ? 0 : pred);
        const spanOK = Math.abs((tB - tA)/(PLANETS[k].P_days*86400*1000)) >= 0.2; // ‚â•0.2 orbits
        const resLabel = spanOK
          ? `${periUI.fmtArcsec(res)} (${periUI.fmtRate(rateRes)})`
          : `<span class="peri-muted">span too short</span>`;
        const epsLabel = spanOK
          ? (isFinite(eps) ? eps.toExponential(2) : 'n/a')
          : `<span class="peri-muted">n/a</span>`;
        return `
          <div class="peri-card">
            <div class="peri-kv"><span>${PLANETS[k].label} Œîœñ<sub>obs</sub> (A‚ÜíB) ${periUI.infoIcon.replace('title=""','title="Measured rotation between the two timestamps, wrapped to ¬±180¬∞ (sign follows A‚ÜíB direction)."')}</span><b>${periUI.fmtArcsec(obs)} (${periUI.fmtRate(rateObs)})</b></div>
            <div class="peri-kv"><span>Œîœñ<sub>pred</sub> (PPN, Œ≤=Œ≥=1) ${periUI.infoIcon.replace('title=""','title="Prediction from tested Solar-System PPN (Œ≤‚âà1, Œ≥‚âà1). Uses the SIGNED number of orbits over A‚ÜíB."')}</span><b>${periUI.fmtArcsec(pred)} (${periUI.fmtRate(ratePred)})</b></div>
            <div class="peri-kv"><span>Residual ${periUI.infoIcon.replace('title=""','title="obs ‚àí pred. If small, the exterior is consistent with GR within the span‚Äôs resolution."')}</span><b>${resLabel}</b></div>
            <div class="peri-kv"><span>Implied exterior Œµ ${periUI.infoIcon.replace('title=""','title="Toy mapping: fractional exterior deviation that would scale perihelion by (1+Œµ) at the planet‚Äôs orbital radius."')}</span><b>${epsLabel}</b></div>
            <div class="peri-kv"><span>Verdict</span><b>${periUI.badge(ver)}</b></div>
          </div>`;
      }).join('');

      const grPPNBlock = `
        <div class="peri-card" data-ppn-panel style="margin-top:.5rem">
          <div class="peri-kv" style="margin-bottom:.5rem">
            <b>GR Compliance (PPN)</b>
            ${periUI.infoIcon.replace('title=""','title="We compare observed perihelion rotation to the PPN/GR prediction (Œ≤=Œ≥=1). Residuals large enough to imply ‚â•1‚Ä≥/century (Mercury) would contradict precision Solar-System tests."')}
            <span class="peri-badge">Œ≤=1.000, Œ≥=1.000</span>
          </div>
          <div class="peri-grid">
            ${rows}
          </div>
        </div>`;

      // Chronology header and series/accumulator helpers (moved outside templates)
      function fmtUTC(ms){ try{ return new Date(ms).toISOString().replace('.000','').replace('T',' ');}catch{ return 'n/a'; } }
      function fmtDeltaT(a,b){ const dt = Math.max(0, (b-a)/1000); const yrs = dt/31557600; return `${dt.toFixed(0)} s  (~${yrs.toFixed(2)} yr)`; }
      const chronoHeader = `
        <div class="peri-card" data-chrono-banner>
          <div class="peri-kv">
            <span>Chronology (UTC)</span>
            <b>${fmtUTC(tA)} <span class="peri-muted">‚Üí</span> ${fmtUTC(tB)}</b>
          </div>
          <div class="peri-kv"><span>Œît (A‚ÜíB)</span><b>+${fmtDeltaT(tA,tB)}</b></div>
          ${swapped ? `<div class=\"peri-kv\"><span class=\"peri-muted\">Note</span><b class=\"peri-muted\">Inputs were reversed; reporting forward in time.</b></div>` : ``}
        </div>`;

  // Series sampling (fallback; Kepler ellipse)
      function monthlySamples(t1, t2){
        const tmin = Math.min(t1,t2), tmax = Math.max(t1,t2);
        const out = []; let t = tmin;
        while (t <= tmax + 1){ out.push(t); t += 30.44*DAY; }
        if (out[out.length-1] !== tmax) out.push(tmax);
        return out;
      }
      // Use helpers defined later in Everyday GR section: curvatureProxy, solarTide_uGal,
      // shapiroDelay_s, summarize, fmtSigned, fmtRange, sunLonRad, pickConjunctionLambda, MIN_B, DAY.
      // Provide a small helper that uses existing MIN_B for psi-aware impact parameter.
      function impactParameter_b_withPsi(rE, psi){ return Math.max(MIN_B, rE*Math.sin(psi)); }
      async function buildSpanSeries(tStart, tEnd){
        const stamps = monthlySamples(tStart, tEnd);
        const out = [];
  for (const t of stamps){ const {r,v}=earth_r_v(t); out.push({t, r, v, tide_uGal: solarTide_uGal(r), K_m2: curvatureProxy(r), einstein_nsps: einsteinNsPerS(r,v)}); }
        const series = { span: out, source: 'kepler' };
        HaloPeri.series = series; window.lastSeries = series; return series;
      }
      function sparklineSVG(values, {w=120,h=24,stroke="#a7c4ff"}={}){
        if (!values || values.length<2) return `<svg width="${w}" height="${h}"></svg>`;
        const min = Math.min(...values), max = Math.max(...values), span = (max-min)||1; const dx = w/(values.length-1);
        const pts = values.map((v,i)=> `${(i*dx).toFixed(1)},${(h - ((v-min)/span)*h).toFixed(1)}`).join(" ");
        return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><polyline points="${pts}" fill="none" stroke="${stroke}" stroke-width="1.3" vector-effect="non-scaling-stroke"/></svg>`;
      }
      // Trapezoid integral over span in "value¬∑day" units (series is time-ordered)
      function trapzDays(series, accessor){
        if (!series || series.length<2) return 0;
        let acc=0;
        for (let i=0;i<series.length-1;i++){
          const a=series[i], b=series[i+1];
          const ya=accessor(a), yb=accessor(b);
          const dt_day=(b.t-a.t)/DAY;
          acc += 0.5*(ya+yb)*dt_day;
        }
        return acc;
      }
      // Absolute Einstein activity ‚à´|rate-mean| dt in ns, and RMS(ns/s) across span
      function einsteinAbs_ns(series){
        if (!series || series.length<2) return 0;
        const mean = series.reduce((s,p)=>s+p.einstein_nsps,0)/series.length;
        let acc=0;
        for (let i=0;i<series.length-1;i++){
          const a=series[i], b=series[i+1];
          const ra=Math.abs(a.einstein_nsps-mean), rb=Math.abs(b.einstein_nsps-mean);
          const dt_s=(b.t-a.t)/1000;
          acc += 0.5*(ra+rb)*dt_s;
        }
        return acc;
      }
      function einsteinRMS_nsps(series){
        if (!series || series.length<2) return 0;
        let acc=0, w=0;
        for (let i=0;i<series.length-1;i++){
          const a=series[i], b=series[i+1];
          const rm=0.5*(a.einstein_nsps + b.einstein_nsps);
          const dt_s=(b.t-a.t)/1000;
          acc += rm*rm*dt_s; w += dt_s;
        }
        return Math.sqrt(acc/(w||1));
      }
      // Higher-cadence Shapiro exposure: weekly steps, fixed ICRS target picked at A
      function shapiroIndex_usDay_highres(tA, tB){
        const step = 7*DAY; const star = (typeof pickConjunctionICRS==='function') ? pickConjunctionICRS(tA) : { alpha:0, delta:0 };
        let acc=0;
        for (let t=tA; t<tB; t+=step){
          const t2 = Math.min(t+step, tB);
            const r1 = earth_r_v(t).r, r2 = earth_r_v(t2).r;
            const psi1 = (typeof separationICRS==='function') ? separationICRS(t, star.alpha, star.delta) : 0;
            const psi2 = (typeof separationICRS==='function') ? separationICRS(t2, star.alpha, star.delta) : 0;
            const b1 = impactParameter_b_withPsi(r1, psi1), b2 = impactParameter_b_withPsi(r2, psi2);
            const sh1 = shapiroDelay_s(r1, r1, b1)*1e6, sh2 = shapiroDelay_s(r2, r2, b2)*1e6;
            const dt_day=(t2-t)/DAY; acc += 0.5*(Math.abs(sh1)+Math.abs(sh2))*dt_day;
        }
        return acc;
      }
      function linearTrendPerYear(xs, ys){ if(xs.length<2) return 0; const x0=xs[0], toYr = ms=> (ms - x0)/(365.25*DAY); const X=xs.map(toYr); const n=X.length; const sx=X.reduce((a,b)=>a+b,0), sy=ys.reduce((a,b)=>a+b,0); const sxx=X.reduce((a,b)=>a+b*b,0), sxy=X.reduce((a,b,i)=>a+b*ys[i],0); const denom = n*sxx - sx*sx; if (Math.abs(denom)<1e-12) return 0; return (n*sxy - sx*sy)/denom; }
      async function renderSpanEvolution(tStart, tEnd){
        const panel=document.querySelector('[data-series-panel]'); if(!panel) return;
        const series= await (HaloPeri.series?.span? HaloPeri.series: buildSpanSeries(tStart,tEnd));
        const xs = series.span.map(p=>p.t);
        const tide = series.span.map(p=>p.tide_uGal);
        const K = series.span.map(p=>p.K_m2/1e-31);
        const trendT = linearTrendPerYear(xs,tide).toFixed(2);
        const trendK = linearTrendPerYear(xs,K).toFixed(3);
        const svgT = sparklineSVG(tide,{w:220});
        const svgK = sparklineSVG(K,{w:220,stroke:'#ffd38a'});
        const durDays = (tEnd - tStart)/DAY;
        const durYears = (tEnd - tStart)/(365.25*DAY);
        const tideExp = trapzDays(series.span, p=>p.tide_uGal);
        const tideMean = tideExp/(durDays||1);
        const KExp_day = trapzDays(series.span, p=>p.K_m2/1e-31);
        const KExp_yr = KExp_day/365.25;
        const KMean = KExp_day/(durDays||1);
        const shapExp = shapiroIndex_usDay_highres(tStart, tEnd);
        const shapMean = shapExp/(durDays||1);
        const einAbs = einsteinAbs_ns(series.span);
        const einRMS = einsteinRMS_nsps(series.span);
        panel.innerHTML = `
          <div class="peri-kv"><span>Span evolution (SSB)</span><b><span class="peri-badge ${series.source==='horizons'?'ok':'peri-muted'}">${series.source}</span></b></div>
          <div class="peri-grid">
            <div class="peri-card"><div class="peri-kv"><span>Solar tide (¬µGal)</span><b class="peri-muted">${trendT} /yr</b></div>${svgT}</div>
            <div class="peri-card"><div class="peri-kv"><span>Curvature √ó10‚Åª¬≥¬π m‚Åª¬≤</span><b class="peri-muted">${trendK} /yr</b></div>${svgK}</div>
          </div>
          <div class="peri-card" style="margin-top:.35rem">
            <div class="peri-kv"><span>Totals (A‚ÜíB)</span><b class="peri-muted">integrated across ${durYears.toFixed(2)} yr</b></div>
            <div class="peri-grid">
              <div class="peri-card"><div class="peri-kv"><span>Solar tide exposure</span><b>${tideExp.toFixed(2)} ¬µGal¬∑day ‚Ä¢ mean ${tideMean.toFixed(2)} ¬µGal</b></div></div>
              <div class="peri-card"><div class="peri-kv"><span>Curvature exposure</span><b>${KExp_yr.toFixed(3)} √ó10‚Åª¬≥¬π m‚Åª¬≤¬∑yr ‚Ä¢ mean ${KMean.toFixed(2)} √ó10‚Åª¬≥¬π m‚Åª¬≤</b></div></div>
              <div class="peri-card"><div class="peri-kv"><span>Shapiro exposure</span><b>${shapExp.toFixed(2)} ¬µs¬∑day ‚Ä¢ mean ${shapMean.toFixed(2)} ¬µs/day</b></div></div>
              <div class="peri-card"><div class="peri-kv"><span>Einstein activity</span><b>${einAbs.toFixed(2)} ns (abs) ‚Ä¢ RMS rate ${einRMS.toFixed(2)} ns/s</b></div></div>
            </div>
          </div>`;
      }
  function accrueGR_arcsec(key, tStart, tEnd){ const body=PLANETS[key]; if(!body) return {arcsec:0,norbits:0,perOrbit_as:0}; const norb=(tEnd - tStart)/(body.P_days*DAY); const perOrbit = (function(){ const a_m=body.a_AU*AU, e=body.e; return 6*Math.PI*GM_SUN/(a_m*(1-e*e)*C*C); })(); const perAs = perOrbit*(180/Math.PI)*3600; return { arcsec: perAs*norb, norbits: norb, perOrbit_as: perAs }; }
      function integrateEinsteinRelative_ns(series){ if(!series||series.length<2) return 0; const mean = series.reduce((s,p)=>s+p.einstein_nsps,0)/series.length; let acc=0; for(let i=0;i<series.length-1;i++){ const a=series[i], b=series[i+1]; const dt_s=(b.t-a.t)/1000; const ra=a.einstein_nsps-mean, rb=b.einstein_nsps-mean; acc += 0.5*(ra+rb)*dt_s; } return acc; }
      // Pick a fixed ecliptic target once per span for consistent Shapiro integration
      function pickFixedTargetLambdaForSpan(series){
        const t0 = series && series[0] && series[0].t;
        if (!t0) return (typeof ECLIPTIC_TARGETS !== 'undefined' ? ECLIPTIC_TARGETS[0] : 0);
        return pickConjunctionLambda(t0).lambda;
      }
      function shapiroIndex_usDay(series){
        if(!series||series.length<2) return 0;
        let acc=0;
        const lamStar = pickFixedTargetLambdaForSpan(series);
        for(let i=0;i<series.length-1;i++){
          const a=series[i], b=series[i+1];
          const lamSunA = sunLonRad(a.t); const lamSunB = sunLonRad(b.t);
          const psiA = Math.abs((lamSunA - lamStar + Math.PI)%(2*Math.PI) - Math.PI);
          const psiB = Math.abs((lamSunB - lamStar + Math.PI)%(2*Math.PI) - Math.PI);
          const bA=impactParameter_b_withPsi(a.r,psiA); const bB=impactParameter_b_withPsi(b.r,psiB);
          const shA=shapiroDelay_s(a.r,a.r,bA)*1e6; const shB=shapiroDelay_s(b.r,b.r,bB)*1e6;
          const dt_day=(b.t-a.t)/DAY; acc += 0.5*(Math.abs(shA)+Math.abs(shB))*dt_day;
        }
        return acc;
      }
  async function renderAccumulators(tStart,tEnd){ const panel=document.querySelector('[data-accum-panel]'); if(!panel) return; const series = await (HaloPeri.series?.span? HaloPeri.series: buildSpanSeries(tStart,tEnd)); const merc=accrueGR_arcsec('mercury',tStart,tEnd); const earthAcc=accrueGR_arcsec('earth',tStart,tEnd); const ein_ns=integrateEinsteinRelative_ns(series.span); const shp_idx=shapiroIndex_usDay_highres(tStart,tEnd); panel.innerHTML = `<div class="peri-kv"><span>Accumulators (A‚ÜíB)</span><b><span class="peri-badge ${series.source==='horizons'?'ok':'peri-muted'}">${series.source}</span></b></div><div class="peri-grid"><div class="peri-card"><div class="peri-kv"><span>Mercury GR accrued</span><b>${periUI.fmtArcsec(merc.arcsec)} ‚Ä¢ ${merc.norbits.toFixed(1)} orbits √ó ${merc.perOrbit_as.toFixed(3)}‚Ä≥/orbit</b></div></div><div class="peri-card"><div class="peri-kv"><span>Earth GR accrued</span><b>${periUI.fmtArcsec(earthAcc.arcsec)} ‚Ä¢ ${earthAcc.norbits.toFixed(1)} orbits √ó ${earthAcc.perOrbit_as.toFixed(3)}‚Ä≥/orbit</b></div></div><div class="peri-card"><div class="peri-kv"><span>Einstein redshift (net vs span-mean)</span><b>${fmtSigned(ein_ns,2)} ns</b></div></div><div class="peri-card"><div class="peri-kv"><span>Shapiro cumulative index</span><b>${shp_idx.toFixed(2)} ¬µs¬∑day</b></div></div></div>`; }
      async function renderTimeline(tStart,tEnd){
        const panel=document.querySelector('[data-timeline-panel]'); if(!panel) return;
        const host = panel.querySelector('#spore-timeline-root');
        if (host) {
          host.setAttribute('data-span-start', String(tStart));
          host.setAttribute('data-span-end', String(tEnd));
          try {
            host.dispatchEvent(new CustomEvent('spore:timeline-span', { detail: { tStart, tEnd } }));
          } catch {}
          return;
        }
        const series = await (HaloPeri.series?.span? HaloPeri.series: buildSpanSeries(tStart,tEnd));
        const span = series.span || [];
        // Collect extrema at monthly cadence
        const allExtrema = (function(){ const arr=[]; for(let i=1;i<span.length-1;i++){ const p0=span[i-1], p=span[i], p1=span[i+1]; if (p.r<p0.r && p.r<p1.r) arr.push({t:p.t, type:'Perihelion (Earth)'}); if (p.r>p0.r && p.r>p1.r) arr.push({t:p.t, type:'Aphelion (Earth)'}); } return arr; })()
          .filter(e=> e.t>=tStart && e.t<=tEnd)
          .sort((a,b)=>a.t-b.t);
        // Year ticks for each UTC year in the span
        const yearsSet = new Set(span.map(p=> new Date(p.t).getUTCFullYear()));
        const years = Array.from(yearsSet).map(y=> ({ t: Date.parse(`${y}-01-01T00:00:00Z`), type:`Year ${y}` }))
          .filter(e=> e.t>=tStart && e.t<=tEnd)
          .sort((a,b)=>a.t-b.t);
        // Anchor with all year ticks, sprinkle up to N extrema
        const maxExtrema = 6;
        const sprinkled = allExtrema.slice(0, maxExtrema);
        const events = [...years, ...sprinkled].sort((a,b)=>a.t-b.t);
        const Pm=PLANETS.mercury.P_days*DAY; const perAs=accrueGR_arcsec('mercury',tStart,tEnd).perOrbit_as;
        const items = events.map(ev=>{ const norb=(ev.t - tStart)/Pm; const cumAs=perAs*norb; return `<li><b>${new Date(ev.t).toISOString().slice(0,10)}</b> ‚Ä¢ ${ev.type} <span class=\"peri-muted\">‚Ä¢ Mercury GR +${cumAs.toFixed(2)}‚Ä≥ since A</span></li>`; }).join('');
        panel.innerHTML = `<div class=\"peri-kv\"><span>Timeline (A‚ÜíB)</span><b class=\"peri-muted\">key milestones</b></div><ul class=\"peri-list\" style=\"padding-left:1rem; margin:.25rem 0 0;\"><li><b>${new Date(tStart).toISOString().slice(0,10)}</b> ‚Ä¢ Start (A)</li>${items || `<li class=\"peri-muted\">no notable extrema detected at monthly cadence</li>`}<li><b>${new Date(tEnd).toISOString().slice(0,10)}</b> ‚Ä¢ End (B)</li></ul>`;
      }

      const timelineBlock = `
        <div class="peri-card" data-timeline-panel style="margin:.5rem 0 .75rem 0; padding:0;">
          <div id="spore-timeline-root"></div>
        </div>`;
      const warpBlock = `
        <div class="peri-card" data-warp-panel style="margin-top:.5rem">
          <div class="peri-kv" style="margin-bottom:.5rem">
            <b>Warp Exterior</b>
            ${periUI.infoIcon.replace('title=""','title="A viable warp metric must match Schwarzschild/Minkowski outside the shell. Any residual Œµ(r>r‚ÇÄ) would leak into planetary precession; here we report the Œµ that would be implied by the observed residuals."')}
          ${chronoHeader}
            <span class="peri-badge ok">Asymptotically GR (Œµ=0)</span>
          </div>
          <div class="peri-grid">
            <div class="peri-card peri-muted">
              <div class="peri-kv"><span>Exterior model</span><b>Œµ(r)=0 (default)</b></div>
              <div class="peri-kv"><span>PPN scale</span><b>ùîâ<sub>PPN</sub>=${F_PPN().toFixed(3)}</b></div>
              <div class="peri-kv"><span>Note</span><b class="peri-muted">Non-zero implied Œµ above would be observational, not assumed.</b></div>
            </div>
            <div class="peri-card" data-accum-panel style="margin-top:.5rem"><div class="peri-kv"><span>Accumulators (A‚ÜíB)</span><b class="peri-muted">integrating‚Ä¶</b></div></div>
          </div>
        </div>`;

      // ============================
      // Everyday GR lenses ‚Äî helpers and computations (A/B windows + geometry-aware Shapiro)
      // ============================
      const R_SUN = 696_340_000;            // m (IAU nominal)
      const J2_SUN = 2.2e-7;                // Solar quadrupole (representative)
      const MU_SUN = GM_SUN;                // shorthand
      const DAY = 86400*1000;               // ms in a day
      const PI = Math.PI;
      const LAMBDA_Q_RAD = 0;               // notional ecliptic quasar longitude
      const MIN_B = 1.005*R_SUN;            // cap minimum b near grazing

      // Orbital r(t) & v(t) for Earth
      function earth_r_v(tms){
        const E = PLANETS.earth;
        const a = E.a_AU*AU, e=E.e;
        const nu = trueAnomalyAt(tms, E);
        const r  = a*(1 - e*e)/(1 + e*Math.cos(nu)); // m
        const v  = Math.sqrt(MU_SUN*(2/r - 1/a));    // m/s (vis-viva)
        return { r, v };
      }
      function curvatureProxy(r){ return 2*MU_SUN/(r*r*r*C*C); }
      const SOLAR_TIDE_AT_1AU_uGal = 50;
      function solarTide_uGal(r){ return SOLAR_TIDE_AT_1AU_uGal * Math.pow(AU/r, 3); }
      function shapiroDelay_s(rE, rS, b){ return (2*MU_SUN/(C*C*C)) * Math.log( (4*rE*rS)/(b*b) ); }
      function einsteinNsPerS(r,v){
        const frac = (-MU_SUN/r)/(C*C) - (v*v)/(2*C*C);
        return frac*1e9; // ns/s
      }
      function dvarpiJ2_perOrbit_rad(body){
        const a = body.a_AU*AU, e=body.e;
        return 3*Math.PI*J2_SUN * (R_SUN*R_SUN)/(a*a) / ((1 - e*e)*(1 - e*e));
      }
      function spanOrbits(tA,tB, body){ return (tB - tA)/(body.P_days*DAY); }
      function toArcsec(x_rad){ return x_rad*(180/Math.PI)*3600; }
      function summarize(arr){
        if (!arr.length) return {mean:NaN, min:NaN, max:NaN, range:NaN};
        const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
        const mn = Math.min(...arr), mx = Math.max(...arr);
        return { mean, min:mn, max:mx, range: mx - mn };
      }
      function fmtSigned(x, dp=2){ const s = (x>=0?'+':''); return s + x.toFixed(dp); }
      function fmtRange(mean, range, unit){ return `${mean.toFixed(2)} ¬± ${(range/2).toFixed(2)} ${unit}`; }

      // Sun apparent ecliptic longitude Œª_sun(t) ‚âà Œª_Earth + œÄ, with Œª_Earth ‚âà varpi_Earth + ŒΩ_Earth
      function sunLonRad(tms){
        const E = PLANETS.earth;
        const varpi = varpiAt(tms, E);
        const nu    = trueAnomalyAt(tms, E);
        const lambdaEarth = normRad(varpi + nu);
        return normRad(lambdaEarth + Math.PI);
      }
      // Discrete ecliptic catalog and nearest-conjunction picker
      const ECLIPTIC_TARGETS = Array.from({length:12}, (_,i)=> i*(2*Math.PI/12)); // 0¬∞,30¬∞,‚Ä¶,330¬∞
      function pickConjunctionLambda(tms){
        const lamSun = sunLonRad(tms);
        let best = ECLIPTIC_TARGETS[0], bestPsi = Math.PI;
        for (const lam of ECLIPTIC_TARGETS){
          const psi = Math.abs((lamSun - lam + Math.PI)%(2*Math.PI) - Math.PI); // ‚àà [0,œÄ]
          if (psi < bestPsi) { bestPsi = psi; best = lam; }
        }
        return { lambda: best, psi: bestPsi };
      }
      // Impact parameter to fixed ecliptic quasar at Œª*=0¬∞, b(t) = r_E sin œà
      function impactParameter_b(tms){
        const { r } = earth_r_v(tms);
        const lamSun = sunLonRad(tms);
        let dpsi = Math.abs((lamSun - LAMBDA_Q_RAD + PI)%(2*PI) - PI);
        const b = Math.max(MIN_B, r * Math.sin(dpsi));
        return b;
      }
      // Sample ¬±N days window around a timestamp
      function sampleWindow(centerT, halfDays=30){
        const vals = { tide:[], K:[], ein:[] };
        const start = centerT - halfDays*DAY, stop = centerT + halfDays*DAY;
        for (let t=start; t<=stop; t+=DAY){
          const { r, v } = earth_r_v(t);
          vals.tide.push( solarTide_uGal(r) );
          vals.K.push( curvatureProxy(r) );
          vals.ein.push( einsteinNsPerS(r,v) );
        }
        return {
          tide: summarize(vals.tide),
          K:    summarize(vals.K),
          ein:  summarize(vals.ein)
        };
      }

      const winA = sampleWindow(tA, 30);
      const winB = sampleWindow(tB, 30);

      // Geometry-aware Shapiro at endpoints
      const rA = earth_r_v(tA).r, rB = earth_r_v(tB).r;
      const bA = impactParameter_b(tA), bB = impactParameter_b(tB);
      const shA_us = shapiroDelay_s(rA, rA, bA)*1e6;
      const shB_us = shapiroDelay_s(rB, rB, bB)*1e6;
      const shDelta_us = shB_us - shA_us;

      // Solar J2 lens for Mercury & Earth over span
      function j2LensRow(key){
        const body = PLANETS[key];
        const dper_orb = dvarpiJ2_perOrbit_rad(body);           // radians/orbit
        const norb     = spanOrbits(tA,tB, body);               // signed
        const dspan_as = toArcsec(dper_orb * norb);             // arcsec over A‚ÜíB
        const rate_asC = toArcsecPerCentury(dspan_as, tA, tB);  // ‚Ä≥/century eq
        const gr_span_as = predictAdvancePPN_arcsec(tA,tB,key); // GR (Œ≤=Œ≥=1) over span
        const frac = (Math.abs(gr_span_as)>1e-9) ? (Math.abs(dspan_as)/Math.abs(gr_span_as)) : 0;
        return { key, dspan_as, rate_asC, frac };
      }
      const j2Merc = j2LensRow("mercury");
      const j2Earth= j2LensRow("earth");

      // ---------- NARRATIVE (five-part) HELPERS ----------
      const SYNODIC_D = 29.530588;   // synodic month (days)
      const CARRINGTON_D = 27.2753;  // Carrington rotation (days)
      const YEAR = 365.25*DAY;       // year in ms (DAY defined above)

      // Build a short series around a single timestamp (¬±windowDays), reusing our Kepler/Horizons pipe.
      async function buildWindowSeries(t0, windowDays=30){
        const t1 = t0 - windowDays*DAY, t2 = t0 + windowDays*DAY;
        return buildSpanSeries(t1, t2); // { span:[{t,r,v,tide_uGal,K_m2,einstein_nsps}...], source }
      }
      function meanOf(series, key){
        if (!series || !series.length) return NaN;
        let s=0; for (const p of series) s += (+p[key]||0);
        return s/series.length;
      }
      function pickEndpointShapiro_us(tms){
        // Fixed ecliptic target chosen by nearest conjunction at the endpoint
        const lamStar = pickConjunctionLambda(tms).lambda;
        const r = earth_r_v(tms).r;
        const psi = Math.abs((sunLonRad(tms) - lamStar + Math.PI)%(2*Math.PI) - Math.PI);
        const b = impactParameter_b_withPsi(r, psi);
        const sh_s = shapiroDelay_s(r, r, b);
        return sh_s*1e6; // ¬µs
      }
      // Minimal lunar long-cycle phases for narrative purposes
      function lunarLongCyclePhases(tms){
        const t0 = Date.parse('2000-01-01T12:00:00Z');
        const days = (tms - t0)/DAY;
        const NODAL_D = 18.6*365.25;     // ~18.6 years
        const ANOM_D  = 27.554551;       // anomalistic month
        const nodalPhaseDeg   = ((days / NODAL_D)%1)*360;
        const perigeePhaseDeg = ((days / ANOM_D)%1)*360;
        return { nodalPhaseDeg, perigeePhaseDeg };
      }
      function cyclesBetween(tA, tB){
        const dt_d = (tB - tA)/DAY;
        const earthOrbits   = dt_d / PLANETS.earth.P_days;
        const mercuryOrbits = dt_d / PLANETS.mercury.P_days;
        const synMonths     = dt_d / SYNODIC_D;
        const carrRot       = dt_d / CARRINGTON_D;
        const phA = lunarLongCyclePhases(tA), phB = lunarLongCyclePhases(tB);
        const dNodal   = (((phB.nodalPhaseDeg   - phA.nodalPhaseDeg)+360)%360);
        const dPerigee = (((phB.perigeePhaseDeg - phA.perigeePhaseDeg)+360)%360);
        return { earthOrbits, mercuryOrbits, synMonths, carrRot, nodalFrac:dNodal/360, perigeeFrac:dPerigee/360, dNodal, dPerigee };
      }

      // ---------- FIVE-PART NARRATIVE RENDERER ----------
      async function renderNarrativeFive(tA, tB){
        const panel = document.querySelector('[data-narrative-panel]');
        if (!panel) return;
        try{
          // Window summaries at A and B (¬±30 d)
          const [winA, winB] = await Promise.all([buildWindowSeries(tA,30), buildWindowSeries(tB,30)]);
          const meanTideA = meanOf(winA.span, 'tide_uGal');
          const meanTideB = meanOf(winB.span, 'tide_uGal');
          const meanKA    = meanOf(winA.span, 'K_m2');
          const meanKB    = meanOf(winB.span, 'K_m2');
          const meanEinA  = meanOf(winA.span, 'einstein_nsps');
          const meanEinB  = meanOf(winB.span, 'einstein_nsps');
          const shapA_us  = pickEndpointShapiro_us(tA);
          const shapB_us  = pickEndpointShapiro_us(tB);

          // Accumulations across the span (reuse our accumulators)
          const merc = accrueGR_arcsec('mercury', tA, tB);
          const earthAcc = accrueGR_arcsec('earth',   tA, tB);
          const series = await (HaloPeri.series?.span ? Promise.resolve(HaloPeri.series) : buildSpanSeries(tA, tB));
          const einNet_ns = integrateEinsteinRelative_ns(series.span);
          const shapExp   = shapiroIndex_usDay_highres(tA, tB);

          // Cycles & elapsed ‚Äúthings‚Äù
          const cyc = cyclesBetween(tA, tB);
          const days = (tB - tA)/DAY, years = (tB - tA)/YEAR;

          // Names (fallbacks)
          const Aname = (window?.Selected?.A?.name) || 'A';
          const Bname = (window?.Selected?.B?.name) || 'B';

          // 1) What essentially stayed the same
          const stayed = [];
          if (isFinite(meanTideA) && isFinite(meanTideB) && Math.abs(meanTideB-meanTideA) < 0.3)
            stayed.push(`**solar tide** was essentially identical (A ${meanTideA.toFixed(2)} ¬µGal, B ${meanTideB.toFixed(2)} ¬µGal)`);
          if (isFinite(meanKA) && isFinite(meanKB) && Math.abs(meanKB-meanKA) < 0.02e-31)
            stayed.push(`**curvature scale** (2GM/(r^3c^2)) matched (A ${(meanKA/1e-31).toFixed(2)}√ó10‚Åª¬≥¬π m‚Åª¬≤, B ${(meanKB/1e-31).toFixed(2)}√ó10‚Åª¬≥¬π m‚Åª¬≤)`);
          if (isFinite(meanEinA) && isFinite(meanEinB) && Math.abs(meanEinB-meanEinA) < 0.02)
            stayed.push(`**Einstein redshift mean** ~ ${(meanEinA).toFixed(2)} ns/s at both epochs`);
          if (isFinite(shapA_us) && isFinite(shapB_us) && Math.abs(shapB_us-shapA_us) < 0.2)
            stayed.push(`**Shapiro endpoint delay** ‚âà ${shapA_us.toFixed(2)} ¬µs at A and ${shapB_us.toFixed(2)} ¬µs at B`);
          const stayedHTML = stayed.length ? `<ul>${stayed.map(s=>`<li>${s}</li>`).join('')}</ul>` : `<p class="peri-muted">No near-constants cleared the ‚Äúessentially same‚Äù thresholds.</p>`;

          // 2) What accumulated between A‚ÜíB
          const accum = [
            `**Mercury perihelion (GR):** +${merc.arcsec.toFixed(1)}‚Ä≥ (${merc.norbits.toFixed(1)} orbits √ó ${merc.perOrbit_as.toFixed(3)}‚Ä≥/orbit)`,
            `**Earth perihelion (GR):** +${earthAcc.arcsec.toFixed(1)}‚Ä≥ (${earthAcc.norbits.toFixed(1)} orbits √ó ${earthAcc.perOrbit_as.toFixed(3)}‚Ä≥/orbit)`,
            `**Einstein net (vs span-mean):** ${einNet_ns>=0?'+':''}${einNet_ns.toFixed(2)} ns`,
            `**Shapiro exposure:** ${shapExp.toFixed(2)} ¬µs¬∑day`
          ];

          // 3) Who did what first? (rank by cycles)
          const who = [
            `~${cyc.synMonths.toFixed(1)} synodic months`,
            `~${cyc.carrRot.toFixed(0)} Carrington rotations`,
            `~${cyc.mercuryOrbits.toFixed(1)} Mercury orbits`,
            `~${cyc.earthOrbits.toFixed(1)} Earth orbits`,
            `lunar nodes advanced ~${cyc.dNodal.toFixed(0)}¬∞`,
            `lunar perigee ~${cyc.dPerigee.toFixed(0)}¬∞`
          ];

          // 4) How many ‚Äúthings‚Äù had to elapse
          const howmany = `‚âà ${Math.round(days)} days (~${years.toFixed(2)} yr), ` +
                          `${cyc.synMonths.toFixed(1)} synodic months, ` +
                          `${cyc.carrRot.toFixed(0)} Carrington rotations, ` +
                          `${cyc.mercuryOrbits.toFixed(1)} Mercury years, ` +
                          `${cyc.earthOrbits.toFixed(1)} Earth years.`;

          // 5) What your results say about the two images (without seeing them)
          const say = `By choosing **equinox ‚Üî equinox**, you held the viewing geometry nearly constant; the small endpoint deltas are expected. The **differences that matter** are the **time-integrated GR effects** (perihelion advance), which accrued exactly as predicted. At this precision the exterior metric is **consistent with GR** (PPN residuals at ~mas level).`;

          panel.innerHTML = `
            <div class="peri-kv"><span>Narrative summary</span><b class="peri-muted">${new Date(tA).toISOString().slice(0,10)} ‚Üí ${new Date(tB).toISOString().slice(0,10)}</b></div>
            <div class="story">
              <p class="lead">Comparing "<b>${Aname}</b>" to "<b>${Bname}</b>" tells a time-ordered story.</p>
              <p><b>1) What essentially stayed the same.</b></p>
              ${stayedHTML}
              <p><b>2) What accumulated between A ‚Üí B (and why it matters).</b></p>
              <ul>${accum.map(s=>`<li>${s}</li>`).join('')}</ul>
              <p><b>3) ‚ÄúWho did what first?‚Äù (time-ordered, cycle-based).</b></p>
              <ul>${who.map(s=>`<li>${s}</li>`).join('')}</ul>
              <p><b>4) How many ‚Äúthings‚Äù had to elapse.</b><br>${howmany}</p>
              <p><b>5) What your results say about the two images.</b><br>${say}</p>
            </div>`;
        }catch(e){ panel.innerHTML = `<div class="peri-kv"><span>Narrative summary</span><b class="peri-muted">unavailable</b></div>`; }
      }

      // ---------- Everyday GR lenses UI ----------
      const lensInfo = {
        bary: periUI.infoIcon.replace('title=""','title="Solar-System barycentric (SSB) view. For each timestamp we sample ¬±30 days to summarize the solar tide (‚àù1/r^3) and the curvature proxy 2GM/(r^3 c^2). We also show Œî of the window means."'),
        j2:   periUI.infoIcon.replace('title=""','title="Sun‚Äôs small quadrupole J2 adds a classical perihelion precession. We show its predicted share of the total over your A‚ÜíB span (no sliders; fixed J2)."'),
        pc:   periUI.infoIcon.replace('title=""','title="Photon/Clock lens. Geometry-aware Shapiro delay to a fixed ecliptic quasar (Œª*=0¬∞) using b(t)=r_E sin œà(t); Einstein redshift from Sun‚Äôs potential and orbital speed ‚Äî each summarized over ¬±30 days."')
      };

      const baryBlock = `
        <div class="peri-card" data-bary-panel style="margin-top:.5rem">
          <div class="peri-kv" style="margin-bottom:.5rem">
            <b>Everyday GR lenses</b>
          </div>
          <div class="peri-grid">
            <div class="peri-card">
              <div class="peri-kv"><span>Barycentric lens (SSB) ${lensInfo.bary}</span><b></b></div>
              <div class="peri-kv"><span>Solar tide (A ¬±30d)</span><b>${fmtRange(winA.tide.mean, winA.tide.range, '¬µGal')}</b></div>
              <div class="peri-kv"><span>Solar tide (B ¬±30d)</span><b>${fmtRange(winB.tide.mean, winB.tide.range, '¬µGal')}</b></div>
              <div class="peri-kv"><span>Œî mean</span><b>${fmtSigned(winB.tide.mean - winA.tide.mean, 2)} ¬µGal</b></div>
              <div class="peri-kv"><span>Curvature 2GM/(r¬≥c¬≤) (A)</span><b>${(winA.K.mean/1e-31).toFixed(2)} √ó10‚Åª¬≥¬π m‚Åª¬≤</b></div>
              <div class="peri-kv"><span>Curvature 2GM/(r¬≥c¬≤) (B)</span><b>${(winB.K.mean/1e-31).toFixed(2)} √ó10‚Åª¬≥¬π m‚Åª¬≤</b></div>
              <div class="peri-kv"><span>Œî mean</span><b>${fmtSigned((winB.K.mean - winA.K.mean)/1e-31, 2)} √ó10‚Åª¬≥¬π m‚Åª¬≤</b></div>
            </div>
            <div class="peri-card">
              <div class="peri-kv"><span>Solar quadrupole lens ${lensInfo.j2}</span><b></b></div>
              <div class="peri-kv"><span>Mercury Œîœñ<sub>J‚ÇÇ</sub> (A‚ÜíB)</span><b>${periUI.fmtArcsec(j2Merc.dspan_as)} (${periUI.fmtRate(j2Merc.rate_asC)}) ‚Ä¢ ${(j2Merc.frac*100).toFixed(2)}%</b></div>
              <div class="peri-kv"><span>Earth Œîœñ<sub>J‚ÇÇ</sub> (A‚ÜíB)</span><b>${periUI.fmtArcsec(j2Earth.dspan_as)} (${periUI.fmtRate(j2Earth.rate_asC)}) ‚Ä¢ ${(j2Earth.frac*100).toFixed(2)}%</b></div>
            </div>
            <div class="peri-card">
              <div class="peri-kv"><span>Photon/Clock lens ${lensInfo.pc}</span><b></b></div>
              <div class="peri-kv"><span>Shapiro to quasar Œª*=0¬∞</span><b>A: ${shA_us.toFixed(2)} ¬µs ‚Ä¢ B: ${shB_us.toFixed(2)} ¬µs ‚Ä¢ Œî: ${fmtSigned(shDelta_us,2)} ¬µs</b></div>
              <div class="peri-kv"><span>Einstein redshift (A ¬±30d)</span><b>${fmtRange(winA.ein.mean, winA.ein.range, 'ns/s')}</b></div>
              <div class="peri-kv"><span>Einstein redshift (B ¬±30d)</span><b>${fmtRange(winB.ein.mean, winB.ein.range, 'ns/s')}</b></div>
              <div class="peri-kv"><span>Œî mean</span><b>${fmtSigned(winB.ein.mean - winA.ein.mean, 2)} ns/s</b></div>
            </div>
          </div>
        </div>`;


      const narrativeBlock = `
        <div class="peri-card" data-narrative-panel style="margin-top:.5rem">
          <div class="peri-kv"><span>Narrative summary</span><b class="peri-muted">composing‚Ä¶</b></div>
        </div>`;

      const timelinePanel = mount.querySelector('[data-timeline-panel]');
      if (timelinePanel) {
        if (timelinePanel !== mount.firstElementChild) {
          mount.insertBefore(timelinePanel, mount.firstChild);
        }
      } else {
        mount.insertAdjacentHTML("afterbegin", timelineBlock);
      }

      const html = `
        <div data-peri-panel class="peri-card" style="margin-top:.5rem">
          <div class="peri-kv" style="margin-bottom:.5rem">
            <b>Perihelion (GR)</b>
            <span class="peri-badge" title="Similarity feature contribution (0..1)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 12h18M3 6h18M3 18h18" stroke-width="1.5"/></svg>
              s<sub>peri</sub>=${s.toFixed(3)}
            </span>
          </div>
          ${narrativeBlock}
          <div class="peri-grid">
            <div class="peri-card peri-muted">
              <div class="peri-kv"><span>Earth œñ (A)</span><b>${A.earth.varpiDeg.toFixed(3)}¬∞</b></div>
              <div class="peri-kv"><span>Earth œñ (B)</span><b>${B.earth.varpiDeg.toFixed(3)}¬∞</b></div>
              <div class="peri-kv"><span>Œîœñ<sub>Earth</sub></span><b>${fmtAng(Œî.dVarpiDeg.earth ?? 0)}</b></div>
            </div>
            <div class="peri-card peri-muted">
              <div class="peri-kv"><span>Mercury œñ (A)</span><b>${A.mercury.varpiDeg.toFixed(3)}¬∞</b></div>
              <div class="peri-kv"><span>Mercury œñ (B)</span><b>${B.mercury.varpiDeg.toFixed(3)}¬∞</b></div>
              <div class="peri-kv"><span>Œîœñ<sub>Mercury</sub></span><b>${fmtAng(Œî.dVarpiDeg.mercury ?? 0)}</b></div>
            </div>
            <div class="peri-card">
              <div class="peri-kv"><span>Earth perihelion proximity (A)</span><b>${A.earth.proximityPct?.toFixed(1)}%</b></div>
              <div class="peri-kv"><span>Earth perihelion proximity (B)</span><b>${B.earth.proximityPct?.toFixed(1)}%</b></div>
              <div class="peri-kv"><span>Œî proximity</span><b>${(Œî.dProxPct??0).toFixed(1)}%</b></div>
            </div>
            <div class="peri-card">
              <div class="peri-kv"><span>Last perihelion (A)</span><b>${A.earth.lastPerihelionISO}</b></div>
              <div class="peri-kv"><span>Next perihelion (A)</span><b>${A.earth.nextPerihelionISO}</b></div>
              <div class="peri-kv"><span>Last perihelion (B)</span><b>${B.earth.lastPerihelionISO}</b></div>
              <div class="peri-kv"><span>Next perihelion (B)</span><b>${B.earth.nextPerihelionISO}</b></div>
              <div class="peri-kv"><span class="peri-muted">Method</span><b class="peri-muted">GR-secular + min-r search</b></div>
            </div>
            ${altBlock}
          </div>
          <div style="margin-top:.5rem">
            <span class="peri-chip" title="Ellipse rotation due to GR">
              Œîœñ (A‚ÜíB): <b style="margin-left:.35rem">${fmtAng(Œî.dVarpiDeg.earth ?? 0)}</b> Earth,
              <b style="margin-left:.35rem">${fmtAng(Œî.dVarpiDeg.mercury ?? 0)}</b> Mercury
            </span>
          </div>
          ${grPPNBlock}
          ${warpBlock}
          ${baryBlock}
          <div class="peri-card" data-series-panel style="margin-top:.5rem"><div class="peri-kv"><span>Span evolution (SSB)</span><b class="peri-muted">sampling‚Ä¶</b></div></div>
        </div>`;
      if (existing) existing.outerHTML = html; else mount.insertAdjacentHTML("beforeend", html);
  // kick async renders after mount
  setTimeout(()=>{ try{ renderSpanEvolution(tA,tB); renderAccumulators(tA,tB); renderTimeline(tA,tB); renderNarrativeFive(tA,tB);}catch(e){ console.warn('peri async post-mount failed:', e);} }, 60);
    }

    // 2) Similarity hook: blend a small perihelion feature into existing score if possible.
    //    We try three strategies for maximum compatibility:
    //    (a) window.registerSimilarityFeature(fn, weight)
    //    (b) window.Similarity?.use(fn, weight)
    //    (c) monkey-patch window.computeSimilarity(A,B,...) -> adds +w*s
    const WEIGHT = 0.06; // gentle contribution
    function tryRegisterSimilarity(){
      const apiA = window.registerSimilarityFeature;
      if (typeof apiA === "function"){
        apiA((A,B)=>HaloPeri.similarityFeature(A?.peri??A, B?.peri??B), WEIGHT, "perihelionGR");
        return true;
      }
      const apiB = window.Similarity?.use;
      if (typeof apiB === "function"){
        window.Similarity.use((A,B)=>({ name:"perihelionGR", weight:WEIGHT, score: HaloPeri.similarityFeature(A?.peri??A, B?.peri??B)}));
        return true;
      }
      // Fallback: wrap computeSimilarity if it exists and hasn't been wrapped by us
      const cs = window.computeSimilarity;
      if (typeof cs === "function" && !cs.__periWrapped){
        const wrapped = function(A,B,...rest){
          const base = cs.call(this,A,B,...rest);
          try {
            const s = HaloPeri.similarityFeature(A?.peri??A, B?.peri??B);
            return base + WEIGHT*s;
          } catch { return base; }
        };
        wrapped.__periWrapped = true;
        window.computeSimilarity = wrapped;
        return true;
      }
      return false;
    }

    // 3) State provider hook: if your app has a notion of timeline A/B,
    //    listen for custom events to (re)render our panel.
    //    You can dispatch: window.dispatchEvent(new CustomEvent("states:updated", {detail:{tA,tB, A,B}}))
    window.addEventListener("states:updated", (ev)=>{
      const tA = ev.detail?.tA ?? nowMs();
      const tB = ev.detail?.tB ?? tA;
      injectPeriUI(tA, tB);
      // After DOM replacement, kick narrative explicitly
      setTimeout(()=>{ try { renderNarrativeFive(tA, tB); } catch(e){ console.warn('narrative render failed after states:updated', e);} }, 50);
    });

    // 4) Expose a handy API for the rest of the app (no-op if unused)
    window.HaloPeriRender = {
      renderPanel: (tA, tB) => injectPeriUI(tA, tB),
      stateAt: HaloPeri.stateAt,
      similarity: HaloPeri.similarityFeature
    };

    // --- NEW: tiny similarity add-on based on Mercury residual ---
    const W_PPN = 0.02; // gentle
    function tryRegisterPPNSim(){
      const hook = (A,B)=>{
        try{
          const tA = A?.ts ?? Date.now(), tB = B?.ts ?? tA;
          const obs = observedAdvance_arcsec(A?.peri||A, B?.peri||B, "mercury");
          const pred = predictAdvancePPN_arcsec(tA,tB,"mercury");
          const res  = obs - pred;
          const rate = toArcsecPerCentury(res, tA, tB);
          const s = 1 - Math.max(0, Math.min(1, Math.abs(rate)/1.0)); // 1‚Ä≥/century scale
          return s;
        }catch{return 0;}
      };
      if (typeof window.registerSimilarityFeature === "function") window.registerSimilarityFeature(hook, W_PPN, "ppnResidual");
      else if (window.Similarity?.use) window.Similarity.use((A,B)=>({ name:"ppnResidual", weight:W_PPN, score:hook(A,B)}));
    }

    // 5) First-pass init: attempt registration and initial render once DOM is ready
    function init(){
      tryRegisterSimilarity();
      tryRegisterPPNSim();
      injectPeriUI(); // best-effort render into Relative States if present
      // Optional: signal to the app that perihelion states are available
      window.dispatchEvent(new CustomEvent("perihelion:ready", { detail: { version: HaloPeri.version }}));
      // Kick async panels using the last known chronology (avoid relying on window.Selected here)
      setTimeout(()=>{
        try{
          const cp = (window.HaloPeri && window.HaloPeri.lastChrono) ? window.HaloPeri.lastChrono : null;
          if (cp && typeof cp.tA==='number' && typeof cp.tB==='number' && cp.tB >= cp.tA){
            renderSpanEvolution(cp.tA, cp.tB);
            renderAccumulators(cp.tA, cp.tB);
            renderTimeline(cp.tA, cp.tB);
          } else {
            // Last resort fallback to globals if provided by host app
            const a = window?.Selected?.A?.ts ?? window?.lastA?.ts ?? null;
            const b = window?.Selected?.B?.ts ?? window?.lastB?.ts ?? null;
            if (a && b){ const A = Math.min(a,b), B = Math.max(a,b);
              renderSpanEvolution(A,B); renderAccumulators(A,B); renderTimeline(A,B); }
          }
        }catch(e){ console.warn('perihelion async render failed:', e); }
      }, 60);
    }
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init, { once:true });
    } else {
      init();
    }

    // ============================================================
    // ZERO-GUARD: smarter number formatting for tiny non-zeros
    // ============================================================
    (function ZeroGuard(){
      // --- helpers ---
      const toFixedNoNegZero = (v, dp) => {
        let s = (+v).toFixed(dp);
        if (Math.abs(+s) === 0) s = (0).toFixed(dp);
        return s;
      };
      // seconds ‚Üí ms ‚Üí ¬µs if needed; keep sign
      function smartSec(x){
        if (x==null || !isFinite(x)) return 'n/a';
        const v = +x; const av = Math.abs(v);
        if (av >= 0.1)   return `${toFixedNoNegZero(v,1)} s`;
        if (av >= 1e-3)  return `${toFixedNoNegZero(v*1e3,2)} ms`;
        if (av >= 1e-6)  return `${toFixedNoNegZero(v*1e6,1)} ¬µs`;
        if (av > 0)      return `${v.toExponential(1)} s`;
        return `0.0 s`;
      }
      // milliseconds ‚Üí ¬µs if needed
      function smartMs(x){
        if (x==null || !isFinite(x)) return 'n/a';
        const v = +x, av=Math.abs(v);
        if (av >= 0.01)  return `${toFixedNoNegZero(v,2)} ms`;
        if (av >= 1e-3)  return `${toFixedNoNegZero(v*1e3,1)} ¬µs`;
        if (av > 0)      return `${v.toExponential(1)} ms`;
        return `0.00 ms`;
      }
      // percent ‚Üí basis points for tiny values; preserve sign
      function smartPct(x){
        if (x==null || !isFinite(x)) return 'n/a';
        const v=+x, av=Math.abs(v);
        if (av >= 0.1)     return `${toFixedNoNegZero(v,1)}%`;
        if (av >= 0.01)    return `${toFixedNoNegZero(v,2)}%`;
        if (av >= 0.001)   return `${toFixedNoNegZero(v*100,1)} bp`;
        if (av > 0)        return `${v.toExponential(1)}%`;
        return `0.0%`;
      }
      // ns/s tiny printer (don‚Äôt collapse to "‚âà0" unless truly zero)
      function smartNsPerS(x){
        if (x==null || !isFinite(x)) return 'n/a';
        const v=+x, av=Math.abs(v);
        if (av >= 0.1)   return `${toFixedNoNegZero(v,3)} ns/s`;
        if (av >= 1e-3)  return `${toFixedNoNegZero(v,6)} ns/s`;
        if (av > 0)      return `${v.toExponential(2)} ns/s`;
        return `0 ns/s`;
      }

      // --- monkey-patch global formatters if present ---
      try {
        if (typeof window.num === 'function') {
          const _num = window.num;
          window.num = function(x, dp=1, unit=''){
            const u = (unit||'').trim();
            if (u === 's')   return smartSec(x);
            if (u === ' ms') return smartMs(x); // in case callers pass leading space
            if (u === 'ms')  return smartMs(x);
            if (u === '%')   return smartPct(x);
            return _num.call(this, x, dp, unit);
          };
        }
      } catch {}
      try {
        if (typeof window.niceNsPerS === 'function') {
          window.niceNsPerS = smartNsPerS;
        }
      } catch {}

      // --- optional post-render smoother for the "Differences" text block ---
      function patchDiffText(diffs){
        const root = document.getElementById('diffText');
        if (!root || !diffs) return;
        // 1) Œî Light-time to Sun
        if (typeof diffs.dLightTime_s === 'number'){
          root.innerHTML = root.innerHTML.replace(/(Œî Light-time to Sun<\/span>\s*)[-+\d\.eE]+\s*s/,
            (_, pre) => pre + smartSec(diffs.dLightTime_s));
          root.innerHTML = root.innerHTML.replace(/Sun light-time changed\s*[-+\d\.eE]+\s*s/,
            () => `Sun light-time changed ${smartSec(diffs.dLightTime_s)}`);
        }
        // 2) Œî Solar contribution
        if (typeof diffs.dSolarPct === 'number'){
          root.innerHTML = root.innerHTML.replace(/(Œî Solar contribution<\/span>\s*)[-+\d\.eE]+%/,
            (_, pre) => pre + smartPct(diffs.dSolarPct));
          root.innerHTML = root.innerHTML.replace(/solar contribution\s*[-+\d\.eE]+%/,
            () => `solar contribution ${smartPct(diffs.dSolarPct)}`);
        }
        // 3) Œî Voxel fraction (unitless)
        if (typeof diffs.dVoxelFrac === 'number'){
          const v = diffs.dVoxelFrac;
          const s = (Math.abs(v) >= 1e-3) ? toFixedNoNegZero(v,3) : v.toExponential(2);
          root.innerHTML = root.innerHTML.replace(/(Œî Voxel fraction<\/span>\s*)[^\s<]+/, (_, pre)=> pre + s);
          root.innerHTML = root.innerHTML.replace(/we traversed\s*[^\s]+\s*of a light-second/,
            () => `we traversed ${s} of a light-second`);
        }
        // 4) Proper-time rates (ns/s)
        if (typeof diffs.dNs_grav === 'number'){
          const s = smartNsPerS(diffs.dNs_grav);
          root.innerHTML = root.innerHTML.replace(/(Œî Clock bias \(1 s\)<\/span>\s*)[^<]+/, (_, pre) => pre + s);
          root.innerHTML = root.innerHTML.replace(/1-s tidal time-bias changed\s*[^;.,<]+/,
            () => `1-s tidal time-bias changed ${s}`);
        }
        if (typeof diffs.dNs_kin === 'number'){
          const s = smartNsPerS(diffs.dNs_kin);
          root.innerHTML = root.innerHTML.replace(/(Œî Kinematic rate \(1 s\)<\/span>\s*)[^<]+/, (_, pre) => pre + s);
        }
        if (typeof diffs.dNs_comb === 'number'){
          const s = smartNsPerS(diffs.dNs_comb);
          root.innerHTML = root.innerHTML.replace(/(Œî Combined rate \(1 s\)<\/span>\s*)[^<]+/, (_, pre) => pre + s);
        }
        // 5) Light-time along Earth
        if (typeof diffs.dLightAlong_ms === 'number' && Math.abs(diffs.dLightAlong_ms) > 0){
          root.innerHTML = root.innerHTML.replace(/(Light-time along Earth<\/span>\s*Œî\s*)0\.00\s*ms/,
            (_, pre) => pre + smartMs(diffs.dLightAlong_ms));
        }
      }

      function onStates(ev){
        const d = (ev && ev.detail && ev.detail.diffs) || window.lastDiffs || null;
        try { patchDiffText(d); } catch {}
      }
      window.addEventListener('states:updated', onStates);
      setTimeout(()=>{ try { patchDiffText(window.lastDiffs||null); } catch {} }, 100);
    })();
  })();
  </script>
  <!-- ======================== -->
  <!-- GR Perihelion module END -->
  <!-- ======================== -->

  <script>
  (function(){
    const TAU = Math.PI * 2;
    const SIDEREAL_DAY_S = 86164.0905;
    const SOLAR_DAY_S = 86400;
    const EASE_ALPHA = 0.12;
    const DEG2RAD = Math.PI / 180;
    const DEFAULT_FILTERS = { day: true, season: true, lunar: true };
    const DEFAULT_SITE = { lat: 34.05, lon: -118.25 };
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const mod1 = value => ((value % 1) + 1) % 1;
    const root = document.documentElement;
    const headerEl = document.querySelector('header');
    const sceneEl = document.getElementById('scene');

    function safeNumber(value, fallback) {
      const n = Number(value);
      return Number.isFinite(n) ? n : fallback;
    }

    function pickSite() {
      const explicit = window.__site;
      if (explicit && Number.isFinite(explicit.lat) && Number.isFinite(explicit.lon)) {
        return { lat: explicit.lat, lon: explicit.lon };
      }
      const storeSite = window.store && window.store.defaultSite;
      if (storeSite && Number.isFinite(storeSite.lat) && Number.isFinite(storeSite.lon)) {
        return { lat: storeSite.lat, lon: storeSite.lon };
      }
      return { lat: DEFAULT_SITE.lat, lon: DEFAULT_SITE.lon };
    }

    function solarLongitudeDeg(ts) {
      const date = new Date(ts);
      const yearStart = Date.UTC(date.getUTCFullYear(), 0, 0);
      const n = (ts - yearStart) / 86400000;
      const L = (280.46 + 0.9856474 * n) % 360;
      const g = (357.528 + 0.9856003 * n) % 360;
      const lambda = L + 1.915 * Math.sin(g * DEG2RAD) + 0.020 * Math.sin(2 * g * DEG2RAD);
      return (lambda % 360 + 360) % 360;
    }

    function solarDeclinationDeg(ts) {
      const lonDeg = solarLongitudeDeg(ts);
      const date = new Date(ts);
      const yearStart = Date.UTC(date.getUTCFullYear(), 0, 0);
      const n = (ts - yearStart) / 86400000;
      const epsilon = 23.439 - 0.0000004 * n;
      const delta = Math.asin(Math.sin(epsilon * DEG2RAD) * Math.sin(lonDeg * DEG2RAD));
      return delta * (180 / Math.PI);
    }

    function seasonFraction(ts) {
      return mod1(solarLongitudeDeg(ts) / 360);
    }

    function orbitPhase(ts) {
      try {
        const yearMap = window.yearElements;
        if (yearMap && typeof yearMap.get === 'function') {
          const year = new Date(ts).getUTCFullYear();
          const el = yearMap.get(year);
          if (el && Number.isFinite(el.a) && Number.isFinite(el.epochJD)) {
            const mu = safeNumber(window.HORIZONS && window.HORIZONS.muSun_AU3_per_d2, 0.00029591220828559104);
            const jd = ts / 86400000 + 2440587.5;
            const meanMotion = Math.sqrt(mu / Math.pow(el.a || 1, 3));
            const meanAnomaly = safeNumber(el.M, 0) + meanMotion * (jd - el.epochJD);
            return mod1(meanAnomaly / TAU);
          }
        }
      } catch (err) {
        console.warn('ColorDirector orbitPhase fallback', err);
      }
      if (typeof heliocentricLongitude === 'function') {
        return mod1(heliocentricLongitude(ts) / TAU);
      }
      if (typeof perihelionApprox === 'object' && perihelionApprox && typeof perihelionApprox.getTime === 'function') {
        const yearMs = 365.25 * 86400000;
        return mod1((ts - perihelionApprox.getTime()) / yearMs);
      }
      return mod1(ts / (365.25 * 86400000));
    }

    function rotationPhase(ts, lonDeg) {
      const lonOffset = (lonDeg || 0) / 360 * SIDEREAL_DAY_S;
      const seconds = ts / 1000;
      return mod1((seconds + lonOffset) / SIDEREAL_DAY_S);
    }

    function localDayFraction(ts, lonDeg) {
      const lonOffset = (lonDeg || 0) / 360 * SOLAR_DAY_S;
      const seconds = ts / 1000;
      return mod1((seconds + lonOffset) / SOLAR_DAY_S);
    }

    function lunarPhaseFraction(ts, latDeg, lonDeg) {
      try {
        if (typeof moonContext === 'function') {
          const ctx = moonContext(ts, latDeg, lonDeg);
          if (ctx && typeof ctx.phasePct === 'number') {
            return clamp(ctx.phasePct / 100, 0, 1);
          }
        }
      } catch (err) {
        console.warn('ColorDirector lunarPhase fallback', err);
      }
      return 0.5;
    }

    const OrbitColor = window.THREE && window.THREE.Color ? window.THREE.Color : null;
    const orbitTmpColor = OrbitColor ? new OrbitColor() : null;

    function computeShading(state) {
      const rotationHue = 12 * Math.sin(TAU * mod1(state.rotation));
      const seasonWave = Math.sin(Math.PI * mod1(state.season));
      const lunarPulse = 0.5 - Math.abs(0.5 - mod1(state.lunar));
      const distanceNudge = clamp((1 - state.rAu) * 18, -3, 3);
      const saturation = clamp(55 + 20 * seasonWave, 35, 85);
      const lightness = clamp(12 + 10 * lunarPulse + distanceNudge, 8, 40);
      return { rotationHue, seasonWave, lunarPulse, distanceNudge, saturation, lightness };
    }

    function updateOrbitGradients(state, shading) {
      if (!orbitTmpColor) return;
      const lines = window.__orbitGradientLines;
      if (!lines || !lines.size) return;
      const rotationHue = shading?.rotationHue ?? 0;
      const saturation = shading?.saturation ?? 55;
      const lightness = shading?.lightness ?? 24;
      const lineSaturation = clamp(saturation + 14, 42, 96);
      const lineLightness = clamp(lightness + 24, 24, 74);
      lines.forEach(line => {
        const fractions = line?.userData?.orbitFractions;
        const colorAttr = line?.geometry?.getAttribute && line.geometry.getAttribute('color');
        if (!fractions || !colorAttr) return;
        const arr = colorAttr.array;
        const count = colorAttr.count;
        const divisor = Math.max(1, count - 1);
        for (let i = 0; i < count; i++) {
          const frac = fractions[i] ?? (i / divisor);
          let hue = (360 * mod1(frac) + rotationHue) % 360;
          if (hue < 0) hue += 360;
          orbitTmpColor.setHSL(hue / 360, lineSaturation / 100, lineLightness / 100);
          const idx = i * 3;
          arr[idx] = orbitTmpColor.r;
          arr[idx + 1] = orbitTmpColor.g;
          arr[idx + 2] = orbitTmpColor.b;
        }
        colorAttr.needsUpdate = true;
        if (line.material && !line.material.vertexColors) {
          line.material.vertexColors = true;
          line.material.needsUpdate = true;
        }
      });
    }

    class ColorDirectorImpl {
      constructor() {
        const now = Date.now();
        this.filters = { ...DEFAULT_FILTERS };
        this.site = pickSite();
        this.targets = {
          orbit: orbitPhase(now),
          rotation: 0.5,
          season: 0.5,
          lunar: 0.5,
          rAu: 1,
          decSun: 0,
          localDay: 0.5
        };
        this.smoothed = { ...this.targets };
        this.filtered = { ...this.targets };
        this.intervals = [];
        this.running = false;
        this.onFiltersChanged = null;
        this.sampleSlow(now);
        this.sampleMid(now);
        this.sampleFast(now);
        this.smoothed = { ...this.targets };
        this.filtered = { ...this.targets };
      }

      start() {
        if (this.running) return;
        this.running = true;
        this.site = pickSite();
        const now = Date.now();
        this.sampleSlow(now);
        this.sampleMid(now);
        this.sampleFast(now);
        this.smoothed = { ...this.targets };
        this.filtered = { ...this.targets };
        this.applyColors(this.filtered);
        this.intervals.push(setInterval(() => this.sampleSlow(), 120000));
        this.intervals.push(setInterval(() => this.sampleMid(), 60000));
        this.intervals.push(setInterval(() => this.sampleFast(), 300));
      }

      stop() {
        this.running = false;
        while (this.intervals.length) {
          clearInterval(this.intervals.pop());
        }
      }

      setSite(site) {
        if (!site) return;
        const next = { ...this.site };
        if (Number.isFinite(site.lat)) next.lat = site.lat;
        if (Number.isFinite(site.lon)) next.lon = site.lon;
        this.site = next;
        window.__site = { ...next };
        this.sampleSlow();
        this.sampleMid();
        this.sampleFast();
      }

      setFilters(partial) {
        if (!partial) return { ...this.filters };
        const next = { ...this.filters };
        if (typeof partial.day === 'boolean') next.day = partial.day;
        if (typeof partial.season === 'boolean') next.season = partial.season;
        if (typeof partial.lunar === 'boolean') next.lunar = partial.lunar;
        this.filters = next;
        if (typeof this.onFiltersChanged === 'function') {
          try {
            this.onFiltersChanged({ ...this.filters });
          } catch (err) {
            console.warn(err);
          }
        }
        return { ...this.filters };
      }

      getFilters() {
        return { ...this.filters };
      }

      sampleSlow(ts = Date.now()) {
        this.targets.orbit = orbitPhase(ts);
        this.targets.rAu = safeNumber(earthSunDistance(ts), 1);
        this.targets.decSun = safeNumber(solarDeclinationDeg(ts), 0);
      }

      sampleMid(ts = Date.now()) {
        this.targets.season = seasonFraction(ts);
        const loc = this.site || DEFAULT_SITE;
        this.targets.lunar = lunarPhaseFraction(ts, loc.lat || 0, loc.lon || 0);
      }

      sampleFast(ts = Date.now()) {
        const loc = this.site || DEFAULT_SITE;
        const lat = Number.isFinite(loc.lat) ? loc.lat : DEFAULT_SITE.lat;
        const lon = Number.isFinite(loc.lon) ? loc.lon : DEFAULT_SITE.lon;
        this.targets.rotation = rotationPhase(ts, lon);
        this.targets.localDay = localDayFraction(ts, lon);
        this.site = { lat, lon };
      }

      tick(now = performance.now()) {
        if (!this.running) return;
        const alpha = EASE_ALPHA;
        const target = this.targets;
        const sm = this.smoothed;
        sm.orbit += alpha * (target.orbit - sm.orbit);
        sm.rotation += alpha * (target.rotation - sm.rotation);
        sm.season += alpha * (target.season - sm.season);
        sm.lunar += alpha * (target.lunar - sm.lunar);
        sm.rAu += alpha * (target.rAu - sm.rAu);
        sm.decSun += alpha * (target.decSun - sm.decSun);
        sm.localDay += alpha * (target.localDay - sm.localDay);

        this.filtered.orbit = sm.orbit;
        this.filtered.rotation = this.filters.day ? sm.rotation : 0.5;
        this.filtered.season = this.filters.season ? sm.season : 0.5;
        this.filtered.lunar = this.filters.lunar ? sm.lunar : 0.5;
        this.filtered.rAu = sm.rAu;
        this.filtered.decSun = sm.decSun;
        this.filtered.localDay = this.filters.day ? sm.localDay : 0.5;

        this.applyColors(this.filtered);
      }

      applyColors(state) {
        const shading = computeShading(state);
        const { rotationHue, saturation, lightness } = shading;
        const baseHue = (360 * mod1(state.orbit)) % 360;
        let hue = baseHue + rotationHue;
        if (hue < 0) hue += 360;
        hue = hue % 360;

        const topHue = (hue + 8) % 360;
        const topSaturation = clamp(saturation + 6, 35, 92);
        const topLightness = clamp(lightness + 6, 8, 55);

        const angleDeg = (360 * mod1(state.localDay)) % 360;
        const focusY = clamp(-8 * (state.decSun / 23.44), -8, 8);

        const bg = `hsl(${hue.toFixed(2)} ${saturation.toFixed(1)}% ${lightness.toFixed(1)}%)`;
        const bgTop = `hsl(${topHue.toFixed(2)} ${topSaturation.toFixed(1)}% ${topLightness.toFixed(1)}%)`;

        root.style.setProperty('--bg', bg);
        root.style.setProperty('--bg-top', bgTop);
        root.style.setProperty('--bg-angle', `${angleDeg.toFixed(2)}deg`);
        root.style.setProperty('--bg-focus-y', `${focusY.toFixed(2)}%`);

        if (headerEl) {
          headerEl.style.background = 'linear-gradient(var(--bg-angle), var(--bg-top) 0%, var(--bg) 100%)';
        }
        if (sceneEl) {
          sceneEl.style.background = 'radial-gradient(1200px 600px at 50% calc(-200px + var(--bg-focus-y)), color-mix(in oklab, var(--bg-top) 60%, transparent), var(--bg) 60%)';
        }
        document.body.style.background = 'var(--bg)';

        updateOrbitGradients(state, shading);
      }
    }

    const director = new ColorDirectorImpl();
    window.ColorDirector = director;

    window.__updateOrbitGradientColors = (stateOverride) => {
      const source = stateOverride || director.filtered || director.targets || director.smoothed;
      updateOrbitGradients(source, computeShading(source));
    };
    window.__updateOrbitGradientColors();

    const filterButtons = [
      { id: 'btnFilterDay', key: 'day' },
      { id: 'btnFilterSeason', key: 'season' },
      { id: 'btnFilterLunar', key: 'lunar' }
    ];

    function updateFilterVisual(btn, isOn) {
      if (!btn) return;
      if (typeof setActive === 'function' && btn.id) {
        setActive(btn.id, isOn);
      } else {
        btn.classList.toggle('active', isOn);
      }
      btn.style.opacity = isOn ? '' : '0.6';
      btn.setAttribute('aria-pressed', String(isOn));
    }

    director.onFiltersChanged = (filters) => {
      filterButtons.forEach(({ id, key }) => {
        const btn = document.getElementById(id);
        if (!btn) return;
        const state = filters[key] !== false;
        updateFilterVisual(btn, state);
      });
    };

    filterButtons.forEach(({ id, key }) => {
      const btn = document.getElementById(id);
      if (!btn) return;
      btn.addEventListener('click', () => {
        const current = director.filters[key] !== false;
        director.setFilters({ [key]: !current });
      });
    });

    director.onFiltersChanged(director.getFilters());
    window.ColorDirector?.start?.();
  })();
  </script>

  <style>
    dialog.upload {
      border: none;
      padding: 0;
      background: #101729;
      color: var(--ink, #e8eefc);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(8, 12, 24, 0.6);
      min-width: min(90vw, 820px);
      max-width: 880px;
      position: relative;
    }
    dialog.upload::backdrop {
      background: rgba(4, 8, 16, 0.72);
      backdrop-filter: blur(4px);
    }
    .upload .u-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px 12px;
      border-bottom: 1px solid rgba(35, 51, 95, 0.65);
    }
    .upload .u-head h2 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.04em;
    }
    .upload .u-body {
      display: flex;
      gap: 18px;
      padding: 18px 20px;
      flex-wrap: wrap;
    }
    .upload .u-prev {
      flex: 1 1 280px;
      background: #0d1425;
      border: 1px solid rgba(33, 49, 86, 0.8);
      border-radius: 14px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .upload .u-prev-frame {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      background: #0b101d;
      border: 1px dashed rgba(73, 102, 170, 0.45);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .upload .u-prev-frame img,
    .upload .u-prev-frame video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
    }
    .upload .u-prev-frame video {
      background: #000;
    }
    .upload .u-prev-hint {
      text-align: center;
      color: var(--muted, #97a3c0);
      font-size: 13px;
      padding: 12px;
    }
    .upload .u-prev-meta {
      font-size: 12px;
      color: var(--muted, #97a3c0);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .upload .u-fields {
      flex: 1 1 320px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px 16px;
    }
    .upload .u-fields .wide {
      grid-column: 1 / -1;
    }
    .upload label.u-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: var(--muted, #97a3c0);
    }
    .upload input.u-input,
    .upload textarea.u-input {
      background: #111a2c;
      border: 1px solid rgba(35, 51, 95, 0.85);
      color: var(--ink, #e8eefc);
      border-radius: 9px;
      font: inherit;
      padding: 7px 10px;
      resize: vertical;
      min-height: 34px;
    }
    .upload input.u-input[readonly] {
      color: rgba(190, 203, 235, 0.85);
      cursor: default;
    }
    .upload textarea.u-input {
      min-height: 64px;
    }
    .upload .u-tags {
      position: relative;
    }
    .upload .u-suggest,
    .hb-search .u-suggest {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #0f162b;
      border: 1px solid rgba(47, 70, 122, 0.85);
      border-radius: 10px;
      margin-top: 6px;
      padding: 4px;
      max-height: 170px;
      overflow-y: auto;
      display: none;
      z-index: 10;
      box-shadow: 0 10px 40px rgba(4, 10, 24, 0.5);
    }
    .upload .u-suggest.visible,
    .hb-search .u-suggest.visible {
      display: block;
    }
    .upload .u-suggest button,
    .hb-search .u-suggest button {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      background: transparent;
      border: none;
      color: var(--ink, #e8eefc);
      padding: 6px 8px;
      border-radius: 8px;
      cursor: pointer;
      font: inherit;
    }
    .upload .u-suggest button:hover,
    .hb-search .u-suggest button:hover {
      background: rgba(58, 82, 138, 0.3);
    }
    .upload .u-chips {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .upload .u-chip {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(60, 90, 148, 0.7);
      background: rgba(28, 44, 74, 0.75);
      font-size: 12px;
    }
    .upload .u-foot {
      padding: 0 20px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .upload .u-foot .u-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .btn-s {
      background: #141b31;
      border: 1px solid rgba(45, 68, 124, 0.9);
      color: var(--ink, #e8eefc);
      border-radius: 10px;
      padding: 7px 14px;
      cursor: pointer;
      font: inherit;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .btn-s:hover {
      border-color: rgba(91, 134, 208, 0.9);
    }
    .hb-search {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .hb-search input {
      background: #0f162b;
      border: 1px solid rgba(45, 68, 124, 0.8);
      color: var(--ink, #e8eefc);
      border-radius: 10px;
      padding: 7px 12px;
      min-width: 180px;
      font: inherit;
    }
    .btn-s.primary {
      background: linear-gradient(120deg, #78d7f4, #8d9bff);
      border-color: rgba(136, 176, 255, 0.9);
      color: #041226;
      font-weight: 600;
    }
    .btn-s.ghost {
      background: transparent;
      border-color: rgba(58, 82, 138, 0.5);
    }
    .upload .u-loading {
      position: absolute;
      inset: 0;
      background: rgba(9, 13, 24, 0.78);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--ink, #e8eefc);
      font-size: 15px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border-radius: 16px;
      backdrop-filter: blur(3px);
      display: none;
    }
    .upload .u-loading.show {
      display: flex;
    }
    @media (max-width: 780px) {
      dialog.upload {
        min-width: 92vw;
      }
      .upload .u-body {
        flex-direction: column;
      }
      .upload .u-fields {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
    }
  </style>

  <dialog id="uploadDialog" class="upload">
    <div class="u-head">
      <h2>New Memory</h2>
      <button type="button" class="btn-s ghost" id="uClose">Close</button>
    </div>
    <div class="u-body">
      <section class="u-prev">
        <div class="u-prev-frame">
          <img id="uImg" alt="Memory preview">
          <video id="uVid" controls></video>
          <div class="u-prev-hint" id="uPrevHint">Choose an image or video to begin.</div>
        </div>
        <div class="u-prev-meta">
          <span id="uPrevName">No file selected</span>
          <button type="button" class="btn-s ghost" id="uPick">Choose file‚Ä¶</button>
        </div>
      </section>
      <section class="u-fields">
        <label class="u-field wide">
          Title
          <input id="uTitle" class="u-input" type="text" placeholder="Memory title">
        </label>
        <label class="u-field">
          Captured
          <input id="uWhen" class="u-input" type="text" readonly>
        </label>
        <label class="u-field">
          Time Zone
          <input id="uTZ" class="u-input" type="text" placeholder="e.g. America/Los_Angeles">
        </label>
        <label class="u-field">
          Latitude
          <input id="uLat" class="u-input" type="number" step="0.000001" placeholder="34.052235">
        </label>
        <label class="u-field">
          Longitude
          <input id="uLon" class="u-input" type="number" step="0.000001" placeholder="-118.243683">
        </label>
        <label class="u-field wide u-tags">
          Hashtags
          <textarea id="uTags" class="u-input" rows="2" placeholder="#memory #sunrise"></textarea>
          <div class="u-suggest" id="uSuggest"></div>
          <div class="u-chips" id="uChips"></div>
        </label>
      </section>
    </div>
    <div class="u-foot">
      <div class="u-actions">
        <button type="button" class="btn-s ghost" id="uReset">Reset</button>
      </div>
      <div class="u-actions">
        <button type="button" class="btn-s ghost" id="uCancel">Close</button>
        <button type="button" class="btn-s primary" id="uSave">Submit upload</button>
      </div>
    </div>
    <div class="u-loading" id="uLoad">Processing...</div>
  </dialog>

  <script>
  (function () {
    'use strict';

    const STORAGE_KEY = 'hb_memories_v1';
    const TAG_KEY = 'hb_tag_counts_v1';
    const YEAR_MS = 365.256 * 24 * 3600 * 1000;
    const TAU = Math.PI * 2;

    const doc = document;
    const header = doc.querySelector('header');
    const elFile = doc.getElementById('file');
    const btnUpload = doc.getElementById('btnUpload');
    const dialog = doc.getElementById('uploadDialog');
    if (!header || !dialog) return;

    const refs = {
      dialog,
      load: doc.getElementById('uLoad'),
      pick: doc.getElementById('uPick'),
      close: doc.getElementById('uClose'),
      cancel: doc.getElementById('uCancel'),
      reset: doc.getElementById('uReset'),
      save: doc.getElementById('uSave'),
      img: doc.getElementById('uImg'),
      vid: doc.getElementById('uVid'),
      hint: doc.getElementById('uPrevHint'),
      prevName: doc.getElementById('uPrevName'),
      title: doc.getElementById('uTitle'),
      when: doc.getElementById('uWhen'),
      tz: doc.getElementById('uTZ'),
      lat: doc.getElementById('uLat'),
      lon: doc.getElementById('uLon'),
      tags: doc.getElementById('uTags'),
      suggest: doc.getElementById('uSuggest'),
      chips: doc.getElementById('uChips'),
      list: doc.getElementById('fileList')
    };

    const state = {
      previewURL: '',
      revokeOnReset: true,
      ts: Date.now(),
      tz: tzGuess(),
      lat: null,
      lon: null,
      file: null,
      mime: ''
    };

    let memories = [];
    let tagCounts = {};
    let searchInput = null;
    let searchSuggest = null;
    let filterTag = '';

    const memoryMap = new Map();
    const recordMap = new Map();
    const markerMap = new Map();

    const markerGroup = { group: null, retry: null, warned: false };

    const makeLabel = typeof window.makeLabelSprite === 'function' ? window.makeLabelSprite : null;
    const THREERef = window.THREE;

    const heliocentricLon = typeof window.heliocentricLongitude === 'function'
      ? window.heliocentricLongitude
      : (ts) => TAU * (((ts % YEAR_MS) + YEAR_MS) % YEAR_MS) / YEAR_MS;
    const earthDistance = typeof window.earthSunDistance === 'function'
      ? window.earthSunDistance
      : () => 1;

    const legacyRenderList = typeof window.renderList === 'function' ? window.renderList.bind(window) : null;
    window.renderList = renderList;

    if (btnUpload) {
      btnUpload.onclick = (ev) => {
        ev.preventDefault();
        openDialog();
      };
    }

    if (elFile) {
      elFile.addEventListener('change', onFilePickedCapture, true);
    }

    attachDialogEvents();
    initSearchBar();
    ensureMarkerGroup();

    document.addEventListener('click', handleGlobalClick, true);

    loadStorage().then(() => {
      renderList();
      applyFilter(filterTag, { skipInput: true });
    });

    function getStore() {
      try {
        return typeof store !== 'undefined' ? store : window.store;
      } catch (err) {
        return window.store;
      }
    }

    async function loadStorage() {
      tagCounts = loadTagCounts();
      const raw = safeJson(localStorage.getItem(STORAGE_KEY));
      memories = [];
      memoryMap.clear();
      recordMap.clear();

      if (Array.isArray(raw)) {
        for (const item of raw) {
          const mem = normalizeMemory(item);
          if (mem && mem.id) {
            memories.push(mem);
            memoryMap.set(mem.id, mem);
          }
        }
      }

      memories.sort((a, b) => (b.ts || 0) - (a.ts || 0));
      tagCounts = recomputeTagCounts(memories);
      saveTagCounts();

      for (const mem of memories) {
        await ensureStoreRecord(mem);
        addMemoryMarker(mem);
      }
    }

    function attachDialogEvents() {
      dialog.addEventListener('cancel', (ev) => {
        ev.preventDefault();
        closeDialog();
      });
      if (refs.pick) {
        refs.pick.addEventListener('click', () => {
          if (elFile) elFile.click();
        });
      }
      if (refs.close) refs.close.addEventListener('click', closeDialog);
      if (refs.cancel) refs.cancel.addEventListener('click', closeDialog);
      if (refs.reset) refs.reset.addEventListener('click', resetForm);
      if (refs.save) refs.save.addEventListener('click', onSubmit);
      if (refs.tags) {
        refs.tags.addEventListener('input', () => {
          updateChips(parseHashtags(refs.tags.value));
          updateTagSuggestions(refs.tags, refs.suggest);
        });
        refs.tags.addEventListener('focus', () => updateTagSuggestions(refs.tags, refs.suggest));
        refs.tags.addEventListener('blur', () => hideSuggestions(refs.suggest));
        refs.tags.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter' && !ev.shiftKey) {
            ev.preventDefault();
            onSubmit();
          }
        });
      }
      if (refs.tz) {
        refs.tz.addEventListener('blur', () => {
          const tz = sanitizeTZ(refs.tz.value) || tzGuess();
          state.tz = tz;
          refs.tz.value = tz;
          refs.when.value = toLocalISO(state.ts, tz);
        });
      }
      if (refs.list) {
        refs.list.addEventListener('click', (ev) => {
          const chip = ev.target.closest('.chip[data-tag]');
          if (chip) {
            ev.stopPropagation();
            const tag = chip.dataset.tag;
            if (tag) {
              setSearchValue(tag);
              applyFilter(tag);
            }
            return;
          }
          const item = ev.target.closest('.item[data-id]');
          if (item && typeof window.toggleSelect === 'function') {
            window.toggleSelect(item.dataset.id);
          }
        });
      }
    }

    function initSearchBar() {
      if (!header || doc.getElementById('hbSearch')) return;
      const wrap = doc.createElement('div');
      wrap.className = 'pill hb-search';

      const label = doc.createElement('label');
      label.setAttribute('for', 'hbSearch');
      label.textContent = 'Search';
      wrap.appendChild(label);

      const input = doc.createElement('input');
      input.type = 'search';
      input.id = 'hbSearch';
      input.placeholder = 'Filter #tag';
      wrap.appendChild(input);

      const suggest = doc.createElement('div');
      suggest.className = 'u-suggest';
      wrap.appendChild(suggest);

      header.appendChild(wrap);

      searchInput = input;
      searchSuggest = suggest;

      input.addEventListener('input', onSearchInput);
      input.addEventListener('focus', onSearchInput);
      input.addEventListener('blur', () => hideSuggestions(searchSuggest));
      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape') {
          input.value = '';
          hideSuggestions(searchSuggest);
          applyFilter('', { skipInput: true });
        }
        if (ev.key === 'Enter') {
          ev.preventDefault();
          const tags = parseHashtags(input.value);
          const tag = tags[0] || '';
          applyFilter(tag, { skipInput: true });
          hideSuggestions(searchSuggest);
        }
      });
    }

    function onSearchInput() {
      if (!searchInput) return;
      const caret = searchInput.selectionStart ?? searchInput.value.length;
      const tokenInfo = findActiveToken(searchInput.value, caret);
      if (tokenInfo) {
        const list = getTagSuggestions(tokenInfo.token.toLowerCase());
        renderSuggestions(searchSuggest, list, (tag) => {
          insertTagSuggestion(searchInput, tokenInfo, tag, false);
          applyFilter(tag, { skipInput: true });
        });
      } else {
        hideSuggestions(searchSuggest);
        const tags = parseHashtags(searchInput.value);
        applyFilter(tags[0] || '', { skipInput: true });
      }
    }

    function handleGlobalClick(ev) {
      if (refs.suggest && !refs.suggest.contains(ev.target) && ev.target !== refs.tags) {
        hideSuggestions(refs.suggest);
      }
      if (searchSuggest && !searchSuggest.contains(ev.target) && ev.target !== searchInput) {
        hideSuggestions(searchSuggest);
      }
    }

    function onFilePickedCapture(ev) {
      ev.preventDefault();
      ev.stopImmediatePropagation();
      const input = ev.target;
      const files = Array.from(input.files || []);
      if (!files.length) return;
      const file = files[0];
      if (!dialog.open) openDialog();
      showPreviewAndEXIF(file);
      input.value = '';
    }

    function openDialog() {
      resetForm();
      try {
        dialog.showModal();
      } catch (err) {
        dialog.show();
      }
    }

    function closeDialog() {
      hideSuggestions(refs.suggest);
      try {
        dialog.close();
      } catch (err) {
        dialog.open = false;
      }
      resetForm();
    }

    function resetForm() {
      if (state.previewURL && state.revokeOnReset) {
        try { URL.revokeObjectURL(state.previewURL); } catch (err) { /* ignore */ }
      }
      state.previewURL = '';
      state.revokeOnReset = true;
      state.file = null;
      state.mime = '';
      state.ts = Date.now();
      state.tz = tzGuess();
      state.lat = null;
      state.lon = null;

      if (refs.img) {
        refs.img.removeAttribute('src');
        refs.img.style.display = 'none';
      }
      if (refs.vid) {
        refs.vid.removeAttribute('src');
        refs.vid.load();
        refs.vid.style.display = 'none';
      }
      if (refs.hint) refs.hint.style.display = 'block';
      if (refs.prevName) refs.prevName.textContent = 'No file selected';
      if (refs.title) refs.title.value = '';
      if (refs.when) refs.when.value = toLocalISO(state.ts, state.tz);
      if (refs.tz) refs.tz.value = state.tz;
      if (refs.lat) refs.lat.value = '';
      if (refs.lon) refs.lon.value = '';
      if (refs.tags) refs.tags.value = '';
      if (refs.chips) refs.chips.innerHTML = '';
      hideSuggestions(refs.suggest);
    }

    async function showPreviewAndEXIF(file) {
      state.file = file;
      state.mime = file.type || '';
      setLoading(true);
      try {
        const url = URL.createObjectURL(file);
        if (state.previewURL && state.revokeOnReset) {
          try { URL.revokeObjectURL(state.previewURL); } catch (err) { /* ignore */ }
        }
        state.previewURL = url;
        state.revokeOnReset = true;
        if (refs.prevName) refs.prevName.textContent = file.name;
        if (refs.title && !refs.title.value) refs.title.value = defaultTitle(file.name);
        updatePreviewMedia(url, file.type);

        const meta = await extractMetadata(file);
        state.ts = meta.ts;
        state.tz = meta.tz;
        state.lat = meta.lat;
        state.lon = meta.lon;

        if (refs.when) refs.when.value = toLocalISO(state.ts, state.tz);
        if (refs.tz) refs.tz.value = state.tz;
        if (refs.lat) refs.lat.value = meta.lat != null ? meta.lat.toFixed(6) : '';
        if (refs.lon) refs.lon.value = meta.lon != null ? meta.lon.toFixed(6) : '';
      } finally {
        setLoading(false);
      }
    }

    async function extractMetadata(file) {
      let ts = file.lastModified || Date.now();
      let tz = tzGuess();
      let lat = null;
      let lon = null;

      if (file.type && file.type.startsWith('image/') && window.exifr?.parse) {
        try {
          const exif = await window.exifr.parse(file, { tiff: true, ifd0: true, exif: true, gps: true });
          if (exif) {
            const dateCandidate = exif.DateTimeOriginal || exif.CreateDate || exif.ModifyDate;
            const offset = exif.OffsetTimeOriginal || exif.OffsetTime;
            const parsed = parseExifDate(dateCandidate, offset);
            if (parsed) ts = parsed;
            const tzCandidate = exif.TimeZoneName || exif.TimeZone || exif.Timezone;
            tz = sanitizeTZ(tzCandidate) || tzGuess();
            if (Number.isFinite(exif.latitude)) lat = roundCoord(exif.latitude);
            if (Number.isFinite(exif.longitude)) lon = roundCoord(exif.longitude);
          }
        } catch (err) {
          console.warn('EXIF parse failed', err);
        }
      }
      return { ts, tz, lat, lon };
    }

    function updatePreviewMedia(url, mime) {
      const isVideo = mime ? mime.startsWith('video/') : false;
      if (refs.hint) refs.hint.style.display = 'none';
      if (isVideo) {
        if (refs.img) {
          refs.img.removeAttribute('src');
          refs.img.style.display = 'none';
        }
        if (refs.vid) {
          refs.vid.src = url;
          refs.vid.style.display = 'block';
          refs.vid.load();
        }
      } else {
        if (refs.img) {
          refs.img.src = url;
          refs.img.style.display = 'block';
        }
        if (refs.vid) {
          refs.vid.removeAttribute('src');
          refs.vid.style.display = 'none';
          refs.vid.load();
        }
      }
    }

    async function onSubmit() {
      if (!state.file || !state.previewURL) {
        alert('Choose a file before submitting.');
        return;
      }
      const title = (refs.title?.value || '').trim() || defaultTitle(state.file.name);
      const tz = sanitizeTZ(refs.tz?.value) || state.tz || tzGuess();
      const tags = parseHashtags(refs.tags?.value || '');
      if (!tags.length) {
        alert('Add at least one hashtag.');
        return;
      }
      const latVal = parseFloat(refs.lat?.value);
      const lonVal = parseFloat(refs.lon?.value);
      const lat = Number.isFinite(latVal) ? roundCoord(latVal) : null;
      const lon = Number.isFinite(lonVal) ? roundCoord(lonVal) : null;

      const memory = {
        id: typeof window.uid === 'function' ? window.uid() : `mem_${Date.now()}`,
        name: title,
        ts: state.ts || Date.now(),
        tz,
        lat,
        lon,
        tags,
        fileURL: state.previewURL,
        mime: state.mime
      };

      state.revokeOnReset = false;

      memoryMap.set(memory.id, memory);
      memories = [memory, ...memories.filter((m) => m.id !== memory.id)];
      tagCounts = recomputeTagCounts(memories);
      saveMemories();
      saveTagCounts();

      try {
        await ensureStoreRecord(memory);
        addMemoryMarker(memory);
        if (typeof window.ensureYearHalo === 'function') {
          const record = recordMap.get(memory.id);
          if (record?.year) {
            window.ensureYearHalo(record.year).catch(() => {});
          }
        }
        if (typeof window.warmYears === 'function') {
          window.warmYears();
        }
      } catch (err) {
        console.warn('Memory hydration failed', err);
      }

      renderList();
      applyFilter(filterTag, { skipInput: true });
      closeDialog();
    }

    function ensureMarkerGroup() {
      if (markerGroup.group && markerGroup.group.parent) return markerGroup.group;
      const hasSceneAdd = Boolean(window.scene && typeof window.scene.add === 'function');
      if (THREERef && hasSceneAdd) {
        markerGroup.group = new THREERef.Group();
        markerGroup.group.name = 'memMarkers';
        window.scene.add(markerGroup.group);
        markerGroup.warned = false;
        return markerGroup.group;
      }
      if (window.scene && !hasSceneAdd && !markerGroup.warned) {
        markerGroup.warned = true;
        console.warn('[halobank] window.scene is present but does not expose an add() method. Skipping marker attachment.');
      }
      if (!markerGroup.retry) {
        markerGroup.retry = setInterval(() => {
          if (THREERef && window.scene && typeof window.scene.add === 'function') {
            clearInterval(markerGroup.retry);
            markerGroup.retry = null;
            ensureMarkerGroup();
            markerMap.forEach((entry) => {
              if (entry?.memory) addMemoryMarker(entry.memory);
            });
          }
        }, 50);
      }
      return null;
    }

    function addMemoryMarker(memory) {
      if (!memory || !THREERef) return;
      const group = ensureMarkerGroup();
      if (!group) {
        const existing = markerMap.get(memory.id);
        if (existing) {
          existing.memory = memory;
        } else {
          markerMap.set(memory.id, { memory });
        }
        return;
      }

      const lon = heliocentricLon(memory.ts || Date.now());
      const dist = earthDistance(memory.ts || Date.now()) || 1;
      const x = Math.cos(lon) * dist;
      const z = Math.sin(lon) * dist;

      let entry = markerMap.get(memory.id);
      if (!entry) {
        const geometry = new THREERef.SphereGeometry(0.01, 16, 16);
        const material = new THREERef.MeshBasicMaterial({
          color: tagColor(memory.tags[0]),
          transparent: true,
          opacity: 0.92
        });
        const mesh = new THREERef.Mesh(geometry, material);
        mesh.position.set(x, 0, z);
        mesh.userData = { id: memory.id, tags: memory.tags, source: 'memory' };
        group.add(mesh);
        if (window.markers instanceof Map) {
          window.markers.set(memory.id, mesh);
        }

        let label = null;
        if (makeLabel) {
          label = makeLabel(memory.name || 'Memory');
          if (label) {
            label.position.copy(mesh.position).add(new THREERef.Vector3(0.03, 0.03, 0));
            label.visible = false;
            group.add(label);
            if (window.labels instanceof Map) {
              window.labels.set(memory.id, label);
            }
          }
        }
        entry = { mesh, label, memory };
        markerMap.set(memory.id, entry);
      } else {
        const { mesh, label } = entry;
        mesh.position.set(x, 0, z);
        mesh.material.color.setHex(tagColor(memory.tags[0]));
        mesh.userData.tags = memory.tags;
        if (label) {
          label.position.copy(mesh.position).add(new THREERef.Vector3(0.03, 0.03, 0));
        }
        entry.memory = memory;
      }
    }

    async function ensureStoreRecord(memory) {
      if (!memory || recordMap.has(memory.id)) {
        return recordMap.get(memory?.id);
      }
      let record = null;
      if (typeof window.buildRecordFromTimestamp === 'function') {
        try {
          record = await window.buildRecordFromTimestamp(memory.name, memory.ts, {
            lat: memory.lat ?? undefined,
            lon: memory.lon ?? undefined,
            tz: memory.tz
          });
        } catch (err) {
          console.warn('buildRecordFromTimestamp fallback', err);
        }
      }
      if (!record) {
        record = {
          id: memory.id,
          name: memory.name,
          when: new Date(memory.ts).toISOString(),
          tz: memory.tz,
          year: new Date(memory.ts).getUTCFullYear(),
          tags: [...memory.tags]
        };
      }
      record.id = memory.id;
      record.name = memory.name;
      record.when = new Date(memory.ts).toISOString();
      record.tz = memory.tz;
      record.tags = [...memory.tags];
      record.memoryMeta = memory;
      const storeRef = getStore();
      const items = storeRef?.items;
      if (Array.isArray(items) && !items.find((item) => item.id === record.id)) {
        items.push(record);
      }
      recordMap.set(memory.id, record);
      return record;
    }

    function renderList() {
      if (!refs.list) return;
      const frag = doc.createDocumentFragment();
      const seen = new Set();

      const storeRef = getStore();
      const combined = [];
      for (const mem of memories) {
        const record = recordMap.get(mem.id) || null;
        combined.push({
          id: mem.id,
          ts: mem.ts,
          tz: mem.tz,
          name: mem.name,
          tags: mem.tags,
          type: 'memory',
          record
        });
        seen.add(mem.id);
      }

      const storeItems = Array.isArray(storeRef?.items) ? storeRef.items : [];
      for (const rec of storeItems) {
        if (seen.has(rec.id)) continue;
        combined.push({
          id: rec.id,
          ts: Date.parse(rec.when || '') || rec.ts || 0,
          tz: rec.tz || tzGuess(),
          name: rec.name,
          tags: Array.isArray(rec.tags) ? rec.tags : [],
          type: 'legacy',
          record: rec
        });
      }

      combined.sort((a, b) => (b.ts || 0) - (a.ts || 0));
      const selected = storeRef?.selected;

      for (const item of combined) {
        const row = doc.createElement('div');
        row.className = 'item';
        if (selected?.has?.(item.id)) row.classList.add('active');
        row.dataset.id = item.id;
        row.dataset.type = item.type;
        row.dataset.tags = item.tags.join(',');

        const labelTime = typeof window.fmt?.dateLocal === 'function'
          ? window.fmt.dateLocal(item.ts, item.tz)
          : toLocalISO(item.ts, item.tz);

        row.innerHTML = `
          <div class="title">${escapeHtml(item.name)}</div>
          <div class="meta">${escapeHtml(labelTime)}${item.tz ? ' &middot; ' + escapeHtml(item.tz) : ''}</div>
          ${item.tags.length ? `<div class="chips">${item.tags.map((tag) => `<span class="chip" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`).join('')}</div>` : '<div class="chips muted">No hashtags</div>'}
        `;

        frag.appendChild(row);
      }

      refs.list.innerHTML = '';
      refs.list.appendChild(frag);

      if (typeof window.renderStates === 'function') {
        try { window.renderStates(); } catch (err) { console.warn(err); }
      } else if (legacyRenderList) {
        try { legacyRenderList(); } catch (err) { console.warn(err); }
      }
    }

    function applyFilter(tag, opts = {}) {
      filterTag = tag || '';
      if (!opts.skipInput && searchInput) {
        searchInput.value = filterTag;
      }
      if (refs.list) {
        const rows = Array.from(refs.list.querySelectorAll('.item'));
        for (const row of rows) {
          const tags = (row.dataset.tags || '').split(',').filter(Boolean);
          const visible = !filterTag || tags.includes(filterTag);
          row.style.display = visible ? '' : 'none';
        }
      }
      filterMarkersByTag(filterTag);
    }

    function filterMarkersByTag(tag) {
      markerMap.forEach((entry) => {
        if (!entry || !entry.mesh || !entry.memory) return;
        const has = !tag || entry.memory.tags.includes(tag);
        entry.mesh.visible = has;
        if (!has && entry.label) entry.label.visible = false;
      });
    }

    function updateChips(tags) {
      if (!refs.chips) return;
      const frag = doc.createDocumentFragment();
      for (const tag of tags) {
        const chip = doc.createElement('span');
        chip.className = 'u-chip';
        chip.dataset.tag = tag;
        chip.textContent = tag;
        frag.appendChild(chip);
      }
      refs.chips.innerHTML = '';
      refs.chips.appendChild(frag);
    }

    function updateTagSuggestions(input, suggestEl) {
      if (!input || !suggestEl) return;
      const caret = input.selectionStart ?? input.value.length;
      const tokenInfo = findActiveToken(input.value, caret);
      if (!tokenInfo) {
        hideSuggestions(suggestEl);
        return;
      }
      const list = getTagSuggestions(tokenInfo.token.toLowerCase());
      renderSuggestions(suggestEl, list, (tag) => {
        insertTagSuggestion(input, tokenInfo, tag, true);
        updateChips(parseHashtags(input.value));
      });
    }

    function renderSuggestions(host, list, onSelect) {
      if (!host) return;
      host.innerHTML = '';
      if (!list.length) {
        host.classList.remove('visible');
        return;
      }
      for (const [tag, count] of list) {
        const btn = doc.createElement('button');
        btn.type = 'button';
        btn.dataset.tag = tag;
        btn.innerHTML = `<span>${escapeHtml(tag)}</span><span>${count}</span>`;
        btn.addEventListener('mousedown', (ev) => {
          ev.preventDefault();
          onSelect(tag);
          host.classList.remove('visible');
        });
        host.appendChild(btn);
      }
      host.classList.add('visible');
    }

    function hideSuggestions(el) {
      if (el) el.classList.remove('visible');
    }

    function findActiveToken(text, caret) {
      const uptoCaret = text.slice(0, caret);
      const match = /(^|[\s.,;])([#][\p{L}\p{N}_-]*)$/u.exec(uptoCaret);
      if (!match) return null;
      const token = match[2];
      const start = caret - token.length;
      return { token, start, end: caret };
    }

    function insertTagSuggestion(input, tokenInfo, tag, addSpace) {
      const value = input.value;
      const before = value.slice(0, tokenInfo.start);
      const after = value.slice(tokenInfo.end);
      const suffix = addSpace ? ' ' : '';
      const next = `${before}${tag}${suffix}${after}`;
      input.value = next;
      const caret = before.length + tag.length + suffix.length;
      input.setSelectionRange(caret, caret);
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }

    function getTagSuggestions(prefix) {
      const raw = prefix.startsWith('#') ? prefix.slice(1) : prefix;
      const needle = raw.trim().toLowerCase();
      const entries = Object.entries(tagCounts);
      if (!needle) {
        return entries
          .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0]))
          .slice(0, 8);
      }
      const scored = [];
      for (const [tag, count] of entries) {
        const body = tag.startsWith('#') ? tag.slice(1) : tag;
        const lowerBody = body.toLowerCase();
        const idx = lowerBody.indexOf(needle);
        if (idx === -1) continue;
        const exactPrefix = idx === 0 ? 0 : 1;
        scored.push({ tag, count, idx, exactPrefix });
      }
      scored.sort((a, b) => {
        if (a.exactPrefix !== b.exactPrefix) return a.exactPrefix - b.exactPrefix;
        if (a.idx !== b.idx) return a.idx - b.idx;
        if (a.count !== b.count) return b.count - a.count;
        return a.tag.localeCompare(b.tag);
      });
      return scored.slice(0, 8).map(({ tag, count }) => [tag, count]);
    }

    function parseHashtags(text) {
      if (!text) return [];
      const matches = text.match(/#[\p{L}\p{N}_-]+/gu) || [];
      const seen = new Set();
      const tags = [];
      for (const tag of matches) {
        const lower = tag.toLowerCase();
        if (!seen.has(lower)) {
          seen.add(lower);
          tags.push(lower);
        }
      }
      return tags;
    }

    function normalizeMemory(item) {
      if (!item || !item.id) return null;
      const latNum = Number(item.lat);
      const lonNum = Number(item.lon);
      const mem = {
        id: String(item.id),
        name: String(item.name || 'Memory'),
        ts: Number(item.ts) || Date.now(),
        tz: item.tz || tzGuess(),
        lat: Number.isFinite(latNum) ? latNum : null,
        lon: Number.isFinite(lonNum) ? lonNum : null,
        tags: Array.isArray(item.tags) ? item.tags.map((t) => String(t).toLowerCase()) : [],
        fileURL: item.fileURL || '',
        mime: item.mime || ''
      };
      return mem;
    }

    function recomputeTagCounts(entries) {
      const counts = {};
      for (const mem of entries) {
        for (const tag of mem.tags) {
          counts[tag] = (counts[tag] || 0) + 1;
        }
      }
      return counts;
    }

    function saveMemories() {
      try {
        const payload = memories.map((mem) => ({
          id: mem.id,
          name: mem.name,
          ts: mem.ts,
          tz: mem.tz,
          lat: mem.lat,
          lon: mem.lon,
          tags: mem.tags,
          fileURL: mem.fileURL,
          mime: mem.mime
        }));
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('Failed to persist memories', err);
      }
    }

    function loadTagCounts() {
      const parsed = safeJson(localStorage.getItem(TAG_KEY));
      if (parsed && typeof parsed === 'object') return parsed;
      return {};
    }

    function saveTagCounts() {
      try {
        localStorage.setItem(TAG_KEY, JSON.stringify(tagCounts));
      } catch (err) {
        console.warn('Failed to persist tag counts', err);
      }
    }

    function safeJson(str) {
      if (!str) return null;
      try {
        return JSON.parse(str);
      } catch (err) {
        console.warn('JSON parse failed', err);
        return null;
      }
    }

    function tzGuess() {
      try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      } catch (err) {
        return 'UTC';
      }
    }

    function toLocalISO(ts, tz) {
      try {
        const opts = {
          timeZone: tz || 'UTC',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        };
        const parts = new Intl.DateTimeFormat('en-CA', opts).formatToParts(new Date(ts));
        const map = Object.fromEntries(parts.map((p) => [p.type, p.value]));
        return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second}`;
      } catch (err) {
        return new Date(ts).toISOString().replace('T', ' ').slice(0, 19);
      }
    }

    function sanitizeTZ(value) {
      const val = (value || '').trim();
      if (!val) return '';
      try {
        Intl.DateTimeFormat(undefined, { timeZone: val });
        return val;
      } catch (err) {
        return '';
      }
    }

    function roundCoord(num) {
      return Math.round(num * 1e6) / 1e6;
    }

    function parseExifDate(value, offset) {
      if (!value) return null;
      if (value instanceof Date) return value.getTime();
      if (typeof value === 'number') return value;
      let raw = String(value).trim();
      if (!raw) return null;
      raw = raw.replace(/^(\d{4}):(\d{2}):(\d{2})\s+/, '$1-$2-$3T');
      if (!/[+-]\d{2}:\d{2}$/.test(raw)) {
        if (typeof offset === 'string' && /^[+-]\d{2}:\d{2}$/.test(offset)) {
          raw += offset;
        } else {
          raw += '+00:00';
        }
      }
      const parsed = Date.parse(raw);
      return Number.isNaN(parsed) ? null : parsed;
    }

    function defaultTitle(name) {
      if (!name) return 'Untitled memory';
      return name.replace(/\.[^/.]+$/, '').replace(/[_-]+/g, ' ').trim() || 'Untitled memory';
    }

    function escapeHtml(str) {
      return String(str ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function setLoading(isOn) {
      if (!refs.load) return;
      refs.load.classList.toggle('show', Boolean(isOn));
    }

    function setSearchValue(tag) {
      if (searchInput) {
        searchInput.value = tag;
      }
    }

    function tagColor(tag) {
      if (!tag || !THREERef) return 0x7bdcf3;
      const color = new THREERef.Color();
      const hue = (hashString(tag) % 360) / 360;
      color.setHSL(hue, 0.62, 0.58);
      return color.getHex();
    }

    function hashString(str) {
      let h = 0;
      for (let i = 0; i < str.length; i++) {
        h = (h << 5) - h + str.charCodeAt(i);
        h |= 0;
      }
      return Math.abs(h);
    }
  })();
</script>

<script type="module">
(async () => {
  const resolvedLocal = new URL("halobank-spore-timeline.js", window.location.href).pathname;
  const candidates = [
    "/halobank-spore-timeline.js",
    "/halobank/halobank-spore-timeline.js",
    "/warp/halobank-spore-timeline.js",
    "./halobank-spore-timeline.js",
    "halobank-spore-timeline.js",
    resolvedLocal,
  ].filter((value, index, array) => value && array.indexOf(value) === index);

  let lastError = null;
  for (const specifier of candidates) {
    try {
      await import(specifier);
      window.__haloBankTimelineSource = specifier;
      console.info(`[halobank] Loaded timeline module from ${specifier}`);
      return;
    } catch (err) {
      lastError = err instanceof Error ? err : new Error(String(err));
      console.warn(`[halobank] Timeline import failed for ${specifier}`, lastError);
    }
  }

  console.error(
    "[halobank] Unable to load halobank-spore-timeline.js from any known location. " +
      "Ensure the file is hosted alongside halobank.html or served at /halobank-spore-timeline.js.",
    lastError,
  );
})();
</script>

</body>
</html>
