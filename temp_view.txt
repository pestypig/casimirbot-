import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useEnergyPipeline } from "@/hooks/use-energy-pipeline";

const EPSILON_0 = 8.8541878128e-12;
const ELECTRON_CHARGE = 1.602176634e-19;
const ELECTRON_MASS = 9.1093837015e-31;
const LIGHT_SPEED = 299792458;
const PLANCK_REDUCED = 1.054571817e-34;
const FINE_STRUCTURE_ALPHA = 7.2973525693e-3;
const BOHR_RADIUS = 5.29177210903e-11;
const CLASSICAL_RADIUS = 2.8179403262e-15;
const COMPTON_WAVELENGTH = 2.42631023867e-12;
const PI = Math.PI;
const K_CANONICAL = 1 / (4 * PI * EPSILON_0);
const MIN_DISTANCE = 1e-12;

export type QuantumNumbers = {
  n: number;
  l: number;
  m: number;
  ms: 1 | -1;
};

export type ElectronStructureModel = "pointlike" | "toroidal";

export type ToroidalPayload = {
  lambdaC: number;
  torusRadius: number;
  rotationHorizon: number;
  photonHelicity: 1 | -1;
  internalPhase: number;
  qDerived: number;
  muDerived: number;
  gDerived: number;
};

export type ElectronState = {
  id: string;
  label: string;
  orbital: QuantumNumbers;
  energyEV: number;
  occupancy: number;
  spinAligned: boolean;
  structureModel: ElectronStructureModel;
  toroidal?: ToroidalPayload;
};

export type PotentialConfig = {
  type: "hydrogenic" | "custom";
  Z: number;
  customId?: string;
};

export type SweepSample = {
  value: number;
  k: number;
};

export type SweepState = {
  activeParam: "radius" | "charge" | "permittivity";
  start: number;
  end: number;
  steps: number;
  currentValue: number;
  running: boolean;
  results: SweepSample[] | null;
  lastRunAt: number | null;
  resultsId?: string;
};

export type CoulombExperiment = {
  enabled: boolean;
  electronA: string | null;
  electronB: string | null;
  separation: number;
  mediumPermittivity: number;
  forceMeasured: number;
  kDerived: number | null;
  kCanonical: number;
  relativeError: number | null;
};

export type OrbitEvent =
  | {
      type: "constant_drift";
      constant: "coulomb_k" | "electron_charge" | "g_factor";
      measured: number;
      canonical: number;
      relError: number;
      simTime: number;
    }
  | {
      type: "normalization_error";
      norm: number;
      tolerance: number;
      simTime: number;
      fieldId: string;
    }
  | {
      type: "topology_switch";
      electronId: string;
      from: ElectronStructureModel;
      to: ElectronStructureModel;
      simTime: number;
    }
  | {
      type: "sweep_complete";
      param: SweepState["activeParam"];
      resultsId: string;
      simTimeEnd: number;
    };

export type OrbitWavefieldState = {
  fieldId: string;
  normalization: number;
  amplitudes: Array<{
    electronId: string;
    amplitude: number;
    phase: number;
  }>;
};

export type OrbitSimState = {
  electrons: ElectronState[];
  potential: PotentialConfig;
  time: {
    tSim: number;
    dt: number;
    playing: boolean;
  };
  wavefields: OrbitWavefieldState;
  sweeps: SweepState;
  experiment: CoulombExperiment;
  derived: {
    bohrRadius: number;
    classicalRadius: number;
    comptonWavelength: number;
    fineStructureAlpha: number;
    pipelineDuty: number;
    normalizationError: number;
  };
  events: OrbitEvent[];
};

export type OrbitSimActions = {
  setPotential: (cfg: Partial<PotentialConfig>) => void;
  setElectrons: (updater: (prev: ElectronState[]) => ElectronState[]) => void;
  toggleStructureModel: (id: string) => void;
  step: (dtOverride?: number) => void;
  togglePlay: () => void;
  configureExperiment: (cfg: Partial<CoulombExperiment>) => void;
  runExperiment: () => void;
  setSweep: (cfg: Partial<SweepState>) => void;
  runSweep: () => void;
};

export function useElectronOrbitSim(): [OrbitSimState, OrbitSimActions] {
  const { data: pipeline } = useEnergyPipeline();
  const [electrons, setElectronsState] = useState<ElectronState[]>(() => createDefaultElectrons());
  const [potential, setPotentialState] = useState<PotentialConfig>({
    type: "hydrogenic",
    Z: 1
  });
  const [time, setTime] = useState({ tSim: 0, dt: 0.05, playing: false });
  const [experiment, setExperiment] = useState<CoulombExperiment>({
    enabled: true,
    electronA: "e-1",
    electronB: "e-2",
    separation: 1.5e-10,
    mediumPermittivity: EPSILON_0,
    forceMeasured: 0,
    kDerived: null,
    kCanonical: K_CANONICAL,
    relativeError: null
  });
  const [sweeps, setSweepState] = useState<SweepState>({
    activeParam: "radius",
    start: 5e-11,
    end: 3e-10,
    steps: 8,
    currentValue: 5e-11,
    running: false,
    results: null,
    lastRunAt: null
  });
  const [events, setEvents] = useState<OrbitEvent[]>([]);

  const pipelineDuty = pipeline?.dutyEffectiveFR ?? pipeline?.dutyCycle ?? 0;
  const pipelineDrift = useMemo(() => {
    const stability = pipeline?.TS_ratio ?? 100;
    const driftFromTS = (stability - 100) / 600;
    const dutyMod = pipelineDuty * 0.25;
    return 1 + driftFromTS + dutyMod;
  }, [pipeline?.TS_ratio, pipelineDuty]);

  useEffect(() => {
    if (!time.playing) return;
    const handle = window.setInterval(() => {
      setTime((prev) => ({ ...prev, tSim: prev.tSim + prev.dt }));
    }, 120);
    return () => window.clearInterval(handle);
  }, [time.playing, time.dt]);

  const wavefields = useMemo<OrbitWavefieldState>(() => {
    const fieldId = `orbital-${potential.Z}-${electrons.length}`;
    const amplitudes = electrons.map((electron, idx) => {
      const freq = Math.max(1, electron.orbital.n);
      const amplitude = 0.5 + 0.5 * Math.sin(time.tSim * freq + idx);
      const phase = (time.tSim * freq + idx * 0.3) % (2 * PI);
      return { electronId: electron.id, amplitude, phase };
    });
    const normalization =
      1 +
      0.01 * Math.sin(time.tSim * 0.7) +
      (pipelineDuty ? pipelineDuty * 0.005 : 0);
    return { fieldId, amplitudes, normalization };
  }, [electrons, pipelineDuty, potential.Z, time.tSim]);

  const derived = useMemo(() => {
    const bohrRadius = BOHR_RADIUS / Math.max(1, potential.Z);
    const normalizationError = Math.abs(1 - wavefields.normalization);
    return {
      bohrRadius,
      classicalRadius: CLASSICAL_RADIUS,
      comptonWavelength: COMPTON_WAVELENGTH,
      fineStructureAlpha: FINE_STRUCTURE_ALPHA,
      pipelineDuty,
      normalizationError
    };
  }, [pipelineDuty, potential.Z, wavefields.normalization]);

  const pushEvent = useCallback((evt: OrbitEvent) => {
    setEvents((prev) => [evt, ...prev].slice(0, 32));
  }, []);

  const normalizationAlertRef = useRef(false);

  useEffect(() => {
    const breach = derived.normalizationError > 0.03;
    if (breach && !normalizationAlertRef.current) {
      pushEvent({
        type: "normalization_error",
        norm: wavefields.normalization,
        tolerance: 0.03,
        simTime: time.tSim,
        fieldId: wavefields.fieldId
      });
    }
    normalizationAlertRef.current = breach;
  }, [derived.normalizationError, normalizationAlertRef, pushEvent, time.tSim, wavefields.fieldId, wavefields.normalization]);

  const computeForce = useCallback(
    (q1: number, q2: number, r: number, epsilon: number) => {
      const distance = Math.max(MIN_DISTANCE, r);
      const permittivity = Math.max(EPSILON_0 * 0.1, epsilon);
      const kMedium = 1 / (4 * PI * permittivity);
      return (kMedium * q1 * q2 * pipelineDrift) / (distance * distance);
    },
    [pipelineDrift]
  );
