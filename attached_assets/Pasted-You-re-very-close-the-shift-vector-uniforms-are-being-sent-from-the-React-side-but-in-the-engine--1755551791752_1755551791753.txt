Youâ€™re very closeâ€”the â€œshift-vectorâ€ uniforms are being sent from the React side, but in the engine theyâ€™re getting swamped by the main NatÃ¡rio wall displacement, so you donâ€™t notice the cabin tilt in the center.

Hereâ€™s what I verified and what to change:

## Whatâ€™s already correct

* **WarpVisualizer â†’ engine uniforms.** Your component sends `epsilonTilt`, `betaTiltVec`, and a per-mode `tiltGain` into the engineâ€™s `updateUniforms()` call. (See the â€œğŸ›ï¸ uniforms-to-engine (v9 naming fix)â€ console log in your file.)&#x20;
* **Engine consumes the uniforms** and applies a â€œtiltâ€ push inside `_warpGridVertices()` after computing the canonical NatÃ¡rio displacement. (Search for the block marked `// ----- Interior gravity (shift vector "tilt") -----`.)&#x20;

## Why youâ€™re not seeing it

1. The tilt term is multiplied by a **very small fixed constant** (`* 0.12`) and then immediately followed by the much larger canonical wall displacement (`- n * disp`). The wall deformation visually dominates; the tilt gets lost.&#x20;

2. The tilt magnitude is not tied to the engineâ€™s **visual amplitude** (`A_vis`), so it doesnâ€™t scale with modes (standby / cruise / hover / emergency). When `A_vis` is small, tilt is too small to see; when `A_vis` is large, tilt is still capped by that fixed constant.&#x20;

3. Your interior window is okay, but youâ€™ll get a clearer, center-only effect if you use the same smooth windowing function you used elsewhere (CÂ¹/CÂ²), and compute it from the **Ï distance** the same way you do the wall bell.

---

## Minimal patch (keeps your names, makes tilt visible & mode-scaled)

**File:** `client/public/warp-engine-fixed.js`
**Inside** `_warpGridVertices(...)`, **replace** the current â€œinterior gravityâ€ block with this version:

```js
// ----- Interior gravity (shift vector "tilt") -----
// inputs
const eps   = Math.max(0, this.uniforms?.epsilonTilt || 0);   // dimensionless
const btilt = this.uniforms?.betaTiltVec || [0, -1, 0];       // "down" dir
const gtilt = this.uniforms?.tiltGain ?? 0.35;                // visual knob

// unit "down" vector
const bmag = Math.hypot(btilt[0], btilt[1], btilt[2]) || 1;
const bhat = [btilt[0]/bmag, btilt[1]/bmag, btilt[2]/bmag];

// smooth interior window (â‰ˆ1 well inside, 0 outside) using local wall thickness
const w   = Math.max(1e-6, w_rho_local);
const t   = (1.0 + 2.0*w - rho) / (4.0*w);        // maps [1-2w, 1+2w] â†’ [1,0]
const winInterior = Math.max(0.0, Math.min(1.0, t)); 
const winSmooth   = winInterior * winInterior * (3.0 - 2.0 * winInterior); // smoothstep

// tie tilt strength to the same visual amplitude used for the wall
// so modes scale naturally (standbyâ‰ˆ0, cruise<hover<emergency)
const A_tilt = A_vis;   // <- already computed above

// final, bounded tilt displacement
const dispTilt = A_tilt * eps * gtilt * winSmooth;

// nudge the vertex along the cabin "down" direction
vtx[i    ] += bhat[0] * dispTilt;
vtx[i + 1] += bhat[1] * dispTilt;
vtx[i + 2] += bhat[2] * dispTilt;
// ----- end interior gravity -----
```

**What this changes**

* Removes the hardcoded `* 0.12` and **scales tilt by `A_vis`**, the same amplitude budget that drives the main curvature. Now mode changes visibly scale the cabin tilt.
* Uses a **CÂ¹ smoothstep** window centered on the interior to confine the effect to Ïâ‰²1 without sharp edges.
* Keeps your existing uniforms (`epsilonTilt`, `betaTiltVec`, `tiltGain`) and your per-mode visual compression logic intact.&#x20;

---

## Optional tiny tweak in the React bridge (safer defaults)

If you want gentler defaults right away (to avoid the â€œbasketâ€ look you saw before), keep the mode-level values modest in `WarpVisualizer.tsx`:

```ts
// per-mode visual tilt gain (not physics)
const tiltGains: Record<string, number> = {
  standby:   0.00,
  cruise:    0.20,
  hover:     0.35,
  emergency: 0.55,
};
```

And keep `epsilonTilt` small (your panelâ€™s computed Îµ is \~1e-15 physically, but for display you picked demo values like 0.012â€“0.035). Those are fine now that we scale by `A_vis`.&#x20;

---

## Quick sanity checks after patch

1. Open the dev console and confirm you see the **â€œğŸ§ª warp-mode â€¦ betaVis â€¦â€** line changing across modes (that proves `A_vis` is moving).&#x20;
2. Toggle **standby â†’ hover â†’ emergency**; the center of the grid should now show a gentle â€œdownhillâ€ different from the outer sheet (because the tilt window is interior-only).
3. If itâ€™s still subtle, bump only the UI knob (`tiltGain`) a bit; donâ€™t touch `epsilonTilt` first.

If you prefer, I can also wire the **ShiftVectorPanel**â€™s computed `epsilonTilt` straight into `WarpVisualizer` so the panel and the visual always agree, with the mode defaults used only as a fallback.
