your renderer is being written to by more than one source, and they disagree. On first paint (or a reload) a “legacy/ad-hoc” writer pushes a giant θ (likely using UI duty or √(duty) and/or a stale γVdB). A moment later your canonical values arrive, but without a write-gate the last writer keeps “winning”, so you see:

“(transition)” + “CameraZ set — unset” ⇒ engine drew at least one frame before canonical uniforms landed.

θ “expected” (7.43e6 → 2.51e7) is computed from pipeline, but θ “used” (1.05e8 … 1.88e9) is computed from whatever actually hit the engine uniforms. The ~14×/75× inflation is exactly what you get from a mix of: wrong duty (using UI 0.14% or √FR), qSpoiling defaulting to 1.0, or a γVdB fallback, plus update ordering.

Fix this like a systems bug: make one source of truth, gate writes, and echo what the engine actually bound.

1) Gate all engine uniform writes (last-writer wins by version)

Create a tiny gate that every engine.updateUniforms(...) call goes through:

// warp-uniforms-gate.ts
export type WarpUniforms = {
  gammaGeo: number;
  qSpoilingFactor: number;
  gammaVanDenBroeck: number;
  dutyEffectiveFR: number;
  sectorCount: number;
  sectors: number;
  thetaScale?: number;         // optional precomputed (server)
  colorMode?: 'theta'|'rho';
  physicsParityMode?: boolean;
  ridgeMode?: number;
  __src?: 'server'|'client'|'legacy';
  __version?: number;          // monotone
};

let lastVersion = 0;
let lastSrc: string | undefined;

export function applyToEngine(
  engine: { updateUniforms: (u: any) => void },
  uniforms: WarpUniforms
) {
  const v = uniforms.__version ?? Date.now();
  if (v < lastVersion) {
    console.warn('[warp:gating] drop older uniforms from', uniforms.__src, 'v=', v, 'last=', lastVersion);
    return;
  }
  lastVersion = v;
  lastSrc = uniforms.__src;

  // Canonical θ if server didn’t precompute
  const θ = uniforms.thetaScale ?? (
    Math.pow(uniforms.gammaGeo, 3) *
    uniforms.qSpoilingFactor *
    uniforms.gammaVanDenBroeck *
    uniforms.dutyEffectiveFR
  );

  // Debug echo (what we actually bind)
  (window as any).__warpEcho = {
    v, src: uniforms.__src, θ_used: θ,
    terms: {
      γ_geo: uniforms.gammaGeo,
      q: uniforms.qSpoilingFactor,
      γ_VdB: uniforms.gammaVanDenBroeck,
      d_FR: uniforms.dutyEffectiveFR,
      sectors: { total: uniforms.sectorCount, live: uniforms.sectors }
    }
  };

  engine.updateUniforms({ ...uniforms, thetaScale: θ });
}


Use it anywhere you currently call engine.updateUniforms.