Below is a **minimal, surgical upgrade** that turns the single ‚Äúfloor‚Äù you‚Äôre warping now into a **volumetric cage** of three orthogonal grids.
With two extra slanted sheets you instantly get:

* an **XZ ‚Äúside wall‚Äù** that reveals the bubble‚Äôs oval silhouette when it inflates/deflates,
* a **YZ ‚Äúend wall‚Äù** that lets you judge radial symmetry,
* the original XY ‚Äúfloor‚Äù that you already have.

Because every sheet is bent by the same `_warpGridVertices` routine, their intersections outline the hull and its expansion in real time, without changing your physics.

---

## 1 - Generate 3 grid sheets instead of 1

```diff
// --- inside _initGrid() ------------------------------------------
- this._initGrid();              // old (one sheet)
+ this._initGrids();             // new (3 sheets)

/* --------------------------------------------------------------- */
_initGrids() {
    // reusable parameters
    const size_nm      = 40_000;   // 40 ¬µm
    const divisions    = 50;
    const makeSheet    = (plane) =>
        this._createGrid(size_nm, divisions, plane);   // NEW param

    // 1) XY floor (your current sheet)             z = 0 .. size
    const sheetXY = makeSheet('XY');
    // 2) XZ side wall                              y = 0 .. size
    const sheetXZ = makeSheet('XZ');
    // 3) YZ end wall                               x = 0 .. size
    const sheetYZ = makeSheet('YZ');

    // concat ‚Üí single Float32Array ‚Üí single VBO
    this.gridVertices     = new Float32Array([
        ...sheetXY, ...sheetXZ, ...sheetYZ
    ]);
    this.gridVertexCount  = this.gridVertices.length / 3;
    this.originalGridVertices = new Float32Array(this.gridVertices);

    /* ‚Ä¶ unchanged buffer creation ‚Ä¶ */
}
```

### `_createGrid` gets a **plane switch**

```diff
// signature now has a 3rd argument: which plane to build
-_createGrid(size = 40_000, divisions = 50) {
+_createGrid(size = 40_000, divisions = 50, plane = 'XY') {

    /* common preparation kept as-is ‚Ä¶ */

    if (plane === 'XY') {
        // what you already had (grid lines parallel to X and Y)
        ‚Ä¶                           // unchanged
    }
+   else if (plane === 'XZ') {
+       // clone the XY code but swap (y,z) ‚Üî (z,y)
+       //   so the sheet stands up vertically at y=0
+   }
+   else if (plane === 'YZ') {
+       // clone again and swap (x, y, z) -> (y, z, x)
+   }
    return new Float32Array(verts);
}
```

*(copy / paste your existing loops twice, only renaming coordinates;
for clarity this answer omits the full repetition).*

---

## 2 - Remove the ‚Äúreset after warp‚Äù line (if you haven‚Äôt yet)

The extra sheets won‚Äôt move if you still restore the vertices at the
bottom of `_warpGridVertices`.
Make sure the very last lines **do not** copy the pristine grid back.

```diff
- // CRITICAL FIX: Reset vertices to prevent drift accumulation
- if (this.originalGridVertices) {
-     vtx.set(this.originalGridVertices);
- }
```

(The grid is now reset **before** every warp in `_updateGrid()` as shown in the previous message.)

---

## 3 - Thin cosmetic touches (optional but nice)

| Touch                           | How                                                                                                                                                         |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Different colours per sheet** | In `_compileGridShaders()` pass a `u_color` uniform and set it before every `drawArrays` (`floor = cyan`, `side = magenta`, `end = yellow`).                |
| **Subtle transparency**         | Enable blending only for the grid pass: `gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);` then set Œ± ‚âà 0.4 in the fragment shader. |
| **Quick camera orbit key**      | Keep a `yaw` angle, update with arrow keys, rebuild the `view` matrix each frame ‚Äì a five-line addition gives you a rotating inspection.                    |

---

## 4 - Result

* In **Stand-by** the three sheets almost coincide (flat metric).
* In **Hover / Cruise / Amplified** each mode now produces an expanding
  ‚Äúbulge‚Äù on all three sheets, outlining an oblate spheroid exactly as in
  the WarpFactory side-profile demo.
* When Œ≤‚ÇÄ spikes (amplifiers on) the sheets visibly stretch outward and
  the intersections form the expected oval-shaped tunnel around the
  needle hull.

---

### Why this is enough

The Nat√°rio solution is axially symmetric; warping three mutually-orthogonal
planes already gives the viewer all cues needed to perceive the full
3-D bubble without the expense of a true volume mesh.
If you later want the candy-store version, you can instanced-draw a
**ring of N radial sheets** by rotating the XY plane, but the three-sheet
cage is the classic ‚Äúorthogonal slice‚Äù trick used in many GR demos and
costs almost nothing.

Happy warping üöÄ
