Nice—this is in good shape to slot a metric tensor into the renderer and make curvature drawing “metric-aware.” Below are **unified diffs** against your `/mnt/data/warp-engine.js` that:

1. enable derivatives so we can estimate curvature in-shader,
2. add metric uniforms + helpers (`u_metric`, `u_metricInv`, `u_metricOn`),
3. switch the lighting/“theta/shear” math to use the metric (when enabled),
4. blend in a metric-aware curvature term based on ∂N/∂x, ∂N/∂y,
5. plumb the new uniforms from JS.

---

### 1) GL init — enable derivatives for curvature estimates

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
-        if (!gl) {
+        if (!gl) {
             try {
                 // Fallback to WebGL1
                 gl = canvas.getContext('webgl', contextOptions) || 
                      canvas.getContext('experimental-webgl', contextOptions);
                 if (gl) {
                     console.log('✅ WebGL1 context created successfully');
                 }
             } catch (e) {
                 console.warn('WebGL1 context creation failed:', e.message);
             }
         }
 
         if (!gl) {
             // If we still don't have a context, log debug info
             console.error('❌ Failed to create any WebGL context');
             ...
         }
 
-        this.gl = gl;
+        this.gl = gl;
+        // Enable derivatives so we can do screen-space curvature (WebGL1 needs this; WebGL2 has dFdx/dFdy)
+        this._derivExt = this.gl.getExtension('OES_standard_derivatives');
```

---

### 2) Shader sources — add metric uniforms & helpers; metric-aware shading and curvature

> These edits live inside your `_makeShaderSources(gl)`/fragment construction (right where you already have the `precision highp float;` header and palette helpers).

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
-precision highp float;
+precision highp float;
+#ifdef GL_OES_standard_derivatives
+#extension GL_OES_standard_derivatives : enable
+#endif
 precision highp int;
 
 varying vec3 vNormalWS;
 varying vec3 vPosWS;
 
 uniform vec3 u_cameraPos;
 uniform vec3 u_lightDirWS;
 uniform vec3 u_colorA;
 uniform vec3 u_colorB;
@@
 // small helpers
 float dot2(vec2 v){return dot(v,v);}
 
+// ───────── Metric helpers (g_ij and its inverse) ─────────
+uniform mat3  u_metric;     // g_ij
+uniform mat3  u_metricInv;  // g^{ij}
+uniform float u_metricOn;   // 0 = Euclidean, 1 = metric-enabled
+
+float dot_g(vec3 a, vec3 b){ return dot(a, u_metric * b); }
+float norm_g(vec3 v){ return sqrt(max(1e-12, dot_g(v,v))); }
+vec3  normalize_g(vec3 v){ float L = norm_g(v); return v / max(L, 1e-12); }
+
@@
 void main(){
     // --- world-space inputs ---
     vec3 posWS    = vPosWS;
     vec3 normalWS = vNormalWS;
 
-    vec3 N = normalize(normalWS);
-    vec3 L = normalize(u_lightDirWS);
-    float lambert = max(0.0, dot(N,L));
+    // Metric-aware normal & light
+    vec3 N = (u_metricOn > 0.5) ? normalize_g(u_metricInv * normalWS) : normalize(normalWS);
+    vec3 L = (u_metricOn > 0.5) ? normalize_g(u_metricInv * u_lightDirWS) : normalize(u_lightDirWS);
+    float lambert = max(0.0, (u_metricOn > 0.5) ? dot_g(N,L) : dot(N,L));
@@
     // --- bell / theta / shear fields (Euclidean → Metric) ---
     vec3 axes = u_axes;                  // (a,b,c) or equivalent scaling you already pass
-    vec3 pN   = posWS / axes;            // normalize to ellipsoidal unit shell
-    float rs  = length(pN) + 1e-6;
-    vec3  dN  = normalize(u_driveDir / axes);
-    float xs  = dot(pN, dN);
+    vec3 pN   = posWS / axes;            // still scale by hull axes
+    float rs  = (u_metricOn > 0.5 ? norm_g(pN) : length(pN)) + 1e-6;
+    vec3  dN  = (u_metricOn > 0.5)
+              ? normalize_g(u_metricInv * (u_driveDir / axes))
+              : normalize(u_driveDir / axes);
+    float xs  = (u_metricOn > 0.5) ? dot_g(pN, dN) : dot(pN, dN);
     float cosphi = clamp(xs/rs, -1.0, 1.0);
     float sinphi = sqrt(max(0.0, 1.0 - cosphi*cosphi));
@@
-    float kval = shearProxy;
+    float kval = shearProxy;
 
     // Metric-aware screen-space curvature (adds ridge accent when enabled)
+#ifdef GL_OES_standard_derivatives
+    vec3 Nm = (u_metricOn > 0.5) ? normalize_g(u_metricInv * normalWS) : normalize(normalWS);
+    float kScreen = length(dFdx(Nm)) + length(dFdy(Nm));
+#else
+    float kScreen = 0.0;
+#endif
+    float curvVis = clamp(u_curvatureGainT * kScreen, 0.0, 1.0);
+    if (ridgeI > 0) {
+        // Blend some metric-aware curvature into the shear proxy when ridge overlay is active
+        kval = clamp(mix(kval, kval + curvVis, 0.5), 0.0, 1.0);
+    }
@@
-    // color mode mux
-    int colorI = clamp(u_colorMode, 0, 4);
+    // color mode mux
+    int colorI = clamp(u_colorMode, 0, 6); // allow curvature-only debug slot (6)
@@
-    vec3 col = (colorI==1) ? diverge(tVis) : seqTealLime(sVis);
+    vec3 col = (colorI==1) ? diverge(tVis) : seqTealLime(sVis);
+    if (colorI==6) {
+        col = seqTealLime(curvVis);
+        SET_FRAG(vec4(col, 1.0)); return;
+    }
```

> Notes:
>
> * We reuse your existing `u_curvatureGainT` and `ridgeMode` (as `ridgeI`) to gate curvature.
> * When `u_metricOn==1.0`, all the dot/length/normalizations switch to metric versions.

---

### 3) Uniform plumbing — cache & set metric uniforms

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
   _cacheGridLocations(){
     const gl   = this.gl;
     const prog = this.gridProgram;
     const U    = this.gridUniforms = {};
@@
     U.u_axes                 = gl.getUniformLocation(prog, "u_axes");
     U.u_driveDir             = gl.getUniformLocation(prog, "u_driveDir");
+    // Metric
+    U.u_metric               = gl.getUniformLocation(prog, "u_metric");
+    U.u_metricInv            = gl.getUniformLocation(prog, "u_metricInv");
+    U.u_metricOn             = gl.getUniformLocation(prog, "u_metricOn");
@@
     U.u_ridgeMode            = gl.getUniformLocation(prog, "u_ridgeMode");
     U.u_curvatureGainT       = gl.getUniformLocation(prog, "u_curvatureGainT");
     U.u_curvatureBoostMax    = gl.getUniformLocation(prog, "u_curvatureBoostMax");
```

Add identity mat3 storage and defaults (near your other constants or in the constructor):

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
-    this.currentParams = {
+    this.currentParams = {
         ...
         u_colorMode: 2,
         u_ridgeMode: 0,
         u_curvatureGainT: 1.0,
         u_curvatureBoostMax: 4.0,
+        // Metric defaults (identity)
+        metric:     new Float32Array([1,0,0, 0,1,0, 0,0,1]),
+        metricInv:  new Float32Array([1,0,0, 0,1,0, 0,0,1]),
+        metricOn:   0.0
     };
```

Set the uniforms every draw (right next to where you already set axes/drive, view, colors, etc.):

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
     // axes / drive, etc.
     gl.uniform3fv(U.u_axes, axes3);
     gl.uniform3fv(U.u_driveDir, drive3);
+    // metric
+    const g  = this.currentParams.metric     || ID3;
+    const gi = this.currentParams.metricInv  || ID3;
+    const gon= this.currentParams.metricOn   || 0.0;
+    gl.uniformMatrix3fv(U.u_metric,    false, g);
+    gl.uniformMatrix3fv(U.u_metricInv, false, gi);
+    gl.uniform1f(U.u_metricOn, gon);
```

And define the identity mat3 (anywhere near other module-level constants):

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
-// Math helpers …
+// Math helpers …
+const ID3 = new Float32Array([1,0,0, 0,1,0, 0,0,1]);
```

---

### 4) Tiny API ergonomics (optional but handy)

Add a tiny setter so UI/bridge code can flip the metric on/off and pass tensors:

```diff
*** a/warp-engine.js
--- b/warp-engine.js
@@
   updateUniforms(up){
     Object.assign(this.currentParams, up);
     return this;
   }
+
+  /** Set/enable a 3×3 metric tensor (and its inverse). Pass `on=false` to revert to Euclidean. */
+  setMetric(g, gInv=null, on=true){
+    if (!g) {
+      this.currentParams.metric    = ID3;
+      this.currentParams.metricInv = ID3;
+      this.currentParams.metricOn  = 0.0;
+      return this;
+    }
+    this.currentParams.metric    = (g instanceof Float32Array) ? g : new Float32Array(g);
+    this.currentParams.metricInv = (gInv instanceof Float32Array) ? gInv :
+                                   (gInv ? new Float32Array(gInv) : ID3);
+    this.currentParams.metricOn  = on ? 1.0 : 0.0;
+    return this;
+  }
```

---

## How to drive it

* **Euclidean (current behavior):**

  ```js
  engine.setMetric(null);               // or updateUniforms({ metricOn: 0 })
  ```

* **Enable a custom metric g (and inverse):**

  ```js
  const g   = [ gxx,gxy,gxz,  gxy,gyy,gyz,  gxz,gyz,gzz ];
  const gInv= invert3x3(g);             // from your math utils or precomputed
  engine.setMetric(g, gInv, true);
  ```

* **Curvature drawing:** turn on your existing ridge overlay and adjust gain:

  ```js
  engine.updateUniforms({
    u_ridgeMode: 1,          // enable
    u_curvatureGainT: 2.0,   // stronger curvature highlights
    u_colorMode: 6           // optional: curvature-only debug palette
  });
  ```

This keeps everything backward-compatible: when `u_metricOn=0`, the shader stays Euclidean. Flip it on, and all dot/length/normalization operations (lighting + “theta/shear” field + curvature) respect your generalized metric.

If you want me to tailor the patch more tightly to a specific block in your `_makeShaderSources(gl)` (or wire additional CPU-side defaults), drop me the exact snippet around your fragment header and that small “theta/shear” section and I’ll splice it precisely.
