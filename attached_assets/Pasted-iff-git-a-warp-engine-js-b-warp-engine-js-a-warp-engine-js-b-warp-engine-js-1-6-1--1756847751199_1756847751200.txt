iff --git a/warp-engine.js b/warp-engine.js
--- a/warp-engine.js
+++ b/warp-engine.js
@@ -1,6 +1,7 @@
 // WarpEngine (WebGL runtime)
 // ------------------------------------------------------------
 
+// (Tensor-driven scaffolding: lapseN, shiftBeta, full spatial metric support)
 // ---- helpers for meters ↔ rho thickness and validation ----------------------
 function _aHarmonic(ax, ay, az) {
   const a = +ax || 0, b = +ay || 0, c = +az || 0;
@@ -17,6 +18,42 @@ function _req(cond, name, U) {
   }
 }
 
+// ---- metric helpers ---------------------------------------------------------
+function _metricFromUniforms(U) {
+  // Prefer full symmetric (gxx,gyy,gzz,gxy,gyz,gzx), else diag, else identity.
+  if (Array.isArray(U.gSpatialSym) && U.gSpatialSym.length >= 6) {
+    const [gxx,gyy,gzz,gxy,gyz,gzx] = U.gSpatialSym.map(Number);
+    return { g:[[gxx,gxy,gzx],[gxy,gyy,gyz],[gzx,gyz,gzz]], diag:false };
+  }
+  if (Array.isArray(U.gSpatialDiag) && U.gSpatialDiag.length >= 3) {
+    const [gx,gy,gz] = U.gSpatialDiag.map(Number);
+    return { g:[[gx,0,0],[0,gy,0],[0,0,gz]], diag:true };
+  }
+  return { g:[[1,0,0],[0,1,0],[0,0,1]], diag:true };
+}
+function _dotG(v, w, U) {
+  const { g } = _metricFromUniforms(U);
+  return v[0]*(g[0][0]*w[0] + g[0][1]*w[1] + g[0][2]*w[2]) +
+         v[1]*(g[1][0]*w[0] + g[1][1]*w[1] + g[1][2]*w[2]) +
+         v[2]*(g[2][0]*w[0] + g[2][1]*w[1] + g[2][2]*w[2]);
+}
+function _normG(v, U) {
+  const d = Math.sqrt(Math.max(1e-18, _dotG(v,v,U)));
+  return [ (v[0]||0)/d, (v[1]||0)/d, (v[2]||0)/d ];
+}
+function _thetaFromMetric(U) {
+  // θ̂_metric ~ ||g - I||_F  (Frobenius norm deviation from identity)
+  const { g } = _metricFromUniforms(U);
+  const m00=g[0][0]-1, m11=g[1][1]-1, m22=g[2][2]-1;
+  const m01=g[0][1],  m02=g[0][2],  m12=g[1][2];
+  const f = m00*m00 + m11*m11 + m22*m22 + 2*(m01*m01 + m02*m02 + m12*m12);
+  return Math.sqrt(Math.max(0, f));
+}
+function _redshiftProxy(U, viewN) {
+  // ẑ ≈ N^{-1} - 1 + (β·n)   (very crude proxy: lapse + shift along view)
+  const N = Number.isFinite(U.lapseN) ? Math.max(1e-6, +U.lapseN) : 1.0;
+  const b = Array.isArray(U.shiftBeta) ? U.shiftBeta.map(Number) : [0,0,0];
+  const n = viewN || [0,0,1];
+  return (1.0/N) - 1.0 + (b[0]*n[0] + b[1]*n[1] + b[2]*n[2]);
+}
+
 class WarpEngine {
   constructor(canvas) {
     // ... existing init ...
@@ -27,6 +64,12 @@ class WarpEngine {
   updateUniforms(parameters) {
     const U = this.uniforms || (this.uniforms = {});
     // Accept strict mode toggle up front
     if (typeof parameters.strictPhysics === "boolean") this.strictPhysics = !!parameters.strictPhysics;
 
+    // --- Metric uniforms (optional, tensor-first path) -----------------------
+    if (typeof parameters.metricMode === "boolean") U.metricMode = !!parameters.metricMode;
+    if (Array.isArray(parameters.gSpatialDiag)) U.gSpatialDiag = parameters.gSpatialDiag.slice(0,3).map(Number);
+    if (Array.isArray(parameters.gSpatialSym))  U.gSpatialSym  = parameters.gSpatialSym.slice(0,6).map(Number); // [gxx,gyy,gzz,gxy,gyz,gzx]
+    if (Number.isFinite(parameters.lapseN))      U.lapseN       = +parameters.lapseN;
+    if (Array.isArray(parameters.shiftBeta))     U.shiftBeta    = parameters.shiftBeta.slice(0,3).map(Number);
     // Axes first (strict mode will *require* these)
     if (Array.isArray(parameters.axesHull))  U.axesHull  = parameters.axesHull.slice(0,3);
     if (Array.isArray(parameters.axesScene)) U.axesScene = parameters.axesScene.slice(0,3);
@@ -120,12 +163,26 @@ class WarpEngine {
     // --- amplitude (theta) ---------------------------------------------------
     let theta = U.thetaScale;
     if (!Number.isFinite(theta)) {
       // Deterministic derive allowed when (and only when) all inputs are present
       const haveAll = Number.isFinite(U.gammaGeo)
                    && Number.isFinite(U.deltaAOverA)
                    && Number.isFinite(U.gammaVanDenBroeck)
                    && Number.isFinite(U.dutyEffectiveFR);
       if (!haveAll && this.strictPhysics) {
         U.__error = "warp-engine: thetaScale missing and inputs incomplete";
         return;
       }
       if (haveAll) {
         theta = Math.pow(U.gammaGeo, 3) * U.deltaAOverA * U.gammaVanDenBroeck * Math.sqrt(Math.max(1e-18, U.dutyEffectiveFR));
       }
     }
     this.uniforms.thetaScale_actual = theta;
 
+    // --- tensor diagnostics (derived) ---------------------------------------
+    if (U.metricMode && (U.gSpatialSym || U.gSpatialDiag)) {
+      U.thetaScale_metric = _thetaFromMetric(U);
+      // view axis: z in scene space (you can swap to camera-forward if you store it)
+      const viewN = [0,0,1];
+      U.redshiftProxy = _redshiftProxy(U, viewN);
+    } else {
+      U.thetaScale_metric = undefined;
+      U.redshiftProxy = undefined;
+    }
+
     // draw...
   }
 
@@ -135,16 +192,11 @@ class WarpEngine {
     // ... build grid lines ...
   }
 
-  // Replace Euclidean normalize/dot with metric-aware when U.metricMode
-  _dot(v, w) {
-    const U = this.uniforms || {};
-    if (U.metricMode && Array.isArray(U.gSpatialDiag)) {
-      const gx = +U.gSpatialDiag[0] || 1, gy = +U.gSpatialDiag[1] || 1, gz = +U.gSpatialDiag[2] || 1;
-      return gx*(v[0]||0)*(w[0]||0) + gy*(v[1]||0)*(w[1]||0) + gz*(v[2]||0)*(w[2]||0);
-    }
-    return (v[0]||0)*(w[0]||0) + (v[1]||0)*(w[1]||0) + (v[2]||0)*(w[2]||0);
-  }
-  _norm(v) {
-    const d = Math.sqrt(Math.max(1e-18, this._dot(v,v)));
-    return [ (v[0]||0)/d, (v[1]||0)/d, (v[2]||0)/d ];
-  }
+  // Metric-aware dot/normalize wrappers (use full g if provided)
+  _dot(v, w)  { const U = this.uniforms || {}; return (U.metricMode ? _dotG(v,w,U) : (v[0]||0)*(w[0]||0)+(v[1]||0)*(w[1]||0)+(v[2]||0)*(w[2]||0)); }
+  _norm(v)    { const U = this.uniforms || {}; return (U.metricMode ? _normG(v,U)    : (()=>{
+                    const d = Math.sqrt(Math.max(1e-18,(v[0]||0)*(v[0]||0)+(v[1]||0)*(v[1]||0)+(v[2]||0)*(v[2]||0)));
+                    return [(v[0]||0)/d,(v[1]||0)/d,(v[2]||0)/d];
+                })()); }
 }