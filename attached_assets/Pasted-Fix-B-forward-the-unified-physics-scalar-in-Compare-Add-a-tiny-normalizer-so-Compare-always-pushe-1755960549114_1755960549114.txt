Fix B — forward the unified physics scalar in Compare

Add a tiny normalizer so Compare always pushes the pipeline’s single source of truth to both engines before applyReal/applyShow.

1) Add helpers near the top of WarpBubbleCompare.tsx
function resolveThetaScale(p: any) {
  if (Number.isFinite(p?.thetaScale)) return Number(p.thetaScale);

  const gammaGeo = Number(p?.gammaGeo ?? 26);
  const qSpoil   = Number(p?.qSpoilingFactor ?? p?.deltaAOverA ?? 1);
  const gammaVdB = Number(p?.gammaVdB ?? p?.gammaVanDenBroeck ?? 2.86e5);
  const duty     = Number(p?.dutyCycle ?? 0.14);
  const sectors  = Math.max(1, Number(p?.sectors ?? p?.sectorCount ?? 1));
  const viewAvg  = (p?.viewAvg ?? true) ? 1 : 0;     // if you ever allow per-view toggles
  const A_geo    = Math.pow(Math.max(1, gammaGeo), 3);
  const dutyTerm = viewAvg ? Math.sqrt(Math.max(1e-12, duty / sectors)) : 1;
  return A_geo * Math.max(1e-12, qSpoil) * Math.max(1, gammaVdB) * dutyTerm;
}

function physicsPayload(p: any) {
  return {
    // the scalar the engine/shader both expect
    thetaScale: resolveThetaScale(p),

    // pieces (the CPU path in WarpEngine logs/uses these for diagnostics)
    dutyCycle: Number(p?.dutyCycle ?? 0.14),
    sectors: Math.max(1, Number(p?.sectors ?? p?.sectorCount ?? 1)),
    viewAvg: p?.viewAvg ?? true,
    gammaGeo: Number(p?.gammaGeo ?? 26),
    deltaAOverA: Number(p?.qSpoilingFactor ?? p?.deltaAOverA ?? 1),
    gammaVdB: Number(p?.gammaVdB ?? p?.gammaVanDenBroeck ?? 2.86e5),
  };
}

2) Push physics before styling in both effects

Right after you compute shared (and before applyReal/applyShow), push the physics payload to both engines:

In the first useEffect (bootstrap block):

const phys = physicsPayload(parameters);
pushUniformsWhenReady(leftEngine.current,  phys);
pushUniformsWhenReady(rightEngine.current, phys);


In the live-updates useEffect:

const phys = physicsPayload(parameters);
pushUniformsWhenReady(leftEngine.current,  phys);
pushUniformsWhenReady(rightEngine.current, phys);


That’s it. Your REAL pane stays parity-neutral, and the SHOW pane is no longer black and now “rides” on the same θ-scale as SliceViewer.