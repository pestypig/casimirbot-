Here’s a tight patch that makes lockPane the single authority (drop hardLockUniforms), preserves caller ridgeMode where provided, and guarantees cameraZ on both panes.

--- a/client/src/components/WarpRenderInspector.tsx
+++ b/client/src/components/WarpRenderInspector.tsx
@@
-// Hard-lock parity and block direct thetaScale writes at the engine edge
-function hardLockUniforms(engine: any, {
-  forceParity,
-  allowThetaScaleDirect = false,
-  tag = 'ENGINE'
-}: { forceParity: boolean; allowThetaScaleDirect?: boolean; tag?: string }) {
-  if (!engine || engine.__locked) return;
-  const orig = engine.updateUniforms?.bind(engine);
-  engine.updateUniforms = (patch: any) => {
-    const safe = { ...(patch || {}) };
-    // parity writes are forbidden
-    if ('physicsParityMode' in safe) {
-      emitDebug('warn', tag, 'blocked physicsParityMode override', {
-        value: (safe as any).physicsParityMode, from: findCaller()
-      });
-      delete (safe as any).physicsParityMode;
-    }
-    // ... (additional safety checks)
-  };
-  engine.__locked = true;
-}
+// NOTE: removed hardLockUniforms — having two wrappers races fields.
 
 // Hard-lock parity & block late thetaScale writers at the engine edge
 function lockPane(engine: any, pane: 'REAL' | 'SHOW') {
   if (!engine || engine.__locked) return;
   const orig = engine.updateUniforms?.bind(engine);
   engine.updateUniforms = (patch: any) => {
     const safe = normalizeKeys({ ...(patch || {}) });
-    if ('thetaScale' in safe) delete safe.thetaScale;
-    if ('ridgeMode'  in safe) delete safe.ridgeMode;
+    // Never accept direct θ writes; renderer derives θ from physics.
+    if ('thetaScale' in safe) delete safe.thetaScale;
     safe.physicsParityMode = (pane === 'REAL');
     safe.parityMode        = (pane === 'REAL');
-    safe.ridgeMode         = (pane === 'REAL') ? 0 : 1;
+    // Respect caller’s ridgeMode if set; else enforce pane default.
+    if (safe.ridgeMode == null) safe.ridgeMode = (pane === 'REAL') ? 0 : 1;
     return gatedUpdateUniforms({ updateUniforms: orig }, safe, `${pane.toLowerCase()}-locked`);
   };
   engine.__locked = true;
 }
@@
     // REAL (unchanged)
     if (leftRef.current && !leftEngine.current) {
       const dpr = Math.min(2, window.devicePixelRatio || 1);
       leftRef.current.width  = Math.max(1, Math.floor((leftRef.current.clientWidth  || 800) * dpr));
       leftRef.current.height = Math.max(1, Math.floor((leftRef.current.clientHeight || 450) * dpr));
       leftEngine.current = W.getOrCreate?.(leftRef.current) || new W(leftRef.current);
       leftOwnedRef.current = true;
       gatedUpdateUniforms(leftEngine.current, { exposure: 5.0, zeroStop: 1e-7 }, 'mute');
       leftEngine.current?.setVisible?.(false);
       lockPane(leftEngine.current, 'REAL');
     }
@@
     if (rightRef.current && !rightEngine.current) {
       const dpr = Math.min(2, window.devicePixelRatio || 1);
       rightRef.current.width  = Math.max(1, Math.floor((rightRef.current.clientWidth  || 800) * dpr));
       rightRef.current.height = Math.max(1, Math.floor((rightRef.current.clientHeight || 450) * dpr));
       rightEngine.current = W.getOrCreate?.(rightRef.current) || new W(rightRef.current);
       rightOwnedRef.current = true;
       gatedUpdateUniforms(rightEngine.current, { exposure: 5.0, zeroStop: 1e-7 }, 'mute');
       rightEngine.current?.setVisible?.(false);
       lockPane(rightEngine.current, 'SHOW');
-
-      // attach SHOW checkpoints so the panel/devtools get live data
+      // attach SHOW checkpoints so the panel/devtools get live data
       bindShowCheckpoints(rightEngine.current, rightRef.current);
     }
-
-    // parity hard-locks (keep)
-    if (leftEngine.current)  hardLockUniforms(leftEngine.current,  { forceParity: true,  tag: 'REAL' });
-    if (rightEngine.current) hardLockUniforms(rightEngine.current, { forceParity: false, allowThetaScaleDirect: true, tag: 'SHOW' });
+    // No extra hard lock — lockPane is the single authority now.
@@
   leftEngine.current?.onceReady?.(() => {
-    const ax = leftEngine.current?.uniforms?.axesClip;
+    // Ensure axesClip exists for a reliable cameraZ
+    let ax = leftEngine.current?.uniforms?.axesClip;
+    if (!ax) {
+      const hull = props.baseShared?.hull ?? { a:503.5, b:132, c:86.5 };
+      ax = deriveAxesClip(hull, 1);
+      gatedUpdateUniforms(leftEngine.current, { axesClip: ax }, 'inspector-left-axes');
+    }
     const cz = compactCameraZ(ax);
     gatedUpdateUniforms(leftEngine.current, { cameraZ: cz, lockFraming: true }, 'inspector-left-init');
     // B) WarpRenderInspector.tsx wire-in: Engine ready + RAF checkpoints
     setupEngineCheckpoints(leftEngine.current, 'REAL', realPayload);
   });
@@
   rightEngine.current?.onceReady?.(() => {
     // seed axes/camera immediately so buffers build and checkpoints flip to "set"
     const hull = props.baseShared?.hull ?? { a:503.5, b:132, c:86.5 };
     const ax = deriveAxesClip(hull, 1);
     const cz = compactCameraZ(ax);
-    gatedUpdateUniforms(rightEngine.current, { axesClip: ax, cameraZ: cz, lockFraming: true }, 'inspector-right-init');
+    gatedUpdateUniforms(rightEngine.current, { axesClip: ax, cameraZ: cz, lockFraming: true, ridgeMode: 1 }, 'inspector-right-init');
     
     // (Nice-to-have) instant grid buffers for the "0/0 floats" row
     rightEngine.current?.updateUniforms?.({
-      hull: props.baseShared?.hull ?? { a:503.5, b:132, c:86.5 },
-      wallWidth_m: props.baseShared?.wallWidth_m ?? 0.6,
-      ridgeMode: 1, colorMode: 'theta',
+      hull: props.baseShared?.hull ?? { a:503.5, b:132, c:86.5 },
+      wallWidth_m: props.baseShared?.wallWidth_m ?? 0.6,
+      physicsParityMode: false,
+      ridgeMode: 1, colorMode: 'theta',
     });
     rightEngine.current?.forceRedraw?.();
     
     // B) WarpRenderInspector.tsx wire-in: Engine ready + RAF checkpoints
     setupEngineCheckpoints(rightEngine.current, 'SHOW', showPayload);
   });