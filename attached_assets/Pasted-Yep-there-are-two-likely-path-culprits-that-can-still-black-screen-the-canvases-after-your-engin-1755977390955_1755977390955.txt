Yep — there are two likely “path” culprits that can still black-screen the canvases after your engine fixes:

the viewer tries to load the engine from an absolute /warp-engine.js (works locally, breaks under a sub-path),

your build “base”/public path in the JSON config (package.json / vite.config) doesn’t match where the app is actually served.

Below is a surgical patch that makes the loader path-aware and resilient, plus a tiny JSON tweak you can apply if you’re using CRA/Vite.

Patch 1 — make the script loader base-aware (no more “/warp-engine.js” trap)

File: client/src/components/warp/WarpVisualizer.tsx

@@
-      // Try fixed bundle, then fall back
-      const trySrcs = ['/warp-engine.js?v=canonical'];
+      // --- Robust asset base resolution (handles sub-path deploys, Next/Vite/CRA) ---
+      const resolveAssetBase = () => {
+        const w: any = window;
+        // explicit override wins
+        if (w.__ASSET_BASE__) return String(w.__ASSET_BASE__);
+        // Vite
+        if ((import.meta as any)?.env?.BASE_URL) return (import.meta as any).env.BASE_URL as string;
+        // Webpack public path
+        if (typeof (w.__webpack_public_path__) === 'string') return w.__webpack_public_path__;
+        // Next.js base path
+        if (typeof (w.__NEXT_DATA__)?.assetPrefix === 'string') return w.__NEXT_DATA__.assetPrefix || '/';
+        // <base href="..."> tag
+        const baseEl = document.querySelector('base[href]');
+        if (baseEl) return (baseEl as HTMLBaseElement).href;
+        return '/';
+      };
+
+      const assetBase = resolveAssetBase();
+      const stamp = (w => (w.__APP_WARP_BUILD || 'dev'))(window as any);
+      const mk = (p: string) => {
+        try { return new URL(p, assetBase).toString(); } catch { return p; }
+      };
+
+      // Try explicit override → base-aware → relative → root
+      const trySrcs = [
+        (window as any).__WARP_ENGINE_SRC__,
+        mk(`warp-engine.js?v=${encodeURIComponent(stamp)}`),
+        'warp-engine.js',
+        '/warp-engine.js?v=canonical'
+      ].filter(Boolean) as string[];
@@
-      for (const src of trySrcs) {
+      for (const src of trySrcs) {
         await new Promise<void>((resolve, reject) => {
           const script = document.createElement('script');
           script.src = src;
           script.async = true;
           script.onload = () => resolve();
-          script.onerror = () => reject(new Error(`Failed to load ${src}`));
+          script.onerror = () => reject(new Error(`Failed to load ${src}`));
           document.head.appendChild(script);
         }).catch((e) => { console.warn(e.message); });
@@
-      throw new Error("WarpEngine not found on window after script load");
+      throw new Error("WarpEngine not found on window after script load (check public path / base URL)");
