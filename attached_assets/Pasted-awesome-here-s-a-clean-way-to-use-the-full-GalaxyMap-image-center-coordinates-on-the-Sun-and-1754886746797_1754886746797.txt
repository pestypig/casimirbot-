awesome — here’s a clean way to use the **full GalaxyMap image**, center coordinates on the Sun, and keep distances correct in **parsecs**, with pan/zoom so the big PNG stays crisp.

---

# How we calibrate (once per image)

You only need two numbers:

1. **originPx = (x₀, y₀)** → the pixel of **Sol** on the PNG
2. **scalePxPerPc** → how many pixels equal **1 parsec** at that image scale

## Quick ways to get them

* Open the PNG in a browser → right–click → “Open image in new tab”.
* Press `Ctrl+Shift+C` (devtools), hover the Sun label until the tooltip shows its pixel position. That’s `(x₀,y₀)`.
* For **scale**, measure pixel distance between two **concentric distance rings** on the map (e.g., 0 pc to 100 pc tick).

  * If 100 pc ring is Δp pixels from the center → `scalePxPerPc = Δp / 100`.
  * Or measure any known separation (e.g., a legend with a fixed pc span).

You can change both later without touching data.

---

# Drop-in: Pan/Zoom GalaxyMap (pc grid centered on Sun)

This version keeps your **pc→px mapping** exact, draws glowing routes, and lets you pan/zoom a giant image without losing detail.

```tsx
// client/src/components/GalaxyMapPanZoom.tsx
import * as React from "react";
import { Body } from "@/lib/galaxy-schema";

type Props = {
  imageUrl: string;
  bodies: Body[];
  routeIds?: string[];
  // calibration
  originPx: {x:number,y:number};     // pixel of Sol in the image
  scalePxPerPc: number;              // pixels per parsec
  // viewport size
  width?: number; height?: number;
  onPickBody?: (id:string)=>void;
};

export function GalaxyMapPanZoom({
  imageUrl, bodies, routeIds = [],
  originPx, scalePxPerPc,
  width = 1024, height = 600,
  onPickBody
}: Props) {
  const containerRef = React.useRef<HTMLDivElement>(null);
  const imgRef = React.useRef<HTMLImageElement>(null);
  const canvasRef = React.useRef<HTMLCanvasElement>(null);

  const [zoom, setZoom] = React.useState(1);
  const [offset, setOffset] = React.useState({ x: 0, y: 0 }); // px in screen coords
  const dragging = React.useRef<null | {x:number;y:number}>(null);

  // pc -> image pixels (untransformed)
  const toImgPx = React.useCallback((xpc:number, ypc:number) => ({
    x: originPx.x + xpc * scalePxPerPc,
    y: originPx.y - ypc * scalePxPerPc,
  }), [originPx, scalePxPerPc]);

  // draw route + markers on canvas (already positioned/scaled by CSS)
  React.useEffect(() => {
    const cvs = canvasRef.current; const img = imgRef.current;
    if (!cvs || !img) return;
    const ctx = cvs.getContext("2d"); if (!ctx) return;
    const { width:w, height:h } = cvs;
    ctx.clearRect(0,0,w,h);

    // transform image->screen: (imgPx * zoom) + offset
    const imgToScreen = (p:{x:number;y:number}) => ({ x: p.x*zoom + offset.x, y: p.y*zoom + offset.y });

    // route glow
    const routeBodies = routeIds.map(id => bodies.find(b=>b.id===id)).filter(Boolean) as Body[];
    if (routeBodies.length >= 2) {
      ctx.save();
      ctx.lineJoin = "round"; ctx.lineCap = "round";
      for (const pass of [10,6,3]) {
        ctx.beginPath();
        routeBodies.forEach((b,i) => {
          const pImg = toImgPx(b.x_pc, b.y_pc);
          const p = imgToScreen(pImg);
          if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        });
        ctx.strokeStyle = `rgba(120, 90, 255, ${pass===10?0.08: pass===6?0.18:0.9})`;
        ctx.lineWidth = pass;
        ctx.stroke();
      }
      ctx.restore();
    }

    // waypoints
    for (const b of bodies) {
      const pImg = toImgPx(b.x_pc, b.y_pc);
      const p = imgToScreen(pImg);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2);
      ctx.fillStyle = routeIds.includes(b.id) ? "#ffd166" : "#7dd3fc";
      ctx.fill();
    }
  }, [bodies, routeIds, zoom, offset, toImgPx]);

  // panning
  const onMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {
    dragging.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
  };
  const onMouseMove: React.MouseEventHandler<HTMLDivElement> = (e) => {
    if (!dragging.current) return;
    setOffset({ x: e.clientX - dragging.current.x, y: e.clientY - dragging.current.y });
  };
  const onMouseUp = () => (dragging.current = null);

  // zoom (center on mouse)
  const onWheel: React.WheelEventHandler<HTMLDivElement> = (e) => {
    e.preventDefault();
    const rect = containerRef.current!.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const dz = Math.exp(-e.deltaY * 0.001); // smooth zoom
    const newZoom = Math.max(0.2, Math.min(6, zoom * dz));
    // keep point under mouse stable: adjust offset
    const sx = (mx - offset.x) / zoom;
    const sy = (my - offset.y) / zoom;
    setOffset({ x: mx - sx*newZoom, y: my - sy*newZoom });
    setZoom(newZoom);
  };

  // click-picking of bodies
  const onClick: React.MouseEventHandler<HTMLCanvasElement> = (e) => {
    if (!onPickBody) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    // screen->image px
    const ix = (x - offset.x) / zoom;
    const iy = (y - offset.y) / zoom;
    // find nearest body (hit radius in img px)
    let min = Infinity, hit: Body | null = null;
    for (const b of bodies) {
      const p = toImgPx(b.x_pc, b.y_pc);
      const d2 = (ix - p.x)**2 + (iy - p.y)**2;
      if (d2 < min && d2 < 12**2) { min = d2; hit = b; }
    }
    if (hit) onPickBody(hit.id);
  };

  return (
    <div
      ref={containerRef}
      onMouseDown={onMouseDown}
      onMouseMove={onMouseMove}
      onMouseLeave={onMouseUp}
      onMouseUp={onMouseUp}
      onWheel={onWheel}
      className="relative overflow-hidden rounded-lg border bg-black"
      style={{ width, height, cursor: dragging.current ? "grabbing" : "grab" }}
    >
      <img
        ref={imgRef}
        src={imageUrl}
        alt="Galaxy Map"
        className="absolute top-0 left-0 select-none pointer-events-none"
        style={{ transform: `translate(${offset.x}px,${offset.y}px) scale(${zoom})`, transformOrigin: "0 0" }}
      />
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        onClick={onClick}
        className="absolute inset-0"
        style={{ pointerEvents: "auto" }}
      />
    </div>
  );
}
```

### Use it (with your full-res PNG)

```tsx
<GalaxyMapPanZoom
  imageUrl="/galaxymap_full.png"   // put your big PNG in /public
  bodies={BODIES}
  routeIds={route}
  originPx={{ x: /* SOL x px */, y: /* SOL y px */ }}
  scalePxPerPc={/* pixels per parsec from ring measurement */}
  width={1200}
  height={650}
  onPickBody={(id)=> setRoute(r=> r.length ? [...r.slice(0,-1), id, r[r.length-1]] : [id])}
/>
```

---

# Optional: quick calibration UI (two clicks)

If you’d prefer not to measure in devtools, add a simple “Calibrate” mode:

* **Click 1:** Sol → sets `originPx`
* **Click 2:** a ring labeled “100 pc” → computes `scalePxPerPc = distance(Sol→Ring) / 100`

I can give you that tiny overlay if you want it — it’s \~30 lines.

---

# Sign convention (so catalog stays sane)

* **x\_pc**: increases **to the right** (east on the map)
* **y\_pc**: increases **up** (north on the map)
* Pixel mapping is `px = x₀ + x_pc * scale`, `py = y₀ − y_pc * scale` (minus because screen y grows downward).

---

# Tying to ETA/Energy

The **RouteSteps** and **FuelGauge** you have already use:

* `vEffLyPerHour(mode,duty)` (same as before)
* `energyPerLyMWh` and optional `energyPerCycleJ`

So as soon as you set `originPx` and `scalePxPerPc`, the route legs will show **distance (pc/ly)**, **ETA**, **MWh**, and **cycles** — all driven by your live Helix-Core tuning.

---

Want me to add the **calibration overlay** next (two-click set-up for origin/scale), or seed a larger **BODIES catalog** (Betelgeuse, Vela SNR, Cas A, Taurus, Orion OB1-4) with approximate pc coordinates so you can start plotting missions immediately?
