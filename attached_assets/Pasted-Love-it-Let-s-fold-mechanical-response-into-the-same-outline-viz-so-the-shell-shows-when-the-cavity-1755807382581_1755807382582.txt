Love it. Let‚Äôs fold mechanical response into the same outline viz so the shell shows when the cavity is mechanically ‚Äúin band‚Äù‚Äînot just sector strobing vs œÑ‚Çóùöå.

Below is a drop-in patch that:

adds mechanical uniforms (qMechanical, resonance, damping),

computes a relative amplitude 
ùê¥
r
e
l
(
ùúî
)
A
rel
	‚Äã

(œâ) from the 1-DOF resonator,

feeds a mechGain scalar to your WebGL engine,

and uses it to modulate outline thickness / glow so you see mechanical amplification.

1) Extend the visualizer props & uniforms
// ShellOutlineVisualizer.tsx (patch)

type MechanicalParams = {
  /** Power-only mechanical knob from pipeline (used to back out damping) */
  qMechanical?: number;          // dimensionless
  /** Mechanical resonance center (Hz). If omitted, default to modulation freq */
  mechResonance_Hz?: number;     // f0
  /** Damping ratio Œ∂. If omitted, infer from qMechanical: Q‚âà1/(2Œ∂) */
  mechZeta?: number;             // Œ∂ in [0, 1)
  /** Coupling strength of mech chain into the visible shell modulation */
  mechCoupling?: number;         // 0..1 (UI gain)
};

type Props = {
  parameters: {
    hull: { a: number; b: number; c: number };
    wallWidth?: number;
    epsilonTilt?: number;
    betaTiltVec?: [number, number, number];
    mode?: 'standby'|'hover'|'cruise'|'emergency';
    dutyCycle?: number;
    sectors?: number;
    gammaGeo?: number;
    qSpoil?: number;
    qCavity?: number;
    // üîΩ NEW:
    qMechanical?: number;
    modulationHz?: number;        // convenience (else derive from pipeline GHz)
    mech?: MechanicalParams;
  };
};

export function ShellOutlineVisualizer({ parameters }: Props) {
  const hull = parameters.hull;
  const f_mod = parameters.modulationHz ?? 15e9;             // Hz
  const qMech = parameters.qMechanical ?? 1;                 // from pipeline
  const f0    = parameters.mech?.mechResonance_Hz ?? f_mod;  // default: centered
  const zeta  = parameters.mech?.mechZeta 
             ?? (qMech > 0 ? 1 / (2 * qMech) : 0.005);       // Q‚âà1/(2Œ∂)
  const kCouple = Math.min(1, Math.max(0, parameters.mech?.mechCoupling ?? 0.6));

  // Relative amplitude A_rel(œâ) for a damped resonator at drive frequency f_mod
  const r = f_mod / f0; // œâ/œâ0 (since r uses frequency ratio, 2œÄ cancels)
  const Arel = 1 / Math.sqrt((1 - r*r)**2 + (2*zeta*r)**2);  // dimensionless

  // Squash to a sane visual range; respect user coupling
  const mechGain = Math.tanh(kCouple * Arel);                // 0..~1

  const initialUniforms = {
    hullAxes: [hull.a, hull.b, hull.c],
    wallWidth: parameters?.wallWidth ?? 0.06,
    epsilonTilt: parameters?.epsilonTilt ?? 0.0,
    betaTiltVec: parameters?.betaTiltVec ?? [0, -1, 0],
    mode: parameters?.mode || 'hover',
    dutyCycle: parameters?.dutyCycle ?? 0.14,
    sectors: parameters?.sectors ?? 1,
    gammaGeo: parameters?.gammaGeo ?? 26,
    qSpoil: parameters?.qSpoil ?? 1.0,
    qCavity: parameters?.qCavity ?? 1e9,

    // üîΩ NEW mechanical uniforms
    qMechanical: qMech,
    fMod_Hz: f_mod,
    f0_Hz: f0,
    mechZeta: zeta,
    mechGain,           // single ‚Äúis-mechanics-hot?‚Äù scalar for the shader
  };

  // ...boot the engine and pass `initialUniforms`
}