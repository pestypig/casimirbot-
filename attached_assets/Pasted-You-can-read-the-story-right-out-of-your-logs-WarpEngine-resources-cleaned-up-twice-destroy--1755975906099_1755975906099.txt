You can read the story right out of your logs:

WarpEngine resources cleaned up (twice) → destroy() ran on both engines (programs & buffers deleted).

Immediately after: Render blocked - missing requirements: { … gridProgram: false … } → the render loop is still ticking, but the shader program was deleted, so draws are skipped.

This almost always happens because the viewer component gets unmounted/re-mounted during a mode switch (often due to a key change or an error path). The 400/429 requests you see on the mode toggle likely trigger that re-render path.

So rendering didn’t “freeze”; the engines were destroyed mid-flight, and nothing rebuilt the GL program before uniforms kept streaming in.

Below are small, surgical hardening patches that make the viewer resilient even if React unmounts or GL hiccups happen.

1) Make the engine self-healing after destroy/context issues

file: client/public/warp-engine.js

Add a destroyed flag and auto-relink if a draw sees no program.

 class WarpEngine {
   constructor(canvas) {
+    this._destroyed = false;
     …
+    // Handle GL context loss/recovery internally
+    canvas.addEventListener('webglcontextlost', (e) => {
+      try { e.preventDefault(); } catch {}
+      this._setLoaded(false);
+      console.warn('[WarpEngine] WebGL context lost');
+    }, false);
+    canvas.addEventListener('webglcontextrestored', () => {
+      console.warn('[WarpEngine] WebGL context restored; rebuilding GL resources');
+      try { this._recreateGL(); } catch (e) { console.error(e); }
+    }, false);
   }
 
+  _recreateGL() {
+    // Reacquire context, rebuild buffers & shaders
+    this.gl = this.canvas.getContext('webgl2', { alpha:false, antialias:false, powerPreference:'high-performance', desynchronized:true })
+      || this.canvas.getContext('webgl', { alpha:false, antialias:false, powerPreference:'high-performance', desynchronized:true });
+    if (!this.gl) throw new Error('WebGL not supported after restore');
+    this.gridProgram = null;
+    this.gridVbo = null;
+    this._initializeGrid();        // re-create VBO + compile shaders
+    this._setLoaded(false);        // will flip to true in _compileGridShaders on ready
+    this._resizeCanvasToDisplaySize();
+  }
+
   _render() {
-    const gl = this.gl;
-    // Clear the screen
-    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
-    // Render the spacetime grid
-    this._renderGridPoints();
+    if (this._destroyed) return;
+    const gl = this.gl;
+    // Guard: if program got torn down, try to rebuild once
+    if (!this.gridProgram && gl) {
+      try { this._compileGridShaders(); } catch (e) { console.warn('Autorelink failed:', e); }
+      return; // wait for shaders to (a)synchronously link
+    }
+    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+    this._renderGridPoints();
     …
   }
 
   updateUniforms(parameters) {
+    if (this._destroyed) return;
     if (!parameters) return;
     …
   }
 
   destroy() {
+    if (this._destroyed) return;
+    this._destroyed = true;
     // Clean up per-canvas guard
     …
     console.log("WarpEngine resources cleaned up");
   }
 }

2) Stop pushing uniforms to a torn-down engine

file: client/src/components/warp/WarpBubbleCompare.tsx

Make the RAF re-push helper bail out if the target was destroyed/unmounted.

 function pushUniformsWhenReady(engine: any, payload: any, retries = 24) {
-  if (!engine) return;
+  if (!engine || (engine._destroyed === true)) return;
   const bundle = compatifyUniforms(payload);
 
   const tryPush = () => {
-    try { engine.updateUniforms?.(bundle); } catch {}
-    try { engine.setParams?.(bundle); }      catch {}
+    if (!engine || engine._destroyed) return;
+    try { engine.updateUniforms?.(bundle); } catch {}
+    try { engine.setParams?.(bundle); }      catch {}
   };
   tryPush();
-  if (retries > 0) {
-    requestAnimationFrame(() => pushUniformsWhenReady(engine, payload, retries - 1));
-  }
+  if (retries > 0) {
+    requestAnimationFrame(() => {
+      if (!engine || engine._destroyed) return;
+      pushUniformsWhenReady(engine, payload, retries - 1);
+    });
+  }
 }


And, when wiring GL loss guards, call the engine’s re-create instead of a plain resize:

-attachGLContextGuards(leftRef.current!,  () => leftEngine.current?._resize?.());
-attachGLContextGuards(rightRef.current!, () => rightEngine.current?._resize?.());
+attachGLContextGuards(leftRef.current!,  () => leftEngine.current?.recreateGL?.());
+attachGLContextGuards(rightRef.current!, () => rightEngine.current?.recreateGL?.());


(If your attachGLContextGuards lives only here, keep it. The engine also installs its own guards now; doubling up is harmless.)

3) Keep the component mounted across mode switches (React side)

Double-check the parent doesn’t do something like:

<WarpBubbleCompare key={mode} … />


If it does, remove that key so the engines aren’t destroyed/recreated on each mode change. Also debounce the mode toggle mutations to avoid the 400/429 storm (those failures often trigger error boundaries or re-renders that unmount the viewer).

Example debounce (pseudo):

const mutateMode = useMemo(() => debounce(realMutate, 150), []);

Why the specific logs you saw?

“resources cleaned up” → destroy() ran (unmount or an explicit call).

“Render blocked … gridProgram: false” → the shader program was deleted by destroy(). The loop kept running and correctly refused to draw without a program.

Many pushUniformsWhenReady frames → our helper kept queueing uniform pushes even though the engine was gone. Patch #2 stops that.

400/429 network errors → the operational-mode toggle spammed backend mutations; that likely triggered UI state that unmounted/remounted the viewer, which caused the destroy.

Apply these and the viewer will (a) not die on mode flips, (b) recover automatically if GL gets reset, and (c) stop spamming uniforms into a dead engine.