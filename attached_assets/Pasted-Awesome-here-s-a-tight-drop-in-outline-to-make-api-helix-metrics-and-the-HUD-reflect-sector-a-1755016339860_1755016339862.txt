Awesome—here’s a tight, drop-in outline to make `/api/helix/metrics` (and the HUD) reflect *sector-aware Ford–Roman* and feed the Tile Grid with the same truth.

---

# 1) Energy pipeline: compute ζ with sector scaling (once)

**File:** `server/energy-pipeline.ts`
**Place:** right after you set/derive `state.sectorStrobing`, `state.dutyCycle`, `state.qSpoilingFactor`, and `state.N_tiles`.

Add (or replace your ζ block) with this:

```ts
// ----- Sector model (consistent across modes) -----
const TOTAL_SECTORS = 400;                           // Fixed logical partitioning
const activeSectors = Math.max(1, state.sectorStrobing);
const activeFraction = activeSectors / TOTAL_SECTORS;
const tilesPerSector = Math.floor(state.N_tiles / TOTAL_SECTORS);
const activeTiles = tilesPerSector * activeSectors;

// Export so /metrics can expose same numbers
state.__sectors = { TOTAL_SECTORS, activeSectors, activeFraction, tilesPerSector, activeTiles };

// ----- Ford–Roman proxy with time-sliced strobing -----
// Instantaneous duty seen by a local observer inside an energized sector
const dutyInstant = state.dutyCycle * state.qSpoilingFactor;

// Effective duty used in ζ after strobing fraction is applied
const dutyEffectiveFR = dutyInstant * activeFraction;

// Quantum cavity Q used for the Ford–Roman inequality proxy
const Q_quantum = 1e10;

// ζ = 1 / (duty_eff * sqrt(Q))
state.zeta = 1 / (dutyEffectiveFR * Math.sqrt(Q_quantum));
// Compliance
state.fordRomanCompliance = state.zeta < 1.0;

// Keep these around for the metrics + HUD
state.__fr = {
  dutyInstant,            // e.g. 0.14 in hover
  dutyEffectiveFR,        // scaled by sectors
  Q_quantum,
};
```

> Notes
>
> * `TOTAL_SECTORS` is fixed (400) so **hover** = 1/400 active, **cruise** can still be `activeSectors=400` (or whatever your mode table says), and **emergency** can go back to 1 or a few—your choice.
> * This is the single source of truth—no recomputations in the controller.

---

# 2) Metrics endpoint: surface the sector truth

**File:** `server/helix-core.ts`
**Function:** `getSystemMetrics`

Replace the JSON body with:

```ts
export function getSystemMetrics(req: Request, res: Response) {
  const s = getGlobalPipelineState();
  const sec = s.__sectors ?? { TOTAL_SECTORS: 400, activeSectors: 1, activeFraction: 1/400, tilesPerSector: Math.floor(s.N_tiles/400), activeTiles: Math.floor(s.N_tiles/400) };
  const fr  = s.__fr ?? { dutyInstant: s.dutyCycle * s.qSpoilingFactor, dutyEffectiveFR: (s.dutyCycle * s.qSpoilingFactor) * sec.activeFraction, Q_quantum: 1e10 };

  res.json({
    // tile/sector truth (these are what your Tile Grid should use)
    totalTiles: Math.floor(s.N_tiles),
    activeTiles: Math.floor(sec.activeTiles),
    tilesPerSector: sec.tilesPerSector,
    totalSectors: sec.TOTAL_SECTORS,
    activeSectors: sec.activeSectors,
    activeFraction: sec.activeFraction,

    // timing (optional but nice for the HUD)
    strobeHz: s.modulationFreq_GHz * 1e9 / sec.TOTAL_SECTORS,        // per sector sweep rate
    sectorPeriod_ms: 1000 * sec.TOTAL_SECTORS / (s.modulationFreq_GHz * 1e9),

    // core outputs
    energyOutput: s.P_avg,                 // MW (your calibrated target)
    exoticMass: Math.round(s.M_exotic),    // kg (calibrated/paper value)
    exoticMassRaw: Math.round(s.M_exotic_raw ?? s.M_exotic), // if you keep a raw

    // FR & friends
    dutyGlobal: s.dutyCycle,
    dutyInstant: fr.dutyInstant,
    dutyEffectiveFR: fr.dutyEffectiveFR,
    gammaVanDenBroeck: s.gammaVanDenBroeck,
    gammaGeo: s.gammaGeo,
    qCavity: s.qCavity,

    fordRoman: {
      value: s.zeta,
      limit: 1.0,
      status: s.fordRomanCompliance ? "PASS" : "FAIL"
    },
    natario: {
      value: 0,
      status: s.natarioConstraint ? "VALID" : "WARN"
    },
    curvatureMax: Math.abs(s.U_cycle) / (3e8 * 3e8),
    timeScaleRatio: s.TS_ratio,
    overallStatus: s.overallStatus ?? (s.fordRomanCompliance ? "NOMINAL" : "CRITICAL"),

    // optional debugging breadcrumbs
    modelMode: s.modelMode ?? "calibrated"
  });
}
```

---

# 3) HUD/UI tweaks (optional but recommended)

**File:** `client/src/pages/helix-core.tsx` (your Compliance HUD display)

* Show ζ with 3–4 sig figs so we can distinguish `7.14e-5` from `0.000`:

```tsx
const fmtExp = (x:number) => (isFinite(x) ? x.toExponential(2) : "—");

{/* Ford–Roman Inequality */}
<Badge variant={metrics.fordRoman.status === "PASS" ? "success" : "destructive"}>
  ζ = {fmtExp(metrics.fordRoman.value)}
  &nbsp;{metrics.fordRoman.status}
</Badge>
```

* In the **tile grid card**, use:

  * `activeSectors/totalSectors`
  * `activeTiles/totalTiles`
  * `tilesPerSector`

This keeps the UI and the HUD reading from the same physics source.

---

## What this fixes

* **Consistency:** Hover, Cruise, Emergency now use the **same** sector model for ζ. No more “hover looks safe, cruise fails randomly”.
* **Truth in metrics:** The “Active Tiles” number no longer lies—it’s derived from sectors and `tilesPerSector`.
* **Single source of physics:** `/api/helix/metrics` and the HUD display the same ζ the pipeline computed; no duplicated math in the controller or UI.
* **Debuggable:** If ζ looks off, you can immediately see `dutyInstant`, `dutyEffectiveFR`, `activeSectors`, `activeFraction`.

---

If you paste these blocks as-is, your **Ford–Roman** status in all modes should line up with the time-sliced strobing derivation, and the **Casimir Tile Grid** will get exactly the counts it needs to light up the correct number of sectors/tiles. Want me to also wire a tiny “sector sweep” animation for the grid using `strobeHz` and `sectorPeriod_ms`?
