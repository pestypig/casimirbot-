// /hooks/use-show-canvas-density.ts
import { useEffect, useRef } from "react";

type EngineLike = {
  setPixelRatio?: (pr: number) => void;
  setSupersample?: (ss: number) => void;
  _resize?: () => void;
  forceRedraw?: () => void;
  setVisible?: (on: boolean) => void;
};

type Opts = {
  engineRef: React.MutableRefObject<EngineLike | null>;
  canvasRef: React.MutableRefObject<HTMLCanvasElement | null>;
  /** hard cap on devicePixelRatio (pre-SSAA) */
  maxDPR?: number;
  /** floor on devicePixelRatio (pre-SSAA) */
  minDPR?: number;
  /** default supersample multiplier (1.0 = off) */
  ssaa?: number;
  /** adapt SSAA down when the render target is “too big” */
  adaptive?: boolean;
  /**
   * megapixel budget before SSAA is reduced (clientWidth×clientHeight×dpr² / 1e6)
   * e.g., 3.0 => keep SSAA when under ~3MP effective pixels
   */
  targetMP?: number;
  /** debounce in ms for resize/RO (small values feel snappier) */
  debounceMs?: number;
};

export function useShowCanvasDensity({
  engineRef,
  canvasRef,
  maxDPR = 2,
  minDPR = 1,
  ssaa = 1.25,
  adaptive = true,
  targetMP = 3.0,
  debounceMs = 60,
}: Opts) {
  const rafRef = useRef<number | null>(null);
  const toRef = useRef<number | null>(null);

  // Compute the effective DPR & SSAA given current canvas size
  const computeSettings = () => {
    const baseDPR = Math.min(maxDPR, Math.max(minDPR, typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1));
    const cv = canvasRef.current;
    const w = Math.max(1, Math.floor((cv?.clientWidth ?? cv?.width ?? 800)));
    const h = Math.max(1, Math.floor((cv?.clientHeight ?? cv?.height ?? 450)));

    let ss = ssaa;
    if (adaptive) {
      const mp = (w * h * baseDPR * baseDPR) / 1e6;
      if (mp > targetMP) ss = 1.0; // drop SSAA on large targets
    }
    const effPR = baseDPR * ss;
    return { baseDPR, ss, effPR, w, h };
  };

  const apply = () => {
    const eng = engineRef.current;
    const cv = canvasRef.current;
    if (!eng || !cv) return;

    const { baseDPR, ss, effPR, w, h } = computeSettings();

    // Preferred path: tell engine to scale + resize
    eng.setPixelRatio?.(baseDPR);
    eng.setSupersample?.(ss);
    eng._resize?.();

    // Fallback for engines without DPR/SSAA knobs
    if (!eng.setPixelRatio || !eng.setSupersample) {
      const pxW = Math.max(1, Math.floor(w * effPR));
      const pxH = Math.max(1, Math.floor(h * effPR));
      if (cv.width !== pxW || cv.height !== pxH) {
        cv.width = pxW;
        cv.height = pxH;
      }
    }

    // Nudge a redraw to avoid a “stale” first frame
    eng.forceRedraw?.();
  };

  // Debounced update
  const schedule = () => {
    if (toRef.current) window.clearTimeout(toRef.current);
    toRef.current = window.setTimeout(() => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(apply);
    }, debounceMs);
  };

  useEffect(() => {
    const cv = canvasRef.current;
    if (!cv) return;

    // Initial apply (when engine becomes available)
    schedule();

    const ro = new ResizeObserver(schedule);
    ro.observe(cv);

    // Window-level signals that typically change DPR or layout
    const onResize = schedule;
    const onOrient = schedule;
    const onVisible = () => {
      if (document.visibilityState === "visible") schedule();
    };

    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onOrient);
    document.addEventListener("visibilitychange", onVisible);

    return () => {
      ro.disconnect();
      window.removeEventListener("resize", onResize);
      window.removeEventListener("orientationchange", onOrient);
      document.removeEventListener("visibilitychange", onVisible);
      if (toRef.current) window.clearTimeout(toRef.current);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [engineRef, canvasRef, maxDPR, minDPR, ssaa, adaptive, targetMP, debounceMs]);
}
Use it in your inspector (SHOW pane)
Just drop this near the bottom of WarpRenderInspector (or right after you create the engines):

tsx
Copy
Edit
import { useShowCanvasDensity } from "@/hooks/use-show-canvas-density";

// …

useShowCanvasDensity({
  engineRef: rightEngine,
  canvasRef: rightRef,
  maxDPR: 2,       // good default cap
  ssaa: 1.25,      // gentle sharpening
  adaptive: true,  // auto drop SSAA if target gets huge
  targetMP: 3.0,   // ~3 megapixels budget at effective DPR
});

// (Optional) also keep REAL crisp:
useShowCanvasDensity({
  engineRef: leftEngine,
  canvasRef: leftRef,
  maxDPR: 2,
  ssaa: 1.0,       // parity pane can stay non-SSAA
  adaptive: true,
  targetMP: 2.5,
});