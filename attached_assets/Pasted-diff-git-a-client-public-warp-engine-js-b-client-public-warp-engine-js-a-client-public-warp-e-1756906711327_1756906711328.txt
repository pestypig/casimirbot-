diff --git a/client/public/warp-engine.js b/client/public/warp-engine.js
--- a/client/public/warp-engine.js
+++ b/client/public/warp-engine.js
@@ -40,6 +40,18 @@ class WarpEngine {
   constructor(gl) {
     this.gl = gl;
     this.gridProgram = null;
+    this.strictScientific = true;
+    this._lc = {
+      tauLC_ms: undefined, dwell_ms: undefined, burst_ms: undefined,
+      phase: undefined, onWindow: false, sectorIdx: undefined, sectorCount: undefined,
+    };
+    // public bag; viewers read here (inspector/checkpoints)
+    this.uniforms = {};
   }
@@ -118,6 +130,23 @@ class WarpEngine {
     return this;
   }
 
+  // LC setter (mirrors to uniforms)
+  setLightCrossing(info = {}) {
+    const L = this._lc || {};
+    L.tauLC_ms    = fin(info.tauLC_ms);
+    L.dwell_ms    = fin(info.dwell_ms);
+    L.burst_ms    = fin(info.burst_ms);
+    L.phase       = fin(info.phase);
+    L.onWindow    = !!info.onWindow;
+    L.sectorIdx   = int(info.sectorIdx);
+    L.sectorCount = int(info.sectorCount);
+    this._lc = L;
+    Object.assign(this.uniforms, {
+      tauLC_ms: L.tauLC_ms, dwell_ms: L.dwell_ms, burst_ms: L.burst_ms,
+      phase: L.phase, onWindow: L.onWindow ? 1 : 0, sectorIdx: L.sectorIdx, sectorCount: L.sectorCount,
+    });
+    return this;
+  }
   _bindGridUniformLocations(gl, program) {
     const loc = (this.gridUniforms = this.gridUniforms || {});
     // existing locationsâ€¦
@@ -132,6 +161,15 @@ class WarpEngine {
     loc.metricOn     = gl.getUniformLocation(program, 'u_metricOn');
     loc.viewForward  = gl.getUniformLocation(program, 'u_viewForward');
     loc.g0i          = gl.getUniformLocation(program, 'u_g0i');
+    // LC
+    loc.tauLC_ms     = gl.getUniformLocation(program, 'u_tauLC_ms');
+    loc.dwell_ms     = gl.getUniformLocation(program, 'u_dwell_ms');
+    loc.burst_ms     = gl.getUniformLocation(program, 'u_burst_ms');
+    loc.phase        = gl.getUniformLocation(program, 'u_phase');
+    loc.onWindow     = gl.getUniformLocation(program, 'u_onWindow');
+    loc.sectorIdx    = gl.getUniformLocation(program, 'u_sectorIdx');
+    loc.sectorCount  = gl.getUniformLocation(program, 'u_sectorCount');
+    loc.dutyUsed     = gl.getUniformLocation(program, 'u_dutyUsed');
   }
@@ -186,6 +224,25 @@ class WarpEngine {
     Object.assign(this.uniforms, parameters || {});
 
+    if (this.strictScientific) {
+      const U = this.uniforms, L = this._lc || {};
+      const miss = [];
+      if (!isF(U.thetaScale))      miss.push('thetaScale');
+      if (!isF(U.gammaGeo))        miss.push('gammaGeo');
+      if (!isF(U.qSpoilingFactor)) miss.push('qSpoiling');
+      if (!isF(U.gammaVdB))        miss.push('gammaVdB');
+      if (!isF(U.sectorCount))     miss.push('sectorCount');
+      if (!isF(U.dutyUsed))        miss.push('dutyUsed');
+      if (!isF(L.tauLC_ms) || !isF(L.dwell_ms) || !isF(L.burst_ms)) miss.push('LC(tauLC_ms/dwell_ms/burst_ms)');
+      this.uniforms.__error = miss.length ? `engine(strict): missing ${miss.join(', ')}` : undefined;
+    }
+
     if (this.isLoaded && this.gl && this.gridProgram) {
       this._applyUniformsNow();
     }
   }
   _applyUniformsNow() {
@@ -206,6 +263,18 @@ class WarpEngine {
     if (loc.g0i && Array.isArray(U.g0i)) gl.uniform3f(loc.g0i, +U.g0i[0]||0, +U.g0i[1]||0, +U.g0i[2]||0);
+    // LC uploads
+    const L = this._lc || {};
+    if (loc.tauLC_ms)     gl.uniform1f(loc.tauLC_ms,  isF(L.tauLC_ms) ? +L.tauLC_ms : 0.0);
+    if (loc.dwell_ms)     gl.uniform1f(loc.dwell_ms,  isF(L.dwell_ms) ? +L.dwell_ms : 0.0);
+    if (loc.burst_ms)     gl.uniform1f(loc.burst_ms,  isF(L.burst_ms) ? +L.burst_ms : 0.0);
+    if (loc.phase)        gl.uniform1f(loc.phase,     isF(L.phase) ? +L.phase : 0.0);
+    if (loc.onWindow)     gl.uniform1f(loc.onWindow,  L.onWindow ? 1.0 : 0.0);
+    if (loc.sectorIdx)    gl.uniform1i(loc.sectorIdx, isF(L.sectorIdx) ? +L.sectorIdx : 0);
+    if (loc.sectorCount)  gl.uniform1i(loc.sectorCount, isF(L.sectorCount) ? +L.sectorCount : 1);
+    if (loc.dutyUsed && isF(U.dutyUsed)) gl.uniform1f(loc.dutyUsed, +U.dutyUsed);
+    // metric path mirror (no boosts)
+    if (typeof U.metricMode === 'boolean') gl.uniform1f(loc.metricOn, U.metricMode ? 1.0 : 0.0);
   }
 }
-function isF(x){ return Number.isFinite(+x); }
+function fin(x){ const n=+x; return Number.isFinite(n)?n:undefined; }
+function int(x){ const n=Math.floor(+x); return Number.isFinite(n)?n:undefined; }
+function isF(x){ return Number.isFinite(+x); }
 export { WarpEngine };