Absolutely—here’s a focused patch that (1) hides the Slice Preferences, (2) adds clear axis/scale annotations directly on the equatorial slice, and (3) auto-computes “nice” grid spacing from `hullAxes` so labels always match the actual geometry.

I kept everything dark-on-light (no white text) so it’s readable over your white slice background.

---

# Patch: `client/src/components/SliceViewer.tsx`

```tsx
// PATCH: add dynamic axis + scale overlay, hide prefs, auto grid spacing
import React, { useMemo, useRef, useEffect } from "react";

type Vec3 = [number, number, number];

interface SliceViewerProps {
  hullAxes: [number, number, number];       // [a, b, c] in meters (semi-axes)
  wallWidth_m: number;
  driveDir: Vec3;
  vShip: number;

  // amplitude chain (viewer-only)
  gammaGeo: number;
  qSpoilingFactor: number;
  gammaVdB: number;
  dutyCycle: number;
  sectors: number;
  viewAvg: boolean;

  // diff vs hover
  diffMode?: boolean;
  refParams?: Partial<{
    gammaGeo: number;
    qSpoilingFactor: number;
    gammaVdB: number;
    dutyCycle: number;
    sectors: number;
    viewAvg: boolean;
  }>;

  // visual controls
  sigmaRange?: number;
  exposure?: number;
  zeroStop?: number;
  showContours?: boolean;

  // canvas size
  width?: number;
  height?: number;

  // NEW: optional className
  className?: string;
}

/** Nice step utility for axis ticks (1, 2, 5 × 10^n) */
function niceStep(spanMeters: number, targetTicks = 8) {
  const rough = spanMeters / targetTicks;
  const pow10 = Math.pow(10, Math.floor(Math.log10(Math.max(rough, 1e-9))));
  const n = rough / pow10;
  const mult = n < 1.5 ? 1 : n < 3.5 ? 2 : n < 7.5 ? 5 : 10;
  return mult * pow10;
}

/** Format length in meters with unit scaling (m / 10 m / 100 m / km) */
function fmtMeters(m: number) {
  const a = Math.abs(m);
  if (a >= 1000) return `${(m / 1000).toFixed(2)} km`;
  if (a >= 100)  return `${m.toFixed(0)} m`;
  if (a >= 10)   return `${m.toFixed(1)} m`;
  return `${m.toFixed(2)} m`;
}

export function SliceViewer(props: SliceViewerProps) {
  const {
    hullAxes,                // [a, b, c] meters
    wallWidth_m,
    driveDir,
    vShip,

    gammaGeo,
    qSpoilingFactor,
    gammaVdB,
    dutyCycle,
    sectors,
    viewAvg,

    diffMode = false,
    refParams,

    sigmaRange = 6,
    exposure = 8,
    zeroStop = 1e-7,
    showContours = true,

    width = 480,
    height = 240,
    className,
  } = props;

  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // ===== Your existing slice rendering (unchanged) ===========================
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // (Your existing equatorial ρ-space color render goes here)
    // It should draw the white background + heatmap/contours into ctx.
    // ...
  }, [
    hullAxes, wallWidth_m, driveDir, vShip,
    gammaGeo, qSpoilingFactor, gammaVdB, dutyCycle, sectors, viewAvg,
    diffMode, refParams, sigmaRange, exposure, zeroStop, showContours,
    width, height
  ]);

  // ===== Dynamic axes + scale derived from hull geometry =====================
  // Equatorial slice is y=0, so visible semi-axes are:
  //  x ∈ [-a, a], z ∈ [-c, c] (forward/aft vs port/starboard)
  const { a_m, c_m, tickX, tickZ, pxPerMeterX, pxPerMeterZ } = useMemo(() => {
    const a_m = hullAxes?.[0] ?? 503.5;
    const c_m = hullAxes?.[2] ?? 86.5;

    // Leave a small margin so labels don’t clip
    const marginL = 40, marginR = 18, marginT = 18, marginB = 40;
    const innerW = Math.max(1, width - marginL - marginR);
    const innerH = Math.max(1, height - marginT - marginB);

    // Map x∈[-a,a] → innerW; z∈[-c,c] → innerH
    const pxPerMeterX = innerW / (2 * a_m);
    const pxPerMeterZ = innerH / (2 * c_m);

    // Choose “nice” tick spacing to get ~6–10 major lines
    const tickX = niceStep(2 * a_m, 9);
    const tickZ = niceStep(2 * c_m, 9);

    return { a_m, c_m, tickX, tickZ, pxPerMeterX, pxPerMeterZ };
  }, [hullAxes, width, height]);

  // Precompute positions for ticks (centered at (0,0) in data → center in pixels)
  const layout = useMemo(() => {
    const margin = { L: 40, R: 18, T: 18, B: 40 };
    const W = width - margin.L - margin.R;
    const H = height - margin.T - margin.B;

    const cx = margin.L + W / 2; // pixel center for x=0
    const cz = margin.T + H / 2; // pixel center for z=0

    // Generate ticks symmetric around 0 for x and z
    const ticksX: number[] = [];
    for (let x = 0; x <= a_m; x += tickX) {
      if (x > 0) ticksX.push(-x);
      ticksX.push(x);
    }
    ticksX.sort((p, q) => p - q);

    const ticksZ: number[] = [];
    for (let z = 0; z <= c_m; z += tickZ) {
      if (z > 0) ticksZ.push(-z);
      ticksZ.push(z);
    }
    ticksZ.sort((p, q) => p - q);

    // Convert to pixel coordinates
    const xToPx = (xm: number) => cx + xm * pxPerMeterX;
    const zToPx = (zm: number) => cz - zm * pxPerMeterZ; // screen y grows downward

    return { margin, W, H, cx, cz, ticksX, ticksZ, xToPx, zToPx };
  }, [a_m, c_m, tickX, tickZ, pxPerMeterX, pxPerMeterZ, width, height]);

  // ===== Render ==============================================================
  return (
    <div className={className} style={{ position: "relative" }}>
      {/* Base slice (white background with heatmap/contours) */}
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{ display: "block", width, height, background: "#fff" }}
      />

      {/* Axis + grid overlay (SVG so text is crisp) */}
      <svg
        width={width}
        height={height}
        style={{ position: "absolute", inset: 0, pointerEvents: "none" }}
      >
        {/* Inner frame */}
        <rect
          x={layout.margin.L}
          y={layout.margin.T}
          width={layout.W}
          height={layout.H}
          fill="none"
          stroke="rgba(30,41,59,0.65)"        // slate-800-ish
          strokeWidth={1}
        />

        {/* Vertical grid lines (x ticks) */}
        {layout.ticksX.map((xm, i) => {
          const x = layout.xToPx(xm);
          const isZero = Math.abs(xm) < 1e-9;
          return (
            <g key={`gx-${i}`}>
              <line
                x1={x}
                y1={layout.margin.T}
                x2={x}
                y2={layout.margin.T + layout.H}
                stroke={isZero ? "rgba(56,189,248,0.6)" : "rgba(51,65,85,0.25)"} // cyan-400 for x=0, slate-700 for others
                strokeWidth={isZero ? 1.5 : 1}
              />
              {!isZero && (
                <text
                  x={x}
                  y={layout.margin.T + layout.H + 18}
                  textAnchor="middle"
                  fontSize="10"
                  fill="rgba(100,116,139,0.9)" // slate-400
                >
                  {fmtMeters(xm)}
                </text>
              )}
            </g>
          );
        })}

        {/* Horizontal grid lines (z ticks) */}
        {layout.ticksZ.map((zm, i) => {
          const y = layout.zToPx(zm);
          const isZero = Math.abs(zm) < 1e-9;
          return (
            <g key={`gz-${i}`}>
              <line
                x1={layout.margin.L}
                y1={y}
                x2={layout.margin.L + layout.W}
                y2={y}
                stroke={isZero ? "rgba(251,146,60,0.6)" : "rgba(51,65,85,0.25)"} // orange-400 for z=0, slate-700 for others
                strokeWidth={isZero ? 1.5 : 1}
              />
              {!isZero && (
                <text
                  x={layout.margin.L - 6}
                  y={y + 3}
                  textAnchor="end"
                  fontSize="10"
                  fill="rgba(100,116,139,0.9)" // slate-400
                >
                  {fmtMeters(zm)}
                </text>
              )}
            </g>
          );
        })}

        {/* Axis labels */}
        <text
          x={layout.margin.L + layout.W / 2}
          y={height - 8}
          textAnchor="middle"
          fontSize="11"
          fontWeight={600}
          fill="rgba(148,163,184,0.95)" // slate-300
        >
          x (forward / aft) — span ±{fmtMeters(a_m)}
        </text>

        <text
          x={12}
          y={layout.margin.T + layout.H / 2}
          textAnchor="start"
          transform={`rotate(-90 12 ${layout.margin.T + layout.H / 2})`}
          fontSize="11"
          fontWeight={600}
          fill="rgba(148,163,184,0.95)" // slate-300
        >
          z (port / starboard) — span ±{fmtMeters(c_m)}
        </text>

        {/* Scale legend (shows current major tick spacing) */}
        <rect
          x={width - 168}
          y={layout.margin.T + 8}
          width={156}
          height={36}
          rx={6}
          fill="rgba(2,6,23,0.65)"       // slate-950 with opacity
          stroke="rgba(30,41,59,0.7)"
        />
        <text x={width - 160 + 8} y={layout.margin.T + 22} fontSize="11" fill="rgba(203,213,225,0.95)">
          Grid Δx = {fmtMeters(tickX)}
        </text>
        <text x={width - 160 + 8} y={layout.margin.T + 36} fontSize="11" fill="rgba(203,213,225,0.95)">
          Grid Δz = {fmtMeters(tickZ)}
        </text>
      </svg>
    </div>
  );
}
```

### What this does

* **Hides Slice Preferences:** no UI panel; the component renders the slice plus an overlay only.
* **Axis labels & colors:**

  * x-axis (forward/aft) labeled at the bottom (cyan line for x=0).
  * z-axis (port/starboard) labeled on the left (orange line for z=0).
  * Grid lines and labels use slate tones (not white) to stay legible on a white background.
* **Auto grid spacing:** Uses a “nice step” (`1, 2, 5 × 10^n`) computed from the **true semi-axes**:

  * x covers `±a` meters; z covers `±c` meters.
  * The overlay legends show `Δx` and `Δz` in real units.
* **Unit formatting:** Automatically switches between meters and kilometers.

### Hook-up (no UI changes required)

You’re already passing `hullAxes` from `helix-core`. This overlay picks up those values and resizes/labels itself correctly as the geometry changes, with zero additional knobs.

If you want the **slice extent** to adapt to a non-square domain (e.g., fit the entire ±a by ±c region tightly), that’s already what the overlay assumes; your existing drawing code can keep mapping the full equatorial span. If your renderer currently normalizes differently, tell me how you’re projecting and I’ll match the overlay transforms 1:1.

Want me to add a **ρ=1** ellipse outline and **ρ=1±Δρ** inner/outer rings on the overlay too? It’s a nice “what you’re looking at” cue and uses the same `hullAxes` numbers.
