1) warp-pipeline-adapter.ts

Keep S_total vs S_live distinct, compute FR duty correctly, and forward θ + both q aliases.

diff --git a/warp-pipeline-adapter.ts b/warp-pipeline-adapter.ts
@@
 export interface EnergyPipelineState {
   // ...existing fields...
   dutyEffective_FR?: number;
   thetaScaleExpected?: number;
+  thetaScale?: number; // authoritative θ from pipeline (if provided)
 }
@@
-  const sectorsTotal =
-    Math.max(1, Math.floor(num(s.sectorCount) ?? num(s.sectorStrobing) ?? 400));
-  const split = Math.floor(sectorsTotal / 2);
+  // Keep total tiling vs concurrent strobing distinct
+  const S_total = Math.max(1, Math.floor(num(s.sectorCount) ?? 400));
+  const S_live  = Math.max(1, Math.floor(num(s.sectorStrobing) ?? 1));
+  const sectorsTotal = S_total;
+  const split        = Math.floor(S_total / 2);
@@
-  let d_ship =
-    num(s.dutyEffective_FR) ??
-    num(s.dutyShip) ??
-    (() => {
-      const d_ui = clamp(s.dutyCycle ?? 0.14, 0, 1);
-      const strobe = Math.max(1, num(s.sectorStrobing) ?? sectorsTotal);
-      // FR duty is ship-wide time-average per total sectors
-      return clamp(d_ui / strobe, 0, 1);
-    })();
+  let d_ship =
+    num(s.dutyEffective_FR) ??
+    num(s.dutyShip) ??
+    (() => {
+      const d_local = clamp(s.dutyCycle ?? 0.01, 0, 1); // local ON fraction
+      const d_eff   = d_local * (S_live / S_total);     // Ford–Roman average
+      return clamp(d_eff, 0, 1);
+    })();
@@
   const gammaGeo = Math.max(1, num(s.gammaGeo) ?? 1);
-  const gammaVdB = Math.max(1, num(s.gammaVanDenBroeck_vis) ?? num(s.gammaVanDenBroeck) ?? 1);
-  const qSpoil = Math.max(1e-12, num(s.qSpoilingFactor) ?? 1);
+  const gammaVdB = Math.max(1, num(s.gammaVanDenBroeck_vis) ?? num(s.gammaVanDenBroeck) ?? 1);
+  const qSpoil   = Math.max(1e-12, num(s.qSpoilingFactor) ?? num((s as any).deltaAOverA) ?? 1);
@@
-  const thetaScaleExpected =
+  const thetaScaleExpected =
     Math.pow(gammaGeo, 3) * qSpoil * gammaVdB * Math.sqrt(Math.max(1e-12, d_ship));
+  const thetaForEngine =
+    num(s.thetaScale) ?? num(s.thetaScaleExpected) ?? thetaScaleExpected;
@@
   gatedUpdateUniforms(engine, {
-    dutyCycle: d_ship,
-    dutyEffectiveFR: d_ship,
+    dutyCycle: clamp(s.dutyCycle ?? 0.01, 0, 1), // semantic: local burst
+    dutyEffectiveFR: d_ship,                     // explicit FR duty
     sectorCount: sectorsTotal,
     sectors: split,
     gammaGeo,
     gammaVanDenBroeck: gammaVdB,
-    qSpoilingFactor: qSpoil,
+    qSpoilingFactor: qSpoil,
+    deltaAOverA: qSpoil,                         // alias for inspector parity
     axesHull: [ax, ay, az],
     axesScene: [sx, sy, sz],
     wallWidth: w,
     wallWidth_rho: w_rho,
-    thetaScaleExpected,
+    thetaScaleExpected,
+    thetaScale: thetaForEngine,                  // authoritative when present
     colorMode: "theta",
     viewAvg: true,
   }, "server");