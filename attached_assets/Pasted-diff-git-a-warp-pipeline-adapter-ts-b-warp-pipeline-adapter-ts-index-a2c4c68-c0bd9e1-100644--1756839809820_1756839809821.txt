diff --git a/warp-pipeline-adapter.ts b/warp-pipeline-adapter.ts
index a2c4c68..c0bd9e1 100644
--- a/warp-pipeline-adapter.ts
+++ b/warp-pipeline-adapter.ts
@@ -1,8 +1,11 @@
 // Pipeline → WarpEngine Adapter
 // Drives renderer uniforms from pipeline state (single source of truth, strict)
 
+import type { GreensPayload } from "@/hooks/use-energy-pipeline";
+
 function aHarmonic(ax: number, ay: number, az: number) {
   const a = +ax || 0, b = +ay || 0, c = +az || 0;
   const d = (a>0?1/a:0) + (b>0?1/b:0) + (c>0?1/c:0);
   return d > 0 ? 3 / d : NaN;
 }
 function req(cond: any, msg: string) {
   if (!cond) throw new Error(`adapter: ${msg}`);
 }
 
 export interface EnergyPipelineState {
   // ... existing fields ...
   // strongly recommended fields (strict mode)
   axesHull?: [number,number,number];
   wallWidth_m?: number;
   wallWidth_rho?: number;
   sectorCount?: number;
   sectorStrobing?: number;
   dutyLocal?: number;
   dutyEffectiveFR?: number;
   gammaGeo?: number;
   gammaVanDenBroeck?: number;
   qSpoilingFactor?: number;
   thetaScale?: number;
 }
 
-export function driveWarpFromPipeline(engine: any, s: EnergyPipelineState): void {
+export type DriveMetricOpts = {
+  greens?: GreensPayload;   // φ samples (normalized or raw; we use as-is)
+  metricKappa?: number;     // required to enable metric mode; no default
+};
+
+export function driveWarpFromPipeline(engine: any, s: EnergyPipelineState, opts?: DriveMetricOpts): void {
   // Resolve axes
   const ax = +(s.axesHull?.[0] ?? s.hull?.a ?? s.hull?.Lx_m ?? NaN);
   const ay = +(s.axesHull?.[1] ?? s.hull?.b ?? s.hull?.Ly_m ?? NaN);
   const az = +(s.axesHull?.[2] ?? s.hull?.c ?? s.hull?.Lz_m ?? NaN);
   req(Number.isFinite(ax)&&Number.isFinite(ay)&&Number.isFinite(az), 'missing axesHull[a,b,c]');
   const axesHull: [number,number,number] = [ax,ay,az];
   const aH = aHarmonic(ax,ay,az);
   req(Number.isFinite(aH), 'bad harmonic radius (axes)");
 
   // Wall width (prefer meters; compute rho)
   const w_m  = Number.isFinite(s.wallWidth_m)   ? +s.wallWidth_m   : (Number.isFinite(s.wallWidth_rho) ? +s.wallWidth_rho * aH : NaN);
   const w_rho= Number.isFinite(s.wallWidth_rho) ? +s.wallWidth_rho : (Number.isFinite(s.wallWidth_m)   ? +s.wallWidth_m / aH   : NaN);
   req(Number.isFinite(w_m) && Number.isFinite(w_rho), 'missing wallWidth_m or wallWidth_rho');
 
   // Sectors / duty
   const S_total = s.sectorCount ?? (s.sectorsTotal as any);
   const S_live  = s.sectorStrobing ?? (s.sectorsConcurrent as any);
   req(Number.isFinite(S_total)&&Number.isFinite(S_live)&&S_total>=1&&S_live>=1, 'missing sectorCount/sectorStrobing');
   const dutyLocal = Number.isFinite(s.dutyLocal) ? +s.dutyLocal : (Number.isFinite((s as any).dutyCycle) ? +(s as any).dutyCycle : NaN);
   req(Number.isFinite(dutyLocal), 'missing dutyLocal/dutyCycle');
   const dutyEffectiveFR = Number.isFinite(s.dutyEffectiveFR) ? +s.dutyEffectiveFR : (dutyLocal * (S_live/S_total));
 
   // Physics gains
   const gammaGeo  = +s.gammaGeo!;
   const gammaVdB  = +(s.gammaVanDenBroeck ?? (s as any).gammaVanDenBroeck_vis ?? NaN);
   const qSpoil    = +(s.qSpoilingFactor ?? (s as any).deltaAOverA ?? NaN);
   req(Number.isFinite(gammaGeo)&&Number.isFinite(gammaVdB)&&Number.isFinite(qSpoil), 'missing gammaGeo/gammaVdB/qSpoilingFactor');
 
   // Optional authoritative theta
   const thetaScale = Number.isFinite(s.thetaScale) ? +s.thetaScale : undefined;
 
+  // --- Optional: conformal metric from Greens φ --------------------------------
+  // Enable metric only if BOTH greens and kappa are provided.
+  let metricMode = false;
+  let gSpatialDiag: [number, number, number] | undefined;
+  if (opts?.greens && Number.isFinite(opts?.metricKappa)) {
+    const phi = opts.greens.phi;
+    if (phi && phi.length > 0) {
+      // Simple mean as a first diagnostic scalar (no hidden normalization here)
+      let sum = 0;
+      for (let i = 0; i < phi.length; i++) sum += phi[i];
+      const phiMean = sum / phi.length;
+      const kappa = Number(opts.metricKappa);
+      const conformal = 1 + kappa * phiMean;
+      gSpatialDiag = [conformal, conformal, conformal];
+      metricMode = true;
+    }
+  }
+
   gatedUpdateUniforms(engine, {
     strictPhysics: true,
+    ...(metricMode ? { metricMode: true } : {}),
+    ...(gSpatialDiag ? { gSpatialDiag } : {}),
     axesHull,
     // keep axesScene derived in engine
     wallWidth: w_rho,
     wallWidth_rho: w_rho,
     wallWidth_m: w_m,
     sectorCount: S_total|0,
     sectorStrobing: S_live|0,
     dutyEffectiveFR,
     gammaGeo,
     gammaVanDenBroeck: gammaVdB,
     qSpoilingFactor: qSpoil,
     lockFraming: true,
     ...(Number.isFinite(thetaScale) ? { thetaScale } : {})
   }, "server");
 }