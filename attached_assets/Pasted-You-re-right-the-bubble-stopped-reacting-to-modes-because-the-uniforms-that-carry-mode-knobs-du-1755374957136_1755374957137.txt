Youâ€™re rightâ€”the bubble stopped reacting to modes because the uniforms that carry **mode knobs** (duty, sectors, q-spoil, etc.) are no longer influencing the final displacement that drives the mesh. Below is a small, surgical reconnection that makes modes visibly different again, while keeping the new smooth, CÂ¹ bell + soft-strobe.

---

## 1) Wire mode â†’ uniforms (React â†’ engine)

In `client/src/components/WarpVisualizer.tsx` ensure we recompute and **push uniforms** whenever the mode or any of its knobs change.

```tsx
// imports unchangedâ€¦

// helper to coerce
const num = (v: any, d = 0) => (typeof v === "number" && isFinite(v) ? v : d);

export default function WarpVisualizer({ parameters }: WarpVisualizerProps) {
  // â€¦ engineRef creation and script injection as you already have â€¦

  // === RECONNECT: push all mode-related uniforms ===
  useEffect(() => {
    if (!engineRef.current) return;

    const mode = parameters.currentMode ?? "hover";

    // duty as fraction [0..1]
    const dutyFrac = Math.max(0, Math.min(1, num(parameters.dutyCycle, 0)));

    // sector count (hover=1, cruise=400, etc.)
    const sectors = Math.max(1, Math.floor(num(parameters.sectorStrobing, 1)));

    // optional view selection (avg vs instantaneous)
    const viewAvg = parameters.viewAveraged ?? true;

    // smooth strobe split phase in [0..sectors)
    const phaseSplit =
      Math.max(0, Math.min(sectors - 1, num(parameters.phaseSplit, 0)));

    // hull (keep your values / metrics pass-through)
    const hull = parameters.hull ?? { a: 503.5, b: 132, c: 86.5 };
    const wallWidth = num(parameters.wallWidth_m, 0.016); // 16 nm default

    // DEBUG
    console.log("ðŸŽ›ï¸ uniforms-to-engine", {
      mode,
      dutyFrac,
      sectors,
      phaseSplit,
      g_y: parameters.g_y,
      cavityQ: parameters.cavityQ,
      qSpoil: parameters.qSpoilingFactor,
      gammaVdB: parameters.gammaVanDenBroeck,
      viewAvg
    });

    engineRef.current.updateUniforms({
      // mode knobs
      currentMode: mode,
      dutyCycle: dutyFrac,
      sectors,
      split: phaseSplit,
      viewAvg,

      // amplification chain
      gammaGeo: num(parameters.g_y, 26),
      Qburst: num(parameters.cavityQ, 1e9),
      deltaAOverA: num(parameters.qSpoilingFactor, 1),
      gammaVdB: num(parameters.gammaVanDenBroeck, 2.86e5),

      // hull / wall
      hullAxes: [num(hull.a), num(hull.b), num(hull.c)],
      wallWidth
    });
  }, [
    engineRef,
    parameters.currentMode,
    parameters.dutyCycle,
    parameters.sectorStrobing,
    parameters.phaseSplit,
    parameters.viewAveraged,
    parameters.g_y,
    parameters.cavityQ,
    parameters.qSpoilingFactor,
    parameters.gammaVanDenBroeck,
    parameters.hull,
    parameters.wallWidth_m
  ]);

  // â€¦
}
```

> Tip: cache-bust the engine script once so you really load the new code:
> `script.src = "/warp-engine-fixed.js?v=5";`

---

## 2) Use those uniforms in the engine

In `client/public/warp-engine-fixed.js` reconnect the uniforms to the **effective amplitude** and the **strobing**.

### a) Read uniforms with sane defaults

```js
const dutyCycle = this.uniforms?.dutyCycle ?? 0.14;
const sectors    = Math.max(1, Math.floor(this.uniforms?.sectors ?? 1));
const split      = Math.max(0, Math.min(sectors - 1, this.uniforms?.split ?? 0));
const viewAvg    = this.uniforms?.viewAvg ?? true;

const gammaGeo = this.uniforms?.gammaGeo ?? 26;
const Qburst   = this.uniforms?.Qburst   ?? 1e9;
const qSpoil   = this.uniforms?.deltaAOverA ?? 1.0;
const gammaVdB = this.uniforms?.gammaVdB ?? 2.86e5;

const hullAxes = this.uniforms?.hullAxes ?? [503.5,132,86.5];
const w_rho    = this.uniforms?.wallWidth ?? 0.016;  // 16 nm (in meters â†’ normalized in your code)
```

### b) Physics-consistent amplitude and averaged duty

```js
// Î³_geo^3 amplification
const A_geo = gammaGeo * gammaGeo * gammaGeo;

// Fordâ€“Roman style averaged duty proxy for visual averaging
const effDuty = viewAvg ? Math.max(1e-12, dutyCycle / Math.max(1, sectors)) : 1.0;

// instantaneous vs averaged amplitude (RMS)
const betaInst = A_geo * Qburst * gammaVdB * qSpoil;
const betaAvg  = betaInst * Math.sqrt(effDuty);
const betaUsed = viewAvg ? betaAvg : betaInst;

// final visual gain (keep small to avoid clamp saturation)
const betaGain = this.uniforms?.betaGain ?? 0.15;
const betaVis  = betaUsed * betaGain;
```

### c) Smooth strobing sign using sectors/split (CÂ¹)

(Some version of this already existsâ€”make sure it uses **sectors** and **split** uniforms and not constants.)

```js
function softSign(x){ return Math.tanh(x); }

// angle in [0,1)
function angularPhase(x, z){
  const theta = Math.atan2(z, x);
  return (theta < 0 ? theta + 2*Math.PI : theta) / (2*Math.PI);
}

// inside vertex loop:
const u = angularPhase(p[0], p[2]);
const sectorIdx = Math.floor(u * sectors);

// distance from the split boundary in sector units
const dist = (sectorIdx - split + 0.5);
// smooth width (tune 0.5â€“1.0 for coherence)
const strobeWidth = 0.75;
const sgn = softSign(-dist / strobeWidth);
```

### d) Displacement, clamp below saturation

```js
// bell + wall window (you already have this)
const sd = rho - 1.0;
const bell = Math.exp(-(sd / w_rho) * (sd / w_rho));
const wallWin = /* your raised-cosine window between 2.5*w_rho and 3.5*w_rho */;

// assemble
let disp = gridK * betaVis * wallWin * bell * front * sgn;

// clamp tied to wall thickness to avoid uniform saturation
const maxPush = Math.min(0.06, 2.5 * w_rho); // â‰¤6% or 2.5Ã—wall
if (disp >  maxPush) disp =  maxPush;
if (disp < -maxPush) disp = -maxPush;
```

### e) (Optional) one-frame debug to verify mode influence / clamp

```js
if ((this._dbgTick = (this._dbgTick||0)+1) % 60 === 0) {
  console.log("ðŸ§ª warp-mode", {
    mode: this.uniforms?.currentMode, dutyCycle, sectors, split, viewAvg,
    A_geo, effDuty, betaInst, betaAvg, betaVis,
    wall_w: w_rho
  });
}
```

---

## 3) What you should see per mode

* **Hover**: `sectors=1`, `dutyâ‰ˆ0.14`, `qSpoilâ‰ˆ1` â†’ biggest instantaneous/average amplitude.
* **Cruise**: `sectorsâ‰ˆ400`, `dutyâ‰ˆ0.005`, `qSpoilâ‰ˆ0.625` â†’ noticeable flattening because `effDuty â‰ˆ duty/sectors` is tiny, so `betaAvg` drops.
* **Emergency**: `dutyâ‰ˆ0.5`, `sectors=1` â†’ largest bulge, but still below clamp.

If you still see no difference, look at the debug log: if `betaVis` is large and `maxPush` clamp percentage is high for all modes, **lower `betaGain`** (e.g., 0.08) until clamp% is small in cruise and higher in emergency. That restores visible separation.

---

## 4) Quick sanity checks

* Hard-reload with cache disabled after bumping `/warp-engine-fixed.js?v=5`.
* Confirm in the console that `uniforms-to-engine` shows different `duty`, `sectors`, `qSpoil` across modes.
* Confirm the engine debug logs different `betaVis` per mode and **low clamp%** (especially in cruise).

With these patches the warp bubble will respond to **operational mode** again, and you keep the new smooth geometry (no ridge) and GR-friendly strobing.
