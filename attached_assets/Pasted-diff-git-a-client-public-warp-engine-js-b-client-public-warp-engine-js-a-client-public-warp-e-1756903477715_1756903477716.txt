diff --git a/client/public/warp-engine.js b/client/public/warp-engine.js
--- a/client/public/warp-engine.js
+++ b/client/public/warp-engine.js
@@ -40,6 +40,19 @@ class WarpEngine {
   constructor(gl) {
     this.gl = gl;
     this.gridProgram = null;
+    // strict-science: never fabricate physics; missing inputs â†’ error
+    this.strictScientific = true;
+    // LC state mirrored in uniforms
+    this._lc = {
+      tauLC_ms: undefined, dwell_ms: undefined, burst_ms: undefined,
+      phase: undefined, onWindow: false, sectorIdx: undefined, sectorCount: undefined,
+    };
+    // public uniforms bag (visible to inspectors/checkpoints)
+    this.uniforms = {};
   }
@@ -112,6 +125,27 @@ class WarpEngine {
     return this;
   }
 
+  // ---- Light-Crossing setter: normalize & mirror into uniforms --------------
+  setLightCrossing(info = {}) {
+    const L = this._lc || {};
+    L.tauLC_ms    = _finite(info.tauLC_ms);
+    L.dwell_ms    = _finite(info.dwell_ms);
+    L.burst_ms    = _finite(info.burst_ms);
+    L.phase       = _finite(info.phase);
+    L.onWindow    = !!info.onWindow;
+    L.sectorIdx   = _int(info.sectorIdx);
+    L.sectorCount = _int(info.sectorCount);
+    this._lc = L;
+    Object.assign(this.uniforms, {
+      tauLC_ms: L.tauLC_ms, dwell_ms: L.dwell_ms, burst_ms: L.burst_ms,
+      phase: L.phase, onWindow: L.onWindow ? 1 : 0,
+      sectorIdx: L.sectorIdx, sectorCount: L.sectorCount
+    });
+    // upload happens in updateUniforms/_applyUniformsNow
+    return this;
+  }
+
   _bindGridUniformLocations(gl, program) {
     const loc = (this.gridUniforms = this.gridUniforms || {});
@@ -135,6 +169,15 @@ class WarpEngine {
     loc.metricOn     = gl.getUniformLocation(program, 'u_metricOn');
     loc.viewForward  = gl.getUniformLocation(program, 'u_viewForward');
     loc.g0i          = gl.getUniformLocation(program, 'u_g0i');
+    // LC uniforms
+    loc.tauLC_ms     = gl.getUniformLocation(program, 'u_tauLC_ms');
+    loc.dwell_ms     = gl.getUniformLocation(program, 'u_dwell_ms');
+    loc.burst_ms     = gl.getUniformLocation(program, 'u_burst_ms');
+    loc.phase        = gl.getUniformLocation(program, 'u_phase');
+    loc.onWindow     = gl.getUniformLocation(program, 'u_onWindow');
+    loc.sectorIdx    = gl.getUniformLocation(program, 'u_sectorIdx');
+    loc.sectorCount  = gl.getUniformLocation(program, 'u_sectorCount');
+    loc.dutyUsed     = gl.getUniformLocation(program, 'u_dutyUsed');
   }
@@ -182,6 +225,29 @@ class WarpEngine {
     // merge new uniforms (verbatim)
     Object.assign(this.uniforms, parameters || {});
 
+    // strict validation: refuse partial physics
+    if (this.strictScientific) {
+      const U = this.uniforms, L = this._lc || {};
+      const miss = [];
+      if (!_isFinite(U.thetaScale))      miss.push('thetaScale');
+      if (!_isFinite(U.gammaGeo))        miss.push('gammaGeo');
+      if (!_isFinite(U.qSpoilingFactor)) miss.push('qSpoiling');
+      if (!_isFinite(U.gammaVdB))        miss.push('gammaVdB');
+      if (!_isFinite(U.sectorCount))     miss.push('sectorCount');
+      if (!_isFinite(U.dutyUsed))        miss.push('dutyUsed');
+      if (!_isFinite(L.tauLC_ms) || !_isFinite(L.dwell_ms) || !_isFinite(L.burst_ms)) {
+        miss.push('LC(tauLC_ms/dwell_ms/burst_ms)');
+      }
+      if (miss.length) {
+        this.uniforms.__error = `engine(strict): missing ${miss.join(', ')}`;
+      } else {
+        delete this.uniforms.__error;
+      }
+    }
+
     if (this.isLoaded && this.gl && this.gridProgram) {
       this._applyUniformsNow();
     }
@@ -201,6 +267,21 @@ class WarpEngine {
     if (loc.g0i && Array.isArray(U.g0i)) {
       gl.uniform3f(loc.g0i, +U.g0i[0]||0, +U.g0i[1]||0, +U.g0i[2]||0);
     }
+    // LC uploads (mirror from this._lc)
+    const L = this._lc || {};
+    if (loc.tauLC_ms)     gl.uniform1f(loc.tauLC_ms,  _isFinite(L.tauLC_ms) ? +L.tauLC_ms : 0.0);
+    if (loc.dwell_ms)     gl.uniform1f(loc.dwell_ms,  _isFinite(L.dwell_ms) ? +L.dwell_ms : 0.0);
+    if (loc.burst_ms)     gl.uniform1f(loc.burst_ms,  _isFinite(L.burst_ms) ? +L.burst_ms : 0.0);
+    if (loc.phase)        gl.uniform1f(loc.phase,     _isFinite(L.phase) ? +L.phase : 0.0);
+    if (loc.onWindow)     gl.uniform1f(loc.onWindow,  L.onWindow ? 1.0 : 0.0);
+    if (loc.sectorIdx)    gl.uniform1i(loc.sectorIdx, _isFinite(L.sectorIdx) ? +L.sectorIdx : 0);
+    if (loc.sectorCount)  gl.uniform1i(loc.sectorCount, _isFinite(L.sectorCount) ? +L.sectorCount : 1);
+    if (loc.dutyUsed && _isFinite(U.dutyUsed)) gl.uniform1f(loc.dutyUsed, +U.dutyUsed);
+
+    // metric toggle mirror (no SHOW boosts)
+    if (typeof U.metricMode === 'boolean') gl.uniform1f(loc.metricOn, U.metricMode ? 1.0 : 0.0);
+    else if (typeof U.useMetric === 'boolean') gl.uniform1f(loc.metricOn, U.useMetric ? 1.0 : 0.0);
   }
 }
 
+function _finite(x){ const n = +x; return Number.isFinite(n) ? n : undefined; }
+function _int(x){ const n = Math.floor(+x); return Number.isFinite(n) ? n : undefined; }
+function _isFinite(x){ return Number.isFinite(+x); }
 export { WarpEngine };