Yep — you nailed the root cause: the UI was keying off `systemMetrics.tiles`, but the server is emitting `tileData`. Two quick fixes unlock φ right away.

# What to change (fastest path)

1. **Energy Pipeline client: read `tileData` first, then fall back to `tiles`.**
   In the Energy Pipeline component, make the `clientTiles` selector do this:

```ts
// Try tileData first (current server format), then fallback to tiles (legacy)
const tiles = (systemMetrics as any)?.tileData || (systemMetrics as any)?.tiles;
if (!Array.isArray(tiles)) return undefined;

return tiles.map((t: any) => ({
  pos: t.pos as [number,number,number],
  t00: t.t00 || 0
}));
```

That’s exactly how the updated file handles it, and it then derives φ on the client if the server didn’t include it.&#x20;

2. **Let the client compute φ = G·ρ when the server’s `greens` is null.**
   The component already prefers server φ, but if it’s missing, it computes φ from `positions` and per-tile `t00` using Poisson (or Helmholtz if requested), then normalizes and publishes. You should see this logic after the selector above:

* Build `positions` and `rho` from the tiles, choose kernel, call `computeGreenPotential`, and return `{ phi, source: "client" }`.&#x20;
* Auto-publish to the shared cache key `["helix:pipeline:greens"]` and broadcast `helix:greens` so the rest of the app picks it up.&#x20;

# Optional hardening (nice-to-have)

* **Type the metrics correctly** so TS surfaces this early. Add `tileData?: { pos: [number,number,number]; t00: number }[];` to your metrics shape so both `tileData` and (legacy) `tiles` become visible to the compiler.

* **Bridge card hotfix:** The “Derivation/Greens” card already refreshes by checking `m.tileData || m.tiles`, then computes and publishes a Poisson φ if needed. That’s a good sanity button while you test.&#x20;

# Why φ wasn’t appearing

* `/api/helix/pipeline` had `greens: null` (no precomputed φ).
* `/api/helix/metrics` **did** include per-tile data — but under `tileData` (positions + `t00`) rather than `tiles`.
* The original client looked only at `systemMetrics.tiles`, so it never built `positions/rho` → no client-side φ compute → nothing to publish.

The current Energy Pipeline logic supports both keys and will compute/publish φ as soon as it sees either `tileData` or `tiles`. Once φ is non-empty, it’s pushed to the cache and broadcast for any listener to show live stats (kernel, N, φ\_min/max/mean, reciprocity).&#x20;

# Server-side compatibility (1-liner, if you prefer)

If you’d rather not touch the UI, alias on the server:

```js
// in /api/helix/metrics handler
payload.tiles ??= payload.tileData;
```

That keeps legacy clients working while you migrate.

# Quick test checklist

* GET `/api/helix/metrics` shows a **non-empty** `tileData` array with `{ pos: [x,y,z], t00 }`.
* Load Energy Pipeline: the Greens panel shows `N (tiles)` > 0 and `source: CLIENT`.&#x20;
* Click “Publish to renderer” (or let auto-publish run): downstream cards/widgets pick up φ via the shared cache/event.&#x20;

If you want, I can produce a tiny diff for your repo, but the two edits above are enough to get φ flowing today.
