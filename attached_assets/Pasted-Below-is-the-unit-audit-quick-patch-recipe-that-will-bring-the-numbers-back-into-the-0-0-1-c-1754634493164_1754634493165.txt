Below is the **unit-audit + quick-patch recipe** that will bring the numbers back into the 0 – 0.1 clip-space range.
You don’t have to redesign the engine; just bring every length into the *same* coordinate system and let the physics formula work.

---

## 1 — Put every distance in one place

Add a tiny helper right after you compute `this.gridHalf` in **`_initGrids()`**

```js
// clip-space normaliser (nm  →  –0.8 … +0.8)
this.normClip = 0.8 / this.gridHalf;   // = 0.8 / 20 000 nm = 4 e-5
```

Now the *same* factor is reused everywhere.

---

## 2 — Fix `sagRclip` (the culprit)

```diff
-_warpGridVertices(vtx, halfSize, originalY, bubbleParams) {
-    const bubbleRadius_nm = bubbleParams.sagDepth_nm || 10000;  // ← WRONG var + fallback
-    const sagRclip = bubbleRadius_nm / halfSize * 0.8;
+_warpGridVertices(vtx, halfSize, originalY, bubbleParams) {
+    // ① decide which physical radius you want – here: 10 μm
+    const bubbleRadius_nm = bubbleParams.bubbleRadius_nm ?? 10_000;   // 10 000 nm = 10 µm
+
+    // ② convert to clip-space using the _same_ factor the grid uses
+    const sagRclip = bubbleRadius_nm * this.normClip; // 10 000 × 4e-5 ≈ 0.4
```

*Result* Console will print `sagRclip ≈ 0.40` (not 8).

---

## 3 — Bring the fragment shader to the same scale

At the moment the warp-field shader only covers **20 nm** (`center * 2 e-8`).
That is **2 000×** smaller than the grid volume (40 µm).
Replace the hard-coded constant with the same normaliser:

```glsl
//   20 nm field of view  →  whole 40 µm cage
-vec3 pos = vec3(center * 2.0e-8, 0.0);
+vec3 pos = vec3(center / 0.8 * 2.0e-4, 0.0);
//                ↑            ↑
//   cancels 0.8  └──── 40 µm ÷ (gridHalf)  (= 2∙10⁻⁴)
```

(If you prefer, inject `u_normClip` as a uniform and compute
`pos = vec3(center / u_normClip, 0.0);`.)

---

## 4 — Clamp the deformation constants

Huge drift comes from two ad-hoc factors:

```js
const push = beta * 0.05;                // lateral
const dy   = beta * 0.05 * powerScale;   // vertical
```

After the unit-fix they are still a bit large.  Replace the magic `0.05`
with a *percentage of sagRclip* so the worst-case deformation never
exceeds 10 % of the bubble radius:

```js
const lateralK  = 0.10 * sagRclip;  // 10 % of bubble radius
const verticalK = 0.10 * sagRclip;

const push = beta * lateralK;
...
const dy   = beta * verticalK * powerScale * timeScale;
```

---

## 5 — Gear your instrumentation to clip-space values

```js
// after warping
console.log(`Max drift (should be ≤${(0.1*sagRclip).toFixed(3)}):`, maxDrift.toFixed(3));
```

Now the logger will shout if the grid escapes your visible window again.

---

### After the patch…

* **sagRclip** → 0.32 – 0.4
* **Max lateral drift** → 0.03 – 0.06
* **Grid Y range** → roughly −0.08 … +0.08

…and the warp bubble looks like a bluish “dimple” sitting inside three
properly curved magenta / yellow / cyan sheets—no more orange wall
stretching out of view.

Happy warping!
