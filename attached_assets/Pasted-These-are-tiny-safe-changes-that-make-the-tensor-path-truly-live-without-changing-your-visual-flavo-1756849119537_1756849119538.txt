These are tiny, safe changes that make the tensor path truly live without changing your visual flavoring. You can drop them straight into warp-engine.js inside _applyUniformsNow() after uniforms are merged:

Tie metricMode → shader’s useMetric and build a 3×3 metric (and inverse):

// --- Metric bridging (enable GPU metric when CPU metricMode is on) ---
if (typeof U.metricMode === 'boolean') U.useMetric = !!U.metricMode;

function _metricFromDiag(d) {
  const gx = +d[0] || 1, gy = +d[1] || 1, gz = +d[2] || 1;
  // row-major 3x3
  return new Float32Array([gx,0,0, 0,gy,0, 0,0,gz]);
}

function _metricFromSym(s) {
  // s: [gxx,gyy,gzz,gxy,gyz,gzx]
  const gxx=+s[0]||1, gyy=+s[1]||1, gzz=+s[2]||1;
  const gxy=+s[3]||0, gyz=+s[4]||0, gzx=+s[5]||0;
  return new Float32Array([
    gxx, gxy, gzx,
    gxy, gyy, gyz,
    gzx, gyz, gzz
  ]);
}

function _inv3(m){ // tiny robust 3×3 inverse
  const [a,b,c, d,e,f, g,h,i] = m;
  const A = (e*i - f*h), B = -(d*i - f*g), C = (d*h - e*g);
  const det = a*A + b*B + c*C;
  if (!isFinite(det) || Math.abs(det) < 1e-18) return null;
  const inv = new Float32Array([
     A, -(b*i - c*h),  (b*f - c*e),
     B,  (a*i - c*g), -(a*f - c*d),
     C, -(a*h - b*g),  (a*e - b*d)
  ]);
  for (let k=0;k<9;k++) inv[k] /= det;
  return inv;
}

// If metric is ON, synthesize full matrices so shaders can use them.
if (U.useMetric) {
  let G = null;
  if (Array.isArray(U.gSpatialSym) && U.gSpatialSym.length >= 6) {
    G = _metricFromSym(U.gSpatialSym);
  } else if (Array.isArray(U.gSpatialDiag) && U.gSpatialDiag.length >= 3) {
    G = _metricFromDiag(U.gSpatialDiag);
  }
  if (G) {
    U.metric = G;
    U.metricInv = _inv3(G) || U.metricInv || ID3;  // don’t crash on near-singular
  }
}


(Reason: maps your adapter’s metricMode into the GPU switch the engine/shader actually reads, and ensures off-diagonals are respected.)

Teach _dot() to use the full metric when available (not just diag):

_dot(v, w) {
  const U = this.uniforms || {};
  if (!U.metricMode) return v[0]*w[0] + v[1]*w[1] + v[2]*w[2];
  if (U.metric instanceof Float32Array && U.metric.length === 9) {
    const g = U.metric;
    // v^T g w
    return v[0]*(g[0]*w[0] + g[1]*w[1] + g[2]*w[2]) +
           v[1]*(g[3]*w[0] + g[4]*w[1] + g[5]*w[2]) +
           v[2]*(g[6]*w[0] + g[7]*w[1] + g[8]*w[2]);
  }
  // fallback: diag only
  if (Array.isArray(U.gSpatialDiag)) {
    const g = U.gSpatialDiag;
    return g[0]*v[0]*w[0] + g[1]*v[1]*w[1] + g[2]*v[2]*w[2];
  }
  return v[0]*w[0] + v[1]*w[1] + v[2]*w[2];
}


(Reason: honors full symmetric g when you pass it from Natário.)

(Optional, small) expose a simple redshift proxy using lapse/shift
If lapseN/shiftBeta arrive, compute a diagnostic scalar redshiftProxy now so Inspector can show it:

if (U.useMetric) {
  if (Number.isFinite(U.lapseN)) {
    const N = +U.lapseN;
    const beta = Array.isArray(U.shiftBeta) ? U.shiftBeta : [0,0,0];
    const b2 = beta[0]*beta[0] + beta[1]*beta[1] + beta[2]*beta[2];
    U.redshiftProxy = 1/Math.max(1e-6, N) * Math.sqrt(1 + b2); // quick diagnostic
  } else {
    U.redshiftProxy = undefined;
  }
}