Got it—your bubble shader is fine; the “weird cage” is a rendering-pipeline problem. Here are the concrete issues I see in your current WarpEngine and the minimal fixes to make the 3D sheets render where you expect.

⸻

The actual rendering bugs
	1.	Depth buffer is killing the grid

You draw the full-screen quad while depth-testing is enabled and writing to the depth buffer. That stamps z everywhere, so the grid fails the depth test.

Fix

// in _draw()
gl.disable(gl.DEPTH_TEST);   // or gl.depthMask(false)
this._renderQuad();
gl.enable(gl.DEPTH_TEST);    // then draw the grid

(If you prefer to leave testing on, use gl.depthMask(false) before the quad and gl.depthMask(true) after.)

⸻

	2.	Double-transforming clip-space vertices

You generate grid vertices already in clip space (∈ ~[-0.8, 0.8]) and then multiply them by a perspective+view matrix. That skews and “slides” the sheets.

Fix (simple & robust): use identity MVP for the grid

// in _renderGridPoints()
const I = new Float32Array([
  1,0,0,0,
  0,1,0,0,
  0,0,1,0,
  0,0,0,1
]);
gl.uniformMatrix4fv(this.gridUniforms.mvpMatrix, false, I);

(If you want a real camera, build the grid in object/world units instead of clip-space and keep the MVP.)

Also remove the duplicated “second” projection/view block in _renderGridPoints()—set the matrix once.

⸻

	3.	Wrong radius source → wrong sagRclip

You compute sagRclip from sagDepth_nm (16 nm), which is a depth, not the bubble radius. That makes sagRclip tiny (≈3.2e-4) unless you later patch it. Decouple them.

Fix

// add a dedicated radius with a sane default
this.uniforms.bubbleRadius_nm ??= 10000; // 10 µm

// in _warpGridVertices()
const bubbleRadius_nm = bubbleParams.bubbleRadius_nm;
const sagRclip = (bubbleRadius_nm / halfSize) * 0.8; // → ~0.3–0.5
this.sagRclip = sagRclip; // cache for sheet placement


⸻

	4.	Only one wall per axis → looks like “lines” not “sheets”

You place one XZ wall at +y, and one YZ wall at −x. With the yawed view this looks like two slanted lines above/right of the bubble.

Fix: draw both sides for each axis
Create six sheets: XY floor & ceiling, XZ ±Y walls, YZ ±X walls, each positioned at ±this.sagRclip.

// build
const xy_bot = this._createGrid(size, divs, 'XY', -1);
const xy_top = this._createGrid(size, divs, 'XY',  1);
const xz_neg = this._createGrid(size, divs, 'XZ', -1);
const xz_pos = this._createGrid(size, divs, 'XZ',  1);
const yz_neg = this._createGrid(size, divs, 'YZ', -1);
const yz_pos = this._createGrid(size, divs, 'YZ',  1);

// in _createGrid(..., plane, sign)
if (plane === 'XZ') { const yConst = (this.sagRclip || 0.4) * sign; /* … */ }
if (plane === 'YZ') { const xConst = (this.sagRclip || 0.4) * sign; /* … */ }
if (plane === 'XY') { const zConst = (this.sagRclip || 0.4) * sign; /* … */ }


⸻

	5.	Line width is clamped to 1px → grid can “disappear”

Most GPUs clamp gl.lineWidth to 1. Thin, sub-pixel lines will alias away.

Fix
Either render points (cheap and visible) or use thin triangle strips for “thick” lines.

// grid vertex shader
gl_PointSize = 3.5;

gl.drawArrays(gl.POINTS, offset, count);


⸻

	6.	Duplicate updateUniforms method

You define updateUniforms twice in the class. The later one overrides the earlier fallback-aware version, so your 2D fallback can silently break.

Fix
Keep a single updateUniforms with the fallback branch; delete the duplicate.

⸻

Minimal patch you can drop in

// _draw()
- this._renderQuad();
- gl.enable(gl.DEPTH_TEST);
+ gl.disable(gl.DEPTH_TEST);     // quad must not touch Z
+ this._renderQuad();
+ gl.enable(gl.DEPTH_TEST);

// _renderGridPoints()
- // several projection/view blocks...
- gl.uniformMatrix4fv(this.gridUniforms.mvpMatrix, false, mvp);
+ const I = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
+ gl.uniformMatrix4fv(this.gridUniforms.mvpMatrix, false, I);

- gl.drawArrays(gl.LINES, offset, count);
+ gl.drawArrays(gl.POINTS, offset, count);

// _warpGridVertices(...)
- const bubbleRadius_nm = bubbleParams.sagDepth_nm || 10000;
+ const bubbleRadius_nm = bubbleParams.bubbleRadius_nm ?? 10000;
  const sagRclip = bubbleRadius_nm / halfSize * 0.8;
  this.sagRclip = sagRclip;

(And implement the ±sheet construction as noted in #4.)

⸻

What your console should read when it’s right
	•	sagRclip ≈ 0.3 … 0.5
	•	Max lateral drift ≲ 0.1
	•	Grid Y range ≈ -0.08 … +0.08
	•	You see six draw calls (or grouped) for XY±, XZ±, YZ±
	•	The cage encloses the orange bubble and bends only in the thin wall

Ping me with your latest console logs after these edits and I’ll sanity-check the numbers.