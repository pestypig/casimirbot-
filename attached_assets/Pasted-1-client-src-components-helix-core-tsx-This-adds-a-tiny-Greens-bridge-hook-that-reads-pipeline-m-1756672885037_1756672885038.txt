1) client/src/components/helix-core.tsx

This adds a tiny “Greens bridge” hook that reads pipeline/metrics, computes or adopts φ, then publishes it to the same cache key and event your cards already use.

*** a/client/src/components/helix-core.tsx
--- b/client/src/components/helix-core.tsx
@@
+// Greens bridge: auto-publish φ from pipeline/metrics so the Greens cards populate
+import { useEffect } from "react";
+import { useQuery, useQueryClient } from "@tanstack/react-query";
+import { useEnergyPipeline } from "@/hooks/use-energy-pipeline";
+
+type V3 = [number, number, number];
+const poissonG = (r: number) => 1 / (4 * Math.PI * Math.max(r, 1e-6));
+function computePhi(positions: V3[], rho: number[], kernel = poissonG, normalize = true) {
+  const N = positions.length, out = new Float32Array(N);
+  for (let i = 0; i < N; i++) {
+    const [xi, yi, zi] = positions[i]; let sum = 0;
+    for (let j = 0; j < N; j++) {
+      const [xj, yj, zj] = positions[j];
+      const r = Math.hypot(xi - xj, yi - yj, zi - zj) + 1e-6;
+      sum += kernel(r) * rho[j];
+    }
+    out[i] = sum;
+  }
+  if (normalize && N > 0) {
+    let mn = +Infinity, mx = -Infinity;
+    for (let i = 0; i < N; i++) { const v = out[i]; if (v < mn) mn = v; if (v > mx) mx = v; }
+    const span = mx - mn || 1;
+    for (let i = 0; i < N; i++) out[i] = (out[i] - mn) / span;
+  }
+  return out;
+}
+
+function useGreensBridge() {
+  const qc = useQueryClient();
+  const { data: pipelineState } = useEnergyPipeline();
+  const { data: systemMetrics } = useQuery({
+    queryKey: ["/api/helix/metrics"],
+    refetchInterval: 5000,
+    suspense: false,
+  });
+
+  useEffect(() => {
+    // 1) Server already provided φ?
+    const srv = pipelineState?.greens;
+    if (srv?.phi && (srv.phi as number[]).length) {
+      const payload = {
+        kind: srv.kind ?? "poisson",
+        m: srv.m ?? 0,
+        normalize: srv.normalize !== false,
+        phi: srv.phi instanceof Float32Array ? srv.phi : new Float32Array(srv.phi),
+        size: (srv.phi as number[]).length,
+        source: "server" as const,
+      };
+      qc.setQueryData(["helix:pipeline:greens"], payload);
+      try { window.dispatchEvent(new CustomEvent("helix:greens", { detail: payload })); } catch {}
+      return;
+    }
+
+    // 2) Otherwise derive from metrics tiles if present
+    const tiles = systemMetrics?.tiles as { pos: V3; t00: number }[] | undefined;
+    if (Array.isArray(tiles) && tiles.length > 0) {
+      const positions = tiles.map(t => t.pos);
+      const rho = tiles.map(t => t.t00);
+      const phi = computePhi(positions, rho, poissonG, true);
+      const payload = { kind: "poisson" as const, m: 0, normalize: true, phi, size: phi.length, source: "client" as const };
+      qc.setQueryData(["helix:pipeline:greens"], payload);
+      try { window.dispatchEvent(new CustomEvent("helix:greens", { detail: payload })); } catch {}
+    }
+  }, [qc, pipelineState?.greens, systemMetrics?.tiles]);
+}
@@
 export default function HelixCore() {
@@
+  // Always keep Greens data flowing to the shared cache/event for the Greens cards
+  useGreensBridge();
@@
 }