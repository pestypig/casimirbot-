Nice snapshot — it tells me two things instantly:

* You’re still **forcing** the display to the paper targets (**83.3 MW**, **1405 kg**) instead of raw physics.
* The UI text says “**Sector Strobing: 400×**” but the proof panel shows **sectors: 1** (hover). One of those is just a stale label.

Here are **surgical patches** to get you back to **raw, un-calibrated physics** with your stated constants (S=400, dₗₒcₐₗ=0.01, Q\_burst=1e9, γᵥdB=1e11, 10 radial layers), and to fix the duty/sector math that currently saturates to 14%.

---

# 1) Add paper constants (top of file, once)

```ts
// ── Paper-backed constants (module scope)
const TOTAL_SECTORS    = 400;
const BURST_DUTY_LOCAL = 0.01;  // 10 µs / 1 ms
const Q_BURST          = 1e9;   // active-window Q
const GAMMA_VDB        = 1e11;  // fixed seed
const RADIAL_LAYERS    = 10;    // surface × radial lattice
```

---

# 2) Keep the 10× radial lattice (your spec)

```ts
// Derived tile count (surface tiling × 10 radial layers)
state.N_tiles = Math.max(1, Math.floor(hullArea_m2 / tileArea_m2) * RADIAL_LAYERS);
```

(Delete any earlier baseTiles/RADIAL\_LAYERS variants that don’t multiply by 10.)

---

# 3) Don’t scale γᵥdB from targets

**REPLACE this block:**

```ts
const realisticGammaVdB = state.gammaVanDenBroeck; // default = 1e11
const massScaling = (state.exoticMassTarget_kg ?? 1405) / 1405;
state.gammaVanDenBroeck = realisticGammaVdB * massScaling;
```

**WITH:**

```ts
state.gammaVanDenBroeck = GAMMA_VDB;  // fixed, raw physics
```

---

# 4) Sector fraction & effective duty (define once, early)

Right after you apply `modeConfig`:

```ts
const S_active     = Math.max(1, Math.round(state.sectorStrobing ?? 1));
const frac_active  = Math.min(1, S_active / TOTAL_SECTORS);   // e.g., 1/400 in hover, 1.0 in cruise
const tilesPerSect = Math.floor(state.N_tiles / TOTAL_SECTORS);

state.activeSectors  = S_active;
state.activeFraction = frac_active;
state.tilesPerSector = tilesPerSect;
state.activeTiles    = tilesPerSect * S_active;

// Ship-wide effective duty is the LOCAL burst duty times active sector fraction
const d_eff = BURST_DUTY_LOCAL * frac_active;
state.dutyEff = d_eff;
```

> Remove any later duplicate “sector model” block.

---

# 5) Power: use **burst-only Q** and **d\_eff** (no 14% saturation)

**REPLACE your power block** (including the “fs burst” math that clamps to 1) **WITH:**

```ts
// Power (loss) — raw: loss happens during the 10 µs burst with Q_burst
const omega = 2 * PI * (state.modulationFreq_GHz ?? 15) * 1e9;

// Stored energy chain: U_static → γ_geo → qMechanical
const U_geo     = state.U_geo;                            // = γ_geo · U_static
const U_Q_store = Math.abs(state.U_Q ?? U_geo * state.qMechanical);

// Per-tile dissipation during ON-window (ignore idle Q in raw physics)
const P_loss_per_tile_raw = U_Q_store * omega / Q_BURST;

// Ship-average: only a fraction of tiles are live, and only during d_eff
const P_total_W = P_loss_per_tile_raw * state.N_tiles * d_eff;

state.P_loss_raw = P_loss_per_tile_raw;
state.P_avg      = P_total_W / 1e6;   // MW (physics-first)
```

> Also delete the “MODEL\_MODE === 'calibrated' ? … : …” overwrite. That’s why your HUD still shows **83.3 MW**.

---

# 6) Exotic mass: use **γ\_geo³ × Q\_burst × γᵥdB × d\_eff** (no target forcing)

**REPLACE your mass block** WITH:

```ts
const U_abs   = Math.abs(state.U_static);
const geo3    = Math.pow(state.gammaGeo ?? 26, 3);

const E_enh   = U_abs * geo3 * Q_BURST * state.gammaVanDenBroeck * d_eff; // J per tile (avg)
const m_tile  = E_enh / (C * C);
const M_total = m_tile * state.N_tiles;

state.M_exotic_raw = M_total;
state.M_exotic     = M_total;   // physics-first
state.massCalibration = 1;      // no overwrites
```

> Delete the `M_CALIBRATED` branch that pins 1405 kg.

---

# 7) Ford–Roman ζ: compute from **d\_eff** (optionally tighten Qₛₐₘₚₗₑ)

```ts
const Q_quantum = 1e12;                  // if you want ζ ≤ 0.05 comfortably
state.zeta = 1 / (d_eff * Math.sqrt(Q_quantum));
state.fordRomanCompliance = state.zeta < 1.0;  // or <0.05 if you want that stricter gate
```

---

# 8) UI truth-source for the “400×” line

Your header says “**Sector Strobing: 400× spatial coherence**” while the panel shows `sectors: 1` (hover). Drive that header from state so it’s never stale:

* If you mean “400 wedges total,” render: `“400 wedges; active: ${state.activeSectors}”`.
* If you meant “coherence gain,” render: `“activeFraction = ${state.activeFraction.toFixed(4)} (S_active/S_total)”`.

---

## What will change

* **Power** and **Mass** will no longer lock to **83.3 MW / 1405 kg**; you’ll see true raw outputs (likely much higher power unless `qMechanical` is small).
* **Duty** will use **d\_eff = 0.01 × (S\_active/400)**, not **0.14** (the old UI duty) nor a saturated fs-ratio.
* **ζ** will track that same **d\_eff**, giving you the GR/QI margin tied to the true activation pattern.

If you want me to compute the **exact `qMechanical`** that hits a power cap (still raw, no forcing in mass), paste your `[PIPELINE]` log lines for `U_static`, `gammaGeo`, `N_tiles`, and `dutyEff` and I’ll give you the single value to set.
