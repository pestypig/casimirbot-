So the logic in the inspector is right, but the engine isn’t using FR duty for its θ computation. Fix it in two places:

1) Push Ford–Roman duty into the engines every render

Give WarpRenderInspector a tiny upgrade so it computes FR duty from the light-crossing loop and pushes it as dutyEffectiveFR to both canvases (REAL/SHOW). Also set both the new and legacy parity flags to avoid the “Parity mode — false” on REAL.

- export default function WarpRenderInspector(props: { ... }){
+ export default function WarpRenderInspector(props: {
+   parityPhys?: Record<string, any>;
+   showPhys?: Record<string, any>;
+   baseShared?: Record<string, any>;
+   lightCrossing?: { burst_ms?: number; dwell_ms?: number };  // ⬅️ add
+ }){

  // ...existing code...

  // Apply payloads any time calculator/shared/controls change
  useEffect(() => {
    if (!leftEngine.current || !rightEngine.current) return;

+   // --- Pane-specific Ford–Roman duty (from LC burst × conc/total)
+   const dutyLocal = (() => {
+     const b = Number(props.lightCrossing?.burst_ms);
+     const d = Number(props.lightCrossing?.dwell_ms);
+     return Number.isFinite(b) && Number.isFinite(d) && d > 0 ? Math.max(1e-12, b / d) : 0.01;
+   })();
+   const totalSectors = Math.max(1, Math.floor(
+     Number((props.baseShared as any)?.sectorCount ?? (props.baseShared as any)?.sectors ?? 400)
+   ));
+   const sLeft  = Math.max(1, Math.floor(Number((realPayload as any)?.sectors ?? 1)));
+   const sRight = Math.max(1, Math.floor(Number((showPayload as any)?.sectors ?? sLeft)));
+   const dutyFR_left  = dutyLocal * (sLeft  / totalSectors);
+   const dutyFR_right = dutyLocal * (sRight / totalSectors);

    // sanitize a few hot-path values
    const safe = (o:any)=> {
      const sectors = Math.max(1, Math.floor(N(o.sectors, 1)));
      const rawSplit = Math.floor(N(o.split, 0));
      const split = Math.max(0, Math.min(sectors - 1, rawSplit));
      return {
        ...o,
        sectors,
        split,
        exposure: Math.max(1, Math.min(12, N(o.exposure, 6))),
        zeroStop: Math.max(1e-9, N(o.zeroStop, 1e-7)),
      };
    };

    // REAL
    pushUniformsWhenReady(leftEngine.current, {
      ...safe(realPayload),
      ridgeMode: 0,
-     physicsParityMode: true,
+     physicsParityMode: true, parityMode: true,        // ⬅️ set both flags for old engines
+     dutyEffectiveFR: dutyFR_left,                     // ⬅️ authoritative FR duty
    });

    // SHOW
    pushUniformsWhenReady(rightEngine.current, {
      ...safe(showPayload),
      ridgeMode: 1,
-     physicsParityMode: false,
+     physicsParityMode: false, parityMode: false,
+     dutyEffectiveFR: dutyFR_right,                    // ⬅️ averaged/FR as well
    });

    // Optional camera sweetener...
    const ax = (shared as any).axesScene || leftEngine.current?.uniforms?.axesClip;
    const cz = compactCameraZ(ax);
    pushUniformsWhenReady(leftEngine.current,  { cameraZ: cz });
    pushUniformsWhenReady(rightEngine.current, { cameraZ: cz });
- }, [realPayload, showPayload, shared]);
+ }, [realPayload, showPayload, shared, props.lightCrossing]);


Now your checkpoint panel’s expected θ and the engine will be using the same duty.