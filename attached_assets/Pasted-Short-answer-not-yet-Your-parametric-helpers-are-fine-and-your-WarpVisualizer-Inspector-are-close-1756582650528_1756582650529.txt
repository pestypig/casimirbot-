Short answer: not yet. Your parametric helpers are fine, and your WarpVisualizer/Inspector are close, but the metric-based curvature path won’t engage unless you actually feed the shader its metric uniforms and (optionally) drive vector. In the fragment you shared, the metric code is gated by:

u_useMetric (bool/int)

u_metric (mat3)

plus consistent names for purple shift: u_epsilonTilt, u_betaTiltVec

and the θ/shear chain uses u_driveDir

Right now your React code never sends u_useMetric/u_metric (and in places uses epsilonTilt/betaTiltVec without the u_ prefixed aliases). So the shader will fall back to Euclidean dot/length.

Here are tight diffs to make it comply (safe to add: they’re no-ops when identity).

1) Bootstrap: send the metric (identity by default) and aliases
@@ makeEngine() bootstrap uniforms
-  const uniforms = {
+  const uniforms = {
     …
     epsilonTilt: epsilonTiltResolved,
     betaTiltVec: betaTiltResolved,
+    // --- Metric integration (identity default) ---
+    u_useMetric: Number(parameters?.metric?.use ?? 0),     // 0 or 1
+    u_metric: (parameters?.metric?.G as number[] | undefined) ??
+              [1,0,0, 0,1,0, 0,0,1],
+    // keep aliases so either naming convention works
+    useMetric: Number(parameters?.metric?.use ?? 0),
+    metric:    (parameters?.metric?.G as number[] | undefined) ??
+               [1,0,0, 0,1,0, 0,0,1],
+    // purple shift aliases (shader may expect u_* names)
+    u_epsilonTilt: epsilonTiltResolved,
+    u_betaTiltVec: betaTiltResolved,
+    // drive direction for θ/shear (default: +x in world space)
+    u_driveDir: parameters?.driveDir ?? [1,0,0],
   };

2) Live updates: keep metric & aliases in sync
@@ useEffect(() => { // Live updates to parameters
-  const parity = !!parameters.physicsParityMode;
+  const parity = !!parameters.physicsParityMode;

+  const useMetric = Number(parameters?.metric?.use ?? 0);
+  const G = (parameters?.metric?.G as number[] | undefined) ??
+            [1,0,0, 0,1,0, 0,0,1];
+  const driveDir = (parameters?.driveDir as number[] | undefined) ?? [1,0,0];

  // ----- Seed framing every update -----
  …
  // Single atomic update to prevent mode conflicts (via gate)
  gatedUpdateUniforms(engineRef.current, {
    …
+   // Metric uniforms (shader gate & tensor)
+   u_useMetric: useMetric,
+   u_metric: G,
+   useMetric,
+   metric: G,
+   // θ/σ drive vector (used in xs = dotG(pN, dN))
+   u_driveDir: driveDir,
+   // Purple shift aliases
+   u_epsilonTilt: Number(parameters.shift?.epsilonTilt ?? parameters.epsilonTilt ?? 0),
+   u_betaTiltVec: parameters.shift?.betaTiltVec ?? parameters.betaTiltVec ?? [0,-1,0],
  }, 'client');

3) If you’re feeding Grid3DEngine directly

When you render a custom mesh (your generateSurface output), the metric logic still lives in the shader, so continue passing the same uniforms to Grid3DEngine:

<Grid3DEngine
  … 
  uniforms={{
    …existing uniforms,
    u_useMetric: 1,
    u_metric:   [ gxx, gxy, gxz,  gyx, gyy, gyz,  gzx, gzy, gzz ], // row-major mat3
    u_driveDir: [1,0,0],
    u_epsilonTilt: epsilonTilt,
    u_betaTiltVec: betaTiltVec,
  }}
/>

4) Minimal identity metric helper (optional)

If you want a quick prop shape on the React side:

type MetricProps = {
  use?: 0|1;               // 0=Euclidean, 1=use u_metric
  G?: [number,number,number, number,number,number, number,number,number]; // mat3
};
// Pass as parameters.metric = { use: 1, G: [...] }

5) Name hygiene check

Your fragment/body uses u_metric, u_useMetric, u_betaTiltVec, u_epsilonTilt, and u_driveDir. Engines sometimes auto-strip the u_ prefix. To be bulletproof we send both forms (as in the diffs). If your warp-uniforms-gate already maps these, the duplicates are harmless.