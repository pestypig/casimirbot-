Yep — that “reading ‘divisions’” is back because our retry still does new Ctor(cv) with no options. The engine’s ctor reads opts.grid.divisions (or opts.divisions) and we’re handing it undefined.

Fix: pass safe options every time we call the constructor (first try, retry, and last-ditch). Here’s a drop-in replacement for your getOrCreateEngine section (keep your seedGridDefaultsHard() and the rest as-is):

function purgeCanvasEngineGuards(cv: HTMLCanvasElement) {
  try { (window as any).__WARP_ENGINES?.delete?.(cv); } catch {}
  try { delete (cv as any).__warpEngine; } catch {}
  try { delete (cv as any).__engine; } catch {}
  try { delete (cv as any).warpEngine; } catch {}
}

function getOrCreateEngine<WarpType = any>(
  Ctor: new (...args: any[]) => WarpType,
  cv: HTMLCanvasElement
): WarpType {
  // Reuse if one is already attached & alive
  const existing =
    (cv as any).__warpEngine ||
    (cv as any).warpEngine ||
    (cv as any).__engine ||
    (Ctor as any).fromCanvas?.(cv) ||
    (Ctor as any).getForCanvas?.(cv);
  if (existing && !existing._destroyed) return existing as WarpType;

  // Prefer factory if available
  const viaFactory =
    (Ctor as any).getOrCreate?.(cv) ||
    (Ctor as any).fromCanvas?.(cv) ||
    (Ctor as any).getForCanvas?.(cv);
  if (viaFactory) {
    (cv as any).__warpEngine = viaFactory;
    return viaFactory as WarpType;
  }

  // Ensure defaults exist *before* first construction
  seedGridDefaultsHard();

  // Hand the ctor explicit safe options (covers both shapes: top-level + nested grid)
  const SAFE_OPTS = {
    divisions: 64,
    grid: { divisions: 64, minSpan: 2.6, spanPadding: 1.35 }
  };

  try {
    const eng = new (Ctor as any)(cv, SAFE_OPTS);
    (cv as any).__warpEngine = eng;
    return eng as WarpType;
  } catch (e1: any) {
    const msg1 = String(e1?.message || e1);

    // If GRID_DEFAULTS/opts were the problem, seed & retry — but first clear any half-attach
    if (/\b(divisions|minSpan|spanPadding)\b/i.test(msg1)) {
      seedGridDefaultsHard();
      purgeCanvasEngineGuards(cv);
      try {
        const eng2 = new (Ctor as any)(cv, SAFE_OPTS); // <-- pass opts on retry too
        (cv as any).__warpEngine = eng2;
        return eng2 as WarpType;
      } catch (e2: any) {
        const msg2 = String(e2?.message || e2);
        if (/already attached/i.test(msg2)) {
          const rebound =
            (cv as any).__warpEngine ||
            (Ctor as any).fromCanvas?.(cv) ||
            (Ctor as any).getForCanvas?.(cv);
          if (rebound && !rebound._destroyed) return rebound as WarpType;
        }
        throw e2;
      }
    }

    // If the first attempt already tripped the "attached" guard
    if (/already attached/i.test(msg1)) {
      const rebound =
        (cv as any).__warpEngine ||
        (Ctor as any).fromCanvas?.(cv) ||
        (Ctor as any).getForCanvas?.(cv);
      if (rebound && !rebound._destroyed) return rebound as WarpType;

      // Last-ditch: temporarily bypass guard, still providing SAFE_OPTS
      try {
        (window as any).__WARP_ENGINE_ALLOW_MULTI = true;
        const eng3 = new (Ctor as any)(cv, SAFE_OPTS);
        (cv as any).__warpEngine = eng3;
        return eng3 as WarpType;
      } finally {
        (window as any).__WARP_ENGINE_ALLOW_MULTI = false;
      }
    }

    throw e1;
  }
}


Why this works:

The ctor now always receives { divisions, grid: { divisions, minSpan, spanPadding } }, so any code path that expects either opts.divisions or opts.grid.divisions is satisfied.

We still seed window.GRID_DEFAULTS for engines that read globals, but the explicit SAFE_OPTS removes reliance on that.

We kept the guard cleanup + rebound logic you already had.