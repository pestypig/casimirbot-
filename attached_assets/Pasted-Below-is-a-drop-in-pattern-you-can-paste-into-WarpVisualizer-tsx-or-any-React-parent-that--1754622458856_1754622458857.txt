Below is a “drop-in” pattern you can paste into **WarpVisualizer.tsx** (or any React parent) that

1. **parses the numbers** already rendered in your pipeline cards
2. converts them into the six uniforms the `WarpEngine` expects
3. **updates the bubble** every time the operator flips the *Operational Mode* menu.

---

## 1 · Utility that scrapes one pipeline panel

```ts
// utils/pipelineGrab.ts
export interface PipelineSet {
  dutyCycle: number;     // 0 – 1 (fraction, not %)
  g:          number;
  Q:          number;
  sagNm:      number;
  powerMW:    number;
  exoticKg:   number;
}

export function grabCurrentPipeline(): PipelineSet | null {
  const root = document.querySelector("div[data-pipeline-active]"); // highest card
  if (!root) return null;

  // helper that finds “label : value unit” lines, e.g. "Power Draw 83.3 MW"
  const find = (txt: string, def = 0) => {
    const el = [...root.querySelectorAll("span,div,td")].find(e =>
      e.textContent?.trim().startsWith(txt)
    );
    if (!el) return def;
    const num = parseFloat(el.textContent!.replace(/[^0-9.+-eE]/g,""));
    return isFinite(num) ? num : def;
  };

  return {
    dutyCycle: find("Duty Cycle") / 100.0,      // displayed as %
    g:          find("γ.geometric", 26),
    Q:          find("Q-factor", 1e9),
    sagNm:      find("Sag Depth", 16),
    powerMW:    find("Power Draw", 0),
    exoticKg:   find("Exotic Mass", 0)
  };
}
```

Adjust the selector strings if your labels differ.

---

## 2 · React hook that pushes those numbers into **WarpEngine**

```tsx
import { useEffect, useRef } from "react";
import WarpEngine from "/static/warp-engine-fixed.js";
import { grabCurrentPipeline } from "./utils/pipelineGrab";

export default function WarpCanvas() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const engineRef = useRef<any>(null);

  useEffect(() => {
    engineRef.current = new WarpEngine(canvasRef.current!);

    // initial push
    const first = grabCurrentPipeline();
    first && engineRef.current.updateUniforms({
      dutyCycle:     first.dutyCycle,
      g_y:           first.g,
      cavityQ:       first.Q,
      sagDepth_nm:   first.sagNm,
      powerAvg_MW:   first.powerMW,
      exoticMass_kg: first.exoticKg
    });

    // whenever the <select> changes pipeline mode
    const sel = document.querySelector("select[data-opmode]")!;
    const cb  = () => {
      const p = grabCurrentPipeline();
      if (p) engineRef.current.updateUniforms({
        dutyCycle:     p.dutyCycle,
        g_y:           p.g,
        cavityQ:       p.Q,
        sagDepth_nm:   p.sagNm,
        powerAvg_MW:   p.powerMW,
        exoticMass_kg: p.exoticKg
      });
    };
    sel.addEventListener("change", cb);

    return () => {
      sel.removeEventListener("change", cb);
      engineRef.current?.destroy();
    };
  }, []);

  return <canvas ref={canvasRef} style={{width:"100%",height:"100%"}}/>;
}
```

*No state management, no Redux—just scrape the DOM each time the operator selects Hover / Cruise / Emergency / Standby.*

---

## 3 · Quick mapping confirmation (using your screenshots)

| Mode          | Parsed Power (MW) | Parsed Duty | Bubble effect you should see         |
| ------------- | ----------------- | ----------- | ------------------------------------ |
| **Hover**     | 83.3              | 0.14        | gentle bulge, slow ripple            |
| **Cruise**    | 7.4               | 0.00        | field nearly flat, faint ripple      |
| **Emergency** | 297.5             | 0.50        | strong bulge, fast shimmer           |
| **Stand-by**  | 0.0               | 0.00        | grid perfectly flat, background calm |

Switch the dropdown → uniform update fires → grid morphs in < 1 frame.

---

## 4 · Gotchas & polish

* **Fraction vs percent** – ensure Duty Cycle is *0 – 1*.
* If you’d rather not scrape text, pipe your backend’s JSON into the hook instead of `grabCurrentPipeline()`.
* Debounce the update (`setTimeout(…, 20)`) if sliders send updates every few ms.
* Show the numeric read-out on top of the canvas for instant feedback:

```css
canvas + .hud {position:absolute;top:8px;left:8px;color:#0ff;font:12px monospace}
```

---

### Done

With the hook above, every time your operator or optimizer updates **Duty, γ, Q, Sag, Power, Exotic Mass**, the WarpEngine reacts live, so you can *see* how each pipeline solution sculpts spacetime.

Let me know if the selectors need tweaking or you’d like smoother transitions (lerp between uniform values instead of snapping).
