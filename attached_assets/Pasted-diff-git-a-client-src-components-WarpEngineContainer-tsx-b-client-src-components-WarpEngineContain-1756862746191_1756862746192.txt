diff --git a/client/src/components/WarpEngineContainer.tsx b/client/src/components/WarpEngineContainer.tsx
--- a/client/src/components/WarpEngineContainer.tsx
+++ b/client/src/components/WarpEngineContainer.tsx
@@ -1,9 +1,12 @@
 import React, { useEffect, useMemo, useRef } from "react";
 import { useEnergyPipeline } from "@/hooks/use-energy-pipeline";
 import { useMetrics } from "@/hooks/use-metrics";
+import { useLightCrossingLoop } from "@/hooks/useLightCrossingLoop";
 // …other imports…
 
 export default function WarpEngineContainer(props:any){
   const leftEngine = useRef<any>(null);
   const rightEngine = useRef<any>(null);
   const { data: pipeline } = useEnergyPipeline({ refetchInterval: 1000 });
   const { data: metrics }  = useMetrics(2000);
+  const { data: lc }       = useLightCrossingLoop(); // τ_LC, dwell, burst, phase, sector, onWindow
 
   // --- ensure engines exist (unchanged) ---
   // …
@@ -65,6 +68,48 @@ export default function WarpEngineContainer(props:any){
     // existing adapter drives uniforms...
   }, [pipeline, metrics /*, greens, etc.*/]);
 
+  // --- NEW: push Light-Crossing timeline into engines each tick --------------
+  useEffect(() => {
+    if (!leftEngine.current && !rightEngine.current) return;
+    if (!lc) return;
+    // Compute TS ratio if modulation freq is present
+    const fGHz = Number.isFinite(pipeline?.modulationFreq_GHz) ? +pipeline!.modulationFreq_GHz! : NaN;
+    const Tm_ms = Number.isFinite(fGHz) ? (1000.0 / (fGHz * 1e9)) : NaN; // ms
+    const tauLC_ms = +lc.tauLC_ms ?? NaN;
+    const TS_ratio = (Number.isFinite(tauLC_ms) && Number.isFinite(Tm_ms) && Tm_ms > 0) ? (tauLC_ms / Tm_ms) : undefined;
+
+    const payload = {
+      tauLC_ms: lc.tauLC_ms,
+      dwell_ms: lc.dwell_ms,
+      burst_ms: lc.burst_ms,
+      phase: lc.phase,
+      sectorIdx: lc.sectorIdx,
+      sectorCount: lc.sectorCount,
+      onWindow: !!lc.onWindow,
+      TS_ratio,
+      dutyEffectiveFR: (pipeline as any)?.dutyEffectiveFR
+    };
+    leftEngine.current?.setLightCrossing?.(payload);
+    rightEngine.current?.setLightCrossing?.(payload);
+  }, [lc?.tauLC_ms, lc?.dwell_ms, lc?.burst_ms, lc?.phase, lc?.sectorIdx, lc?.sectorCount, lc?.onWindow, pipeline?.modulationFreq_GHz, (pipeline as any)?.dutyEffectiveFR]);
+
+  // --- NEW: set a deterministic cameraZ and forward view/tensors -------------
+  useEffect(() => {
+    const z = 3.0; // stable frame (tweak if you have a UI knob)
+    const vf: [number,number,number] = [0,0,-1]; // camera looks -Z in our scene
+    const g0i = (pipeline as any)?.natario?.g0i || (pipeline as any)?.natario?.shiftBeta || undefined;
+    const pack = {
+      cameraZ: z,
+      viewForward: vf,
+      ...(Array.isArray(g0i) ? { g0i } : {})
+    };
+    if (leftEngine.current)  leftEngine.current.updateUniforms?.(pack);
+    if (rightEngine.current) rightEngine.current.updateUniforms?.(pack);
+  }, [pipeline?.natario]);
+
   return (
     <div className="warp-engines">
       {/* canvases & overlays */}