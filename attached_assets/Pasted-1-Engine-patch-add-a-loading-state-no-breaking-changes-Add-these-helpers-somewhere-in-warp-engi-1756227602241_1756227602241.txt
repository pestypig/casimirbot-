1) Engine patch: add a loading state (no breaking changes)

Add these helpers somewhere in warp-engine.js (near other privates):

// New: canonical loading state for DAG
// 'idle' | 'compiling' | 'linked' | 'failed'
_setLoadingState(state) {
  this.loadingState = state;               // ← DAG reads this
  this.isLoaded = (state === 'linked');    // ← keep boolean for legacy paths
  // keep existing handler behavior (boolean) so nothing breaks:
  try { this.onLoadingStateChange?.(this.isLoaded); } catch {}
}


Now modify _createShaderProgram to use it and avoid early failure while KHR is active (keeps your existing behavior when no KHR):

_createShaderProgram(vertexSource, fragmentSource, onReady = null) {
  const gl = this.gl;

  const vertexShader   = this._compileShader(gl.VERTEX_SHADER,   vertexSource);
  const fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);
  if (!vertexShader || !fragmentShader) return null;

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  // record initial debug
  this._glStatus = {
    vertOK: !!gl.getShaderParameter(vertexShader,   gl.COMPILE_STATUS),
    fragOK: !!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS),
    linkOK: !!gl.getProgramParameter(program,       gl.LINK_STATUS),
    vertLog: (gl.getShaderInfoLog(vertexShader)   || '').trim(),
    fragLog: (gl.getShaderInfoLog(fragmentShader) || '').trim(),
    linkLog: (gl.getProgramInfoLog(program)       || '').trim(),
  };
  (window.__glDiag ||= {})[this.canvas?.id || `engine_${Date.now()}`] = this._glStatus;

+ // expose a live program handle even during compile so panels can query status
+ this.program = this.gridProgram = program;

  // --- Async path (KHR) ---
  if (this.parallelShaderExt && onReady) {
+   this._setLoadingState('compiling');
    this._pollShaderCompletion(program, (p) => {
      if (!p) {
+       this._setLoadingState('failed');
        onReady?.(null);
        return;
      }
      if (this._onProgramLinked(p)) {
        this.program = this.gridProgram = p;
+       this._setLoadingState('linked');
        onReady?.(p);
      } else {
+       this._setLoadingState('failed');
        onReady?.(null);
      }
    });
    return program;
  }

  // --- Sync path ---
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    const vsLog = gl.getShaderInfoLog(vertexShader) || '(vs ok)';
    const fsLog = gl.getShaderInfoLog(fragmentShader) || '(fs ok)';
    const pgLog = gl.getProgramInfoLog(program) || '(program no log)';
    console.error('[WarpEngine] Link error:', { vsLog, fsLog, pgLog });
    gl.deleteProgram(program);
+   this._setLoadingState('failed');
    return null;
  }

  // success (sync)
  if (this._onProgramLinked(program)) {
    this.program = this.gridProgram = program;
+   this._setLoadingState('linked');
    onReady?.(program);
    return program;
  }
+ this._setLoadingState('failed');
  return null;
}


And in _pollShaderCompletion keep boolean callbacks but set the richer state:

_pollShaderCompletion(program, onReady) {
  const gl = this.gl;
  const ext = this.parallelShaderExt;

  const poll = () => {
    const done = gl.getProgramParameter(program, ext.COMPLETION_STATUS_KHR);
    if (done) {
      const ok = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (ok) {
-       onReady(program);
-       this.onLoadingStateChange?.(true);
+       onReady(program);
+       this._setLoadingState('linked');
      } else {
        console.error('Shader program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
-       onReady(null);
-       this.onLoadingStateChange?.(false);
+       onReady(null);
+       this._setLoadingState('failed');
      }
    } else {
      requestAnimationFrame(poll);
-     this.onLoadingStateChange?.(false);
+     this._setLoadingState('compiling'); // keep telling the world we’re compiling
    }
  };
  poll();
}


(You don’t need to touch _onProgramLinked, but you can keep it as-is.)