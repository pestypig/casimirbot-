You’re not crazy—80–82 m is coming from a hard-coded radius used only to compute the time-scale ratio (TS). It isn’t your hull’s real size.

Where it’s set

In your backend pipeline:
	•	server/energy-pipeline.ts — there’s a literal:

// Time scale ratio should be ~4100 for 82m hull
const R_hull = 82; // Fixed hull radius for Needle Hull
const f_m = state.modulationFreq_GHz * 1e9;
const T_m = 1 / f_m;
const T_hull = R_hull / C;
state.TS_ratio = T_hull / T_m;



That’s the only place the “~82 m” shows up functionally (it feeds TS shown in the HUD). Everything else (γ_VdB, γ_geo, Q, power, etc.) doesn’t use that constant.

⸻

Patch: support your 1007 m × 264 m × 173 m needle

Replace the fixed R_hull with explicit hull dimensions and compute TS from them. This keeps the UI honest and lets you expose the numbers.

1) Extend the state (defaults + types)

Add a hull block to your pipeline state (where you define the interface / defaults):

// In server/energy-pipeline.ts (where you define defaults)
state.hull ??= {
  // full lengths in meters (not semiaxes)
  Lx_m: 1007,  // length (needle axis)
  Ly_m: 264,   // width
  Lz_m: 173    // height
};

(If you have a TS type/interface, add:)

export interface EnergyPipelineState {
  // ...
  hull?: { Lx_m: number; Ly_m: number; Lz_m: number };
  // expose optional derived
  TS_ratio?: number;
  TS_long?: number;
  TS_geom?: number;
}

2) Replace the 82 m TS calculation

Swap the old block for this:

// --- Time-scale separation (TS) using actual hull size ---
const { Lx_m, Ly_m, Lz_m } = state.hull!;
const L_long = Math.max(Lx_m, Ly_m, Lz_m);                // conservative: longest light-crossing
const L_geom = Math.cbrt(Lx_m * Ly_m * Lz_m);             // geometric mean (volume-equivalent length)
const f_m = state.modulationFreq_GHz * 1e9;
const T_m = 1 / f_m;

const T_long = L_long / C;   // s
const T_geom = L_geom / C;   // s

state.TS_long = T_long / T_m;   // most conservative
state.TS_geom = T_geom / T_m;   // typical
state.TS_ratio = state.TS_long; // keep existing field = conservative

3) Expose geometry in the metrics API (so the UI can show it)

In server/helix-core.ts → getSystemMetrics, include:

geometry: {
  Lx_m: state.hull?.Lx_m ?? 1007,
  Ly_m: state.hull?.Ly_m ?? 264,
  Lz_m: state.hull?.Lz_m ?? 173,
  TS_ratio: state.TS_ratio,
  TS_long: state.TS_long,
  TS_geom: state.TS_geom
}

4) (Optional) Tiny UI copy so users see both
	•	In the Engineer → Compliance HUD (where TS is shown), add a muted line under TS:
	•	“Hull: 1007×264×173 m · TS (long): {TS_ratio.toFixed(0)}”
	•	If you want, show both: TS_long (conservative) and TS_geom (typical).

⸻

Notes
	•	You don’t need to change the Amplification Chain or Strobing math for this; those are driven by γ_geo, Q, duty/strobe, etc. TS is the part that referenced a hull radius.
	•	If later you want surface/area-dependent budgets (e.g., tile count scaling, power density), we can also scale N_tiles and heat flux with the new lengths. For now, this patch only fixes the 82 m artifact and reports your 1007×264×173 m geometry cleanly.

If you paste this into your pipeline, your TS readouts will immediately reflect the 1.007 km needle and you’ll no longer see the “82 m hull” comment mislead future readers.