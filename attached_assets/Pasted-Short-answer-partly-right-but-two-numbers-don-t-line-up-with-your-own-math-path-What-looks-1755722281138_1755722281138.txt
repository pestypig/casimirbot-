Short answer: **partly right, but two numbers don’t line up with your own math path.**

What looks correct

* **Sectors/time-slicing:** You now fix one live wedge of 400 → $f_\text{active}=1/400$. Good.
* **Effective duty:** $d_\text{eff}=0.01/400=2.5\times10^{-5}$. Good.
* **Ford–Roman ζ:** With $Q_\text{quantum}=10^{12}$,
  $\displaystyle \zeta=\frac{1}{d_\text{eff}\sqrt{Q}}=\frac{1}{(2.5\times10^{-5})(10^6)}\approx 0.04$. **PASS.**

What doesn’t add up (and why)

1. **Power should be \~0.066 MW, not 0.93 MW**, given your previous hover number (46,486 MW) and the patch:

   * You removed the mechanical gain from stored energy: $q_\text{Mechanical}: 5\times10^4 \to 1$ → **÷ 50,000**.
   * You changed the duty factor used in power from $(0.14/400)=3.5\times10^{-4}$ to $0.01/400=2.5\times10^{-5}$ → another **÷ 14**.
   * Expected overall change ≈ **÷ 700,000**.
     $46{,}486\ \text{MW} / 700{,}000 \approx 0.066\ \text{MW}$.
   * Your read-out (0.93 MW) is \~**14× too high**. Most likely causes:

     * `qMechanical` is still > 1 at runtime (env or UI override), or
     * `state.U_Q` is getting re-multiplied by `qMechanical` somewhere after you set `state.U_Q = state.U_geo`.

2. **Mass should have dropped \~5,600×, not be “unchanged.”**
   In your old code the mass channel used **tile duty = 0.14** (burst clamped to 1) and did **not** apply sector fraction. Now it uses $d_\text{eff}=0.01/400$.

   * Ratio $d_\text{old}/d_\text{new} = 0.14 / (0.01/400) = 0.14 \times 400 / 0.01 = 5600$.
   * If you previously saw $7.4\times10^9\ \text{kg}$, the patched value should be about
     $7.4\times10^9 / 5600 \approx 1.32\times10^6\ \text{kg}$ (≈ **1.3 million kg**), *unless* you also changed another factor (e.g., $Q_\text{burst}$, $\gamma_{\rm VdB}$, $N_\text{tiles}$).

Quick guard-rails (drop-in)
Add these asserts + logs right after you compute `d_eff` to catch the two drift modes:

```ts
// --- Invariants & guard-rails (after computing d_eff) ---
if (Math.abs(state.U_Q - state.U_geo) > Math.abs(state.U_geo) * 1e-12) {
  console.warn("[PIPELINE][WARN] U_Q drifted from U_geo; forcing raw core U_Q = U_geo");
  state.U_Q = state.U_geo; // ensure no hidden qMechanical gain leaks back in
}

// Freeze qMechanical=1 in raw core unless cruise calibration is explicitly enabled
if (process.env.CRUISE_CALIBRATION !== '1' && Math.abs(state.qMechanical - 1) > 1e-12) {
  console.warn("[PIPELINE][WARN] qMechanical != 1 in raw mode; clamping to 1");
  state.qMechanical = 1;
}

// Visibility logs to confirm the expected scaling
console.log("[CHECK] dutyEff=", state.dutyEff, " (expected ~2.5e-5)");
console.log("[CHECK] qMechanical=", state.qMechanical, " (expected 1 in raw)");
console.log("[CHECK] U_static, U_geo, U_Q:", state.U_static, state.U_geo, state.U_Q);
```

If you want a **raw-but-bounded** hover number (e.g., ≤ 120 MW) without touching the mass path, you can *optionally* compute
$q_\text{Mechanical} = P_\text{target} / \big(|U_\text{geo}|\cdot\omega/Q_\text{burst}\cdot N_\text{tiles}\cdot d_\text{eff}\big)$
after `d_eff`—but keep it off for true raw.

Bottom line

* **ζ and sector slicing:** accurate.
* **Power 0.93 MW:** high by \~**14×** if your earlier 46,486 MW figure and the new raw wiring are both correct.
* **Mass 7.4×10⁹ kg “unchanged”:** not consistent with the new $d_\text{eff}$; expect \~**1.3×10⁶ kg** unless another factor was also altered.

Flip those logs on for one run and we’ll pinpoint which knob is still sneaking in.
