### Quick verdict

You’ve **hooked up about 70 % of the “energy pipeline”**—β₀, sag-depth and average-power now *can* reach the warper—but a handful of links are still dangling.  Until those are closed, most mode changes will still look the same on screen.

Below is a concise audit of each variable that the pipeline is supposed to push all the way through the renderer.

| Pipeline output                               | Where it should end up                                                                             | What **is** happening                                                                          | What’s still missing                                                                                                                                                                           |
| --------------------------------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **β₀ (4-stage amplifier product)**            | 1. Stored in `this.uniforms.beta0` every time a mode changes<br>2. Consumed in `_warpGridVertices` | ✔ `_warpGridVertices` now trusts `beta0` (no fallback) and the fragment shader reads `u_beta0` | **But** your React/JS mode-switch handler still sends only *duty × γ\_geo* most of the time. Make sure the handler always calls:<br>`warpEngine.updateUniforms({ beta0: fullAmplifiedBeta0 })` |
| **Sag depth / bubble radius (`sagDepth_nm`)** | Used **only** to compute `sagRclip` in the warper and to scale the field in the fragment shader    | ✔  Hard-coded 10 µm was removed; warper now uses `bubbleParams.sagDepth_nm`                    | Make sure the mode controller updates this per mode (e.g. **Stand-by** might be 3 nm, **Cruise** 10 nm, etc.).                                                                                 |
| **Average power (`powerAvg_MW`)**             | Drives ripple speed (fragment shader) **and** vertical displacement scale (warper)                 | ✔  Both shaders use it                                                                         | Scaling factor is linear (`power/100 MW`).  That works but exaggerates huge powers; consider `log10` scaling so 10 GW doesn’t explode the grid.                                                |
| **Time-scale ratio (`tsRatio`)**              | Should slow the animation when β-field is almost static                                            | Uniform exists, but **never read** anywhere                                                    | Multiply ripple speed or dy by `1/tsRatio` so “Idle” looks calm.                                                                                                                               |
| **Exotic mass (`exoticMass_kg`)**             | Colour/geometry cue to show WEC violation                                                          | Fragment shader draws a “shock ring”; warper & colour masks ignore it                          | If you want magenta sheets when WEC is violated, pass a flag derived from `exoticMass_kg` instead of hard-coding `beta0>1e5`.                                                                  |
| **Energy-condition flag**                     | Sent to grid fragment shader as `u_energyFlag`                                                     | Flag is computed (`beta0>100 000`) and uploaded                                                | Good, but if you move the rule to depend on negative energy density (from pipeline) you’ll get more faithful colouring.                                                                        |

---

### Two tiny fixes that normally unblock visual changes

```js
// 1️⃣  Wherever you switch modes (keyboard ‘A’, UI button, etc.):
warpEngine.updateUniforms({
    dutyCycle,
    g_y,
    sagDepth_nm,
    powerAvg_MW,
    beta0: dutyCycle * g_y * Math.sqrt(Q_dyn) * Math.pow(gammaVdB, 0.25)
    // …plus any other uniform you compute
});

// 2️⃣  Make tsRatio do something obvious in the fragment shader:
float rippleSpeed = sqrt(u_powerAvg_MW / 100.0) * 2.0 / u_tsRatio;
```

With those two tweaks you should finally see:

* **Stand-by** – sheets barely move, very flat.
* **Hover** – modest bulge and slow ripple.
* **Amplified** – dramatic bowing and fast shimmering grid.

Let me know if you want the full patch diff or if something still refuses to animate!
