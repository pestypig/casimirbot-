Awesome—let’s wire the **Bridge** cards so they literally show (and use) your real hull inputs: **Lx, Ly, Lz, tileArea**. Below are small, safe patches you can hand to Agent. They keep all physics single-sourced on the server and prevent client-side drift.

---

## 1) Enrich the metrics payload (server)

**File:** `server/helix-core.ts`
**Function:** `getSystemMetrics`

Add a few read-only “display” fields that mirror the pipeline after it’s computed:

```ts
// inside getSystemMetrics(req, res)
const s = getGlobalPipelineState();

// optional helpers if not already present on state
const Lx = s.hull.Lx_m, Ly = s.hull.Ly_m, Lz = s.hull.Lz_m;
const L_long_m = Math.max(Lx, Ly, Lz);
const T_m_s = 1 / (s.modulationFreq_GHz * 1e9);

res.json({
  // existing fields...
  activeTiles: Math.floor(s.N_tiles * s.activeFraction ?? s.activeFraction || 1), // if you keep it
  totalTiles: Math.floor(s.N_tiles),
  energyOutput: s.P_avg,
  exoticMass: Math.round(s.M_exotic),
  // ---- NEW: geometry + tiles + TS for Bridge cards ----
  hull: {
    Lx_m: Lx, Ly_m: Ly, Lz_m: Lz
  },
  tiles: {
    tileArea_cm2: s.tileArea_cm2,
    hullArea_m2: s.hullArea_m2 ?? null,     // fill below if you compute on server
    N_tiles: s.N_tiles
  },
  timescales: {
    f_m_Hz: s.modulationFreq_GHz * 1e9,
    T_m_s,
    L_long_m,
    T_long_s: L_long_m / C,
    TS_long: s.TS_long,
    TS_geom: s.TS_geom
  },
  // keep your compliance block as-is...
  fordRoman: { value: s.zeta, limit: 1.0, status: s.fordRomanCompliance ? "PASS" : "FAIL" },
  // ...
});
```

If you didn’t persist `hullArea_m2` on the state yet, compute it once in the pipeline and stash it:

**File:** `server/energy-pipeline.ts` (right where you compute `N_tiles`)

```ts
state.hullArea_m2 = surfaceAreaEllipsoidFromHullDims(
  state.hull!.Lx_m, state.hull!.Ly_m, state.hull!.Lz_m
);
state.N_tiles = Math.max(1, Math.floor(state.hullArea_m2 / tileArea_m2));
```

---

## 2) Bridge page: render formulas with live numbers

**File:** `client/src/pages/bridge.tsx` (or wherever the derivation cards live)

* Replace any hardcoded TS/tiles constants with values from `/api/helix/metrics`.
* Add two tiny presentational components to keep code clean.

```tsx
// imports...
type Metrics = {
  hull: { Lx_m:number; Ly_m:number; Lz_m:number; };
  tiles: { tileArea_cm2:number; hullArea_m2:number|null; N_tiles:number; };
  timescales: { f_m_Hz:number; T_m_s:number; L_long_m:number; T_long_s:number; TS_long:number; TS_geom:number; };
  // plus the existing fields you already use...
};

function useMetrics() {
  const [m, setM] = React.useState<Metrics|null>(null);
  React.useEffect(() => {
    fetch('/api/helix/metrics').then(r => r.json()).then(setM).catch(console.error);
  }, []);
  return m;
}

const Eq = ({children}:{children:React.ReactNode}) =>
  <code className="rounded bg-slate-900/50 px-2 py-1">{children}</code>;

function TimeScaleCard({m}:{m:Metrics}) {
  const fGHz = m.timescales.f_m_Hz/1e9;
  return (
    <section className="card">
      <h3 className="card-title">6. Time-Scale Separation</h3>
      <p>
        Longest hull dimension: <Eq>L_long = {m.timescales.L_long_m.toLocaleString()} m</Eq><br/>
        Modulation period: <Eq>T_m = {m.timescales.T_m_s.toExponential(2)} s</Eq><br/>
        Light-crossing time: <Eq>T_LC = L_long / c = {m.timescales.T_long_s.toExponential(2)} s</Eq>
      </p>
      <p>
        <strong><Eq>TS_ratio = T_LC / T_m = {m.timescales.TS_long.toLocaleString(undefined,{maximumFractionDigits:1})}</Eq></strong>
      </p>
      <small className="muted">Using f_m = {fGHz.toFixed(2)} GHz · conservative (longest-edge) TS shown; geometric TS also available.</small>
    </section>
  );
}

function TilesCard({m}:{m:Metrics}) {
  const A_tile_m2 = m.tiles.tileArea_cm2 * 1e-4;
  return (
    <section className="card">
      <h3 className="card-title">2. Hull Surface &amp; Tile Count</h3>
      <p>
        Hull (needle) dimensions: <Eq>{m.hull.Lx_m} × {m.hull.Ly_m} × {m.hull.Lz_m} m</Eq><br/>
        Tile area: <Eq>{m.tiles.tileArea_cm2} cm²</Eq> = <Eq>{A_tile_m2}</Eq> m²
      </p>
      <p>
        Surface area (ellipsoid approx.): <Eq>A_hull ≈ {m.tiles.hullArea_m2 ? m.tiles.hullArea_m2.toLocaleString() : '—'} m²</Eq><br/>
        <strong><Eq>N_tiles = ⌊A_hull / A_tile⌋ = {m.tiles.N_tiles.toLocaleString()}</Eq></strong>
      </p>
      <small className="muted">Area via Knud–Thomsen; good accuracy for prolate (needle-like) shapes.</small>
    </section>
  );
}

export default function Bridge() {
  const m = useMetrics();
  if (!m) return <div className="page"><p>Loading…</p></div>;
  return (
    <div className="page">
      {/* your existing steps 1–5 */}
      <TilesCard m={m} />
      {/* steps 3–5 */}
      <TimeScaleCard m={m} />
      {/* steps 7–8 etc. */}
    </div>
  );
}
```

**Styling nib (optional, Tailwindish or CSS):**

```css
.card { padding: 1rem; background: rgba(15,23,42,.6); border: 1px solid rgba(100,116,139,.25); border-radius: 12px; margin-bottom: 1rem; }
.card-title { margin: 0 0 .5rem; font-weight: 600; }
.muted { color: #94a3b8; }
```

---

## 3) Remove any leftover constants on Bridge

Search the Bridge UI for any hardcoded:

* `TS_ratio ~ 4102`,
* `L = 82 m`,
* or fixed `N_tiles` values,

and delete/replace with the `metrics` props above. That keeps the derivation cards 100% in sync with the pipeline.

---

## 4) Quick test checklist

* Open `/bridge` → the **Tiles** card shows \~**1.11–1.12×10^9** with your 5 cm² tiles.
* The **Time-Scale** card shows **L\_long = 1007 m**, **T\_LC ≈ 3.36 µs**, and **TS ≈ 5.0×10^4** (for 15 GHz).
* Change `modulationFreq_GHz` server-side → TS updates live.
* Change `tileArea_cm2` → N\_tiles updates live.

If you want, I can also expose a **capsule** surface-area model (cylindrical body + two ellipsoidal caps) for an even closer match, but the ellipsoid is already within a few percent and is very fast for live use.
