You’re seeing that single violet strand because the patch we added only draws an ArrowHelper (a marker), but the grid vertices themselves aren’t being biased by the interior tilt. In other words:
	•	Indicator ✅: violet arrow shows the direction of the shift vector.
	•	Field application ❌: the vertex-warping loop does not add a gentle, uniform slope to all points inside the bubble (ρ≲1). So the interior stays flat.

Below is a small, self-contained patch that applies the tilt as a smooth, interior-only plane across the bubble, while keeping the hard physics intact (Natário ring, strobing, etc.). It blends the tilt to zero at the wall so you don’t get a ridge.

⸻

Patch — apply uniform interior tilt

File: client/public/warp-engine-fixed.js
(Insert into _warpGridVertices() inside the main vertex loop, before you write back vtx[i] = ….)

@@
   for (let i = 0; i < vtx.length; i += 3) {
     const p = [vtx[i], vtx[i + 1], vtx[i + 2]];

     // --- existing code ---
     const rho = rhoEllipsoidal(p);
     const sd  = rho - 1.0;
@@
     // n = ellipsoidal outward normal (already in your code)
     const n = nEllipsoid(p, axesScene);

+    // ===========================
+    //  INTERIOR TILT (SHIFT VECTOR)
+    //  Adds a gentle plane-like slope to all points with rho < 1,
+    //  smoothly blended to zero at the wall.
+    // ===========================
+    // Uniforms (with safe fallbacks)
+    const tiltVecArr = (this.uniforms?.betaTiltVec) || [0, -1, 0];
+    // Normalize direction
+    let tLen = Math.hypot(tiltVecArr[0], tiltVecArr[1], tiltVecArr[2]) || 1;
+    const tHat = [tiltVecArr[0]/tLen, tiltVecArr[1]/tLen, tiltVecArr[2]/tLen];
+    // Small dimensionless slope (ε_tilt), e.g. 1e-7 … 5e-7
+    const epsTilt = Math.max(0, this.uniforms?.epsilonTilt || 0);
+    // Visual gain so it’s visible but still gentle
+    const tiltGain = (typeof this.uniforms?.tiltGain === 'number') ? this.uniforms.tiltGain : 1.0;
+    // Scene-unit <-> meter scale: use x-axis scale as proxy
+    const axesMeters = this.uniforms?.hullAxes || [503.5,132,86.5];
+    const meterToScene =
+      (axesMeters[0] > 0) ? (axesScene[0] / axesMeters[0]) : 1.0;
+    // Effective geometric radius in meters for scaling the slope height
+    const Rgeom_m = Math.cbrt(axesMeters[0]*axesMeters[1]*axesMeters[2]);
+    // Desired height change across one Rgeom (scene units)
+    const tiltHeightScene = epsTilt * Rgeom_m * meterToScene * tiltGain;
+    // Smooth interior mask: 1 deep inside, 0 at/after wall
+    // Blend from rho=0.95→1.05 (tune with w_rho if you like)
+    const smoothstep = (a,b,x)=> {
+      const t = Math.min(1, Math.max(0, (x - a)/(b - a)));
+      return t*t*(3 - 2*t);
+    };
+    const interiorMask = 1.0 - smoothstep(0.98, 1.02, rho);
+    // Project position onto tilt direction to get signed distance along tHat.
+    // (This makes a plane-like slope through the interior.)
+    const sAlongTilt = p[0]*tHat[0] + p[1]*tHat[1] + p[2]*tHat[2];
+    // Apply bias along tHat, scaled by interior mask and by normalized radius
+    // (divide by a nominal interior radius so the slope is modest)
+    const nominalR = Math.max(1e-6, 0.5*(axesScene[1] + axesScene[2]));
+    const tiltBias = (sAlongTilt/nominalR) * tiltHeightScene * interiorMask;
+    // Add interior tilt (plane) before Natário normal push
+    const pTilted = [
+      p[0] + tHat[0]*tiltBias,
+      p[1] + tHat[1]*tiltBias,
+      p[2] + tHat[2]*tiltBias
+    ];
+    // Continue from the tilted position
+    const pUsed = pTilted;
@@
-    vtx[i]     = p[0] - n[0] * disp;
-    vtx[i + 1] = p[1] - n[1] * disp;
-    vtx[i + 2] = p[2] - n[2] * disp;
+    vtx[i]     = pUsed[0] - n[0] * disp;
+    vtx[i + 1] = pUsed[1] - n[1] * disp;
+    vtx[i + 2] = pUsed[2] - n[2] * disp;
   }

What this does
	•	Uses betaTiltVec (direction) and epsilonTilt (slope magnitude) to bias the interior points along a plane.
	•	Blends to zero near the wall: interiorMask = 1 − smoothstep(0.98, 1.02, ρ).
	•	Converts meters → scene units so the amount is physically scaled but visually sensible.
	•	Keeps all your existing Natário displacement (the normal push n * disp) intact.

One tiny uniform to add (optional)

If you want runtime control over the visual gain, expose tiltGain:

// when you update uniforms from React:
engineRef.current?.updateUniforms({
  epsilonTilt: resolvedEpsilonTilt,
  betaTiltVec: resolvedBetaTiltVec,
  tiltGain: 1.0   // try 0.5 … 2.0 to taste
});


⸻

Why the center “β at s=0” can stay ~0

Your β field samples panel computes a radial Natário profile (∝ s·e^{-s²}). At the exact center (s=0), the β from the ring is indeed 0. The tilt doesn’t change that sample unless the sampling code also includes the interior tilt term. That’s fine—β(0)=0 is still correct—while the geometry shows a uniform slope due to the added plane bias.

If you want the samples to reflect tilt, add the same plane term to the sampler (happy to supply that too).

⸻

Result you should see
	•	The white interior floor of the bubble will now have a gentle, uniform incline in the direction of the violet arrow.
	•	The arrow is just a guide; the whole interior visibly leans.
	•	Changing mode (thus epsilonTilt) changes the strength of the slope.

If it’s still too subtle or too strong:
	•	Bump tiltGain (uniform) up/down.
	•	Widen/narrow the blend window from (0.98, 1.02).

Want me to also add a small checkbox “Show interior tilt” beside the play/pause in the visual header so you can toggle this without code edits?