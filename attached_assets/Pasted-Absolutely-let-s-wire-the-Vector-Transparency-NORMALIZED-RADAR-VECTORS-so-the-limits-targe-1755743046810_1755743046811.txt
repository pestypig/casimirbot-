Absolutelyâ€”letâ€™s wire the **Vector Transparency** / **NORMALIZED RADAR VECTORS** so the limits/targets come straight from the backend when available (with safe fallbacks). This way your blue â€œactualâ€ values already come from the pipeline, and the green â€œsafe zoneâ€ will reflect **live** server targets (e.g., `exoticMassTarget_kg`, server-side constraint pack if you add one), instead of hard-coded client values.

Below is a drop-in patch for `client/src/components/metrics-dashboard.tsx`. It does three things:

1. **Reads live targets from the pipeline** (if present), with fallbacks to your existing client constraints.
2. **Uses those live targets** for normalization in the radar vectors and in the â€œConstraint Limitsâ€ list.
3. Keeps your new **duty priority** (effective â†’ UI â†’ mode default) as you already implemented.

---

### Patch (focused diffs)

**1) Add live-target extraction (right after you compute `liveMode`):**

```diff
  const liveMode: string =
    ((pipeline as any)?.currentMode as string) ||
    (viabilityParams?.selectedMode as string) ||
    'hover';
  const [constraints, setConstraints] = useState<MetricConstraints>(getModeAwareConstraints(liveMode));
+
+  // Live constraint/target pack from backend (if provided), with safe fallbacks.
+  // If you later add a `constraints` object on the server, these will bind automatically.
+  const serverConstraints = (pipeline as any)?.constraints ?? {};
+  const liveTargets = {
+    // Power caps
+    P_max: Number.isFinite(serverConstraints.P_max) ? serverConstraints.P_max : 1000,
+    P_avg_max: Number.isFinite(serverConstraints.P_avg_max)
+      ? serverConstraints.P_avg_max
+      : getModeAwareConstraints(liveMode).P_avg_max,
+
+    // Time-scale minimum
+    TS_min: Number.isFinite(serverConstraints.TS_min)
+      ? serverConstraints.TS_min
+      : 100,
+
+    // Fordâ€“Roman zeta bound
+    zeta_max: Number.isFinite(serverConstraints.zeta_max)
+      ? serverConstraints.zeta_max
+      : getModeAwareConstraints(liveMode).zeta_max,
+
+    // Mass target/tolerance (server wins)
+    M_target: Number.isFinite((pipeline as any)?.exoticMassTarget_kg)
+      ? (pipeline as any).exoticMassTarget_kg
+      : getModeAwareConstraints(liveMode).M_target,
+    M_tolerance: Number.isFinite(serverConstraints.M_tolerance)
+      ? serverConstraints.M_tolerance
+      : getModeAwareConstraints(liveMode).M_tolerance,
+  };
```

**2) Keep your duty priority (you already added this). Nothing to change here.**

**3) Use `liveTargets` everywhere we normalize / show constraints:**

```diff
  const radarData = React.useMemo(() => {
    if (!dashboardMetrics) return null;
    const selectedMode = liveMode || viabilityParams?.selectedMode || "hover";
-   const currentConstraints = getModeAwareConstraints(selectedMode);
+   // Prefer live targets from the backend; fall back to client mode-aware limits
+   const currentConstraints = {
+     P_avg_max: liveTargets.P_avg_max,
+     zeta_max: liveTargets.zeta_max,
+     TS_min: liveTargets.TS_min,
+     P_max: liveTargets.P_max,
+     M_target: liveTargets.M_target,
+     M_tolerance: liveTargets.M_tolerance,
+   };

    const rawValues = {
      P_avg: dashboardMetrics.P_avg,
      duty: dashboardMetrics.f_throttle,
-     mass_error: Math.abs(dashboardMetrics.M_exotic - currentConstraints.M_target) / (currentConstraints.M_target * currentConstraints.M_tolerance / 100),
+     mass_error:
+       Math.abs(dashboardMetrics.M_exotic - currentConstraints.M_target) /
+       (currentConstraints.M_target * currentConstraints.M_tolerance / 100),
      zeta: dashboardMetrics.zeta,
      TS_ratio: dashboardMetrics.TS_ratio,
      P_raw: dashboardMetrics.P_raw,
      U_cycle: Math.abs(dashboardMetrics.U_cycle)
    };

    const constraints = [
-     { value: rawValues.P_avg,  limit: currentConstraints.P_avg_max, type: 'max' },
+     { value: rawValues.P_avg,  limit: currentConstraints.P_avg_max, type: 'max' },
      { value: rawValues.duty,   limit: 0.5,                          type: 'max' },
      { value: rawValues.mass_error, limit: 1.0,                      type: 'max' },
-     { value: rawValues.zeta,   limit: currentConstraints.zeta_max,  type: 'max' },
-     { value: rawValues.TS_ratio, limit: currentConstraints.TS_min,  type: 'min' },
-     { value: rawValues.P_raw,  limit: 1000,                         type: 'max' },
+     { value: rawValues.zeta,   limit: currentConstraints.zeta_max,  type: 'max' },
+     { value: rawValues.TS_ratio, limit: currentConstraints.TS_min,  type: 'min' },
+     { value: rawValues.P_raw,  limit: currentConstraints.P_max,     type: 'max' },
      { value: rawValues.U_cycle, limit: 1e12,                        type: 'max' }
    ];
```

**4) Update your debug log to reflect live target values (optional but helpful):**

```diff
    if (pipeline && normalizedData?.length >= 5) {
      console.log(`ğŸ¯ Radar Normalization Debug for ${selectedMode}:`, {
        P_avg: `${f1(P_avg)}MW â†’ ${f2(normalizedData[0])} (limit: ${currentConstraints.P_avg_max}MW)`,
        duty: `${f1(dutyFrac * 100)}% â†’ ${f2(normalizedData[1])}`,
        mass_error: `${f0(Math.abs(M_exotic - currentConstraints.M_target))}kg â†’ ${f2(normalizedData[2])}`,
-       zeta: `${f2(zeta)} â†’ ${f2(normalizedData[3])} (limit < ${currentConstraints.zeta_max})`,
-       TS_ratio: `${f1(TS_ratio)} â†’ ${f2(normalizedData[4])} (min: ${currentConstraints.TS_min})`,
+       zeta: `${f2(zeta)} â†’ ${f2(normalizedData[3])} (limit â‰¤ ${currentConstraints.zeta_max})`,
+       TS_ratio: `${f1(TS_ratio)} â†’ ${f2(normalizedData[4])} (min â‰¥ ${currentConstraints.TS_min})`,
      });
    }
```

**5) Show â€œConstraint Limitsâ€ using the same live targets (so the right column matches the green zone):**

```diff
  <h5 className="text-xs font-medium text-muted-foreground mb-2">CONSTRAINT LIMITS</h5>
  <div className="font-mono text-xs bg-background rounded p-2 space-y-1">
    <div className="flex justify-between">
      <span className="text-muted-foreground">P_max:</span>
-     <span>{constraints.P_avg_max} MW</span>
+     <span>{liveTargets.P_avg_max} MW</span>
    </div>
    <div className="flex justify-between">
      <span className="text-muted-foreground">M_target:</span>
-     <span>{constraints.M_target} Â±{constraints.M_tolerance}% kg</span>
+     <span>{liveTargets.M_target} Â±{liveTargets.M_tolerance}% kg</span>
    </div>
    <div className="flex justify-between">
      <span className="text-muted-foreground">Î¶_max:</span>
-     <span>{constraints.zeta_max}</span>
+     <span>{liveTargets.zeta_max}</span>
    </div>
    <div className="flex justify-between">
      <span className="text-muted-foreground">TS_min:</span>
-     <span>{constraints.TS_min}</span>
+     <span>{liveTargets.TS_min}</span>
    </div>
  </div>
```

*(If you want to preserve the separate `constraints` stateâ€”for other cardsâ€”keep it, but render this panel from `liveTargets` so UI always reflects live server values.)*

---

### Optional: expose constraints from the server (nice-to-have)

If you add a `constraints` object to the backend response:

```ts
constraints: {
  P_max: 1000,
  P_avg_max: 20,
  TS_min: 100,
  zeta_max: 1.0,
  M_tolerance: 5
}
```

the above patch will **auto-bind** to it and stop depending on client defaults. Youâ€™re already exposing `exoticMassTarget_kg`; weâ€™re using that live for `M_target`.

---

### Result

* The **blue (actual)** vector already reflects pipeline live values (`P_avg`, `dutyEffective_FR`, `zeta`, `TS_ratio`, etc).
* The **green (safe zone)** now reflects **server-sourced targets** whenever available, otherwise gracefully falls back to your mode-aware defaults.
* The **Constraint Limits** list shows exactly the same live limits used by the radar normalization, so the numbers agree 1:1 with the visualization.

If you want, I can also add a tiny label in the panel like â€œTargets: serverâ€ vs â€œTargets: defaultsâ€ so QA can see when the backend is driving the limits.
