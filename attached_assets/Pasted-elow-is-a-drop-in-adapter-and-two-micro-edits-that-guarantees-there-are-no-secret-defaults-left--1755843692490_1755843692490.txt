elow is a drop-in adapter (and two micro-edits) that guarantees there are no “secret” defaults left in the visual path.

1) Adapter: pipeline → WarpEngine (single source of truth)
// Call this every time the pipeline state changes (or on a fixed tick)
export function driveWarpFromPipeline(engine, s /* EnergyPipelineState */) {
  if (!engine || !s) return;

  // --- Hull semi-axes in meters (renderer expects [a,b,c]) ---
  const a = (s.hull?.Lx_m ?? s.shipRadius_m*2) / 2;
  const b = (s.hull?.Ly_m ?? s.shipRadius_m*2) / 2;
  const c = (s.hull?.Lz_m ?? s.shipRadius_m*2) / 2;

  // --- Canonical wall width in ρ-units (matches HELIX sampler) ---
  const aEff = Math.cbrt(a * b * c);                 // geometric-mean radius (m)
  const w_m  = Math.max(1e-9, (s.sag_nm ?? 16) * 1e-9);
  const w_rho = Math.max(1e-6, w_m / aEff);

  // --- Ship-wide effective duty (exactly HELIX’s d_eff) ---
  const d_ship = s.dutyEffective_FR ?? (s as any).dutyShip ?? 0.01/400; // safe fallback

  // --- Sectoring: use *total* wedges for York & geometry, never “concurrent” ---
  const sectors = Math.max(1, s.sectorCount || 400);
  const split   = Math.floor(sectors / 2); // canonical (+/–) split

  // --- Physics amplitude chain (renderer consumes this as u_thetaScale) ---
  // NOTE: qSpoilingFactor is an *idle cryo* knob in HELIX; it should NOT scale
  // on-window field amplitude. Keep it out of thetaScale.
  const gammaGeo = Math.max(1, s.gammaGeo ?? 26);
  const gammaVdB = Math.max(0, s.gammaVanDenBroeck ?? 0);
  const thetaScale =
    Math.pow(gammaGeo, 3) *
    gammaVdB *
    Math.sqrt(Math.max(1e-12, d_ship / sectors));

  // --- Burst Q for visuals (matches HELIX Q_BURST semantics) ---
  const Qburst = s.qCavity ?? 1e9;

  // --- Mode & parity (MODEL_MODE=raw ⇒ parity visuals) ---
  const physicsParityMode = (s.modelMode === 'raw');

  // Push everything into the renderer in one shot
  engine.updateUniforms({
    // Physics/ops
    currentMode: s.currentMode,
    dutyCycle: d_ship,                // ship-wide effective duty
    sectors, split,
    gammaGeo, gammaVdB, Qburst,
    // keep idle spoil around for diagnostics only (not in thetaScale)
    qSpoilingFactor: s.qSpoilingFactor,
    deltaAOverA: 1.0,                 // do not amplitude-scale visuals with spoil
    // Geometry
    hullAxes: [a, b, c],
    wallWidth_rho: w_rho,
    // Unified amplitude handed in numerically
    thetaScale,
    // Parity / cosmetics
    physicsParityMode,
    // Optional: keep your existing cosmetics; parity mode will disable them
    // cosmeticLevel: 10,
    // curvatureBoostMax: 40,
    // curvatureGainT: 0.0,
  });
}


Usage example:

import { getGlobalPipelineState } from './helix-core';
import WarpEngine from './WarpEngine';

const engine = new WarpEngine(document.getElementById('warpCanvas'));

// initial paint
driveWarpFromPipeline(engine, getGlobalPipelineState());

// whenever HELIX updates
const state = getGlobalPipelineState();
driveWarpFromPipeline(engine, state);