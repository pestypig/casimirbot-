WarpBubbleCompare. Two concrete issues usually cause the “no visible change” symptom:

The dual engines are not fed distinct physics at render time (stale snapshot / wrong chain).

Preset calls or mismatched uniforms overwrite live updates (e.g., calling setPresetShowcase() after you push uniforms), so mode/duty changes never reach the shaders/CPU warp.

Below is a drop-in fix that (a) computes per-pane physics on the client using the same chain as your Energy Pipeline, and (b) pushes coherent uniforms to each engine whenever the pipeline changes.

1) Add a tiny client-side calculator (identical chain)

Put this near the top of WarpBubbleCompare.tsx (or in a small warp/physics.ts util):

// ---- client-side physics calc identical to EnergyPipeline ----
type BaseInputs = {
  hull: { a: number; b: number; c: number };
  wallWidth_m?: number;
  driveDir?: [number, number, number];
  vShip?: number;

  // duties
  dutyCycle: number;          // UI duty (0..1)
  dutyEffectiveFR: number;    // ship-wide FR duty (0..1)

  // sectors
  sectorCount: number;        // total sectors (averaging)
  sectors: number;            // concurrent (strobing)

  // physics chain
  gammaGeo: number;           // γ_geo
  qSpoilingFactor: number;    // ΔA/A
  gammaVanDenBroeck: number;  // γ_VdB

  colorMode?: 'theta'|'shear'|'solid';
  lockFraming?: boolean;
};

const clamp01 = (x: number) => Math.max(0, Math.min(1, x));

function buildThetaScale(base: BaseInputs, flavor: 'fr'|'ui') {
  // canonical: θ-scale = γ^3 · (ΔA/A) · γ_VdB · √(duty / sectors_avg)
  const g3   = Math.pow(Math.max(1, base.gammaGeo), 3);
  const dAA  = Math.max(1e-12, base.qSpoilingFactor);
  const gVdB = Math.max(1, base.gammaVanDenBroeck);

  const duty = (flavor === 'fr') 
    ? clamp01(base.dutyEffectiveFR)                     // ship-averaged FR duty
    : clamp01(base.dutyCycle / Math.max(1, base.sectorCount)); // UI duty averaged over all sectors

  const sectorsAvg = Math.max(1, base.sectorCount);
  const dutySqrt = Math.sqrt(Math.max(1e-12, duty));    // √(duty) ; sectors already averaged in "duty" above

  return g3 * dAA * gVdB * dutySqrt;
}

function buildCommonUniforms(base: BaseInputs) {
  return {
    // geometry
    hullAxes: [base.hull.a, base.hull.b, base.hull.c] as [number,number,number],
    wallWidth_m: base.wallWidth_m ?? 6.0,
    driveDir: base.driveDir ?? [1,0,0],
    vShip: base.vShip ?? 1.0,

    // timing / averaging
    dutyCycle: base.dutyCycle,          // UI duty (for diagnostics)
    sectors: Math.max(1, base.sectors), // concurrent
    sectorCount: Math.max(1, base.sectorCount), // total
    viewAvg: true,

    // visual defaults
    colorMode: base.colorMode ?? 'theta',
    lockFraming: base.lockFraming ?? true,
  };
}

export function buildEngineUniforms(base: BaseInputs) {
  const common = buildCommonUniforms(base);
  const real = {
    ...common,
    thetaScale: buildThetaScale(base, 'fr'),
    physicsParityMode: true,
    ridgeMode: 0,          // ⚠ physics double-lobe (real)
    exposure: 4.2,
    zeroStop: 1e-6,
    cosmeticLevel: 1,
    curvatureGainT: 0,
    curvatureBoostMax: 1,
    userGain: 1,
  };
  const show = {
    ...common,
    thetaScale: buildThetaScale(base, 'ui'),
    physicsParityMode: false,
    ridgeMode: 1,          // single crest at ρ=1 (show)
    exposure: 7.5,
    zeroStop: 1e-7,
    cosmeticLevel: 10,
    // these two can be driven by your "heroExaggeration"/slider
    curvatureGainT: 0.70,
    curvatureBoostMax: 40,
    userGain: 4.0,
  };
  return { real, show };
}


Note the ridgeMode fix: in your engine, 0 = physics double-lobe, 1 = single crest. Your comments said the opposite; that mismatch alone causes confusing visuals.