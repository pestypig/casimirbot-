import React, {useEffect, useMemo, useRef, useState} from "react";
/**
 * WarpRenderInspector • Physics Debug (integrated)
 *
 * Adds a per-pane Checkpoints Panel under the REAL/SHOW canvases to verify the
 * entire path from Energy/Calculator → WarpEngine uniforms → Render loop.
 *
 * It surfaces likely causes for: (1) operational mode not affecting curvature
 * and (2) black screens. Each row shows green/yellow/red with fix buttons.
 */

// ---- Utility: type-light helpers -------------------------------------------
type Num = number | undefined | null;
const N = (x: Num, d = 0) => (Number.isFinite(x as number) ? Number(x) : d);
const clamp01 = (x: number) => Math.max(0, Math.min(1, x));

// Push only after shaders are ready
function pushUniformsWhenReady(engine: any, patch: Record<string, any>) {
  if (!engine) return;
  if (engine.isLoaded && engine.gridProgram) {
    engine.updateUniforms(patch);
  } else {
    engine.onceReady(() => engine.updateUniforms(patch));
  }
}

// A safe camera helper (optional override)
function compactCameraZ(axesScene?: number[] | null, canvas?: HTMLCanvasElement | null) {
  const ax = axesScene || [1,1,1];
  const R = Math.max(ax[0], ax[1], ax[2]) || 1;
  const w = canvas?.clientWidth || canvas?.width || 800;
  const h = canvas?.clientHeight || canvas?.height || 450;
  const aspect = w / Math.max(1, h);
  const fovDesktop = Math.PI / 3.272;  // ~55°
  const fovPortrait = Math.PI / 2.65;  // ~68°
  const t = Math.min(1, Math.max(0, (1.2 - aspect) / 0.6));
  const fov = fovDesktop * (1 - t) + fovPortrait * t;
  const margin = 1.0;
  return (margin * R) / Math.tan(fov * 0.5);
}

// Mode → visual seasoning presets (so changes are obvious)
const MODE_PRESET: Record<string, {curvT:number; boost:number; displayGain:number}> = {
  hover:     { curvT: 0.25, boost: 20, displayGain: 1.0 },
  cruise:    { curvT: 0.45, boost: 30, displayGain: 2.0 },
  emergency: { curvT: 0.70, boost: 40, displayGain: 6.0 },
  standby:   { curvT: 0.00, boost:  1, displayGain: 1.0 },
};

/* ================== Checkpoints Panel (internal component) ================= */

type Pane = 'REAL' | 'SHOW';

function expectedThetaScaleFromUniforms(U: any) {
  const g = N(U?.gammaGeo, 26);
  const dAA = Math.max(1e-12, N(U?.deltaAOverA ?? U?.qSpoilingFactor, 1));
  const gV = Math.max(1, N(U?.gammaVdB ?? U?.gammaVanDenBroeck, 2.86e5));
  const sectors = Math.max(1, N(U?.sectors ?? U?.sectorCount ?? U?.sectorStrobing, 1));
  const duty = Math.max(0, N(U?.dutyCycle, 0));
  const viewAvg = (U?.viewAvg ?? true) ? 1 : 0;
  const betaInst = Math.pow(Math.max(1, g), 3) * dAA * gV;
  const eff = Math.max(1e-12, duty / sectors);
  return viewAvg ? betaInst * Math.sqrt(eff) : betaInst;
}

function usePaneSnapshot(engineRef: React.MutableRefObject<any>, canvasRef: React.MutableRefObject<HTMLCanvasElement|null>) {
  const [snap, setSnap] = useState<any>({});
  useEffect(() => {
    let alive = true;
    const tick = () => {
      const e = engineRef.current;
      const gl: WebGLRenderingContext | WebGL2RenderingContext | null = e?.gl || null;
      const u = e?.uniforms || {};
      const diag = (() => { try { return e?.computeDiagnostics?.(); } catch { return null; } })();
      const canvas = canvasRef.current;
      const ctxLost = !!(gl && (gl as any).isContextLost && (gl as any).isContextLost());
      const sized = !!(canvas && (canvas.width || 0) > 0 && (canvas.height || 0) > 0);
      const shLinked = !!(e?.gridProgram && e?.isLoaded);
      const theta = N(u?.thetaScale, NaN);
      const thetaExpected = expectedThetaScaleFromUniforms(u);
      const axesOk = Array.isArray(u?.axesClip) && u.axesClip.length === 3 && u.axesClip.every((v: any)=>Number.isFinite(v) && Math.abs(v) > 1e-9);
      const camOk = Number.isFinite(u?.cameraZ) || u?.lockFraming === true; // if locked, engine fits overhead
      const gridOk = !!(e?.gridVbo && e?.gridVertices && e.gridVertices.length > 0);
      const strobeOk = Math.max(1, N(u?.sectors, 0)) >= 1 && N(u?.split, 0) >= 0 && N(u?.split, 0) < Math.max(1, N(u?.sectors, 1));
      const rafActive = e?._raf != null;
      const exposure = N(u?.exposure, 0);
      const zeroStop = N(u?.zeroStop, 0);

      const pane: Pane | undefined = u?.physicsParityMode ? 'REAL' : 'SHOW';
      const parityOk = (pane === 'REAL') ? (u?.physicsParityMode === true && (u?.ridgeMode|0) === 0)
                                         : (u?.physicsParityMode === false && (u?.ridgeMode|0) === 1);

      const nearBlackReason = (() => {
        if (!sized) return 'Canvas has 0px size';
        if (ctxLost) return 'WebGL context lost';
        if (!shLinked) return 'Shaders not linked';
        if (!gridOk) return 'Grid VBO/vertices not ready';
        if (!axesOk) return 'axesClip invalid';
        if (!camOk) return 'cameraZ missing';
        return null;
      })();

      const thetaMismatch = Number.isFinite(theta) ? Math.abs(theta - thetaExpected) / Math.max(1e-12, thetaExpected) : NaN;

      const row = {
        sized, ctxLost, shLinked, axesOk, camOk, gridOk, strobeOk, rafActive,
        exposure, zeroStop, parityOk, nearBlackReason,
        theta, thetaExpected, thetaMismatch,
        uniforms: u, diag,
      };
      if (alive) setSnap(row);
    };
    const id = window.setInterval(tick, 750);
    tick();
    return () => { alive = false; window.clearInterval(id); };
  }, [engineRef, canvasRef]);
  return snap;
}

function StatusDot({ok, warn = false}: {ok: boolean; warn?: boolean}) {
  const color = ok ? 'bg-emerald-500' : warn ? 'bg-amber-500' : 'bg-rose-500';
  return <span className={`inline-block w-2.5 h-2.5 rounded-full ${color}`} />;
}

function Row({label, left, right}: {label: string; left: React.ReactNode; right: React.ReactNode}){
  return (
    <div className="grid grid-cols-[1fr_auto_auto] gap-3 items-center py-1 border-b border-white/5 last:border-0">
      <div className="text-xs text-slate-300">{label}</div>
      <div className="text-xs text-slate-200 flex items-center gap-2">{left}</div>
      <div className="text-xs text-slate-200 flex items-center gap-2">{right}</div>
    </div>
  );
}

function PaneQuickFixes({pane, engineRef, canvasRef}:{pane:Pane; engineRef:React.MutableRefObject<any>; canvasRef:React.MutableRefObject<HTMLCanvasElement|null>}){
  const e = engineRef.current;
  const c = canvasRef.current;
  const fit = () => {
    try {
      const axes = e?.uniforms?.axesClip || [1,1,1];
      const z = compactCameraZ(axes, c);
      pushUniformsWhenReady(e, { cameraZ: z, lockFraming: true });
      e?.forceRedraw?.();
    } catch {}
  };
  return (
    <div className="flex flex-wrap gap-2">
      <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={()=>{ try{ e?._resizeCanvasToDisplaySize?.(); e?._resize?.(); e?.forceRedraw?.(); }catch{} }}>Resize</button>
      <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={fit}>Fit camera</button>
      <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={()=>{ try{ e?._compileGridShaders?.(); }catch{} }}>Recompile shaders</button>
      <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={()=>{ try{ e?.gl?.getExtension('WEBGL_lose_context')?.restoreContext?.(); }catch{} }}>Restore GL</button>
      <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={()=>{ try{ e?._render?.(); e?.forceRedraw?.(); }catch{} }}>Re-render</button>
      {pane==='REAL' ? (
        <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={()=>{ try{ e?.setPresetParity?.(); }catch{} }}>Preset: Parity</button>
      ) : (
        <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-[11px]" onClick={()=>{ try{ e?.setPresetShowcase?.(); }catch{} }}>Preset: Show</button>
      )}
    </div>
  );
}

function PaneSummary({title, snap}:{title:string; snap:any}){
  const classBox = "rounded-xl border border-white/10 p-3 bg-slate-900/40";
  return (
    <div className={classBox}>
      <div className="text-xs text-slate-400 mb-1">{title}</div>
      <div className="grid grid-cols-2 gap-x-3 gap-y-1 text-[11px] leading-tight">
        <div className="text-slate-400">θ-scale</div>
        <div className="text-slate-200">{Number.isFinite(snap.theta) ? snap.theta.toExponential(2) : '—'}</div>
        <div className="text-slate-400">θ expected</div>
        <div className={`text-slate-200 ${Number.isFinite(snap.thetaMismatch) && snap.thetaMismatch>0.25 ? 'text-amber-300' : ''}`}>{Number.isFinite(snap.thetaExpected) ? snap.thetaExpected.toExponential(2) : '—'}</div>
        <div className="text-slate-400">mismatch</div>
        <div className={`${Number.isFinite(snap.thetaMismatch) && snap.thetaMismatch>0.5 ? 'text-rose-300' : 'text-emerald-300'}`}>{Number.isFinite(snap.thetaMismatch) ? (snap.thetaMismatch*100).toFixed(0)+"%" : '—'}</div>
        <div className="text-slate-400">exposure • zeroStop</div>
        <div className="text-slate-200">{snap.exposure?.toFixed?.(2)} • {snap.zeroStop?.toExponential?.(2)}</div>
        <div className="text-slate-400">strobing</div>
        <div className="text-slate-200">s={snap.uniforms?.sectors} • split={snap.uniforms?.split}</div>
      </div>
    </div>
  );
}

function WarpRenderCheckpointsPanel({
  leftLabel = 'REAL',
  rightLabel = 'SHOW',
  leftEngineRef,
  rightEngineRef,
  leftCanvasRef,
  rightCanvasRef,
}: {
  leftLabel?: string; rightLabel?: string;
  leftEngineRef: React.MutableRefObject<any>;
  rightEngineRef: React.MutableRefObject<any>;
  leftCanvasRef: React.MutableRefObject<HTMLCanvasElement|null>;
  rightCanvasRef: React.MutableRefObject<HTMLCanvasElement|null>;
}){
  const L = usePaneSnapshot(leftEngineRef, leftCanvasRef);
  const R = usePaneSnapshot(rightEngineRef, rightCanvasRef);

  const Head = (
    <div className="grid grid-cols-[1fr_auto_auto] gap-3 items-center px-3 py-2 border-b border-white/10">
      <div className="text-[11px] uppercase tracking-wider text-slate-400">Checkpoints</div>
      <div className="text-[11px] text-slate-400">{leftLabel}</div>
      <div className="text-[11px] text-slate-400">{rightLabel}</div>
    </div>
  );

  const okRow = (val:boolean|undefined, warn=false)=> <><StatusDot ok={!!val} warn={warn && !val} /> <span>{val? 'OK':'Fail'}</span></>;

  return (
    <div className="rounded-2xl border border-white/10 bg-slate-950/40 overflow-hidden">
      {Head}
      <div className="px-3">
        <Row label="Canvas sized (px)">
          {{ left: (<>{okRow(L.sized)} <span className="text-[11px] text-slate-400">{leftCanvasRef.current?.width}×{leftCanvasRef.current?.height}</span></>), right: (<>{okRow(R.sized)} <span className="text-[11px] text-slate-400">{rightCanvasRef.current?.width}×{rightCanvasRef.current?.height}</span></>) }}
        </Row>
        <Row label="WebGL context">
          {{ left: (<>{okRow(!L.ctxLost)}</>), right: (<>{okRow(!R.ctxLost)}</>) }}
        </Row>
        <Row label="Shaders linked / ready">
          {{ left: (<>{okRow(L.shLinked)}</>), right: (<>{okRow(R.shLinked)}</>) }}
        </Row>
        <Row label="Uniforms: axesClip + cameraZ">
          {{ left: (<>{okRow(L.axesOk && L.camOk, !L.axesOk || !L.camOk)}</>), right: (<>{okRow(R.axesOk && R.camOk, !R.axesOk || !R.camOk)}</>) }}
        </Row>
        <Row label="θ-scale valid & matches">
          {{ left: (<>{okRow(Number.isFinite(L.theta) && L.theta>0 && (L.thetaMismatch??0) < 0.5, Number.isFinite(L.thetaMismatch) && (L.thetaMismatch??0) >= 0.5)}</>), right: (<>{okRow(Number.isFinite(R.theta) && R.theta>0 && (R.thetaMismatch??0) < 0.5, Number.isFinite(R.thetaMismatch) && (R.thetaMismatch??0) >= 0.5)}</>) }}
        </Row>
        <Row label="Parity / Ridge as expected">
          {{ left: (<>{okRow(L.parityOk)}</>), right: (<>{okRow(R.parityOk)}</>) }}
        </Row>
        <Row label="Grid buffers present">
          {{ left: (<>{okRow(L.gridOk)}</>), right: (<>{okRow(R.gridOk)}</>) }}
        </Row>
        <Row label="Strobing sane (sectors/split)">
          {{ left: (<>{okRow(L.strobeOk, !L.strobeOk)}</>), right: (<>{okRow(R.strobeOk, !R.strobeOk)}</>) }}
        </Row>
        <Row label="Render loop active">
          {{ left: (<>{okRow(L.rafActive)}</>), right: (<>{okRow(R.rafActive)}</>) }}
        </Row>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 py-3">
          <PaneSummary title={`${leftLabel} snapshot`} snap={L} />
          <PaneSummary title={`${rightLabel} snapshot`} snap={R} />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 pb-3">
          <div className="rounded-xl border border-white/10 p-2"><PaneQuickFixes pane={'REAL'} engineRef={leftEngineRef} canvasRef={leftCanvasRef} /></div>
          <div className="rounded-xl border border-white/10 p-2"><PaneQuickFixes pane={'SHOW'} engineRef={rightEngineRef} canvasRef={rightCanvasRef} /></div>
        </div>
        {(L.nearBlackReason || R.nearBlackReason) && (
          <div className="rounded-xl border border-rose-500/30 bg-rose-500/10 text-rose-200 text-xs p-3 mb-3">
            <div className="font-medium mb-1">Likely black-screen causes</div>
            <ul className="list-disc pl-4">
              {L.nearBlackReason && <li><span className="opacity-70">{leftLabel}:</span> {L.nearBlackReason}</li>}
              {R.nearBlackReason && <li><span className="opacity-70">{rightLabel}:</span> {R.nearBlackReason}</li>}
            </ul>
          </div>
        )}
      </div>
    </div>
  );
}

// ---- Main Component ---------------------------------------------------------
export default function WarpRenderInspector(props: {
  parityPhys?: Record<string, any>;
  showPhys?: Record<string, any>;
  baseShared?: Record<string, any>;
}){
  const leftRef = useRef<HTMLCanvasElement>(null);   // REAL
  const rightRef = useRef<HTMLCanvasElement>(null);  // SHOW
  const leftEngine = useRef<any>(null);
  const rightEngine = useRef<any>(null);

  const [mode, setMode] = useState<'hover'|'cruise'|'emergency'|'standby'>('hover');
  const [ridgeMode, setRidgeMode] = useState<0|1>(1); // 0=physics df, 1=single crest
  const [colorMode, setColorMode] = useState<'theta'|'shear'|'solid'>('theta');
  const [userGain, setUserGain] = useState(1);
  const [decades, setDecades] = useState(0.6 * 8); // UI slider 0..8 → 0..1

  // Pulled from calculator (if present). Keeps names WarpEngine expects.
  const shared = useMemo(() => ({
    colorMode,
    ridgeMode,
    lockFraming: true,
    hull: { a: 503.5, b: 132, c: 86.5 }, // default hull
    hullAxes: [1, 1, 1],
    gridSpan: 2.6,
    sectors: 400,
    split: 0,
    ...props.baseShared,
  }), [props.baseShared, colorMode, ridgeMode]);

  // Build REAL and SHOW payloads using canonical keys and aliases.
  const realPayload = useMemo(() => {
    const p = props.parityPhys || {};
    return {
      ...shared,
      // geometry
      hull: p.hull || p.hullDims || shared.hull,
      hullAxes: p.hullAxes || shared.hullAxes,
      gridSpan: p.gridSpan ?? shared.gridSpan,
      // physics chain & overrides
      physicsParityMode: true,
      gammaGeo: N(p.gammaGeo ?? p.g_y, 26),
      deltaAOverA: N(p.deltaAOverA ?? p.qSpoilingFactor, 1),
      gammaVdB: N(p.gammaVdB ?? p.gammaVanDenBroeck, 2.86e5),
      dutyCycle: N(p.dutyCycle, 0.14),
      dutyEffectiveFR: N(p.dutyEffectiveFR ?? p.dutyEff ?? p.dutyFR, undefined),
      sectors: Math.max(1, Math.floor(N(p.sectors ?? p.sectorCount, shared.sectors ?? 1))),
      split: Math.max(0, Math.floor(N(p.split ?? p.sectorSplit ?? shared.split, 0))),
      // conservative visuals
      exposure: 3.5,
      zeroStop: 1e-5,
      curvatureGainT: 0.0,
      curvatureBoostMax: 1,
      vizGain: 1,
      displayGain: 1,
      userGain: Math.max(1, userGain),
      currentMode: mode,
    };
  }, [props.parityPhys, shared, userGain, mode]);

  const showPayload = useMemo(() => {
    const p = props.showPhys || {};
    const T = clamp01(decades / 8);
    const mp = MODE_PRESET[mode] || MODE_PRESET.hover;
    return {
      ...shared,
      physicsParityMode: false,
      hull: p.hull || p.hullDims || shared.hull,
      hullAxes: p.hullAxes || shared.hullAxes,
      gridSpan: p.gridSpan ?? shared.gridSpan,
      gammaGeo: N(p.gammaGeo ?? p.g_y, 26),
      deltaAOverA: N(p.deltaAOverA ?? p.qSpoilingFactor, 1),
      gammaVdB: N(p.gammaVdB ?? p.gammaVanDenBroeck, 2.86e5),
      dutyCycle: N(p.dutyCycle, 0.14),
      sectors: Math.max(1, Math.floor(N(p.sectors ?? p.sectorCount, shared.sectors ?? 1))),
      split: Math.max(0, Math.floor(N(p.split ?? p.sectorSplit ?? shared.split, 0))),
      // boosted visuals (operational-mode seasoning baked in so you can SEE it)
      curvatureGainT: Math.max(mp.curvT, T),
      curvatureBoostMax: Math.max(mp.boost, 20),
      zeroStop: 1e-7,
      exposure: 6.0,
      vizGain: 1.0,
      displayGain: Math.max(1, mp.displayGain),
      userGain: Math.max(1, userGain),
      currentMode: mode,
    };
  }, [props.showPhys, shared, userGain, decades, mode]);

  // Engine creation & lifecycle
  useEffect(() => {
    const W: any = (window as any).WarpEngine;
    if (!W) { console.error("WarpEngine not found on window. Load warp-engine.js first."); return; }
    if (leftRef.current && !leftEngine.current)  leftEngine.current  = new W(leftRef.current);
    if (rightRef.current && !rightEngine.current) rightEngine.current = new W(rightRef.current);
    // Bootstrap so the first frame fits correctly
    leftEngine.current?.bootstrap({ ...realPayload });
    rightEngine.current?.bootstrap({ ...showPayload });
    // Diagnostics → window for quick comparison
    leftEngine.current && (leftEngine.current.onDiagnostics  = (d: any) => ((window as any).__diagREAL = d));
    rightEngine.current && (rightEngine.current.onDiagnostics = (d: any) => ((window as any).__diagSHOW = d));
    return () => {
      try { leftEngine.current?.destroy(); } catch {}
      try { rightEngine.current?.destroy(); } catch {}
      leftEngine.current = null as any;
      rightEngine.current = null as any;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Apply payloads any time calculator/shared/controls change
  useEffect(() => {
    if (!leftEngine.current || !rightEngine.current) return;
    // REAL
    pushUniformsWhenReady(leftEngine.current, {
      ...realPayload,
      ridgeMode: 0,
      physicsParityMode: true,
    });
    // SHOW
    pushUniformsWhenReady(rightEngine.current, {
      ...showPayload,
      ridgeMode: 1,
      physicsParityMode: false,
    });
    // Optional camera sweetener so both keep same framing
    const ax = (shared as any).axesScene || leftEngine.current?.uniforms?.axesClip;
    const cz = compactCameraZ(ax, leftRef.current);
    pushUniformsWhenReady(leftEngine.current,  { cameraZ: cz });
    pushUniformsWhenReady(rightEngine.current, { cameraZ: cz });
  }, [realPayload, showPayload, shared]);

  // Wire strobing once; both engines receive the same stream
  useEffect(() => {
    const add = (window as any).__addStrobingListener as undefined | ((cb: any) => () => void);
    if (!add) return;
    const off = add(({ sectorCount, currentSector, split }: any) => {
      const s = Math.max(1, sectorCount|0);
      const sp = Number.isFinite(split) ? (split|0) : (currentSector|0);
      const payload = { sectors: s, split: Math.max(0, Math.min(s - 1, sp)) };
      pushUniformsWhenReady(leftEngine.current,  payload);
      pushUniformsWhenReady(rightEngine.current, payload);
    });
    return () => { try { off?.(); } catch {} };
  }, []);

  // UI events
  const onMode = (m: 'hover'|'cruise'|'emergency'|'standby') => setMode(m);

  return (
    <div className="w-full grid gap-4 p-4">
      <header className="flex items-end justify-between">
        <div>
          <h2 className="text-xl font-semibold">Operational Render Inspector</h2>
          <p className="text-sm text-neutral-500">REAL (Ford–Roman parity) vs SHOW (UI boosted) — same render path as WarpBubbleCompare.</p>
        </div>
        <div className="flex items-center gap-3">
          <label className="text-sm font-medium">Mode</label>
          {(['hover','cruise','emergency','standby'] as const).map(m => (
            <button
              key={m}
              onClick={() => onMode(m)}
              className={`px-3 py-1 rounded-2xl text-sm border ${mode===m? 'bg-blue-600 text-white border-blue-600' : 'border-neutral-300 hover:bg-neutral-100'}`}
            >{m}</button>
          ))}
        </div>
      </header>

      <section className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <article className="rounded-2xl border border-neutral-200 bg-neutral-950/40 p-3">
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-sm font-semibold">REAL — Parity (Ford–Roman)</h3>
            <div className="text-xs text-neutral-400">ridgeMode=0 • {colorMode}</div>
          </div>
          <div className="relative aspect-video rounded-xl overflow-hidden bg-black/90">
            <canvas ref={leftRef} className="w-full h-full block"/>
          </div>
        </article>
        <article className="rounded-2xl border border-neutral-200 bg-neutral-950/40 p-3">
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-sm font-semibold">SHOW — Boosted (UI)</h3>
            <div className="text-xs text-neutral-400">ridgeMode=1 • {colorMode}</div>
          </div>
          <div className="relative aspect-video rounded-xl overflow-hidden bg-black/90">
            <canvas ref={rightRef} className="w-full h-full block"/>
          </div>
        </article>
      </section>

      {/* === NEW: Checkpoints Panel under the viewers === */}
      <WarpRenderCheckpointsPanel
        leftLabel="REAL"
        rightLabel="SHOW"
        leftEngineRef={leftEngine}
        rightEngineRef={rightEngine}
        leftCanvasRef={leftRef}
        rightCanvasRef={rightRef}
      />

      <section className="grid grid-cols-1 lg:grid-cols-3 gap-4">
        <div className="rounded-2xl border border-neutral-200 p-4">
          <h4 className="font-medium mb-3">Visual Controls</h4>
          <div className="flex items-center justify-between mb-2">
            <label className="text-sm">Color</label>
            <select value={colorMode} onChange={e=>setColorMode(e.target.value as any)} className="border rounded px-2 py-1 text-sm">
              <option value="theta">theta (diverging)</option>
              <option value="shear">shear (teal→lime)</option>
              <option value="solid">solid</option>
            </select>
          </div>
          <div className="flex items-center justify-between mb-2">
            <label className="text-sm">Ridge</label>
            <select value={ridgeMode} onChange={e=>setRidgeMode(Number(e.target.value) as 0|1)} className="border rounded px-2 py-1 text-sm">
              <option value={0}>0 — physics df (double-lobe)</option>
              <option value={1}>1 — single crest at ρ=1</option>
            </select>
          </div>
          <div className="mb-2">
            <label className="text-sm">Decades blend (T) — SHOW</label>
            <input type="range" min={0} max={8} step={0.01} value={decades}
              onChange={e=>setDecades(Number(e.target.value))} className="w-full"/>
            <div className="text-xs text-neutral-500">T={(decades/8).toFixed(2)} • boost≤40</div>
          </div>
          <div className="mb-2">
            <label className="text-sm">User Gain (both)</label>
            <input type="range" min={1} max={64} step={0.1} value={userGain}
              onChange={e=>setUserGain(Number(e.target.value))} className="w-full"/>
            <div className="text-xs text-neutral-500">{userGain.toFixed(2)}×</div>
          </div>
        </div>
        <div className="rounded-2xl border border-neutral-200 p-4">
          <h4 className="font-medium mb-3">Strobing</h4>
          <div className="text-sm text-neutral-600 mb-2">Use your existing strobing emitter; this panel listens and forwards to both engines.</div>
          <div className="text-xs text-neutral-500">Tip: in DevTools → <code>window.setStrobingState({`{sectorCount:6,currentSector:2}`});</code></div>
        </div>
        <div className="rounded-2xl border border-neutral-200 p-4">
          <h4 className="font-medium mb-3">Live Engine Snapshot</h4>
          <button
            className="px-3 py-1 rounded bg-neutral-900 text-white text-sm"
            onClick={() => {
              const L = leftEngine.current?.uniforms; const R = rightEngine.current?.uniforms;
              console.table({
                REAL_thetaScale: L?.thetaScale, SHOW_thetaScale: R?.thetaScale,
                REAL_gammaVdB: L?.gammaVdB, SHOW_gammaVdB: R?.gammaVdB,
                REAL_dutyFR: (leftEngine.current?.uniforms as any)?.dutyEffectiveFR,
                REAL_dutyCycle: L?.dutyCycle, SHOW_dutyCycle: R?.dutyCycle,
                sectors: L?.sectors, split: L?.split,
                REAL_parity: L?.physicsParityMode, SHOW_parity: R?.physicsParityMode,
              });
              console.log('REAL diag', (window as any).__diagREAL);
              console.log('SHOW diag', (window as any).__diagSHOW);
            }}
          >Dump uniforms + diagnostics</button>
          <p className="text-xs text-neutral-500 mt-2">Opens a concise table/diagnostics in DevTools.</p>
        </div>
      </section>
    </div>
  );
}
