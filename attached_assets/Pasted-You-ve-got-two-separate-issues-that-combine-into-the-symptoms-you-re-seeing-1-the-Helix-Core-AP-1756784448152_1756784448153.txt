You’ve got two separate issues that combine into the symptoms you’re seeing:

1. the Helix Core API is handing the viewer the wrong uniform bundle (naming + provenance mismatch), and
2. WarpBubbleCompare’s REAL payload isn’t giving WarpEngine the canonical keys it actually uses to compute θ.

Here’s the tight read with exact line refs and the minimal fixes.

---

# What’s going wrong (and where)

## A) Helix Core is exporting the *wrong* `warpUniforms` object

Inside `helix-core.ts` you build a proper, “canonical for engines” bundle that uses **short, engine-facing keys**:

* `gammaVdB` (not `gammaVanDenBroeck`) and
* `deltaAOverA` (not `qSpoilingFactor`)
* plus `dutyEffectiveFR` and the mode

See the canonical, engine-facing `warpUniforms` you construct here: `gammaVdB`, `deltaAOverA`, etc.&#x20;

…but in the final JSON you actually send **`canonicalWarpUniforms`** under the name `warpUniforms` — which uses the **long, UI-ish names** (`gammaVanDenBroeck`, `qSpoilingFactor`) and even includes a precomputed `thetaScale`.  This is the opposite of what the engine expects (and the comment above it implies). The long-name packet is defined here (note `gammaVanDenBroeck`, `qSpoilingFactor`, and `thetaScale`).&#x20;

Why that matters: The engine **intentionally ignores external θ** and recomputes it from canonical inputs; it also hard-zeros REAL+standby. So handing it the wrong-named keys silently degrades to defaults and θ looks “stagnant.” The ignore-θ code path is explicit: “Engine authority: never accept external θ; hard-zero REAL+standby.”&#x20;

## B) WarpBubbleCompare’s REAL payload uses wrong keys

When building the REAL uniforms, WBC sends:

* `qSpoilingFactor` instead of **`deltaAOverA`**, and
* `gammaVanDenBroeck_mass` instead of **`gammaVdB`**.

See the REAL payload build; note `qSpoilingFactor` and `gammaVanDenBroeck_mass`. &#x20;

But WarpEngine’s θ chain multiplies **`gammaGeo³ × deltaAOverA × gammaVdB × √duty`** (or `× dutyFR` depending on viewAvg) — it reads **`deltaAOverA`** and **`gammaVdB`** specifically. If those are missing, it falls back to benign defaults, and θ barely moves. The canonical θ chain and the keys it pulls are here.&#x20;

## C) Mode-change surface + logging confusion

* Your mode-change effect *does* subscribe to the pipeline’s mode (`pipelineState.currentMode`) and triggers a re-init; good.&#x20;
* However, various logs still print `parameters.currentMode`, which can mislead you into thinking WBC didn’t switch when it actually did. Example: “Applying physics… mode: parameters.currentMode”.&#x20;
* The initial mount guard only checks `parameters.currentMode`, so if parameters are empty but the pipeline hook is already populated, the first init can be skipped.&#x20;

These don’t *cause* the stagnation, but they make it harder to see what’s actually happening.

---

# Quick fixes (surgical)

## 1) Server: export the canonical, short-key engine bundle

Replace the response mapping so `warpUniforms` carries the **canonical** short-key bundle (no external θ reliance), and tuck the FR-expected θ into hints.

**Change this** (current):

* You’re returning `warpUniforms: canonicalWarpUniforms` (long names + `thetaScale`).&#x20;

**To this** (intended):

* Return the *short-key* `warpUniforms` object you built above (with `gammaVdB` / `deltaAOverA`), and keep `theta_FR` only as a **viewer hint** (you already have `viewerHints` for that).&#x20;

That one change aligns the Helix Core page with WarpEngine’s expectations and stops the θ-stagnation caused by naming drift.

## 2) WBC REAL packet: send `gammaVdB` + `deltaAOverA`

In `WarpBubbleCompare.tsx` when building the REAL pane payload, swap the two fields:

```diff
- qSpoilingFactor: real.qSpoilingFactor,
- gammaVanDenBroeck_mass: real.gammaVanDenBroeck_mass,
+ deltaAOverA: real.qSpoilingFactor,
+ gammaVdB: real.gammaVanDenBroeck ?? real.gammaVdB,
```

(These lines correspond to the locations where REAL is built.) &#x20;

You already do the right thing for the SHOW packet (`gammaVdB` / `deltaAOverA`), so mirror that for REAL.&#x20;

## 3) WBC: log and gate on the merged mode; accept pipeline-only init

* Change logging to use `mergedState.currentMode` so logs match what the engine actually receives.&#x20;
* In the mount-only effect, allow init if **either** `parameters.currentMode` or `pipelineState.currentMode` exists, not just parameters.&#x20;

---

# Why this explains your symptoms

* **“Theta uniform is stagnant on the Helix Core page.”**
  The page’s `warpUniforms` contain long-name keys and a `thetaScale` hint, but WarpEngine ignores external θ and looks for `gammaVdB/deltaAOverA` to compute its own. With wrong keys, the chain reduces to near-constant defaults → stagnant θ. See the ignore-θ logic and canonical builder.  &#x20;

* **“WarpBubbleCompare not switching operational modes so warp-engine doesn’t receive the call.”**
  WBC *does* watch pipeline mode, but because the REAL payload uses the wrong keys, the engine’s “Operational change detected” pathway won’t result in a visible θ change, and the logs that print `parameters.currentMode` make it *look* like mode didn’t flip. Fixing the keys + logging exposes the real mode transitions. See the mode-change effect and the misleading log. &#x20;

* **“warp-engine doesn’t receive the call.”**
  The engine *does* receive updates (`updateUniforms` enqueues and applies), and it logs when an operational change is detected; if keys don’t change semantics, θ won’t move and it’ll look like a no-op. The engine’s mode/θ application and logging are here. &#x20;

---

# Sanity checks after the patch

1. In the console, you should see WarpEngine’s “Canonical Theta chain” debug print showing **non-trivial** values for `γ³`, `q` (=`deltaAOverA`), `γ_VdB`, and `√duty`, and a changing `actualTheta`.&#x20;

2. In WBC’s “Applying physics…” log, verify `mode` reflects the pipeline value (use `mergedState.currentMode`, not `parameters.currentMode`).&#x20;

3. In standby + REAL, θ must clamp to 0 regardless of inputs (engine enforces that).&#x20;

---

# TL;DR: one-line fixes

* **Server (`helix-core.ts`)**: return the **short-key** `warpUniforms` (with `gammaVdB` / `deltaAOverA`) and keep `theta_FR` only under `viewerHints`; don’t wire `thetaScale` to the engine path. &#x20;
* **Client (WBC REAL)**: send `deltaAOverA` + `gammaVdB` instead of `qSpoilingFactor` + `gammaVanDenBroeck_mass`.&#x20;
* **Client logging/mount**: log `mergedState.currentMode`; allow initial init when only pipeline mode is known. &#x20;

Make those changes and the parity enforcement warnings should stop, θ will stop being “stagnant”, and mode changes from the energy pipeline will clearly propagate into both REAL and SHOW paths.
