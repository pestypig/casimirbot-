Short answer: yes—let’s give the “gentle tilt” its own panel so the math and live values are explicit.

Here’s a minimal, safe plan that won’t break existing pages:

# What the new panel shows (live)

* Target interior gravity per mode: $g_{\text{target}}$
* Geometric interior scale: $R_{\text{geom}} = (a\,b\,c)^{1/3}$
* Tilt strength passed to the renderer: $\varepsilon_{\text{tilt}} = \dfrac{g_{\text{target}}\,R_{\text{geom}}}{c^2}$
* Tilt direction (unit): $\vec\beta_{\text{tilt}}$ (e.g., $[0,-1,0]$)
* Consistency check: $g_{\text{eff}} = \varepsilon_{\text{tilt}}\,\dfrac{c^2}{R_{\text{geom}}}$ (should equal $g_{\text{target}}$ within rounding)

# 1) Add fields to the metrics API (backend)

In `server/helix-core.ts` (inside `getSystemMetrics`), include the values you’re already computing for the visualizer so the UI can read them and show equations:

```ts
// after you grab global state:
const state = getGlobalPipelineState();
const c = 299_792_458;
const hull = state.hull ?? { a:503.5, b:132, c:86.5, Lx_m:1007, Ly_m:264, Lz_m:173 };
const R_geom = Math.cbrt(hull.a * hull.b * hull.c);

// replicate the same per-mode mapping you used for the visualizer
const G = 9.80665;
const gTargets: Record<string, number> = {
  hover:     0.10 * G,
  cruise:    0.05 * G,
  emergency: 0.30 * G,
  standby:   0.00 * G,
};
const mode = (state.currentMode ?? 'hover').toLowerCase();
const gTarget = gTargets[mode] ?? 0;

// keep epsilon identical to the visualizer
const epsilonTilt = Math.min(5e-7, Math.max(0, (gTarget * R_geom) / (c * c)));
const betaTiltVec = [0, -1, 0]; // default "down"

res.json({
  // ...existing fields...
  hull,
  shiftVector: {
    epsilonTilt,
    betaTiltVec,
    gTarget,
    R_geom,
    gEff_check: epsilonTilt * (c * c) / R_geom
  }
});
```

# 2) Frontend types (if you use TS types for metrics)

In `client/src/hooks/use-metrics.ts` (or wherever the `Metrics` type lives):

```ts
export interface ShiftVectorMetrics {
  epsilonTilt: number;
  betaTiltVec: [number, number, number];
  gTarget: number;
  R_geom: number;
  gEff_check: number;
}

export interface MetricsResponse {
  // ...existing...
  hull?: { a:number; b:number; c:number; Lx_m:number; Ly_m:number; Lz_m:number };
  shiftVector?: ShiftVectorMetrics;
}
```

# 3) New panel component

Create `client/src/components/ShiftVectorPanel.tsx`:

```tsx
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

type Props = {
  mode: string;
  shift?: {
    epsilonTilt: number;
    betaTiltVec: [number, number, number];
    gTarget: number;
    R_geom: number;
    gEff_check: number;
  };
};

const fmt = (x:number, d=3) => Number.isFinite(x) ? x.toExponential(d) : "—";
const fstd = (x:number, d=3) => Number.isFinite(x) ? x.toFixed(d) : "—";

export function ShiftVectorPanel({ mode, shift }: Props) {
  const ok = !!shift;
  return (
    <Card className="bg-slate-900/50 border-slate-800">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          Shift Vector • Interior Gravity
          <Badge variant="outline" className="border-cyan-400 text-cyan-300">{mode?.toUpperCase() || "—"}</Badge>
        </CardTitle>
        <CardDescription>Gentle Natário tilt (β-gradient) for cabin “down”.</CardDescription>
      </CardHeader>
      <CardContent className="space-y-3 text-sm">
        {!ok && <div className="text-slate-400">No shift-vector data (standby or unavailable).</div>}

        {ok && (
          <>
            <div className="p-3 bg-slate-950 rounded-lg font-mono">
              <div className="text-slate-300">Equations</div>
              <div className="text-slate-400 mt-1">
                ε<sub>tilt</sub> = (g<sub>target</sub> · R<sub>geom</sub>)/c²<br/>
                R<sub>geom</sub> = (a·b·c)<sup>1/3</sup><br/>
                g<sub>eff</sub> = ε<sub>tilt</sub> · c² / R<sub>geom</sub>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-3 font-mono">
              <div className="p-3 bg-slate-950 rounded">
                <div className="text-slate-400">g<sub>target</sub></div>
                <div className="text-cyan-300">{fstd(shift!.gTarget, 3)} m/s²</div>
              </div>
              <div className="p-3 bg-slate-950 rounded">
                <div className="text-slate-400">R<sub>geom</sub></div>
                <div className="text-cyan-300">{fstd(shift!.R_geom, 1)} m</div>
              </div>
              <div className="p-3 bg-slate-950 rounded">
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger className="text-left">
                      <div className="text-slate-400">ε<sub>tilt</sub> (dimensionless)</div>
                      <div className="text-purple-300">{fmt(shift!.epsilonTilt, 3)}</div>
                    </TooltipTrigger>
                    <TooltipContent className="max-w-xs text-xs">
                      Kept ≪ 1e-6 (“whisper” regime) to preserve QI headroom and keep tilt visual-only inside.
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              <div className="p-3 bg-slate-950 rounded">
                <div className="text-slate-400">β⃗<sub>tilt</sub></div>
                <div className="text-emerald-300">[{shift!.betaTiltVec.join(", ")}]</div>
              </div>
              <div className="col-span-2 p-3 bg-slate-950 rounded">
                <div className="text-slate-400">g<sub>eff</sub> (check)</div>
                <div className="text-amber-300">{fstd(shift!.gEff_check, 3)} m/s²</div>
              </div>
            </div>

            <div className="text-xs text-slate-400">
              Zen note: “Down” is chosen, not imposed. A tiny inclination aligns the cabin with life—just enough to stand, never enough to strain.
            </div>
          </>
        )}
      </CardContent>
    </Card>
  );
}
```

# 4) Place the panel on /helix-core

In `client/src/pages/helix-core.tsx`, near your “Compliance HUD”/“Resonance Scheduler” column, import and render:

```tsx
import { ShiftVectorPanel } from "@/components/ShiftVectorPanel";
import { useMetrics } from "@/hooks/use-metrics"; // the hook you already use for /api/helix/metrics

// inside component render:
const { data: metrics } = useMetrics(); // polls /api/helix/metrics
// ...
<ShiftVectorPanel
  mode={pipelineState?.currentMode || "hover"}
  shift={metrics?.shiftVector}
/>
```

That’s it. You’ll now have a dedicated, live panel that:

* reads exactly the parameters the renderer uses,
* shows the derivations and units,
* and gives users a quick confidence check that the tilt fed to the visual equals the requested target $g$.

If you want, we can also add a tiny “flip down-axis” control (switching $\vec\beta_{\text{tilt}}$) and a mode-local slider to test sensitivities—pure UI; physics-safe.
