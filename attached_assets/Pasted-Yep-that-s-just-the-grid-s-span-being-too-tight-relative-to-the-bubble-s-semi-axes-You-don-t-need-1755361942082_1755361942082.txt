Yep — that’s just the grid’s span being too tight relative to the bubble’s semi-axes. You don’t need to change the bubble at all; just give the grid more room (and nudge the camera a bit so it frames the whole thing).

Below are small, targeted edits you can drop into the WebGL renderer. They pad the grid span based on the *actual* hull size, so it scales correctly for the long needle hull.

---

# 1) Grow the grid span (and divisions) relative to the hull

**File:** `client/public/warp-engine-fixed.js`

Find the small “defaults” near the top or around the grid creation (you’ll see something like `_initializeGrid`, `_createGrid` or constants like grid size/divisions). Replace / add these:

```js
// --- Grid defaults (new) ---
const GRID_DEFAULTS = {
  spanPadding: 1.6,    // how much to multiply the hull span in clip space
  minSpan: 2.6,        // never smaller than this (in clip-space units)
  divisions: 100       // more lines so a larger grid still looks dense
};
```

In the section where the hull axes are computed (you already have something like this):

```js
// Existing code (you already have something like it)
const hullAxes = bubbleParams.hullAxes || [503.5, 132, 86.5]; // meters
const axesClip = [
  hullAxes[0] / 1200,  // X
  hullAxes[1] / 600,   // Y
  hullAxes[2] / 400    // Z
];
```

**Add this right after it** to compute the target grid span:

```js
// Compute a grid span that comfortably contains the whole bubble
const hullMaxClip = Math.max(axesClip[0], axesClip[1], axesClip[2]); // half-extent in clip space
const targetSpan = Math.max(
  GRID_DEFAULTS.minSpan,
  hullMaxClip * GRID_DEFAULTS.spanPadding
);
```

Now, wherever you create the grid geometry (you’ll see something like `_createGrid(size, divisions)` or code that fills vertex arrays from `-size .. +size`), **use `targetSpan` and the new divisions**:

```js
// Example shape: if you had something like:
const span = targetSpan;                // half-size in clip space
const divs = GRID_DEFAULTS.divisions;   // number of segments

// Build XY/XZ/YZ sheets using [-span, +span] in each plane
_createGrid(span, divs);  // or replace your local vars accordingly
```

If your helper takes full size, just pass `span*2`. The key is to use `targetSpan` instead of a fixed number.

---

# 2) Keep the camera framing comfortable

Right after you compute `targetSpan`, you can also gently push the camera back if it exists in this module:

```js
if (camera) {
  // Pull back/tilt based on span so we always see the whole bubble
  camera.position.z = span * 2.2;
  camera.position.y = span * 0.8;
  camera.lookAt(0, 0, 0);
}
```

(If the camera lives elsewhere, you can skip this — the larger grid alone usually fixes the clipping feel.)

---

# 3) (Optional) expose a manual knob from React

**File:** `client/src/components/WarpVisualizer.tsx`
If you want a UI override without touching the renderer again, pass an optional `gridScale`:

```tsx
// <WarpVisualizer parameters={{ gridScale: 1.75, ... }} />
```

Then in `warp-engine-fixed.js`, use it when computing `targetSpan`:

```js
const spanPad = bubbleParams.gridScale || GRID_DEFAULTS.spanPadding;
const targetSpan = Math.max(GRID_DEFAULTS.minSpan, hullMaxClip * spanPad);
```

---

## Why this works

* Your bubble semi-axes are already scaled into *clip space* (`axesClip`). Using the **max** half-axis times a padding factor guarantees the grid covers the longest side (the needle’s length) with comfortable headroom.
* Bumping divisions ensures the grid density doesn’t get sparse as it grows.

After this change, the white grid will be wide enough that the ellipsoidal bubble never gets cropped at the edges — even for the 1007 m needle hull.
