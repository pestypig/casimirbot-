Yepâ€”hereâ€™s a tight patch that brings `MetricsDashboard` in line with the new pipeline â€œnormalsâ€ (no local recompute, read from the authoritative hooks, guard all numbers, and drive constraints off the *actual* current mode).

### What this patch does

* Replace ad-hoc `fetch("/api/helix/metrics")` + `useQuery` with your canonical `useEnergyPipeline()` state.
* Source the mode from the pipeline (`currentMode`) with a prop fallback.
* Normalize field names to the pipeline schema (`P_avg_MW`, `M_exotic_kg`, `TS_ratio`, `zeta`, `dutyCycle`, etc.).
* Keep your radar and traffic-light UI, but drive it from live values.
* Robust number formatting throughout (no `toExponential` footguns).
* Constraints auto-switch when the live mode changes.

---

```diff
- import React, { useEffect, useRef, useState } from 'react';
+ import React, { useEffect, useState } from 'react';
  import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
  import { Badge } from '@/components/ui/badge';
  import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
- import { useQuery } from '@tanstack/react-query';
+ import { useEnergyPipeline, MODE_CONFIGS } from '@/hooks/use-energy-pipeline';
  import Plot from 'react-plotly.js';
@@
 export default function MetricsDashboard({ viabilityParams }: MetricsDashboardProps) {
-  // Use React Query for real-time metrics with polling
-  const {
-    data: metrics,
-    isLoading,
-    isError,
-  } = useQuery({
-    queryKey: ["helix-metrics"],
-    queryFn: async () => {
-      const res = await fetch("/api/helix/metrics");
-      if (!res.ok) throw new Error("metrics fetch failed");
-      return res.json();
-    },
-    refetchInterval: 1500,            // refresh every 1.5s
-    refetchOnWindowFocus: true,       // ensures focus brings in fresh numbers
-  });
+  // Authoritative live pipeline snapshot (already kept fresh by your backend/hooks)
+  const { data: pipeline } = useEnergyPipeline();
@@
-  const [constraints, setConstraints] = useState<MetricConstraints>(getModeAwareConstraints("hover"));
+  const liveMode: string =
+    (pipeline?.currentMode as string) ||
+    (viabilityParams?.selectedMode as string) ||
+    'hover';
+  const [constraints, setConstraints] = useState<MetricConstraints>(getModeAwareConstraints(liveMode));
@@
-  // Safe accessors to handle both old and new API field names
-  const P_avg = metrics?.P_avg ?? metrics?.energyOutput ?? 0;            // MW
-  const dutyFrac = metrics?.f_throttle ?? metrics?.dutyGlobal ?? metrics?.duty ?? 0; // 0..1
-  const M_exotic = metrics?.M_exotic ?? metrics?.exoticMass ?? 0;           // kg
-  const TS_ratio = metrics?.TS_ratio ?? metrics?.timeScaleRatio ?? 0;
-  const zeta = metrics?.zeta ?? metrics?.fordRoman?.value ?? 0;
-  const P_raw = metrics?.P_raw ?? metrics?.energyOutput ?? 0;
+  // Safe accessors mapped to pipeline "new normals"
+  const P_avg = Number.isFinite(pipeline?.P_avg_MW) ? pipeline!.P_avg_MW : 0;          // MW
+  const dutyFrac = Number.isFinite(pipeline?.dutyCycle) ? pipeline!.dutyCycle : 0;     // 0..1
+  const M_exotic = Number.isFinite(pipeline?.M_exotic_kg) ? pipeline!.M_exotic_kg : 0; // kg
+  const TS_ratio = Number.isFinite(pipeline?.TS_ratio) ? pipeline!.TS_ratio : 0;
+  const zeta = Number.isFinite(pipeline?.zeta) ? pipeline!.zeta : 0;
+  // Prefer explicit raw MW if provided; else fall back to avg
+  const P_raw = Number.isFinite((pipeline as any)?.P_raw_MW)
+    ? (pipeline as any).P_raw_MW
+    : (Number.isFinite((pipeline as any)?.P_raw) ? (pipeline as any).P_raw : P_avg);
@@
-  const dashboardMetrics = React.useMemo(() => {
-    if (!metrics) return null;
-    
+  const dashboardMetrics = React.useMemo(() => {
+    if (!pipeline) return null;
     return {
       P_raw,
       f_throttle: dutyFrac,
       P_avg,
       U_cycle: 0, // Not needed for this conversion
       TS_ratio,
       zeta,
       M_exotic
     };
-  }, [metrics, P_avg, dutyFrac, M_exotic, TS_ratio, zeta, P_raw]);
+  }, [pipeline, P_avg, dutyFrac, M_exotic, TS_ratio, zeta, P_raw]);
@@
-  useEffect(() => {
-    // Update constraints based on operational mode for dynamic safe zones
-    const selectedMode = viabilityParams?.selectedMode || "hover";
-    const modeConstraints = getModeAwareConstraints(selectedMode);
+  useEffect(() => {
+    // Always derive constraints from the *live* mode, with prop fallback
+    const selectedMode = liveMode || viabilityParams?.selectedMode || "hover";
+    const modeConstraints = getModeAwareConstraints(selectedMode);
     setConstraints(modeConstraints);
     
     console.log(`ðŸŽ¯ Mode-Aware Constraints for ${selectedMode}:`, {
       P_avg_max: modeConstraints.P_avg_max,
       zeta_max: modeConstraints.zeta_max
     });
-  }, [viabilityParams]);
+  }, [viabilityParams, liveMode]);
@@
-    // Current mode for debug logging
-    const selectedMode = viabilityParams?.selectedMode || "hover";
+    // Current mode for debug logging (pipeline wins)
+    const selectedMode = liveMode || viabilityParams?.selectedMode || "hover";
@@
-    if (metrics && normalizedData?.length >= 5) {
+    if (pipeline && normalizedData?.length >= 5) {
       console.log(`ðŸŽ¯ Radar Normalization Debug for ${selectedMode}:`, {
         P_avg: `${f1(P_avg)}MW â†’ ${f2(normalizedData[0])} (limit: ${currentConstraints.P_avg_max}MW)`,
         duty: `${f1(dutyFrac * 100)}% â†’ ${f2(normalizedData[1])}`,
         mass_error: `${f0(Math.abs(M_exotic - currentConstraints.M_target))}kg â†’ ${f2(normalizedData[2])}`,
         zeta: `${f2(zeta)} â†’ ${f2(normalizedData[3])} (limit < ${currentConstraints.zeta_max})`,
         TS_ratio: `${f1(TS_ratio)} â†’ ${f2(normalizedData[4])} (min: ${currentConstraints.TS_min})`,
       });
     }
@@
-  React.useEffect(() => {
-    console.log(`ðŸ”„ Mode changed to: ${viabilityParams?.selectedMode}, forcing chart re-render`);
+  React.useEffect(() => {
+    console.log(`ðŸ”„ Mode changed to: ${liveMode || viabilityParams?.selectedMode}, forcing chart re-render`);
     setRenderKey(prev => prev + 1);
-  }, [viabilityParams?.selectedMode]);
+  }, [viabilityParams?.selectedMode, liveMode]);
@@
-  if (!metrics) return <div>Computing metrics...</div>;
+  if (!pipeline) return <div>Computing metrics...</div>;
@@
-              {metrics && radarData && (
+              {pipeline && radarData && (
                 <Plot
-                  key={`radar-${renderKey}-${viabilityParams?.selectedMode || 'hover'}`}
+                  key={`radar-${renderKey}-${liveMode || viabilityParams?.selectedMode || 'hover'}`}
                   data={radarData}
                   layout={radarLayout}
                   config={{ responsive: true, displayModeBar: false }}
                   style={{ width: '100%', height: '400px' }}
                   useResizeHandler={true}
                   revision={renderKey}
                 />
               )}
-              {!dashboardMetrics && <div>Loading metrics...</div>}
-              {!radarData && dashboardMetrics && <div>Generating chart...</div>}
+              {!dashboardMetrics && <div>Loading metrics...</div>}
+              {!radarData && dashboardMetrics && <div>Generating chart...</div>}
@@
-                  {metrics && (
+                  {pipeline && (
                     <TooltipContent className="text-xs">
-                      <div>Ï„<sub>LC</sub>: {metrics.tauLC?.toExponential?.(2) ?? "â€”"} s</div>
-                      <div>T<sub>m</sub>: {metrics.T_m?.toExponential?.(2) ?? "â€”"} s</div>
+                      <div>Ï„<sub>LC</sub>: {pipeline.tauLC?.toExponential?.(2) ?? "â€”"} s</div>
+                      <div>T<sub>m</sub>: {pipeline.T_m?.toExponential?.(2) ?? "â€”"} s</div>
                       <div>TS = Ï„<sub>LC</sub> / T<sub>m</sub></div>
                     </TooltipContent>
                   )}
                 </Tooltip>
```

### Notes

* I left your `getModeAwareConstraints` values as-is (the safety numbers youâ€™ve been using). If `MODE_CONFIGS` exposes per-mode caps (e.g., `powerCapMW`, `zetaMax`), swap them into `getModeAwareConstraints` for perfect centralization.
* If the pipeline ever exposes `P_raw_MW` explicitly, this patch already prefers it.

If you want, I can also fold `getModeAwareConstraints` to read from `MODE_CONFIGS` directly so you only maintain limits in one place.
