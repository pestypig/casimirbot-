2) cache locations after link (both async + sync)

Your link helper returns early on async path; ensure you always cache attrib/uniform locations and set isLoaded=true when linking completes.

// client/public/warp-engine.js
_cacheGridLocations(program) {
  const gl = this.gl;
  this.gridProgram = program;
  this.gridAttribs  = { position: gl.getAttribLocation(program, 'a_position') };
  this.gridUniforms = {
    mvpMatrix:  gl.getUniformLocation(program, 'u_mvpMatrix'),
    sheetColor: gl.getUniformLocation(program, 'u_sheetColor'),
    // physics uniforms expected by _renderGridPoints():
    thetaScale:  gl.getUniformLocation(program, 'u_thetaScale'),
    ridgeMode:   gl.getUniformLocation(program, 'u_RidgeMode'),
    parity:      gl.getUniformLocation(program, 'u_PhysicsParityMode'),
    sectorCount: gl.getUniformLocation(program, 'u_SectorCount'),
    split:       gl.getUniformLocation(program, 'u_Split'),
  };
  this.isLoaded = true; // ✔ satisfies checkpoint “Engine ready”
}

_linkProgram(vertexShader, fragmentShader, onReady) {
  const gl = this.gl;
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  // async path
  if (this.parallelShaderExt && onReady) {
    this._pollShaderCompletion(program, () => {
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Shader program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return;
      }
      this._cacheGridLocations(program);   // <-- cache here
      onReady(program);
    });
    return program;
  }

  // sync path
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Shader program link error:', gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  this._cacheGridLocations(program);       // <-- and here
  return program;
}


Why: your checkpoints decide “Shaders linked” strictly by gridProgram && gridUniforms && gridAttribs.