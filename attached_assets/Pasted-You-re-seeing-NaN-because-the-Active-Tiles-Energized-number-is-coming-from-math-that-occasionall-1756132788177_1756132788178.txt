You’re seeing NaN because the “Active Tiles (Energized)” number is coming from math that occasionally gets fed undefined/NaN inputs on first paint, and the UI formatter doesn’t guard against NaN. Two quick fixes:

Make the inputs to useActiveTiles numerically safe (so the math can’t produce NaN).

Guard the formatter (so even if something slips through, the UI never prints NaN).

Below are minimal diffs you can drop into your HelixCore file.

1) Sanitize inputs before calling useActiveTiles

Add these helpers near your other formatters:

// add with your other small utils
const npos = (x: unknown, d = 0) => {
  const v = Number(x);
  return Number.isFinite(v) && v > 0 ? v : d;
};
const nnonneg = (x: unknown, d = 0) => {
  const v = Number(x);
  return Number.isFinite(v) && v >= 0 ? v : d;
};


Create safe totals before the hook:

-  // Split sector handling: total sectors (400) for averaging vs concurrent sectors (1-2) for strobing
-  const totalSectors = useMemo(() => {
-    return Number.isFinite(systemMetrics?.totalSectors)
-      ? Math.max(1, Math.floor(systemMetrics!.totalSectors!))
-      : 400;
-  }, [systemMetrics?.totalSectors]);
+  // Split sector handling: total sectors (400) for averaging vs concurrent sectors (1-2) for strobing
+  const totalSectors = useMemo(() => {
+    const s = npos(systemMetrics?.totalSectors, 400);
+    return Math.max(1, Math.floor(s));
+  }, [systemMetrics?.totalSectors]);
+
+  // Total tiles (prefer metrics, then pipeline, then a sane fallback)
+  const totalTilesSafe = useMemo(() => {
+    const a = npos(systemMetrics?.totalTiles, 0);
+    const b = npos(pipeline?.N_tiles, 0);
+    // use the first positive source, else fall back to your UI default
+    return a || b || 2_800_000;
+  }, [systemMetrics?.totalTiles, pipeline?.N_tiles]);
+
+  // Tiles per sector (prefer metrics; else derive from totalTiles/totalSectors)
+  const tilesPerSectorSafe = useMemo(() => {
+    const fromMetrics = npos(systemMetrics?.tilesPerSector, 0);
+    if (fromMetrics) return Math.floor(fromMetrics);
+    return Math.max(1, Math.floor(totalTilesSafe / Math.max(1, totalSectors)));
+  }, [systemMetrics?.tilesPerSector, totalTilesSafe, totalSectors]);


Use the safe values when you call your hook:

-  const activeTiles = useActiveTiles({
-    totalTiles: systemMetrics?.totalTiles ?? pipeline?.N_tiles,
-    totalSectors,
-    concurrentSectors,
-    dutyEffectiveFR_safe,
-    tilesPerSector: systemMetrics?.tilesPerSector,
-    lc,
-    serverActiveTiles: systemMetrics?.activeTiles,
-  });
+  const activeTiles = useActiveTiles({
+    totalTiles: totalTilesSafe,
+    totalSectors,
+    concurrentSectors,
+    dutyEffectiveFR_safe: nnonneg(dutyEffectiveFR_safe, 0),
+    tilesPerSector: tilesPerSectorSafe,
+    lc,
+    serverActiveTiles: nnonneg(systemMetrics?.activeTiles, NaN),
+  });


If useActiveTiles multiplies totalTiles * dutyEffectiveFR_safe (or similar), these guards prevent undefined * something → NaN.