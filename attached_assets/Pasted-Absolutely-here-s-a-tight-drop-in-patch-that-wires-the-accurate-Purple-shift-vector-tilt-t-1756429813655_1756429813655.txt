Absolutely‚Äîhere‚Äôs a tight, drop-in patch that wires the *accurate Purple shift vector* (Œµ tilt + Œ≤ tilt dir) **and** the *hero curvature system* into **both** the HERO `WarpBubbleCompare` and the `WarpRenderInspector` (REAL + SHOW). I‚Äôm only changing three spots so you can paste safely.

---

# PATCH 1 ‚Äî compute normalized Œ≤ tilt vector next to `epsilonTilt`

**Replace your current epsilon-tilt block with this one** (it adds a normalized `betaTiltVecN` you can reuse everywhere):

```ts
// Calculate epsilonTilt and normalized beta-tilt vector (Purple shift)
const G = 9.80665, c = 299792458;

const gTargets: Record<string, number> = {
  hover: 0.1 * G,
  cruise: 0.05 * G,
  emergency: 0.3 * G,
  standby: 0,
};

const currentMode = effectiveMode.toLowerCase();
const gTarget = gTargets[currentMode] ?? 0;
const R_geom = Math.cbrt(hull.a * hull.b * hull.c);

// Œµ (dimensionless) used by shaders + viz overlays
const epsilonTilt = Math.min(5e-7, Math.max(0, (gTarget * R_geom) / (c * c)));

// Œ≤ direction (Purple arrow) ‚Äî prefer live metrics, fallback to canonical ‚Äúnose down‚Äù
const betaTiltVecRaw = (systemMetrics?.shiftVector?.betaTiltVec ?? [0, -1, 0]) as [number, number, number];
const betaNorm = Math.hypot(betaTiltVecRaw[0], betaTiltVecRaw[1], betaTiltVecRaw[2]) || 1;
const betaTiltVecN: [number, number, number] = [
  betaTiltVecRaw[0] / betaNorm,
  betaTiltVecRaw[1] / betaNorm,
  betaTiltVecRaw[2] / betaNorm,
];
```

---

# PATCH 2 ‚Äî HERO: attach Œµ/Œ≤ + hero curvature to `WarpBubbleCompare`

**Replace the `<WarpBubbleCompare ... />` call inside the HERO card with this one**:

```tsx
<WarpBubbleCompare
  key={`hero-${renderNonce}`}
  parameters={{
    ...compareParams,
    currentMode: effectiveMode,

    // physics + timing
    lightCrossing: lc,
    sectorCount: totalSectors,          // total (averaging)
    sectors: concurrentSectors,         // live (sweep)
    dutyEffectiveFR: dutyEffectiveFR_safe,
    dutyCycle: dutyUI_safe,

    // curvature + shift vector (Purple arrow)
    epsilonTilt,
    betaTiltVec: betaTiltVecN,

    // hero curvature ‚Äúpop‚Äù
    curvatureGainDec: 0.0,              // keep transfer flat
    curvatureBoostMax: 40,              // larger for hero
    colorMode: "theta",
    lockFraming: true,

    // amps + bookkeeping
    gammaVanDenBroeck: isStandby
      ? 1
      : Number(pipeline?.gammaVanDenBroeck_vis ?? pipeline?.gammaVanDenBroeck ?? 1),
    gammaGeo: pipeline?.gammaGeo ?? 26,
    qSpoilingFactor: qSpoilUI,

    // HUD helpers
    powerAvg_MW: Number(pipeline?.P_avg ?? 83.3),
    exoticMass_kg: Number(pipeline?.M_exotic ?? 1405),
  }}
  parityExaggeration={1}
  heroExaggeration={82}
  colorMode="theta"
  lockFraming={true}
/>
```

Optionally drop a visual legend under the hero block (you already import it):

```tsx
<div className="mt-2">
  <CurvatureKey />
</div>
```

---

# PATCH 3 ‚Äî Inspector: feed Œµ/Œ≤ + measured curvature knobs to REAL & SHOW

**Replace the entire `<WarpRenderInspector ... />` call with this version** (REAL stays slice2d, SHOW stays grid3d, both get Œµ/Œ≤ + sensible curvature knobs):

```tsx
<WarpRenderInspector
  key={`inspector-${modeNonce}-${totalSectors}-${concurrentSectors}`}
  parityPhys={(() => {
    const realPhys = {
      gammaGeo: pipeline?.gammaGeo ?? 26,
      q: qSpoilUI,
      gammaVdB: isStandby ? 1 : Number(pipeline?.gammaVanDenBroeck_vis ?? pipeline?.gammaVanDenBroeck ?? 1),
      dFR: dutyEffectiveFR_safe,
    };

    const expREAL = thetaScaleExpected(realPhys);
    const usedREAL = thetaScaleUsed(expREAL, {
      concurrent: 1,
      total: 400,
      dutyLocal: 0.01,
      viewFraction: 0.0025,
      viewAveraging: true,
    });

    React.useEffect(() => {
      checkpoint({
        id: "Œ∏-expected",
        side: "REAL",
        stage: "expect",
        pass: true,
        msg: `Œ∏_expected=${expREAL.toExponential()}`,
        expect: expREAL,
      });
      checkpoint({
        id: "Œ∏-used",
        side: "REAL",
        stage: "expect",
        pass: true,
        msg: `Œ∏_used=${usedREAL.toExponential()}`,
        expect: usedREAL,
      });
    }, [expREAL, usedREAL]);

    return {
      gammaGeo: pipeline?.gammaGeo ?? 26,
      qSpoilingFactor: qSpoilUI,
      gammaVanDenBroeck_vis: isStandby
        ? 1
        : Number(pipeline?.gammaVanDenBroeck_vis ?? pipeline?.gammaVanDenBroeck ?? 1),
      dutyEffectiveFR: dutyEffectiveFR_safe,
      dutyCycle: dutyUI_safe,
      viewMassFraction: viewMassFracReal,

      // üîé extras shown on the REAL side HUD (non-breaking extras)
      thetaExpected: expREAL,
      thetaUsed: usedREAL,
      fordRomanZeta: pipeline?.zeta,
    } as any;
  })()}
  showPhys={{
    gammaGeo: pipeline?.gammaGeo ?? 26,
    qSpoilingFactor: qSpoilUI,
    gammaVanDenBroeck_vis: isStandby
      ? 1
      : Number(pipeline?.gammaVanDenBroeck_vis ?? pipeline?.gammaVanDenBroeck ?? 1),
    dutyEffectiveFR: dutyEffectiveFR_safe,
    dutyCycle: dutyUI_safe,
    viewMassFraction: 1.0,
  }}
  baseShared={{
    hull: {
      a: Number(hull.a) || 503.5,
      b: Number(hull.b) || 132.0,
      c: Number(hull.c) || 86.5,
    },
    wallWidth_m: 6.0,
    driveDir: [1, 0, 0],
    vShip: 0,
    sectorCount: totalSectors,
    sectors: concurrentSectors,

    // ‚úÖ attach Purple shift vector + curvature knobs to BOTH renderers
    epsilonTilt,
    betaTiltVec: betaTiltVecN,
    curvatureGainDec: 0.0,
    curvatureBoostMax: 20,

    colorMode: "theta",
    lockFraming: true,
    currentMode: effectiveMode,
  } as any}
  lightCrossing={{ burst_ms: lc.burst_ms, dwell_ms: lc.dwell_ms }}
  realRenderer="slice2d"
  showRenderer="grid3d"
/>
```

> Notes
> ‚Ä¢ I cast `as any` at two call-sites to avoid TypeScript grumbling if your inspector‚Äôs prop types don‚Äôt yet list these extra uniforms; the engines will still receive them.
> ‚Ä¢ REAL gets `viewMassFraction = tilesPerSector / totalTiles` (already in your code) and SHOW stays `1.0`.
> ‚Ä¢ We keep color mode = `"theta"` while enabling curvature scaling; the boost only lifts contour visibility and does not change the underlying Œ∏ mapping.

---

That‚Äôs it‚ÄîŒµ/Œ≤ (Purple shift vector) is now plumbed into both canvases, and the hero curvature tuning is live where it matters. If you want me to also push these into the uniform bus (`sanitizeServerUniforms`) so any late-mount visualizer auto-picks them up, say the word and I‚Äôll hand you that tiny add-on too.
