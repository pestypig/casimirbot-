--- a/client/src/components/WarpRenderCheckpointsPanel.tsx
+++ b/client/src/components/WarpRenderCheckpointsPanel.tsx
@@
-// (imports)
+// Do NOT send theta from here. Engine computes canonical θ internally.
 
@@
-// (keep your existing engine refs/props)
+const sanitizeUniforms = (o: any) =>
+  Object.fromEntries(Object.entries(o ?? {}).filter(([_, v]) => v !== undefined));
+function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
+  const p = { ...patch };
+  if (pane === 'REAL') { p.physicsParityMode = true;  p.parityMode = true;  p.viewAvg = true;  p.ridgeMode = 0; }
+  else                 { p.physicsParityMode = false; p.parityMode = false; p.viewAvg = false; p.ridgeMode = 1; }
+  delete (p as any).thetaScale;
+  delete (p as any).u_thetaScale;
+  return p;
+}
+function buildRealPacket(parameters: any, base: any = {}) {
+  const dutyFR = Math.max(1e-9, Math.min(1, parameters?.dutyEffectiveFR ?? parameters?.dutyFR ?? 0.000025));
+  return {
+    ...base,
+    currentMode: parameters?.currentMode,
+    physicsParityMode: true,
+    viewAvg: true,
+    dutyEffectiveFR: dutyFR,
+    dutyCycle: dutyFR,
+    sectors: 1,
+    sectorCount: 1,
+    vShip: 0,
+    ridgeMode: 0,
+    gammaVanDenBroeck_mass: Math.max(1, Math.min(1000,
+      parameters?.gammaVanDenBroeck_mass ?? parameters?.gammaVanDenBroeck ?? 38.3)),
+    thetaScale: undefined, u_thetaScale: undefined,
+  };
+}
+function buildShowPacket(parameters: any, base: any = {}) {
+  return {
+    ...base,
+    currentMode: parameters?.currentMode,
+    physicsParityMode: false,
+    viewAvg: false,
+    dutyCycle: Math.max(0, Math.min(1, parameters?.dutyCycle ?? 0.14)),
+    sectorCount: Math.max(1, Math.floor(parameters?.sectorCount ?? 400)),
+    sectors:     Math.max(1, Math.floor(parameters?.sectors     ?? 1)),
+    vShip: parameters?.currentMode === 'standby' ? 0 : 1,
+    ridgeMode: 1,
+    gammaVanDenBroeck_vis: Math.max(1, Math.min(1e9,
+      parameters?.gammaVanDenBroeck_vis ?? parameters?.gammaVanDenBroeck ?? 2.86e5)),
+    thetaScale: undefined, u_thetaScale: undefined,
+  };
+}
 
@@
-// Buttons that push presets / test writes
-const onPresetReal = () => leftEngine.current?.updateUniforms({ physicsParityMode: true, viewAvg: true, ridgeMode: 0 });
-const onPresetShow = () => rightEngine.current?.updateUniforms({ physicsParityMode: false, viewAvg: false, ridgeMode: 1 });
+// Buttons that push presets / test writes (always go through builders)
+const onPresetReal = () => {
+  if (!leftEngine.current) return;
+  const pkt = paneSanitize('REAL', sanitizeUniforms(buildRealPacket(parameters, {})));
+  leftEngine.current.updateUniforms(pkt);
+};
+const onPresetShow = () => {
+  if (!rightEngine.current) return;
+  const pkt = paneSanitize('SHOW', sanitizeUniforms(buildShowPacket(parameters, {})));
+  rightEngine.current.updateUniforms(pkt);
+};
 
@@
-// θ readouts
-const thetaShaderReal  = Number(leftEngine.current?.uniforms?.thetaScale ?? NaN);
-const thetaShaderShow  = Number(rightEngine.current?.uniforms?.thetaScale ?? NaN);
+// θ readouts (prefer engine’s telemetry “thetaScale_actual” when present)
+const thetaShaderReal  = Number(leftEngine.current?.uniforms?.thetaScale_actual ??
+                                leftEngine.current?.uniforms?.thetaScale ?? NaN);
+const thetaShaderShow  = Number(rightEngine.current?.uniforms?.thetaScale_actual ??
+                                rightEngine.current?.uniforms?.thetaScale ?? NaN);
 
@@
-// legacy expected (exp) value computation here ...
-// (leave your UI computation if it’s display-only, but NEVER send it to the engine)
+// If you display “expected/exp” θ, compute locally for display-only (never send)
+function expectedThetaForPanel(u: any, pane: 'REAL'|'SHOW') {
+  const g  = Math.max(1, Number(u?.gammaGeo ?? u?.g_y ?? 26));
+  const q  = Math.max(1e-12, Number(u?.deltaAOverA ?? u?.qSpoilingFactor ?? 1));
+  const vM = Math.max(1, Math.min(1e2, Number(u?.gammaVanDenBroeck_mass ?? 38.3)));
+  const vV = Math.max(1, Math.min(1e9, Number(u?.gammaVanDenBroeck_vis  ?? 2.86e5)));
+  const sectors   = Math.max(1, pane === 'REAL' ? 1 : (u?.sectors ?? 1));
+  const sectorCnt = Math.max(1, pane === 'REAL' ? 1 : (u?.sectorCount ?? 400));
+  const dutyLocal = Math.max(0, Number(u?.dutyCycle ?? 0.14));
+  const dFR = pane === 'REAL' ? dutyLocal : (dutyLocal * (sectors/sectorCnt));
+  const dutyFactor = pane === 'REAL' ? Math.sqrt(Math.max(1e-12, dFR)) : 1;
+  const v = pane === 'REAL' ? vM : vV;
+  return (g*g*g) * q * v * dutyFactor;
+}
+const thetaExpReal = expectedThetaForPanel(leftEngine.current?.uniforms, 'REAL');
+const thetaExpShow = expectedThetaForPanel(rightEngine.current?.uniforms,'SHOW');
 
@@
-// render readouts that previously used raw thetaScale; swap to thetaScale_actual and show exp side-by-side
+// render: show θ(shader) from engine + θ(exp) for quick sanity
+// e.g. “θ-scale — 1.26e+4 • exp 1.26e+4 (Δ …)”
 
@@
-// anywhere you send updateUniforms directly, route through paneSanitize + builders
+// anywhere you send updateUniforms directly, route through paneSanitize + builders:
+// leftEngine.current?.updateUniforms(paneSanitize('REAL', sanitizeUniforms(buildRealPacket(parameters, payload))));
+// rightEngine.current?.updateUniforms(paneSanitize('SHOW', sanitizeUniforms(buildShowPacket(parameters, payload))));
