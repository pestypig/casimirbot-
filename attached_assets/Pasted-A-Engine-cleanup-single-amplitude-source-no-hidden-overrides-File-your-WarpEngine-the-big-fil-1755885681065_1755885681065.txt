A) Engine cleanup (single amplitude source, no hidden overrides)

File: your WarpEngine (the big file you pasted)

Remove the viz thetaScale overrides and compute from physics (or honor an explicit numeric thetaScale if you really pass it).
Replace the whole thetaScale: builder in updateUniforms with:

- // HELIX drives a numeric thetaScale; fall back to local rebuild only if absent
- thetaScale: (() => {
-   if (parameters?.viz?.thetaScale_FR_like != null &&
-       (parameters?.viz?.defaultThetaScale === "FR_like" || !parameters?.viz?.defaultThetaScale)) {
-     return +parameters.viz.thetaScale_FR_like;
-   }
-   if (parameters?.viz?.thetaScale_UI_like != null &&
-       parameters?.viz?.defaultThetaScale === "UI_like") {
-     return +parameters.viz.thetaScale_UI_like;
-   }
-   if (Number.isFinite(parameters.thetaScale)) return +parameters.thetaScale;
-   const gammaGeo = N(parameters.gammaGeo ?? this.currentParams.g_y ?? 26);
-   const gammaVdB = N(parameters.gammaVdB ?? this.currentParams.gammaVanDenBroeck ?? 1);
-   const dAa      = N(parameters.deltaAOverA ?? parameters.qSpoilingFactor ?? 1);
-   const duty     = Math.max(1e-12, N(dutyFrac));
-   const sectors  = Math.max(1, N(parameters.sectors ?? 400));
-   return Math.pow(gammaGeo, 3) * dAa * gammaVdB * Math.sqrt(duty / sectors);
- })(),
+ // Explicit thetaScale wins; otherwise derive from physics (matches SliceViewer)
+ thetaScale: (() => {
+   if (Number.isFinite(parameters.thetaScale)) return +parameters.thetaScale;
+   const gammaGeo = N(parameters.gammaGeo ?? this.currentParams.g_y ?? 26);
+   const gammaVdB = N(parameters.gammaVdB ?? this.currentParams.gammaVanDenBroeck ?? 1);
+   const dAa      = N(parameters.deltaAOverA ?? parameters.qSpoilingFactor ?? 1);
+   const duty     = Math.max(1e-12, N(dutyFrac));
+   const sectors  = Math.max(1, N(parameters.sectors ?? parameters.sectorStrobing ?? 1));
+   const viewAvg  = parameters.viewAvg !== undefined ? !!parameters.viewAvg : true;
+   const eff      = viewAvg ? Math.sqrt(duty / sectors) : 1.0;
+   return Math.pow(gammaGeo, 3) * dAa * gammaVdB * eff;
+ })(),