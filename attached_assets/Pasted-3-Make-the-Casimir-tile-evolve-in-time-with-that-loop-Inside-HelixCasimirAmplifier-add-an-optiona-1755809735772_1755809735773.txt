3) Make the Casimir tile evolve in time with that loop

Inside HelixCasimirAmplifier, add an optional lightCrossing prop and use it to time-step a simple cavity energy model that respects τₗ꜀ and Q:

Tile drive frequency: f = freqGHz * 1e9

Cavity time constant (ring-up/down): τ_Q = Q / (π f)

During ON window: dU/dt = (U∞ - U)/τ_Q (approach steady state)

During OFF: dU/dt = -(U/τ_Q) (ring-down)

Display U(t), P_Casimir(t) ~ κ·U(t) or plate pressure proxy

// components/HelixCasimirAmplifier.tsx (add at top)
type LightCrossing = {
  sectorIdx: number; sectorCount: number; phase: number;
  dwell_ms: number; tauLC_ms: number; burst_ms: number;
  duty: number; freqGHz: number; onWindow: boolean;
};

type Props = {
  // ...existing props
  lightCrossing?: LightCrossing; // NEW
};

// inside component:
const qCav = isFiniteNumber(state?.qCavity) ? state.qCavity : 1e9;
const f = (props.lightCrossing?.freqGHz ?? 15) * 1e9;
const tauQ_s = qCav / (Math.PI * f); // cavity time constant

// pick a normalized steady-state target energy from pipeline (or fallback)
const U_inf = (state?.U_cycle ?? 1) * 1; // arbitrary scale -> keep consistent

const [U, setU] = useState(0);  // cavity "stored" energy (relative units)
const lastT = useRef<number | null>(null);

useEffect(() => {
  let raf: number;
  const step = (t: number) => {
    if (!props.lightCrossing) { raf = requestAnimationFrame(step); return; }
    const on = props.lightCrossing.onWindow;          // τLC-safe ON window
    const now = t / 1000;                             // s
    const prev = lastT.current ?? now;
    const dt = Math.min(0.05, Math.max(0, now - prev)); // clamp dt for stability
    lastT.current = now;

    setU((U0) => {
      if (tauQ_s <= 0) return U0;
      const alpha = dt / tauQ_s;
      if (on) {
        // ring-up toward U_inf
        return U0 + (U_inf - U0) * (1 - Math.exp(-alpha));
      } else {
        // ring-down toward 0
        return U0 * Math.exp(-alpha);
      }
    });

    raf = requestAnimationFrame(step);
  };
  raf = requestAnimationFrame(step);
  return () => cancelAnimationFrame(raf);
}, [props.lightCrossing?.onWindow, tauQ_s, U_inf]);

// Use U to drive visuals / numbers
const pInstant = U / Math.max(1e-9, props.lightCrossing?.dwell_ms ?? 1); // arbitrary proportional readout

// In your render HUD, add:
<div className="mt-2 grid grid-cols-3 gap-2 text-[10px] font-mono text-slate-300">
  <div className="px-2 py-1 rounded bg-slate-800/60 border border-slate-700">
    τ_LC ≈ { (props.lightCrossing?.tauLC_ms ?? 0).toFixed(3) } ms
  </div>
  <div className="px-2 py-1 rounded bg-slate-800/60 border border-slate-700">
    τ_Q ≈ { (tauQ_s*1e3).toFixed(1) } ms
  </div>
  <div className="px-2 py-1 rounded bg-slate-800/60 border border-slate-700">
    U(t)/U∞ = { (U / Math.max(1e-12, U_inf)).toFixed(3) }
  </div>
</div>

// (Optional) tint/animate your cavity visual when inside ON window:
const on = !!props.lightCrossing?.onWindow;
// e.g. bar fill/pulse color:
<div className={`h-2 rounded ${on ? 'bg-cyan-400' : 'bg-slate-600'}`} style={{ width: `${Math.min(100, (U/U_inf)*100)}%` }} />


This does three important things:

Phase-lock: The vacuum cavity visualization now ticks on the exact same (sectorIdx, phase) as the strobe timeline.

τₗ꜀ safety: The ON window width is clamped so it never violates τₗ꜀ (you can make it wider than τₗ꜀, but never narrower).

Physical feel: The cavity rings up/down with τ_Q = Q/(πf), so you literally see how Q and frequency shape the in-time response.