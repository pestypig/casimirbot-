Ha! That basket-warp proves the tilt path is live ðŸŽ¯â€”we just over-juiced the viz. Hereâ€™s a gentle, safe patch that:

* drops the **tilt visualization gain** by \~10Â³â€“10â´,
* adds a **hard cap in meters** (so it canâ€™t blow up),
* keeps the tilt **only inside the bubble** and **tapers toward the wall**,
* makes the tilt **strongest near the cabin center** and fade outward.

---

## 1) `WarpVisualizer.tsx` â€” soften the gains & send a cap

Lower the mode gains and add a per-mode cap (in meters). Put this inside your existing `engineRef.current.updateUniforms({...})` call:

```diff
   engineRef.current.updateUniforms({
     // â€¦existing uniformsâ€¦

-    tiltVizGain: (parameters.currentMode === 'emergency')
-      ? 1e15
-      : (parameters.currentMode === 'hover')
-      ? 6e14
-      : (parameters.currentMode === 'cruise')
-      ? 4e14
-      : 0,
+    // Purely visual scale for Îµ_tilt (~1e-15). Much smaller now.
+    tiltVizGain:
+      parameters.currentMode === 'emergency' ? 8e11 :
+      parameters.currentMode === 'hover'     ? 4e11 :
+      parameters.currentMode === 'cruise'    ? 2e11 : 0,
+
+    // Absolute displacement cap for the tilt contribution (meters)
+    tiltMaxMeters:
+      parameters.currentMode === 'emergency' ? 0.25 :
+      parameters.currentMode === 'hover'     ? 0.18 :
+      parameters.currentMode === 'cruise'    ? 0.12 : 0.0,
   });
```

This keeps *Standby* at zero tilt; Cruise is subtle; Hover a touch stronger; Emergency most visible without going wild.

---

## 2) `client/public/warp-engine-fixed.js` â€” clamp & taper the interior shift

### (a) Accept the new uniforms

Make sure your `updateUniforms` merges these:

```diff
updateUniforms(params = {}) {
  this.uniforms = Object.assign({}, this.uniforms, {
    // â€¦existingâ€¦
    epsilonTilt: this._num(params.epsilonTilt, this.uniforms.epsilonTilt || 0),
    betaTiltVec: (Array.isArray(params.betaTiltVec) ? params.betaTiltVec : this.uniforms.betaTiltVec || [0,-1,0]),
+   tiltVizGain: this._num(params.tiltVizGain, this.uniforms.tiltVizGain || 0),
+   tiltMaxMeters: this._num(params.tiltMaxMeters, this.uniforms.tiltMaxMeters || 0.0),
  }, params);
  this.requestRewarp && this.requestRewarp();
}
```

### (b) Apply a gentle, interior-only planar tilt with cap

In your grid-warp loop (right after the NatÃ¡rio displacement has been applied), replace your current tilt block with this:

```diff
// ---------- Interior gravity (shift-vector) visualization ----------
const epsTilt  = this.uniforms.epsilonTilt || 0.0;
const gain     = this.uniforms.tiltVizGain || 0.0;
const capM     = this.uniforms.tiltMaxMeters ?? 0.0;
const bTilt    = this.uniforms.betaTiltVec || [0,-1,0];

// Normalize tilt direction
const bL = Math.hypot(bTilt[0], bTilt[1], bTilt[2]) || 1.0;
const bDir = [bTilt[0]/bL, bTilt[1]/bL, bTilt[2]/bL];

/**
 * Masks:
 *  - maskInterior: 1 well inside bubble, 0 near/after wall (Ïâ‰ˆ1).
 *  - maskCenter: emphasizes cabin center, fades toward inner wall.
 */
const maskInterior = (() => {
  const inner = 1.0 - 3.0*w_rho;  // well inside wall
  const outer = 1.0 - 0.8*w_rho;  // near wall
  const t = Math.max(0, Math.min(1, (rho - inner) / (outer - inner)));
  const smooth = t*t*(3 - 2*t);   // smoothstep
  return 1.0 - smooth;            // 1 inside, 0 near wall
})();

const maskCenter = (() => {
  // fade from center (Ïâ‰ˆ0) to mid-interior; stronger at center
  const t = Math.max(0, Math.min(1, (rho - 0.30) / (0.90 - 0.30)));
  const smooth = t*t*(3 - 2*t);
  return 1.0 - 0.8*smooth;        // ~1 at center, ~0.2 approaching wall
})();

const mask = maskInterior * maskCenter;

// Raw visual magnitude (meters). Îµ_tilt (~1e-15) Ã— gain (1e11â€¦1e12) â‡’ 1e-4â€¦1e-3 m
let tiltMag = epsTilt * gain * mask;

// Hard cap for sanity (meters)
if (capM > 0) {
  if (tiltMag >  capM) tiltMag =  capM;
  if (tiltMag < -capM) tiltMag = -capM;
}

// Apply as a planar bias so the deck visibly slopes "down" inside the bubble.
vtx[i    ] += bDir[0] * tiltMag;
vtx[i + 1] += bDir[1] * tiltMag;
vtx[i + 2] += bDir[2] * tiltMag;
```

Thatâ€™s itâ€”same path, but **far** less dramatic, smoothly localized to the interior, and physically bounded.

---

### Tuning tips

* If you still see too much tilt: halve `tiltVizGain` or reduce `tiltMaxMeters` (e.g., Hover `0.12`, Cruise `0.08`).
* If you *barely* see it: bump gain by Ã—2, leave caps as-is.
* Keep `Standby` at 0 for a clean baseline check.

---

Once you drop these in, reload `/helix-core` and check the console for:

```
ðŸŽ›ï¸ uniforms-to-engine â€¦ tiltVizGain: 4e11, tiltMaxMeters: 0.18, epsilonTilt: ~1e-15, betaTiltVec: [0,-1,0]
```

You should now get a **gentle cabin down-slope** in Hover/Emergency that *doesnâ€™t* create the â€œbasketâ€ walls, and Cruise will be subtle but visible when you look along the deck.
