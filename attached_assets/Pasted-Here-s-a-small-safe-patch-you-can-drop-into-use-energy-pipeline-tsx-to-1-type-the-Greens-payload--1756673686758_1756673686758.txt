Here’s a small, safe patch you can drop into use-energy-pipeline.tsx to (1) type the Greens payload, (2) expose a useGreens() hook that subscribes to cache + window events and (3) expose a publishGreens() helper you can call from anywhere (e.g., after client-side compute or server response).

Patch: add Greens helpers to use-energy-pipeline.tsx
// ⬇️ add near the top with other imports
import * as React from "react";

// ⬇️ add types
export type GreensKind = "poisson" | "helmholtz";
export type GreensSource = "server" | "client" | "none";

export interface GreensPayload {
  kind: GreensKind;
  m: number;                 // mass parameter for Helmholtz (0 ⇒ Poisson limit)
  normalize: boolean;
  phi: Float32Array;         // normalized or raw potential samples (per-tile order)
  size: number;              // phi.length
  source: GreensSource;      // who computed it
}

// Optional: inline compute helper (Poisson kernel) for emergency fallback
const poissonKernel = (r: number) => 1/(4*Math.PI*Math.max(r,1e-6));

/**
 * Publish Greens payload to the canonical cache key and broadcast the window event.
 * Call this from the Energy Pipeline page after compute, or from a worker/other panel.
 */
export function publishGreens(payload: GreensPayload) {
  queryClient.setQueryData(["helix:pipeline:greens"], payload);
  try { window.dispatchEvent(new CustomEvent("helix:greens", { detail: payload })); } catch {}
}

/**
 * Subscribe to Greens payload no matter who publishes it.
 * - Reads from React-Query cache key ["helix:pipeline:greens"]
 * - Listens to `helix:greens` window events
 * Returns latest payload (or undefined if none yet).
 */
export function useGreens() {
  const [greens, setGreens] = React.useState<GreensPayload | undefined>(() =>
    queryClient.getQueryData(["helix:pipeline:greens"]) as GreensPayload | undefined
  );

  // react-query cache poll (cheap; avoids event-order races)
  React.useEffect(() => {
    let raf = 0, lastSig = "";
    const tick = () => {
      const cached = queryClient.getQueryData(["helix:pipeline:greens"]) as GreensPayload | undefined;
      const sig = cached ? `${cached.kind}|${cached.size}|${cached.source}` : "";
      if (sig && sig !== lastSig) {
        lastSig = sig;
        setGreens(cached);
      }
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, []);

  // window event listener
  React.useEffect(() => {
    const onGreens = (e: any) => {
      const payload = e?.detail as GreensPayload | undefined;
      if (payload?.phi && payload.size > 0) setGreens(payload);
    };
    window.addEventListener("helix:greens" as any, onGreens as any);
    return () => window.removeEventListener("helix:greens" as any, onGreens as any);
  }, []);

  return greens;
}

/**
 * Optional emergency helper:
 * Build a Poisson φ on the client if you just have tiles but no publisher mounted.
 * (You can keep this or omit it if the Energy Pipeline page will always publish.)
 */
export function buildGreensFromTiles(
  tiles?: { pos: [number,number,number]; t00: number }[],
  normalize = true
): GreensPayload | undefined {
  if (!Array.isArray(tiles) || tiles.length === 0) return undefined;
  const N = tiles.length;
  const phi = new Float32Array(N);
  for (let i=0;i<N;i++){
    let s=0; const [xi,yi,zi] = tiles[i].pos;
    for (let j=0;j<N;j++){
      const [xj,yj,zj] = tiles[j].pos;
      const r = Math.hypot(xi-xj, yi-yj, zi-zj) + 1e-6;
      s += poissonKernel(r) * tiles[j].t00;
    }
    phi[i] = s;
  }
  if (normalize) {
    let min=Infinity, max=-Infinity;
    for (let i=0;i<N;i++){ const v=phi[i]; if(v<min)min=v; if(v>max)max=v; }
    const span = (max-min) || 1;
    for (let i=0;i<N;i++) phi[i] = (phi[i]-min)/span;
  }
  return { kind:"poisson", m:0, normalize, phi, size:N, source:"client" };
}