diff --git a/WarpBubbleCompare.tsx b/WarpBubbleCompare.tsx
@@
-// Force parity mode based on pane - this is critical for physics validation
-  if (pane === 'REAL') {
-    p.physicsParityMode = true;
-    p.parityMode = true;  // Also set the fallback field
-    p.ridgeMode = 0;
-    if (DEBUG) console.log(`[${pane}] Parity lock: physicsParityMode=true, ridgeMode=0`);
-  } else {
-    p.physicsParityMode = false;
-    p.parityMode = false; // Also set the fallback field
-    p.ridgeMode = 1;
-    if (DEBUG) console.log(`[${pane}] Parity lock: physicsParityMode=false, ridgeMode=1`);
-  }
-  return p;
+// Enforcement disabled: leave parity/ridge untouched (pass-through)
+  return p;
 }
 
@@
-    // Build physics payload for REAL engine with enforced parity
-    const realPhysicsPayload = paneSanitize('REAL', {
+    // Build physics payload for REAL engine (no enforced parity)
+    const realPhysicsPayload = paneSanitize('REAL', {
       ...shared,
       gridSpan: gridSpanReal,            // tight framing around hull
       ...real,
       currentMode: parameters.currentMode,
       vShip: 0,                          // never "fly" in REAL
@@
       colorMode: 2,                      // shear proxy is a clear "truth" view
       cameraZ: camZ,                     // ⟵ key: to-scale camera
-      // Force parity mode explicitly
-      physicsParityMode: true,
-      ridgeMode: 0,
-      // Use shared theta calculation with mass-focused gamma VdB
-      thetaScale: computeThetaScale({
-        gammaGeo: real.gammaGeo,
-        qSpoilingFactor: real.qSpoilingFactor,
-        gammaVanDenBroeck: real.gammaVanDenBroeck,
-        gammaVanDenBroeck_mass: real.gammaVanDenBroeck_mass,
-        dutyEffectiveFR: real.dutyEffectiveFR
-      }, { mode: 'mass', vdbMax: 100, vdbDefault: 38.3 }),
+      // θ: prefer pipeline (verbatim), else fallback to previous compute
+      thetaScale: (Number.isFinite(Number((parameters as any)?.thetaScale)))
+        ? Number((parameters as any).thetaScale)
+        : computeThetaScale({
+            gammaGeo: real.gammaGeo,
+            qSpoilingFactor: real.qSpoilingFactor,
+            gammaVanDenBroeck: real.gammaVanDenBroeck,
+            gammaVanDenBroeck_mass: real.gammaVanDenBroeck_mass,
+            dutyEffectiveFR: real.dutyEffectiveFR
+          }, { mode: 'mass', vdbMax: 100, vdbDefault: 38.3 }),
     });
 
@@
-    const showPhysicsPayload = paneSanitize('SHOW', {
+    const showPhysicsPayload = paneSanitize('SHOW', {
       ...shared,
       ...show,
       currentMode: parameters.currentMode,
       vShip: parameters.currentMode === 'standby' ? 0 : 1,
       gammaVdB: Math.max(1, Math.min(1000, show.gammaVanDenBroeck ?? show.gammaVdB ?? 1)), // clamp γ_VdB
       deltaAOverA: Math.max(0.01, Math.min(10, show.qSpoilingFactor ?? 1)), // clamp q-spoiling
       sectors: Math.max(1, Math.min(1000, parameters.sectors || 400)),
       // SHOW camera can share the same camZ for easy side-by-side comparison
       cameraZ: camZ,
       // Apply heroExaggeration to visual amplification (normalized heroBoost)
       curvatureGainT: Math.max(0, Math.min(1, 0.70)), // clamp gain T
       curvatureBoostMax: Math.max(1, Math.min(1000, heroBoost)), // clamp boost max
       userGain: Math.max(1, Math.min(100, 4)), // clamp user gain
       displayGain: 1,
-      // Force non-parity mode explicitly
-      physicsParityMode: false,
-      ridgeMode: 1,
-      // Use shared theta calculation with visual-focused gamma VdB, handle standby mode
-      thetaScale: parameters.currentMode === 'standby' ? 0 : computeThetaScale({
-        gammaGeo: show.gammaGeo,
-        qSpoilingFactor: show.qSpoilingFactor,
-        gammaVanDenBroeck: show.gammaVanDenBroeck,
-        gammaVanDenBroeck_vis: show.gammaVanDenBroeck_vis,
-        dutyEffectiveFR: show.dutyEffectiveFR
-      }, { mode: 'vis', vdbMax: 100, vdbDefault: 38.3 }),
+      // θ: prefer pipeline (verbatim), else handle standby/compute fallback
+      thetaScale: (Number.isFinite(Number((parameters as any)?.thetaScale)))
+        ? Number((parameters as any).thetaScale)
+        : (parameters.currentMode === 'standby' ? 0 : computeThetaScale({
+            gammaGeo: show.gammaGeo,
+            qSpoilingFactor: show.qSpoilingFactor,
+            gammaVanDenBroeck: show.gammaVanDenBroeck,
+            gammaVanDenBroeck_vis: show.gammaVanDenBroeck_vis,
+            dutyEffectiveFR: show.dutyEffectiveFR
+          }, { mode: 'vis', vdbMax: 100, vdbDefault: 38.3 })),
     });
 
@@
-    pushRight.current(paneSanitize('SHOW', sanitizeUniforms(showPhysicsPayload)), 'SHOW');
+    pushRight.current(paneSanitize('SHOW', sanitizeUniforms(showPhysicsPayload)), 'SHOW');
 
@@
-    // REAL: cosmetics only (don't touch wallWidth/cameraZ/amp)
-    pushLeft.current(paneSanitize('REAL', sanitizeUniforms({
-      exposure: real.exposure,
-      zeroStop: real.zeroStop,
-      colorMode: 2,             // pin shear proxy permanently for REAL
-      ridgeMode: 0              // pin double-lobe physics mode
-    })), 'REAL');
+    // REAL: cosmetics only (don't touch wallWidth/cameraZ/amp); no ridge lock
+    pushLeft.current(paneSanitize('REAL', sanitizeUniforms({
+      exposure: real.exposure,
+      zeroStop: real.zeroStop,
+      colorMode: 2
+    })), 'REAL');
 