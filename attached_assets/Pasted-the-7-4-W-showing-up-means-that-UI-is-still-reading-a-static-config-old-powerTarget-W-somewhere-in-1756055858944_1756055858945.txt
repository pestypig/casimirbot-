the 7.4 W showing up means that UI is still reading a static config (old powerTarget_W) somewhere in the operational-modes panel instead of the live pipeline (P_avg_MW). That explains why Cruise keeps saying 7.4 W even though the pipeline moved Hover+Cruise to ~83 MW.

Here’s a tight fix that (a) prefers live pipeline numbers for every mode title, (b) only falls back to config when live is absent, and (c) never confuses W/MW again.

What’s going wrong

Source mix-up: Mode items use MODE_CONFIGS.powerTarget_W (7.4) for non-current modes instead of the live stream.

Unit drift: That value is in watts; earlier code was formatting it as MW or showing it verbatim, causing bogus titles.

Memo deps: Some titles are computed once and never recomputed when the pipeline emits new values.

Patch (in client/src/components/live-energy-pipeline.tsx)

Replace the item-title building so it always pulls live first:

// utils near top of file
type ModeKey = "hover" | "cruise" | "emergency" | "standby";

const formatPower = (P_MW?: number, P_W?: number) => {
  if (Number.isFinite(P_MW as number)) return `${(P_MW as number).toFixed(1)} MW`;
  if (Number.isFinite(P_W as number)) {
    const w = P_W as number;
    if (w >= 1e6) return `${(w / 1e6).toFixed(1)} MW`;
    if (w >= 1e3) return `${(w / 1e3).toFixed(1)} kW`;
    return `${w.toFixed(1)} W`;
  }
  return "—";
};

const buildLiveDesc = (snap?: { P_avg_MW?: number; M_exotic_kg?: number; zeta?: number }, cfg?: { powerTarget_W?: number }) => {
  const P = formatPower(snap?.P_avg_MW, cfg?.powerTarget_W);
  const M = Number.isFinite(snap?.M_exotic_kg) ? `${snap!.M_exotic_kg!.toFixed(0)} kg` : "— kg";
  const Z = Number.isFinite(snap?.zeta) ? `ζ=${snap!.zeta!.toFixed(3)}` : "ζ=—";
  return `${P} • ${M} • ${Z}`;
};


Use the live snapshot for each mode in the dropdown and the active title:

// assume `live` comes from the pipeline hook
// try multiple shapes defensively (live.byMode or live.modes or individual fields)
const liveForMode = (key: ModeKey) =>
  (live?.byMode && live.byMode[key]) ||
  (live?.modes && live.modes[key]) ||
  (live && (live as any)[key]) || null;

// current mode label
const currentModeKey: ModeKey = (live?.currentMode as ModeKey) || "hover";
const currentSnap = liveForMode(currentModeKey);
const currentCfg = modes[currentModeKey];
const currentTitle = buildLiveDesc(currentSnap, currentCfg);

// ...
<SelectTrigger className="w-56">
  <SelectValue placeholder="Select mode">
    <div className="flex flex-col">
      <span className="font-medium">{currentCfg?.name ?? currentModeKey}</span>
      <span className="text-xs text-muted-foreground">{currentTitle}</span>
    </div>
  </SelectValue>
</SelectTrigger>

<SelectContent>
  {Object.entries(modes).map(([key, cfg]) => {
    const k = key as ModeKey;
    const snap = liveForMode(k);
    return (
      <SelectItem key={key} value={key}>
        <div className="flex flex-col">
          <span className="font-medium">{cfg?.name ?? key}</span>
          <span className="text-xs text-muted-foreground">
            {buildLiveDesc(snap, cfg)}
          </span>
        </div>
      </SelectItem>
    );
  })}
</SelectContent>


Make sure the component re-renders when live updates arrive (simple, safe dep):

// optional: expose for quick console checks
useEffect(() => { (window as any).__energyLive = live; }, [live]);