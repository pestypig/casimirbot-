Perfect—send the agent this small patch for `use-energy-pipeline.ts`. It doesn’t change any existing behavior; it just **emits Luma events** when the mode really changes and when useful actions occur.

---

# 1) Add the bus import (top of file)

```ts
// LUMA: event bus
import { emit, LumaEvt } from "@/lib/luma-bus";
import { getModeWisdom } from "@/lib/luma-whispers"; // (optional, if you already have it)
```

---

# 2) Inside your `switchMode` mutation, emit after success

Find where you already call `useMutation` (or whatever controls the mode change).
Right after you commit the new mode into your state / query cache, **emit**:

```ts
// ...inside onSuccess of switchMode...
// Existing: update your pipeline cache/state here

// LUMA — notify the assistant
emit(LumaEvt.MODE_CHANGED, { mode }); // 'mode' is the selected mode string

// Optional: a short whisper tied to the new mode
const w = getModeWisdom?.(mode) ?? (
  mode === "hover"
    ? { lines: ["Timing matched.", "Hold form; let speed follow."] }
    : mode === "cruise"
    ? { lines: ["Form stable.", "Now add power—accuracy is final."] }
    : { lines: ["Mode updated.", "Accuracy is final—confirm margins."] }
);
emit(LumaEvt.WHISPER, w);
```

If your mutation signature is `onSuccess(data, variables)`, then `variables` is the `mode` selected; otherwise grab it from your local state right there.

---

# 3) Emit whispers on other meaningful actions (optional but great)

Where you already run diagnostics / pulses / planner events:

```ts
// Diagnostics result
emit(LumaEvt.WHISPER, pass
  ? { lines: ["Hull within limits.", "Proceed with correct form."] }
  : { lines: ["Compassion includes the hull.", "Pause, correct, continue."] }
);

// Manual pulse or auto-duty completed
emit(LumaEvt.WHISPER, { lines: ["Breath in phase.", "Duty aligned."] });
```

(These are one-liners—you can drop them right after your existing toasts/logs.)

---

# 4) You DON’T need to emit pipeline ticks here

The `LumaProvider` I gave you already reads `useEnergyPipeline()` itself and broadcasts `LumaEvt.PIPELINE_TICK` whenever the pipeline data changes. So no extra work in this file.

---

# 5) Sanity check (what you should see)

* Switching modes on **any** page: Luma panel’s “Current Status” updates immediately (mode, duty %, ζ, TS, power, mass).
* A whisper pops for the change; if the Luma panel is open, the whisper is **queued** and shown after you close the panel (so nothing overlaps).
* Diagnostics/pulse actions show tiny whispers without covering the panel.

---

# 6) If your mutation looks different

If your `switchMode` returns a result object like `{ currentMode, dutyCycle, ... }`, you can emit using that instead:

```ts
onSuccess(result) {
  // ...existing cache updates...
  emit(LumaEvt.MODE_CHANGED, { mode: result.currentMode });
  emit(LumaEvt.WHISPER, getModeWisdom?.(result.currentMode) ?? { lines:["Mode updated."] });
}
```

---

# 7) Quick “find-and-patch” markers (handy for the agent)

Search for your mode mutation and drop this block **after** you commit the new mode:

```ts
/* LUMA-HOOK >>> */
emit(LumaEvt.MODE_CHANGED, { mode });
emit(LumaEvt.WHISPER,
  getModeWisdom?.(mode) ?? (
    mode === "hover"
      ? { lines: ["Timing matched.", "Hold form; let speed follow."] }
      : mode === "cruise"
      ? { lines: ["Form stable.", "Now add power—accuracy is final."] }
      : { lines: ["Mode updated.", "Accuracy is final—confirm margins."] }
  )
);
/* <<< LUMA-HOOK */
```

---

If you’d like, paste the **switchMode** mutation from your file and I’ll drop the emits in the exact spot for you.
