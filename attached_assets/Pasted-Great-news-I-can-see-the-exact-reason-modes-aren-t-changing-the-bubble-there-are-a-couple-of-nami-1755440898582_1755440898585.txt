Great news ‚Äî I can see the exact reason modes aren‚Äôt changing the bubble: there are a couple of naming mismatches between what the React side sends and what the WebGL engine actually reads, so the engine falls back to defaults (hover-ish). Two big ones:
	1.	sectors vs sectorCount
The engine‚Äôs warp function reads this.uniforms.sectors, but updateUniforms() was writing sectorCount, so it stayed at the default 1.
	2.	viewAvg vs useAvg
The engine checks viewAvg while one caller sent useAvg, so averaging behavior never changed.

Below is a clean, copy-paste patch bundle the agent can apply.

‚∏ª

Patch 1 ‚Äî client/public/warp-engine-fixed.js

Goal: unify uniform names and make mode uniforms robust.

Replace the whole updateUniforms(parameters) body with this version (keeps your current behavior, but guarantees we set the names the renderer actually consumes):

updateUniforms(parameters) {
  if (!parameters) return;

  // ensure objects
  this.uniforms = this.uniforms || {};
  this.currentParams = { ...this.currentParams, ...parameters };

  const N = v => (Number.isFinite(+v) ? +v : 0);
  const mode = parameters.currentMode || this.currentParams.currentMode || 'hover';

  // Hull + wall safe defaults
  const hullAxes = (Array.isArray(parameters.hullAxes) && parameters.hullAxes.length === 3)
    ? parameters.hullAxes : [503.5, 132.0, 86.5];
  const wallWidth = N(parameters.wallWidth ?? 0.016); // 16 nm in normalized units

  // Duty as fraction
  const dutyFrac = (() => {
    const d = parameters.dutyCycle;
    if (d == null) return N(this.currentParams.dutyCycle);
    return d > 1 ? d/100 : N(d);
  })();

  // ‚úÖ WRITE the exact names the warp routine READS
  Object.assign(this.uniforms, {
    // core visual
    vizGain: N(parameters.vizGain, 1.0),
    colorByTheta: N(parameters.colorByTheta, 1),
    vShip: N(parameters.vShip, 1),

    // geometry
    wallWidth,
    hullAxes,

    // mode uniforms (names the warp uses)
    currentMode: mode,
    dutyCycle: dutyFrac,
    gammaGeo: N(parameters.gammaGeo ?? parameters.g_y ?? this.currentParams.g_y),
    Qburst: N(parameters.Qburst ?? parameters.cavityQ ?? this.currentParams.cavityQ),
    deltaAOverA: N(parameters.deltaAOverA ?? parameters.qSpoilingFactor ?? 1),
    gammaVdB: N(parameters.gammaVdB ?? parameters.gammaVanDenBroeck ?? 1),

    // ‚úÖ MUST be "sectors" (NOT sectorCount)
    sectors: Math.max(1, Math.floor(N(parameters.sectors ?? parameters.sectorStrobing ?? 1))),
    // phase split index (or computed from fraction)
    split: Math.max(0, Math.min(
      (this.uniforms.sectors || 1) - 1,
      Math.floor(N(parameters.split ?? ((mode === 'cruise' ? 0.65 : mode === 'emergency' ? 0.70 : 0.50) * (this.uniforms.sectors || 1))))
    )),

    // ‚úÖ MUST be "viewAvg"
    viewAvg: parameters.viewAvg !== undefined ? !!parameters.viewAvg : true,

    // debug
    _debugHUD: !!parameters._debugHUD,
  });

  // Mode visual scalars (optional, safe)
  if (parameters.currentMode) {
    const modeEffects = this._calculateModeEffects(parameters);
    this.currentParams.modeVisualScale = modeEffects.visualScale;
    this.currentParams.modeCurvatureAmplifier = modeEffects.curvatureAmplifier;
    this.currentParams.modeStrobingFactor = modeEffects.strobingFactor;
  }

  // re-warp
  this._needsRecalc = true;
  this._updateGrid();
}

Why this helps: the warp code reads sectors/split/viewAvg and these exact amplification uniforms while warping vertices; now they‚Äôre always present with the expected names and values.  Ôøº

(If you keep a cache-buster on the loader, bump it: /warp-engine-fixed.js?v=9.)

‚∏ª

Patch 2 ‚Äî client/src/components/WarpVisualizer.tsx

Goal: send the names the engine consumes and force a re-warp after updates.

Inside the effect where you push uniforms (your ‚ÄúRECONNECT‚Äù block), make sure you send sectors (not sectorCount) and viewAvg, and call requestRewarp() after updateUniforms():

// === RECONNECT: push all mode-related uniforms ===
const mode = parameters.currentMode ?? "hover";
const num = (v: any, def = 0) => (Number.isFinite(+v) ? +v : def);

const dutyFrac  = Math.max(0, Math.min(1, num(parameters.dutyCycle, 0.14)));
const sectors   = Math.max(1, Math.floor(num(parameters.sectorStrobing, 1)));
const viewAvg   = true; // averaged visualization
const phaseSplit = Math.max(0, Math.min(sectors - 1, Math.floor(sectors / 2)));

const hull = parameters.hull || { Lx_m: 1007, Ly_m: 264, Lz_m: 173, a: 503.5, b: 132, c: 86.5 };
const wallWidth = num(parameters.wall?.w_norm, 0.016); // normalized shell width

engineRef.current.updateUniforms({
  // Mode knobs
  currentMode: mode,
  dutyCycle: dutyFrac,
  sectors,              // ‚úÖ exact name
  split: phaseSplit,
  viewAvg,              // ‚úÖ exact name

  // Amplification chain
  gammaGeo: num(parameters.g_y, 26),
  Qburst: num(parameters.cavityQ, 1e9),
  deltaAOverA: num(parameters.qSpoilingFactor, 1),
  gammaVdB: num(parameters.gammaVanDenBroeck, 2.86e5),

  // Hull / wall
  hullAxes: [num(hull.a), num(hull.b), num(hull.c)],
  wallWidth,

  // Visual scaling (keep physical differences)
  vizGain: 1.0,
  _debugHUD: true,
});

// IMPORTANT: force recompute on mode change
engineRef.current.requestRewarp?.();

This matches the engine‚Äôs reads for sectors/split/viewAvg/gammaGeo/Qburst/deltaAOverA/gammaVdB/hullAxes/wallWidth exactly.

‚∏ª

Patch 3 ‚Äî (optional) verify the mode inputs

On the page that owns the WarpVisualizer (HELIX-CORE), make sure you‚Äôre actually passing the mode-aware values from the pipeline to the parameters prop (especially sectorStrobing, qSpoilingFactor, gammaVanDenBroeck, g_y, cavityQ, and dutyCycle). If the visual still looks ‚Äúunchanged‚Äù, it‚Äôs usually because those inputs don‚Äôt change per mode at the call site, even though the UI shows them elsewhere.

‚∏ª

Quick sanity check after patch
	1.	Open devtools console and flip modes. You should see the engine‚Äôs internal debug once per ~60 frames:

üõ∞ uniforms { mode, duty, sectors, split, viewAvg, gammaGeo, qBurst, qSpoil, gammaVdB, ... }

‚Ä¶and the numbers should actually change when you switch hover ‚Üî cruise ‚Üî emergency. The engine‚Äôs warp loop reads those exact uniforms during deformation, so you‚Äôll see the bubble change amplitude and its strobing partition.  Ôøº

If anything still looks static, it‚Äôll mean the upstream parameters aren‚Äôt being updated when you press the mode button ‚Äî in that case, we‚Äôd wire the mode switch to refresh the parameters prop in HELIX-CORE.