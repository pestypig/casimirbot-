Great catch — the gain you’re setting was only reaching the **fragment shader color** path (`u_userGain`) and never the **geometry displacement**, so sliding it felt like “no curvature.” Below is a tight patch that:

1. Drives **visual displacement** with the same gain you see in the Slice Viewer.
2. Keeps color + geometry on a **single amplitude** story (γ³·ΔA/A·γVdB·√(duty/sectors) × gain).
3. Optionally **expands the grid span** as you boost gain so the effect stays framed and obvious.

You already have uniforms for `u_thetaScale` and `u_userGain`; this just wires them correctly and applies the same gain to the vertex displacement and grid span.

---

### 1) Pass the user gain from UI → engine uniforms

In `updateUniforms(...)`, after you set `curvatureGainT` and `curvatureBoostMax`, compute a **unified boost** and save it as `userGain` so the shader gets it, and we can reuse it on the CPU side for geometry:

```diff
 this.uniforms = {
   ...this.uniforms,
   ...
   curvatureGainT: Number.isFinite(parameters.curvatureGainT)
     ? Math.max(0, Math.min(1, parameters.curvatureGainT))
     : (this.uniforms?.curvatureGainT ?? 0.75),
   curvatureBoostMax: Number.isFinite(parameters.curvatureBoostMax)
     ? Math.max(1, parameters.curvatureBoostMax)
     : (this.uniforms?.curvatureBoostMax ?? 40),
+  // Derived unified gain used by both color and geometry:
+  userGain: (() => {
+    const t = (Number.isFinite(parameters.curvatureGainT)
+      ? parameters.curvatureGainT
+      : (this.uniforms?.curvatureGainT ?? 0.75));
+    const mx = (Number.isFinite(parameters.curvatureBoostMax)
+      ? Math.max(1, parameters.curvatureBoostMax)
+      : (this.uniforms?.curvatureBoostMax ?? 40));
+    return (1 - t) + t * mx; // 1 .. curvatureBoostMax
+  })(),
   ...
   // Same amplitude chain as SliceViewer:
   thetaScale: (() => {
     const gammaGeo = N(parameters.gammaGeo ?? parameters.g_y ?? this.currentParams.g_y ?? 26);
     const qSpoil = N(parameters.deltaAOverA ?? parameters.qSpoilingFactor ?? 1.0);
     const gammaVdB = N(parameters.gammaVdB ?? parameters.gammaVanDenBroeck ?? 3.83e1);
     const duty = Math.max(1e-12, N(dutyFrac));
     const sectors = Math.max(1, N(parameters.sectors ?? parameters.sectorStrobing ?? 1));
     return Math.pow(gammaGeo, 3) * qSpoil * gammaVdB * Math.sqrt(duty / sectors);
   })(),
   ...
 };
```

> Now `this.uniforms.userGain` is the single source of truth (1..max) that both the **shader color** and **CPU geometry** will use.

---

### 2) Apply the gain to **geometry displacement** and **grid span**

Inside `_warpGridVertices(...)`, just after you compute the span and before the deformation loop, derive the same **boost** and use it in two places:

* multiply the final `A_vis` used for **displacement**;
* gently expand **targetSpan** so framing tracks the boost.

```diff
 // Compute a grid span that comfortably contains the whole bubble
 const hullMaxClip = Math.max(axesScene[0], axesScene[1], axesScene[2]);
 const spanPadding = bubbleParams.gridScale || GRID_DEFAULTS.spanPadding;
-let targetSpan = Math.max(GRID_DEFAULTS.minSpan, hullMaxClip * spanPadding);
+let targetSpan = Math.max(GRID_DEFAULTS.minSpan, hullMaxClip * spanPadding);

+// --- Gain boost used for BOTH color & geometry ---
+const userGain = Math.max(1.0, this.uniforms?.userGain || 1.0);
+// Expand grid a little with gain so boosted curvature stays framed
+const spanBoost = 1.0 + (userGain - 1.0) * 0.35;  // 35% of gain goes to span
+targetSpan *= spanBoost;
```

Now, in the **core displacement** section, replace the current visibility/gain shaping with a clean, unified amplitude that uses your viewer chain (`thetaScale`) and the `userGain`. You already compute a local `A_gross/A_log` path — remove the old visualization-only shaping and do:

```diff
- // === LOGARITHMIC COMPRESSION TO PREVENT SATURATION ===
- const gammaGeo = this.uniforms?.gammaGeo ?? 26;
- const Qburst   = this.uniforms?.Qburst   ?? this.uniforms?.cavityQ ?? 1e9;
- const qSpoil   = this.uniforms?.deltaAOverA ?? this.uniforms?.qSpoilingFactor ?? 1.0;
- const gammaVdB = this.uniforms?.gammaVdB ?? 3.83e1;
- const duty     = Math.max(0, Math.min(1, this.uniforms?.dutyCycle ?? 0.14));
- const sectors  = Math.max(1, this.uniforms?.sectors ?? 1);
- const mode     = (this.uniforms?.currentMode || 'hover').toLowerCase();
- const A_geo   = gammaGeo * gammaGeo * gammaGeo; // γ^3
- const dutyEff = Math.sqrt(duty / sectors);
- const A_gross = A_geo * Qburst * gammaVdB * qSpoil * dutyEff;
- const k = 1e10; // knee
- const s = 1.0;
- const A_log = Math.log10(1 + A_gross / k) * s;
- const A_vis_base = Math.min(1.0, A_log);
- const tGain   = this.uniforms?.curvatureGainT ?? 0.75;
- const boostMx = this.uniforms?.curvatureBoostMax ?? 40;
- const boost   = (1 - tGain) + tGain * boostMx;
- const modeScale =
-   mode === 'standby'   ? 0.90 :
-   mode === 'cruise'    ? 1.00 :
-   mode === 'hover'     ? 1.05 :
-   mode === 'emergency' ? 1.10 : 1.00;
- const A_vis = Math.min(1.0, A_vis_base * boost * modeScale);
+ // === Unified “SliceViewer-consistent” amplitude for geometry ===
+ // thetaScale = γ^3 · (ΔA/A) · γ_VdB · √(duty/sectors)  (already computed in updateUniforms)
+ const thetaScale = Math.max(0, this.uniforms?.thetaScale || 0);
+ const mode       = (this.uniforms?.currentMode || 'hover').toLowerCase();
+ const A_base     = thetaScale;          // physics, averaged if viewAvg was true upstream
+ const boost      = userGain;            // 1..max (same number sent to shader as u_userGain)
+ // Small per-mode seasoning only, so we don’t hide the physics
+ const modeScale  =
+   mode === 'standby'   ? 0.95 :
+   mode === 'cruise'    ? 1.00 :
+   mode === 'hover'     ? 1.05 :
+   mode === 'emergency' ? 1.08 : 1.00;
+ // Final, bounded visual amplitude for geometry
+ const A_vis = Math.min(1.0, A_base * boost * modeScale);
 
- let disp;
+ let disp;
 if (mode === 'standby') {
   disp = 0;
 } else {
-  disp = gridK * A_vis * wallWin * front * sgn * gaussian_local;
+  disp = gridK * A_vis * wallWin * front * sgn * gaussian_local;
   disp *= 2.0;
   const maxPush = 0.15;
   const softClamp = (x, m) => m * Math.tanh(x / m);
   disp = softClamp(disp, maxPush);
   ...
 }
```

That’s it — now the **same gain** you see in the Slice Viewer:

* multiplies the **shader color** via `u_userGain`;
* multiplies **geometry displacement** via `A_vis`;
* plus the **grid** grows \~35% of your gain to keep the boosted curvature visible.

---

### 3) Ensure the shader receives the same gain (you already do)

You already added:

```js
gl.uniform1f(this.gridUniforms.thetaScale, this.uniforms?.thetaScale || 1.0);
gl.uniform1f(this.gridUniforms.userGain,   this.uniforms?.userGain   || 1.0);
```

No change needed — with step (1) `userGain` will be set consistently.

---

### Why this works (and matches the formulation)

* **One amplitude chain** (γ³·ΔA/A·γVdB·√(duty/sectors)) feeds both **color** and **geometry**.
* The **gain slider** is a pure *view* multiplier on that same chain (1..max), consistent in both places.
* The **grid span** expands with gain so viewers actually *see* the additional curvature instead of it compressing against the camera.

If you want the grid to expand even more aggressively with gain, bump the `0.35` to `0.5` (or expose it as a UI knob like `gridGainFollow = 0..1`).
