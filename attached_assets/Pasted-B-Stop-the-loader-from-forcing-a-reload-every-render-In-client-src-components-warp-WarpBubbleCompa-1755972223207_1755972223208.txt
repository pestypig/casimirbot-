B) Stop the loader from forcing a reload every render

In client/src/components/warp/WarpBubbleCompare.tsx:

Make the app build token stable in dev (no Date.now()):

-const APP_WARP_BUILD = (window as any).__APP_WARP_BUILD || "dev-" + Date.now();
+const APP_WARP_BUILD =
+  (window as any).__APP_WARP_BUILD ||
+  (window as any).__WarpEngineBuild || // reuse engine’s stamped build if present
+  "dev";


Short-circuit ensureWarpEngineCtor if an engine is already present (and don’t rip out tags):

 async function ensureWarpEngineCtor(opts: { requiredBuild?: string; forceReload?: boolean } = {}): Promise<any> {
   const { requiredBuild = APP_WARP_BUILD, forceReload = false } = opts;
   const w = window as any;

   // If an engine is already present, verify its build token
   let Ctor = w.WarpEngine?.default || w.WarpEngine;
   const currentBuild = w.WarpEngine?.BUILD || w.__WarpEngineBuild;
-  if (Ctor && !forceReload) {
-    if (!requiredBuild || currentBuild === requiredBuild) {
-      console.log('[WARP LOADER] Reusing WarpEngine', { build: currentBuild });
-      return Ctor;
-    }
-    console.warn('[WARP LOADER] Build mismatch; reloading engine', { currentBuild, requiredBuild });
-  }
+  if (Ctor && !forceReload) {
+    // In dev, accept any build; in prod, match the token
+    const dev = requiredBuild === 'dev';
+    if (dev || !requiredBuild || currentBuild === requiredBuild) {
+      console.log('[WARP LOADER] Reusing WarpEngine', { build: currentBuild });
+      return Ctor;
+    }
+    console.warn('[WARP LOADER] Build mismatch; reloading engine', { currentBuild, requiredBuild });
+  }

-  // Remove any old <script> tags and load a fresh one with cache-bust
-  removeOldWarpScripts();
+  // Only inject if no script tag exists (avoid double execution)
+  const existing = Array.from(document.scripts).find(s => /\/warp-engine\.js(\?|$)/.test(s.src));
+  if (!existing) {
+    // Fresh load with cache-bust
+    const url = `/warp-engine.js?v=${encodeURIComponent(requiredBuild)}&t=${Date.now()}`;
+    await loadScript(url);
+  } else {
+    // Wait for the existing tag to finish (or the global to appear)
+    await new Promise<void>((resolve, reject) => {
+      const ok = () => (w.WarpEngine ? resolve() : setTimeout(ok, 30));
+      existing.addEventListener('error', () => reject(new Error('warp-engine.js failed to load')));
+      ok();
+    });
+  }


This ensures we reuse a loaded engine in dev, and we don’t re-execute the script if a tag is already present.