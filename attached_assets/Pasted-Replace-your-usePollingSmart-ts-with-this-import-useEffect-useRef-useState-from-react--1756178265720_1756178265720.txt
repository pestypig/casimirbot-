Replace your usePollingSmart.ts with this:

import { useEffect, useRef, useState } from "react";

/**
 * Smart polling (teardown-safe):
 * - Visibility aware (pauses when tab hidden)
 * - Online/Offline aware
 * - AbortController for in-flight cancellation
 * - Exponential backoff on failures
 * - Dedupe across components via a shared bus
 */

type Opts = {
  minMs?: number;
  maxMs?: number;
  backoffFactor?: number;
  dedupeKey?: string;
  enabled?: boolean;
  parser?: (res: Response) => Promise<any>;
};

const defaultParser = (r: Response) => r.json();

// in-module cache to fan out results to multiple components
const bus = new Map<
  string,
  {
    subscribers: Set<(v: any) => void>;
    last?: any;
    controller?: AbortController;
    timer?: number;
    running?: boolean;
  }
>();

function safeAbort(ch: { controller?: AbortController }, reason = "teardown") {
  try {
    ch.controller?.abort(reason);
  } catch {
    // some environments throw if aborting an already-settled signal; ignore
  } finally {
    ch.controller = undefined;
  }
}

export function usePollingSmart<T = any>(
  url: string,
  {
    minMs = 8000,
    maxMs = 30000,
    backoffFactor = 1.6,
    dedupeKey,
    enabled = true,
    parser = defaultParser,
  }: Opts = {}
) {
  const key = dedupeKey ?? url;
  const [data, setData] = useState<T | null>(null);
  const [err, setErr] = useState<string | null>(null);
  const delayRef = useRef(minMs);

  useEffect(() => {
    if (!enabled) return;

    // SSR guard
    if (typeof window === "undefined" || typeof document === "undefined") return;

    // ensure channel exists
    if (!bus.has(key)) {
      bus.set(key, { subscribers: new Set(), running: false });
    }
    const ch = bus.get(key)!;

    const sub = (v: any) => setData(v as T);
    ch.subscribers.add(sub);

    // emit cached value immediately if available
    if (ch.last !== undefined) setData(ch.last as T);

    let disposed = false;

    const scheduleNext = (delay: number) => {
      if (disposed || ch.subscribers.size === 0) {
        ch.running = false;
        return;
      }
      ch.timer = window.setTimeout(tick, delay);
    };

    const tick = async () => {
      if (disposed) return;

      const tabHidden = typeof document !== "undefined" && document.hidden;
      const online = typeof navigator === "undefined" ? true : (navigator as any).onLine !== false;

      if (tabHidden || !online) {
        // cheap wait while hidden/offline â€” do NOT touch controller
        scheduleNext(minMs);
        return;
      }

      try {
        // cancel any in-flight request before starting a new one
        safeAbort(ch, "cycle-restart");
        ch.controller = new AbortController();

        const res = await fetch(url, { signal: ch.controller.signal });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

        const json = await parser(res);
        ch.last = json;
        ch.subscribers.forEach(fn => fn(json));

        setErr(null);
        delayRef.current = minMs; // reset backoff on success
      } catch (e: any) {
        // If the error is caused by our abort, keep it quiet
        const msg = e?.message || String(e || "");
        const aborted =
          (e?.name === "AbortError") ||
          /aborted/i.test(msg) ||
          /The user aborted a request/i.test(msg) ||
          /signal is aborted/i.test(msg);

        if (!aborted) {
          setErr(msg || "fetch failed");
          delayRef.current = Math.min(
            maxMs,
            Math.max(minMs, Math.round(delayRef.current * backoffFactor))
          );
        } else {
          // on abort, keep current delay (usually minMs)
        }
      } finally {
        scheduleNext(delayRef.current);
      }
    };

    // start loop only once per key
    if (!ch.running) {
      ch.running = true;
      delayRef.current = minMs;
      tick();
    }

    const onVis = () => {
      if (!document.hidden && ch.timer == null && ch.running) {
        delayRef.current = minMs;
        tick();
      }
    };
    document.addEventListener("visibilitychange", onVis);

    return () => {
      disposed = true;
      document.removeEventListener("visibilitychange", onVis);

      // unsubscribe
      ch.subscribers.delete(sub);

      // stop loop if nobody is listening
      if (ch.subscribers.size === 0) {
        if (ch.timer) {
          clearTimeout(ch.timer);
          ch.timer = undefined as any;
        }
        // abort any in-flight request with a clear reason
        safeAbort(ch, "teardown");
        ch.running = false;
        bus.delete(key);
      }
    };
  }, [key, url, enabled, minMs, maxMs, backoffFactor, parser]);

  return { data, err } as const;
}