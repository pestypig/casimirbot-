Great catch — the panel is rendering but the values stay “—” because the `shift` prop is arriving as an **object without fields**, which short-circuits the fallback logic. In your current component you do:

> `const displayShift = shift ?? { …fallbacks… }`

If `shift` is `{}` (truthy), the right side never runs, so all fields are `undefined`. That’s exactly what your screenshot shows: `gTarget` got printed (it comes from a separate literal), while `R_geom`, `ε_tilt`, etc. are blank.

Here’s a tiny, safe fix that **merges** per-field fallbacks so the UI always shows numbers even when the backend hasn’t populated everything yet.

### Patch — `ShiftVectorPanel.tsx`

Replace the single `displayShift` line with the per-field merge:

```tsx
// BEFORE
// const displayShift = shift ?? {
//   gTarget: fallbackGTarget,
//   R_geom: fallbackRGeom,
//   epsilonTilt: fallbackEpsilonTilt,
//   betaTiltVec: fallbackBetaTiltVec as [number, number, number],
//   gEff_check: fallbackGEffCheck
// };

// AFTER
const s = shift ?? {};
const displayShift = {
  gTarget: (s as any).gTarget ?? fallbackGTarget,
  R_geom: (s as any).R_geom ?? fallbackRGeom,
  epsilonTilt: (s as any).epsilonTilt ?? fallbackEpsilonTilt,
  betaTiltVec: ((s as any).betaTiltVec ?? fallbackBetaTiltVec) as [number, number, number],
  gEff_check: (s as any).gEff_check ?? fallbackGEffCheck,
};
```

This way, **any** missing property falls back cleanly, even when `shift` is just `{}`.&#x20;

---

### While you’re here — wire the uniforms (already present)

Your WebGL engine already defines uniforms for the gentle interior-gravity tilt:

```js
this.uniforms = {
  // …
  epsilonTilt: 0.0,          // gentle tilt strength
  betaTiltVec: [0, -1, 0],   // “down” direction
};
```

So once the panel is populated correctly, you can also pass these through your visualizer’s `updateUniforms` call (it looks like you already do this), and then consume them inside the warp code path where you compute the displacement field. The uniforms exist and are ready to be used.&#x20;

---

### If the panel still shows blanks

* Confirm `ShiftVectorPanel` is receiving `mode` and `shift` props (even `{}` is fine after this patch).
* If you want **no** panel in true standby, keep your existing `ok` logic; otherwise set `ok = true` to always show computed values.

This small change should make the panel light up with:

* $g_{\text{target}}$ (e.g., `0.981 m/s²` for hover when you pick 0.1 g),
* $R_{\text{geom}}=\sqrt[3]{abc}$,
* $\varepsilon_{\text{tilt}} = g_{\text{target}} R_{\text{geom}}/c^2$,
* $\vec{\beta}_{\text{tilt}}$,
* $g_{\text{eff}}$ check.

If you want, I can also sketch the minimal changes needed in `WarpVisualizer.tsx` to forward `epsilonTilt` / `betaTiltVec` directly from metrics to the engine so the **gentle tilt** becomes visible in the bubble render.
