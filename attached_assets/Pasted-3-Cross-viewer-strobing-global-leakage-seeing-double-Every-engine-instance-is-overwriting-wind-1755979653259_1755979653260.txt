3) Cross-viewer strobing/global leakage (“seeing double”)

Every engine instance is overwriting window.setStrobingState. Your React layer builds a mux, but the second engine overwrites it again. Result: the latest engine “owns” the strobe; the other one may mirror it (or miss updates).

Patch

Make the engine register with a mux if it exists, or create one once if it doesn’t. Don’t clobber it per instance.

@@ constructor(canvas) {
-        // Expose strobing sync function globally
-        window.setStrobingState = ({ sectorCount, currentSector, split }) => {
-            try {
-                this.strobingState.sectorCount  = Math.max(1, sectorCount|0);
-                this.strobingState.currentSector= Math.max(0, currentSector|0) % this.strobingState.sectorCount;
-                this.updateUniforms({
-                  sectors: this.strobingState.sectorCount,
-                  split: Number.isFinite(split) ? Math.max(0, Math.min(this.strobingState.sectorCount-1, split|0)) : this.uniforms?.split
-                });
-            } catch (e) {
-                console.warn("WarpEngine.setStrobingState error:", e);
-            }
-        };
+        const strobeHandler = ({ sectorCount, currentSector, split }) => {
+          try {
+            this.strobingState.sectorCount   = Math.max(1, sectorCount|0);
+            this.strobingState.currentSector = Math.max(0, currentSector|0) % this.strobingState.sectorCount;
+            this.updateUniforms({
+              sectors: this.strobingState.sectorCount,
+              split: Number.isFinite(split) ? Math.max(0, Math.min(this.strobingState.sectorCount-1, split|0)) : this.uniforms?.split
+            });
+          } catch(e){ console.warn("WarpEngine strobe error:", e); }
+        };
+        if (typeof window.__addStrobingListener === 'function') {
+          this._offStrobe = window.__addStrobingListener(strobeHandler);
+        } else {
+          // create a mux once
+          const listeners = (window.__strobeListeners = new Set());
+          window.setStrobingState = payload => { for (const fn of listeners) { try{ fn(payload); }catch{} } };
+          window.__addStrobingListener = fn => { listeners.add(fn); return () => listeners.delete(fn); };
+          this._offStrobe = window.__addStrobingListener(strobeHandler);
+        }


…and in destroy():

-        delete window.setStrobingState;
+        try { this._offStrobe?.(); } catch {}


That guarantees each canvas reacts to strobe updates independently, and neither one overwrites the other.