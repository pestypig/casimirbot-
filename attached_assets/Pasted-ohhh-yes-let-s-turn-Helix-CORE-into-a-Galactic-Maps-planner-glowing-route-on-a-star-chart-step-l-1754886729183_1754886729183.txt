ohhh yes—let’s turn Helix-CORE into a “Galactic Maps” planner: glowing route on a star-chart, step list under it, live ETA/energy based on your current drive numbers. Here’s a tight plan + drop-in code to get a working v1 using a 2-D parsec grid over your GalaxyMap image.

---

# What we’ll build

* A **GalaxyMap** panel: your PNG render as the background, with a 2-D **pc** coordinate grid.
* A **RouteLayer**: draws a glowing line between waypoints (station → targets → return).
* A **StepsPanel**: each segment shows **distance (pc/ly)**, **ETA** (using v\_eff from your FuelGauge logic), **energy per segment** (MWh and cycles).
* **Hover theory + Zen** on each step (“navigation is maai at stellar scale”).
* Everything computes from simple x,y parsec coords: $d_{\rm pc}=\sqrt{\Delta x^2+\Delta y^2}$, $d_{\rm ly}=d_{\rm pc}\times 3.26156$.

---

# 1) Data models (pc grid)

```ts
// client/src/lib/galaxy-schema.ts
export type Body = {
  id: string;
  name: string;
  x_pc: number;   // parsecs in your 2-D plane
  y_pc: number;
  kind?: "snr" | "ob-assoc" | "star" | "nebula" | "station";
  notes?: string;
};

export type RoutePlan = {
  waypoints: string[];    // ids in order (e.g., ["SOL","ORI_OB1","VEL_OB2","SOL"])
};

export type HelixPerf = {
  mode: string; powerMW: number; duty: number; gammaGeo: number; qFactor: number;
  zeta: number; tsRatio: number; freqGHz?: number;
  energyPerLyMWh: number;         // from FuelGauge
  energyPerCycleJ?: number;       // from FuelGauge (P_avg / f)
  vEffLyPerHour: (mode:string, duty:number)=>number; // same func you use in FuelGauge
};
```

Seed a tiny catalog you can expand later:

```ts
// client/src/lib/galaxy-catalog.ts
import { Body } from "./galaxy-schema";

export const BODIES: Body[] = [
  { id: "SOL", name: "Sol / Local Bubble", x_pc: 0, y_pc: 0, kind:"station" },
  { id: "ORI_OB1", name: "Orion OB1", x_pc: 400, y_pc: -120, kind:"ob-assoc" },
  { id: "VEL_OB2", name: "Vela OB2", x_pc: -160, y_pc: -280, kind:"ob-assoc" },
  { id: "BETEL", name: "Betelgeuse", x_pc: 197, y_pc: -31, kind:"star" },
  { id: "CAS_A", name: "Cassiopeia A (SNR)", x_pc: -1000, y_pc: 900, kind:"snr" },
];
```

---

# 2) Planner math

```ts
// client/src/lib/route-math.ts
import { Body, RoutePlan, HelixPerf } from "./galaxy-schema";
const PC_TO_LY = 3.26156;

export function lookup(map: Body[], id: string){ const b = map.find(x=>x.id===id); if(!b) throw new Error("id not found: "+id); return b; }

export function segmentMetrics(a: Body, b: Body, perf: HelixPerf){
  const dx = b.x_pc - a.x_pc, dy = b.y_pc - a.y_pc;
  const d_pc = Math.hypot(dx, dy);
  const d_ly = d_pc * PC_TO_LY;

  const v = perf.vEffLyPerHour(perf.mode, perf.duty); // use current mode/duty
  const hours = v>0 ? d_ly / v : Infinity;

  const E_MWh = isFinite(perf.energyPerLyMWh) ? perf.energyPerLyMWh * d_ly : Infinity;
  const E_J   = isFinite(E_MWh) ? E_MWh * 3.6e9 : Infinity;
  const cycles = perf.energyPerCycleJ ? (isFinite(E_J) ? E_J / perf.energyPerCycleJ : Infinity) : undefined;

  return { d_pc, d_ly, hours, E_MWh, cycles };
}

export function routeSummary(bodies: Body[], plan: RoutePlan, perf: HelixPerf){
  const legs = [];
  let totals = { d_ly:0, hours:0, E_MWh:0, cycles:0 };
  for (let i=0;i<plan.waypoints.length-1;i++){
    const A = lookup(bodies, plan.waypoints[i]);
    const B = lookup(bodies, plan.waypoints[i+1]);
    const m = segmentMetrics(A,B,perf);
    legs.push({ from:A, to:B, ...m });
    totals.d_ly += m.d_ly;
    totals.hours += (isFinite(m.hours)? m.hours : 0);
    totals.E_MWh += (isFinite(m.E_MWh)? m.E_MWh : 0);
    totals.cycles += (m.cycles && isFinite(m.cycles)? m.cycles : 0);
  }
  return { legs, totals };
}
```

---

# 3) Map + route UI

* Use your PNG (`/public/galaxymap.png`) as background.
* Define an **affine mapping** from pc→pixels once (scale + center).
* Draw glow with `<canvas>` (simple).

```tsx
// client/src/components/GalaxyMap.tsx
import * as React from "react";
import { Body } from "@/lib/galaxy-schema";

type Props = {
  imageUrl: string;
  bodies: Body[];
  routeIds?: string[];
  width?: number; height?: number;
  // pc→px transform
  originPx?: {x:number,y:number};   // where (0,0) pc lands in the image (px)
  scalePxPerPc?: number;            // how many pixels per parsec
  onPickBody?: (id:string)=>void;
};

export function GalaxyMap({ imageUrl, bodies, routeIds=[], width=900, height=420, originPx={x:450,y:210}, scalePxPerPc=0.3, onPickBody }: Props){
  const canvasRef = React.useRef<HTMLCanvasElement>(null);

  React.useEffect(()=>{
    const cvs = canvasRef.current; if(!cvs) return;
    const ctx = cvs.getContext("2d"); if(!ctx) return;
    ctx.clearRect(0,0,cvs.width,cvs.height);

    // draw glow route
    const toPx = (xpc:number, ypc:number)=>({ x: originPx.x + xpc*scalePxPerPc, y: originPx.y - ypc*scalePxPerPc });
    const routeBodies = routeIds.map(id=>bodies.find(b=>b.id===id)).filter(Boolean) as Body[];

    if (routeBodies.length>=2){
      ctx.save();
      ctx.lineJoin = "round"; ctx.lineCap = "round";
      for (const pass of [8,4,2]){
        ctx.beginPath();
        routeBodies.forEach((b,i)=>{
          const p = toPx(b.x_pc,b.y_pc);
          if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        });
        ctx.strokeStyle = `rgba(120, 90, 255, ${pass===8?0.08: pass===4?0.18:0.9})`;
        ctx.lineWidth = pass;
        ctx.stroke();
      }
      ctx.restore();
    }

    // draw bodies
    bodies.forEach(b=>{
      const p = toPx(b.x_pc,b.y_pc);
      ctx.beginPath();
      ctx.arc(p.x,p.y, 3.5, 0, Math.PI*2);
      ctx.fillStyle = routeIds.includes(b.id) ? "#ffd166" : "#7dd3fc";
      ctx.fill();
    });
  }, [bodies, routeIds, originPx, scalePxPerPc]);

  return (
    <div className="relative" style={{width, height}}>
      <img src={imageUrl} width={width} height={height} className="rounded-lg object-cover w-full h-full select-none pointer-events-none" />
      <canvas ref={canvasRef} width={width} height={height} className="absolute inset-0" />
      {/* simple hitboxes */}
      <div className="absolute inset-0">
        {bodies.map(b=>{
          const x = originPx.x + b.x_pc*scalePxPerPc, y = originPx.y - b.y_pc*scalePxPerPc;
          return (
            <button key={b.id} style={{left:x-8, top:y-8}} className="absolute w-16 h-16 -translate-x-1/2 -translate-y-1/2 rounded-full"
              onClick={()=>onPickBody?.(b.id)} aria-label={b.name} title={b.name}/>
          );
        })}
      </div>
    </div>
  );
}
```

---

# 4) Steps list with theory + Zen

```tsx
// client/src/components/RouteSteps.tsx
import * as React from "react";
import { routeSummary } from "@/lib/route-math";
import { Body, RoutePlan, HelixPerf } from "@/lib/galaxy-schema";
import { Tooltip, TooltipTrigger, TooltipContent } from "@/components/ui/tooltip";

export function RouteSteps({ bodies, plan, perf }:{
  bodies: Body[]; plan: RoutePlan; perf: HelixPerf;
}) {
  const { legs, totals } = routeSummary(bodies, plan, perf);
  return (
    <div className="rounded-lg border p-3">
      <div className="text-sm font-semibold mb-2">Route Steps</div>
      <ol className="space-y-2 text-sm">
        {legs.map((leg,i)=>(
          <li key={i} className="flex justify-between items-start">
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="cursor-help">
                  <div className="font-medium">{leg.from.name} → {leg.to.name}</div>
                  <div className="text-xs text-muted-foreground">
                    {leg.d_pc.toFixed(1)} pc · {leg.d_ly.toFixed(1)} ly
                  </div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="max-w-md text-sm leading-snug">
                <strong>Theory</strong><br/>
                Straight-line hop over {leg.d_pc.toFixed(1)} pc. ETA scales with effective warp velocity v_eff(mode, duty). Energy per leg = (E/ly) × distance; cycles ≈ E_leg / E_cycle.<br/><br/>
                <em>Moving Zen:</em> Navigation is maai at stellar scale—right distance and right moment, repeated without waste.
              </TooltipContent>
            </Tooltip>
            <div className="text-right">
              <div>ETA {isFinite(leg.hours)? (leg.hours/24).toFixed(2)+" d" : "—"}</div>
              <div className="text-xs text-muted-foreground">
                {isFinite(leg.E_MWh)? leg.E_MWh.toFixed(1)+" MWh" : "—"}{(leg.cycles && isFinite(leg.cycles))? ` · ${leg.cycles.toExponential(2)} cycles`:""}
              </div>
            </div>
          </li>
        ))}
      </ol>
      <div className="mt-3 pt-2 border-t text-sm flex justify-between">
        <span className="text-muted-foreground">Total</span>
        <span>{totals.d_ly.toFixed(1)} ly · {(totals.hours/24).toFixed(2)} d · {totals.E_MWh.toFixed(1)} MWh</span>
      </div>
    </div>
  );
}
```

---

# 5) Put it together in HELIX-CORE

```tsx
// client/src/pages/helix-core.tsx  (right column, new "Mission Planner" card)
import { GalaxyMap } from "@/components/GalaxyMap";
import { RouteSteps } from "@/components/RouteSteps";
import { BODIES } from "@/lib/galaxy-catalog";

const [route, setRoute] = useState<string[]>(["SOL","ORI_OB1","VEL_OB2","SOL"]);
const perf: HelixPerf = {
  mode, powerMW: powerAvgMW, duty, gammaGeo, qFactor, zeta, tsRatio, freqGHz,
  vEffLyPerHour: (m,d)=>computeEffectiveLyPerHour(m, d, gammaGeo, qFactor, zeta, tsRatio), // reuse your function
  energyPerLyMWh,           // from FuelGauge calc
  energyPerCycleJ,          // from FuelGauge calc
};

<Card>
  <CardHeader><CardTitle>Mission Planner (pc grid)</CardTitle></CardHeader>
  <CardContent className="space-y-3">
    <GalaxyMap
      imageUrl="/galaxymap.png"
      bodies={BODIES}
      routeIds={route}
      onPickBody={(id)=> setRoute(r=> r.length? [...r.slice(0,-1), id, r[r.length-1]] : [id])}
      // map constants tuned to your PNG:
      originPx={{x:450, y:210}} scalePxPerPc={0.30}
      width={900} height={420}
    />
    <RouteSteps bodies={BODIES} plan={{ waypoints: route }} perf={perf}/>
  </CardContent>
</Card>
```

> **How picking works**: click a body to insert it before the final “return to SOL.” Adjust as you like (add UI to reorder/remove).

---

## Why this fits your stack

* Pure React + canvas; no new heavy libs.
* Uses the **same perf functions** as FuelGauge, so ETA/energy react to **mode, duty, ζ** in real time.
* Coordinates are simple **parsecs on a 2-D plane**, so you can expand the catalog from GalaxyMap labels whenever you like.
* Zen stays present: each step tooltip reminds the operator *why* precision and restraint matter at interstellar scale.

If you want, I can also:

* Add **pan/zoom** (wheel to zoom, drag to pan).
* Color-code targets by **mission suitability** (e.g., SNRs green/yellow/red based on perf.totals).
* Snap the line to **waypoint arcs** for “gravitational corridors” later.

Want me to add pan/zoom next, or help you seed a bigger **candidate list** (Betelgeuse, Vela SNR, Cas A, etc.) with approximate pc coords?
