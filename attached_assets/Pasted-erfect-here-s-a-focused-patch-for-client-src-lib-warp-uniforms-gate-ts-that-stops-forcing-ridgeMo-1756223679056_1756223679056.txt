erfect—here’s a focused patch for /client/src/lib/warp-uniforms-gate.ts that:

stops forcing ridgeMode=0 (lets REAL=0 / SHOW=1 flow from caller),

hardens the θ calculation with a safe default for dutyEffectiveFR,

preserves (or computes) cameraZ so the “CameraZ unset” check passes,

keeps viewAvg configurable (defaults to true if omitted),

enriches __warpEcho for the checkpoints panel.

--- a/client/src/lib/warp-uniforms-gate.ts
+++ b/client/src/lib/warp-uniforms-gate.ts
@@ -1,5 +1,6 @@
 export function applyToEngine(
   engine: { updateUniforms: (u: any) => void },
   uniforms: WarpUniforms
 ) {
   // Normalize uniform names to ensure both spellings exist
   const normalizedUniforms = { ...uniforms };
@@ -28,25 +29,71 @@
   } else {
     lastVersion = v;
     lastSrc = src;
   }
-  // Canonical θ if server didn't precompute
-  // Use visual-only γ_VdB to keep mass calibration away from theta calculations
-  const gammaVdB_vis = normalizedUniforms.gammaVanDenBroeck_vis ?? normalizedUniforms.gammaVanDenBroeck;
-  // Unify duty law with renderer: use sqrt(d_FR)
-  const θ = normalizedUniforms.thetaScale ?? (
-    Math.pow(normalizedUniforms.gammaGeo, 3) *
-    normalizedUniforms.qSpoilingFactor *
-    gammaVdB_vis *
-    Math.sqrt(normalizedUniforms.dutyEffectiveFR)
-  );
-  // Apply locked display settings - modes only change physics, not visuals
-  const lockedUniforms = {
-    ...normalizedUniforms,
-    thetaScale: θ,
-    ridgeMode: 0,
-    exposure: 5.0,
-    zeroStop: 1e-7,
-    colorMode: 'theta',
-    viewAvg: true,
-    // Always ensure viewMassFraction is available and defaulted
-    viewMassFraction: Number.isFinite(normalizedUniforms?.viewMassFraction) ? normalizedUniforms.viewMassFraction : 1.0,
-  };
-  // Debug echo (what we actually bind)
-  (window as any).__warpEcho = {
-    v, src: normalizedUniforms.__src, θ_used: θ,
-    terms: {
-      γ_geo: normalizedUniforms.gammaGeo,
-      q: normalizedUniforms.qSpoilingFactor,
-      γ_VdB: gammaVdB_vis,  // use visual version for debug display
-      γ_VdB_mass: normalizedUniforms.gammaVanDenBroeck_mass, // also show mass version  
-      d_FR: normalizedUniforms.dutyEffectiveFR,
-      sectors: { total: normalizedUniforms.sectorCount, live: normalizedUniforms.sectors }
-    }
-  };
-  engine.updateUniforms(lockedUniforms);
+  // ---- Canonical θ (renderer law √d_FR) with safe defaults -----------------
+  // visual-only γ_VdB to keep mass calibration away from renderer
+  const gammaVdB_vis =
+    (typeof normalizedUniforms.gammaVanDenBroeck_vis === 'number' && normalizedUniforms.gammaVanDenBroeck_vis) ??
+    (typeof normalizedUniforms.gammaVanDenBroeck === 'number' && normalizedUniforms.gammaVanDenBroeck) ??
+    (typeof normalizedUniforms.gammaVdB === 'number' && normalizedUniforms.gammaVdB) ?? 1;
+
+  const gammaGeo = Math.max(1, Number(normalizedUniforms.gammaGeo ?? 26));
+  const q = Math.max(1e-12, Number(
+    normalizedUniforms.qSpoilingFactor ?? normalizedUniforms.deltaAOverA ?? 1
+  ));
+
+  // FR duty guard: use provided value or compute 0.01 × (S_live / S_total)
+  const sectorsTotal = Math.max(1, Number(normalizedUniforms.sectorCount ?? 400));
+  const sectorsLive  = Math.max(1, Number(normalizedUniforms.sectors ?? 1));
+  const dutyLocal    = Number.isFinite(+normalizedUniforms.dutyLocal)
+    ? Math.max(1e-12, Number(normalizedUniforms.dutyLocal))
+    : 0.01;
+  const dutyFR = Math.max(
+    1e-12,
+    Number(normalizedUniforms.dutyEffectiveFR ??
+      (dutyLocal * (sectorsLive / sectorsTotal)))
+  );
+
+  const thetaFromChain =
+    Math.pow(gammaGeo, 3) * q * Math.max(1, Number(gammaVdB_vis)) * Math.sqrt(dutyFR);
+  const θ = Number.isFinite(+normalizedUniforms.thetaScale)
+    ? Number(normalizedUniforms.thetaScale)
+    : thetaFromChain;
+
+  // ---- Display locks (non-physics) ----------------------------------------
+  const viewAvg = (normalizedUniforms.viewAvg ?? true) ? true : false;
+  const exposure = Number.isFinite(+normalizedUniforms.exposure) ? +normalizedUniforms.exposure : 5.0;
+  const zeroStop = Number.isFinite(+normalizedUniforms.zeroStop) ? +normalizedUniforms.zeroStop : 1e-7;
+  const colorMode = normalizedUniforms.colorMode ?? 'theta';
+
+  // Respect caller’s ridgeMode; if absent, infer from parity (REAL→0, SHOW→1)
+  let ridgeMode = normalizedUniforms.ridgeMode;
+  if (ridgeMode == null && typeof normalizedUniforms.physicsParityMode === 'boolean') {
+    ridgeMode = normalizedUniforms.physicsParityMode ? 0 : 1;
+  }
+
+  // Ensure viewMassFraction always present
+  const viewMassFraction = Number.isFinite(+normalizedUniforms.viewMassFraction)
+    ? Number(normalizedUniforms.viewMassFraction)
+    : 1.0;
+
+  // CameraZ helper (prevents “CameraZ unset” warnings)
+  let cameraZ = normalizedUniforms.cameraZ as any;
+  let lockFraming = normalizedUniforms.lockFraming as any;
+  if (!Number.isFinite(cameraZ)) {
+    const ax = (normalizedUniforms as any).axesClip;
+    if (Array.isArray(ax) && ax.length === 3) {
+      const R = Math.max(1e-6, Math.max(ax[0]||0, ax[1]||0, ax[2]||0));
+      const fov = Math.PI / 3.2; // ~56°
+      cameraZ = (1.8 * R) / Math.tan(fov * 0.5);
+      lockFraming = true;
+    }
+  }
+
+  const lockedUniforms: any = {
+    ...normalizedUniforms,
+    thetaScale: θ,
+    dutyEffectiveFR: dutyFR,   // echo back the authoritative duty
+    exposure,
+    zeroStop,
+    colorMode,
+    viewAvg,
+    viewMassFraction,
+  };
+  if (ridgeMode != null) lockedUniforms.ridgeMode = ridgeMode;
+  if (Number.isFinite(cameraZ)) {
+    lockedUniforms.cameraZ = cameraZ;
+    lockedUniforms.lockFraming = (lockFraming ?? true);
+  }
+
+  // Debug echo (what we actually bind)
+  (window as any).__warpEcho = {
+    v, src: normalizedUniforms.__src, θ_used: θ,
+    terms: {
+      γ_geo: gammaGeo,
+      q,
+      γ_VdB: gammaVdB_vis,
+      γ_VdB_mass: normalizedUniforms.gammaVanDenBroeck_mass,
+      d_FR: dutyFR,
+      viewAvg,
+      viewMassFraction,
+      sectors: { total: sectorsTotal, live: sectorsLive }
+    }
+  };
+  engine.updateUniforms(lockedUniforms);
 }