Short answer: yes—your current fallback is sane, but you can make it even safer (and DRYer) by centralizing the “effective mode” once and re-using it everywhere.

### What you have now (works)

Inside the hero block you already do:

* `const mode = (pipeline?.currentMode ?? 'hover').toLowerCase();`
* pass `currentMode: pipeline?.currentMode || 'hover'` down to `<WarpVisualizer />`

That avoids the earlier `currentMode is not defined` error and gives a reasonable default.&#x20;

### Tiny hardening (recommended)

Define a single `effectiveMode` right after you fetch pipeline + metrics, then reuse it for:

* the hero `<WarpVisualizer/>`
* your quick mode buttons’ `isActive` check
* any other panels (samplers, outline viewer, etc.)

#### Patch (drop-in)

Paste this just after you compute `pipeline` and `systemMetrics`:

```ts
// Unified, defensive mode fallback for the whole page
const effectiveMode = (
  pipeline?.currentMode ??
  (systemMetrics as any)?.currentMode ??
  'hover'
) as 'standby' | 'hover' | 'cruise' | 'emergency';
```

Then replace scattered uses:

```tsx
// Quick mode buttons
const isActive = effectiveMode === m.key;

// Hero visualizer key + props
<WarpVisualizer
  key={`mode-${effectiveMode}-${pipeline?.sectorStrobing || 1}-${pipeline?.dutyCycle || 0.14}-v${modeVersion}`}
  parameters={{
    // ...
    currentMode: effectiveMode,
    // ...
  }}
/>
```

…and in the hero block where you compute tilt:

```ts
const mode = effectiveMode.toLowerCase();
```

This gives you one source of truth and guarantees a valid mode string even if the pipeline or metrics momentarily lag during refetch/invalidations. It also keeps the “force remount on mode change” key stable and readable.&#x20;

If you want an extra safeguard against any stray code paths, you can wrap the mode in a small normalizer:

```ts
const normalizeMode = (m?: string) =>
  (['standby','hover','cruise','emergency'] as const).includes((m||'').toLowerCase() as any)
    ? (m!.toLowerCase() as 'standby'|'hover'|'cruise'|'emergency')
    : 'hover';

const effectiveMode = normalizeMode(pipeline?.currentMode || (systemMetrics as any)?.currentMode);
```

That’s it—no behavior change, just fewer moving parts and no chance for `currentMode` to go missing mid-render.
