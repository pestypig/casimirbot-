// at top:
import { thetaCanonical } from "@/lib/warp-theta"; // <-- add

// replace sampleDisplacementField with:
const sampleDisplacementField = (x: number, y: number, z: number, u: any) => {
  // sane defaults that match physics path
  const hullAxes = Array.isArray(u.hullAxes) ? u.hullAxes : [1, 0.26, 0.17];
  const wallWidth = Number.isFinite(u.wallWidth) ? u.wallWidth : 0.06;

  // sectoring + duty
  const sectorsConcurrent = Math.max(1, (u.sectors ?? 1)|0);
  const sectorsTotal      = Math.max(1, (u.sectorCount ?? 400)|0);
  const dutyLocal         = Math.max(0, Number(u.dutyCycle ?? 0.01));

  // canonical θ (engine authority)
  const thetaScale = thetaCanonical({
    gammaGeo: Number(u.gammaGeo ?? 26),
    qSpoilingFactor: Number(u.qSpoilingFactor ?? u.deltaAOverA ?? 1),
    gammaVanDenBroeck_mass: Math.max(1, Math.min(1e2, Number(u.gammaVanDenBroeck_mass ?? u.gammaVdB ?? 38.3))),
    dutyLocal,
    sectorsConcurrent,
    sectorsTotal,
    viewAveraged: !!u.physicsParityMode,                      // REAL averages
    mode: (u.currentMode ?? 'hover') as 'standby'|'hover'|'cruise'|'emergency'
  });

  // make this visible to the inspector (so θ(shader) shows the same thing)
  u.thetaScale = thetaScale;

  // ellipsoidal radius (clip-space axes)
  const rho = Math.sqrt(
    (x / hullAxes[0]) ** 2 +
    (y / hullAxes[1]) ** 2 +
    (z / hullAxes[2]) ** 2
  );

  // canonical bell around ρ=1 with C² width ~wallWidth
  const sigma = Math.max(1e-6, wallWidth * 0.5);
  const bell  = Math.exp(-((rho - 1) ** 2) / (sigma * sigma));

  // REAL+standby must be flat
  if ((u.currentMode ?? 'hover') === 'standby' && !!u.physicsParityMode) {
    return { theta: 0, sign: 0, rho, displacement: 0 };
  }

  // local θ on the shell
  const theta = bell * thetaScale;

  // sign convention (compress inside vs expand outside is purely cosmetic here)
  const sign = rho < 1 ? -1 : 1;

  return { theta, sign, rho, displacement: theta * sign };
};

// (optional) after engineRef.current = { ... } creation, ensure we keep θ in sync
// inside engineRef.current.updateUniforms:
updateUniforms: (newUniforms: any) => {
  Object.assign(uniforms, newUniforms);
  // force recomputation of thetaScale on next frame by touching a flag if you like
}
