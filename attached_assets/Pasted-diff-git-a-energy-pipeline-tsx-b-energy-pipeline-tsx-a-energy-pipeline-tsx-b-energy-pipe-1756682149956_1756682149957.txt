diff --git a/energy-pipeline.tsx b/energy-pipeline.tsx
--- a/energy-pipeline.tsx
+++ b/energy-pipeline.tsx
@@ -1,7 +1,7 @@
 /**
  * Energy Pipeline Display Component (aligned with Helix-Core)
  * Shares pipeline mode + FR duty with the rest of the app
- * + Green's-function (φ = G * ρ) stage with live stats and publish-to-renderer
+ * + Green's-function (φ = G · ρ) stage with live stats and publish-to-renderer
  */
 
@@ -... +... @@
-  // 2) Use any available client tiles from metrics (fallback - main Green's data comes from HelixCore hook now)
-  const clientTiles = useMemo(() => {
-    // NOTE: old builds only emitted `tiles`
-    const tiles = (systemMetrics as any)?.tiles;
-    if (!Array.isArray(tiles)) return undefined;
-    return tiles.map((t: any) => ({
-      pos: t.pos as Vec3,
-      t00: t.t00 || 0
-    }));
-  }, [systemMetrics]);
+  // 2) Use any available client tiles from metrics (server now emits `tileData`, legacy was `tiles`)
+  const clientTiles = useMemo(() => {
+    const tiles =
+      (systemMetrics as any)?.tileData ||
+      (systemMetrics as any)?.tiles;
+    if (!Array.isArray(tiles)) return undefined;
+    return tiles.map((t: any) => ({
+      pos: t.pos as Vec3,
+      t00: t.t00 || 0,
+    }));
+  }, [systemMetrics]);
 
@@ -... +... @@
-  // Compute or adopt φ (server wins)
-  const greenPhi = useMemo(() => {
-    if (serverGreens?.phi && (serverGreens.phi as any).length > 0) {
-      const arr = serverGreens.phi instanceof Float32Array
-        ? serverGreens.phi
-        : new Float32Array(serverGreens.phi);
-      return { phi: arr, source: "server" as const };
-    }
-    return { phi: new Float32Array(0), source: "none" as const };
-  }, [serverGreens]);
+  // Compute or adopt φ (server-provided wins; else derive from tiles)
+  const greenPhi = useMemo(() => {
+    // 1) Adopt server φ if present
+    if (serverGreens?.phi && (serverGreens.phi as any).length > 0) {
+      const arr = serverGreens.phi instanceof Float32Array
+        ? serverGreens.phi
+        : new Float32Array(serverGreens.phi);
+      return { phi: arr, source: "server" as const };
+    }
+    // 2) Otherwise, compute φ = G · ρ from tiles on the client
+    if (clientTiles && clientTiles.length > 0) {
+      const positions: Vec3[] = clientTiles.map(t => t.pos);
+      const rho: number[]   = clientTiles.map(t => t.t00);
+      const kernel = (greenKind === "helmholtz")
+        ? helmholtzKernel(Math.max(0, mHelm))
+        : poissonKernel;
+      const phi = computeGreenPotential(positions, rho, kernel, normalizeGreens);
+      return { phi, source: "client" as const };
+    }
+    // 3) No data available
+    return { phi: new Float32Array(0), source: "none" as const };
+  }, [serverGreens, clientTiles, greenKind, mHelm, normalizeGreens]);
 
diff --git a/BridgeDerivationCards.tsx b/BridgeDerivationCards.tsx
--- a/BridgeDerivationCards.tsx
+++ b/BridgeDerivationCards.tsx
@@ -... +... @@
-              // Try to trigger a manual computation if we have metrics
-              const tiles = (m as any)?.tiles as { pos: [number, number, number]; t00: number }[] | undefined;
+              // Try to trigger a manual computation if we have metrics
+              // Read new shape first, then legacy for back-compat
+              const tiles = (m as any)?.tileData || (m as any)?.tiles as { pos: [number, number, number]; t00: number }[] | undefined;
               if (Array.isArray(tiles) && tiles.length > 0) {
                 const positions = tiles.map(t => t.pos);
                 const rho = tiles.map(t => t.t00);
                 const poissonG = (r: number) => 1 / (4 * Math.PI * Math.max(r, 1e-6));
                 const computePhi = (positions: [number, number, number][], rho: number[]) => {
                   /* … unchanged … */
                 };
                 const phi = computePhi(positions, rho);
                 const payload = {
                   kind: "poisson" as const,
                   m: 0,
                   normalize: true,
                   phi,
                   size: phi.length,
                   source: "client" as const
                 };
                 qc.setQueryData(["helix:pipeline:greens"], payload);
                 setGreens(payload);
                 window.dispatchEvent(new CustomEvent("helix:greens", { detail: payload }));
               }
 
diff --git a/use-energy-pipeline.ts b/use-energy-pipeline.ts
--- a/use-energy-pipeline.ts
+++ b/use-energy-pipeline.ts
@@ -80,6 +80,11 @@ export interface EnergyPipelineState {
   overallStatus: 'NOMINAL' | 'WARNING' | 'CRITICAL';
 }
 
+// Server emits per-tile stress–energy samples for φ = G · ρ
+export type TileDatum = {
+  pos: [number, number, number];
+  t00: number;
+};
 
 // Chat message interface for HELIX-CORE
 export interface ChatMessage {
@@ -88,16 +93,22 @@ export interface ChatMessage {
   timestamp: Date;
 }
 
-// System metrics interface
+// System metrics interface (add tile arrays for φ compute back-compat)
 export interface SystemMetrics {
   totalTiles: number;
   activeTiles: number;
   currentMode?: string;
+  tileData?: TileDatum[]; // current server shape
+  tiles?: TileDatum[];    // legacy shape
 }
 
-// Helix metrics interface
+// Helix metrics interface (some callers read directly from here)
 export interface HelixMetrics {
   totalTiles: number;
   activeTiles: number;
   data?: any;
+  tileData?: TileDatum[];
+  tiles?: TileDatum[];
 }
 
 // Shared physics constants from pipeline backend
