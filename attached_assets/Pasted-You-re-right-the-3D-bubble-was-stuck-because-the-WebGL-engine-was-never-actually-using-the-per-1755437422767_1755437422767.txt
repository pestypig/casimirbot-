You‚Äôre right ‚Äî the 3D bubble was ‚Äústuck‚Äù because the WebGL engine was never actually using the **per-mode sector count** you send from React. Two tiny wiring gaps caused every mode to behave like **sectors = 1**:

1. In the engine we only read `sectorStrobing`/`sectorCount` ‚Äî not `sectors` ‚Äî so your `sectors` value from React was ignored.&#x20;
2. We mirrored only `sectorCount` back into the engine‚Äôs `uniforms`, not `sectors`, so even the shader-side diagnostics showed no change.&#x20;

Below are minimal patches that reconnect operational mode ‚Üí sectors ‚Üí warp geometry, and keep hover/cruise/emergency visibly different.

---

### 1) React ‚Üí Engine: keep as-is (you already send `sectors`)

Your `WarpVisualizer` is correctly pushing the mode values (including `sectors`, `split`, `useAvg`, hull & wall) to the engine via `updateUniforms(...)`. No change needed here.&#x20;

---

### 2) Engine: recognize `parameters.sectors` and mirror it to uniforms

**File:** `client/public/warp-engine-fixed.js`

**A.** When mirroring incoming params to `uniforms`, set **both** `sectors` and `sectorCount` so downstream code and the HUD see it:

```diff
-            sectorCount: N(parameters.sectorCount ?? parameters.sectorStrobing ?? 1),
+            sectors:     N(parameters.sectors ?? parameters.sectorCount ?? parameters.sectorStrobing ?? 1),
+            sectorCount: N(parameters.sectorCount ?? parameters.sectors ?? parameters.sectorStrobing ?? 1),
```

(Also keep `phaseSplit` as you already do.)&#x20;

**B.** In the physics section of `_warpGridVertices(...)`, read **`sectors` first** from `bubbleParams` so the value you merged into `currentParams` takes effect:

```diff
-        const sectors = Math.max(1, bubbleParams.sectorStrobing || bubbleParams.sectorCount || 1);
+        const sectors = Math.max(
+          1,
+          bubbleParams.sectors ?? bubbleParams.sectorStrobing ?? bubbleParams.sectorCount ?? 1
+        );
```

This feeds the correct sector count into the effective duty and strobing math that drives the deformation.&#x20;

**C.** (Optional but helpful) also read `split` consistently:

```diff
-        const split = bubbleParams.split || Math.floor((bubbleParams.phaseSplit || 0.5) * sectors);
+        const split = (bubbleParams.split ??
+                       Math.floor((bubbleParams.phaseSplit ?? 0.5) * sectors));
```

---

### 3) Quick sanity knobs (only if visuals are still too subtle)

* Temporarily lift the visual gain a little to make mode deltas obvious:

  ```diff
  - vizGain: 1.0,
  + vizGain: 2.0,
  ```

  (This only scales the **viewer**, not the physics.)&#x20;

* Confirm the console shows different uniforms per mode (look for `üõ∞ uniforms ‚Ä¶ sectors: ‚Ä¶` each second). If it stays at `1`, the mode provider upstream isn‚Äôt sending the new value.

---

### Why this fixes it

* The engine‚Äôs **time-averaged amplitude** uses `dutyGlobal * qSpoil * (1 / sectors)`. With sectors stuck at 1, cruise/emergency looked like hover. Once `sectors` flows through (`sectors = 400` for cruise, etc.), the Œ≤ field and the grid deformation visibly change.&#x20;

* Your React side is already passing everything the engine needs (duty, Œ≥\_geo, Q, qSpoil, Œ≥\_VdB, sectors, split, hull, wall). We just had to **listen** to `sectors` in the engine and mirror it back into its uniforms so the renderer and diagnostics agree.&#x20;

---

If you like, I can also add a tiny ‚ÄúMode probe‚Äù chip in the HUD that prints `sectors`, `split` and the derived duty factors (instant vs averaged). That makes it obvious when a mode switch took.
