diff --git a/client/public/warp-engine.js b/client/public/warp-engine.js
new file mode 100644
--- /dev/null
+++ b/client/public/warp-engine.js
@@
+/* global window */
+// Minimal, robust global WarpEngine with singleton getOrCreate and helper APIs
+// This file is loaded as a <script> from /public, so attach to window.
+(function () {
+  // Reuse existing class if present; we'll augment it with missing helpers.
+  var Existing = (typeof window !== "undefined" && window.WarpEngine) || null;
+  var __INSTANCES = new WeakMap(); // canvas -> engine
+
+  function isFn(f) { return typeof f === "function"; }
+
+  class WarpEngine {
+    static getOrCreate(canvas) {
+      if (!canvas) throw new Error("WarpEngine.getOrCreate: canvas is required");
+      var eng = __INSTANCES.get(canvas);
+      if (eng) return eng;
+      eng = new WarpEngine(canvas);
+      __INSTANCES.set(canvas, eng);
+      return eng;
+    }
+    constructor(canvas) {
+      this.canvas = canvas;
+      this.gl =
+        (canvas && (canvas.getContext("webgl2") || canvas.getContext("webgl"))) ||
+        null;
+      if (!this.gl) throw new Error("WarpEngine: WebGL not available");
+      this.uniforms = {};
+      this._ready = false;
+      this._error = null;
+      this._readyCbs = new Set();
+      // Simulate async shader/program init; call _markReady() once shader setup completes in your real engine
+      var self = this;
+      requestAnimationFrame(function () { self._markReady(); });
+    }
+    _markReady() {
+      if (this._ready) return;
+      this._ready = true;
+      this._readyCbs.forEach((cb) => { try { cb(this); } catch(_) {} });
+      this._readyCbs.clear();
+    }
+    // ---- helper surface expected by React components -----------------------
+    isLoaded() { return !!this._ready; }
+    onceReady(cb) {
+      if (!isFn(cb)) return function noop(){};
+      if (this._ready) { try { cb(this); } catch(_) {} ; return function(){}; }
+      this._readyCbs.add(cb);
+      var setRef = this._readyCbs;
+      return function unsubscribe(){ setRef.delete(cb); };
+    }
+    getLoadingState() {
+      return { ready: this._ready, error: this._error, hasGL: !!this.gl };
+    }
+    getShaderStatus() {
+      // If you have real programs, report them here; placeholders for safety:
+      return { programs: { grid: !!this.gridProgram, shell: !!this.shellProgram }, lastCompileError: this._shaderError || null };
+    }
+    updateUniforms(patch) {
+      if (!patch || typeof patch !== "object") return;
+      Object.assign(this.uniforms, patch);
+      this.requestRewarp();
+    }
+    requestRewarp() {
+      try { this._render && this._render(); } catch(e) { this._error = e; }
+    }
+    getCanvas() { return this.canvas; }
+    getGL() { return this.gl; }
+    setDebugTag(tag) { this.__debugTag = String(tag || ""); }
+    destroy() {
+      try {
+        this._readyCbs && this._readyCbs.clear();
+        // TODO: delete GL resources if you track them
+      } catch(_) {}
+      __INSTANCES.delete(this.canvas);
+      this.canvas = null; this.gl = null;
+    }
+    // ---- placeholder draw (replace with real renderer) ----------------------
+    _render() {
+      if (!this.gl) return;
+      var gl = this.gl;
+      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
+      gl.clearColor(0.02, 0.02, 0.05, 1);
+      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+    }
+  }
+
+  // If an older global exists, augment it with helpers and getOrCreate.
+  var Final = Existing || WarpEngine;
+  if (!isFn(Final.getOrCreate)) {
+    // graft singleton map onto the existing class
+    Final.getOrCreate = function(canvas){
+      if (!canvas) throw new Error("WarpEngine.getOrCreate: canvas is required");
+      var eng = __INSTANCES.get(canvas);
+      if (!eng) { eng = new Final(canvas); __INSTANCES.set(canvas, eng); }
+      return eng;
+    };
+  }
+  // Ensure helper methods exist (no-ops if missing)
+  ["isLoaded","onceReady","getLoadingState","getShaderStatus","updateUniforms","requestRewarp","getCanvas","getGL","setDebugTag","destroy"].forEach(function(k){
+    if (!isFn(Final.prototype[k])) { Final.prototype[k] = WarpEngine.prototype[k]; }
+  });
+
+  try { window.WarpEngine = Final; } catch(_) {}
+})();
diff --git a/client/src/components/WarpEngineContainer.tsx b/client/src/components/WarpEngineContainer.tsx
--- a/client/src/components/WarpEngineContainer.tsx
+++ b/client/src/components/WarpEngineContainer.tsx
@@
-import React, { useEffect, useRef } from "react";
+import React, { useEffect, useRef, useState } from "react";
@@
-export default function WarpEngineContainer(props: { className?: string }) {
-  const canvasRef = useRef<HTMLCanvasElement | null>(null);
-  const engineRef = useRef<any>(null);
-  useEffect(() => {
-    const canvas = canvasRef.current!;
-    const eng = (window as any).WarpEngine.getOrCreate(canvas);
-    engineRef.current = eng;
-    return () => { eng?.destroy?.(); };
-  }, []);
-  return <canvas ref={canvasRef} className={props.className} />;
-}
+export default function WarpEngineContainer(props: { className?: string }) {
+  const canvasRef = useRef<HTMLCanvasElement | null>(null);
+  const engineRef = useRef<any>(null);
+  const [status, setStatus] = useState<"idle"|"loading"|"ready"|"error">("idle");
+  const [err, setErr] = useState<string | null>(null);
+
+  useEffect(() => {
+    let cancelled = false;
+    let retries = 0;
+    let timer: any = null;
+
+    function step() {
+      if (cancelled) return;
+      const W: any = (window as any).WarpEngine;
+      const cvs = canvasRef.current;
+      if (!cvs) { timer = setTimeout(step, 50); return; }
+      if (!W || typeof W.getOrCreate !== "function") {
+        // Wait for script load; retry a bit longer on cold loads
+        if (retries++ < 200) { setStatus("loading"); timer = setTimeout(step, 50); return; }
+        setStatus("error"); setErr("WarpEngine script not loaded"); return;
+      }
+      try {
+        const eng = W.getOrCreate(cvs);
+        engineRef.current = eng;
+        setStatus(eng.isLoaded?.() ? "ready" : "loading");
+        // Subscribe to ready
+        const unsub = eng.onceReady?.(() => {
+          if (cancelled) return;
+          setStatus("ready");
+          try { eng.requestRewarp?.(); } catch(_) {}
+        });
+        // Initial draw attempt
+        try { eng.requestRewarp?.(); } catch(_) {}
+        // Cleanup
+        return () => { unsub && unsub(); };
+      } catch (e: any) {
+        setStatus("error"); setErr(e?.message || String(e));
+      }
+    }
+    const cleanup = step();
+    return () => {
+      cancelled = true;
+      if (timer) clearTimeout(timer);
+      try { engineRef.current?.destroy?.(); } catch(_) {}
+    };
+  }, []);
+
+  if (status === "error") {
+    return (
+      <div className={"flex items-center justify-center " + (props.className||"")}>
+        <div className="text-red-400 text-sm font-mono">
+          WarpEngine error: {err}
+        </div>
+      </div>
+    );
+  }
+  return <canvas ref={canvasRef} className={props.className} />;
+}