Patch (replace the old file with this)
/**
 * Stress–Energy (pipeline-true) for Van den Broeck–Natário flow
 * No magic constants; reads γ_geo, Q, q_spoil, γ_VdB, duty from pipeline.
 */

import { PHYSICS_CONSTANTS } from '../core/physics-constants.js';

const G = 6.67430e-11; // m^3 kg^-1 s^-2

// ---------- Casimir baseline (volume energy density) ----------
/** ρ₀(a) = −π² ħ c / (720 a⁴)  (J/m³), a in meters */
export function casimirEnergyDensity(a_m: number): number {
  const a = Math.max(1e-12, a_m);
  const hbar_c = PHYSICS_CONSTANTS.HBAR_C; // J·m
  return -(Math.PI ** 2) * hbar_c / (720 * a ** 4);
}

// ---------- Pipeline amplification chain ----------
/** A_inst = (γ_geo)^3 · √(Q/1e9) · γ_VdB · q_spoil  (dimensionless) */
export function amplificationFromPipeline({
  gammaGeo = 26,
  cavityQ = 1e9,
  gammaVanDenBroeck = 3.83e1,
  qSpoilingFactor = 1
}: {
  gammaGeo?: number;
  cavityQ?: number;
  gammaVanDenBroeck?: number;
  qSpoilingFactor?: number;
}): number {
  const A_geo = Math.max(1, gammaGeo) ** 3;
  const qGain = Math.sqrt(Math.max(1, cavityQ) / 1e9);
  const vdb  = Math.max(1, gammaVanDenBroeck);
  const qsp  = Math.max(1e-6, qSpoilingFactor);
  return A_geo * qGain * vdb * qsp;
}

/** Resolve FR-consistent average duty d_eff */
export function resolveDutyEff({
  dutyCycle,
  sectorStrobing,
  burst_ms,
  dwell_ms,
  dutyEffectiveFR
}: {
  dutyCycle?: number;
  sectorStrobing?: number;
  burst_ms?: number;
  dwell_ms?: number;
  dutyEffectiveFR?: number;
}): number {
  if (Number.isFinite(dutyEffectiveFR)) {
    return clamp01(dutyEffectiveFR as number);
  }
  if (Number.isFinite(burst_ms) && Number.isFinite(dwell_ms) && (dwell_ms as number) > 0) {
    return clamp01((burst_ms as number) / (dwell_ms as number));
  }
  const d = clamp01(Number(dutyCycle) || 0);
  const S = Math.max(1, Math.floor(Number(sectorStrobing) || 1));
  return clamp01(d / S);
}

const clamp01 = (x: number)=> Math.max(0, Math.min(1, x));

// ---------- Average energy density (used by Tμν and β) ----------
/**
 * ρ_avg = ρ₀(a) · A_inst · d_eff
 * (Use this if you want time-averaged Tμν; for instantaneous, drop d_eff.)
 */
export function enhancedAvgEnergyDensity({
  gap_m,
  gammaGeo,
  cavityQ,
  gammaVanDenBroeck,
  qSpoilingFactor,
  dutyEff
}: {
  gap_m: number;
  gammaGeo: number;
  cavityQ: number;
  gammaVanDenBroeck: number;
  qSpoilingFactor: number;
  dutyEff: number;
}): number {
  const rho0 = casimirEnergyDensity(gap_m);          // negative
  const A    = amplificationFromPipeline({ gammaGeo, cavityQ, gammaVanDenBroeck, qSpoilingFactor });
  return rho0 * A * clamp01(dutyEff);                // stays negative
}

// ---------- Stress–energy tensor (perfect-fluid proxy, w = −1) ----------
export function stressEnergyFromDensity(rho_J_per_m3: number) {
  // T00 = ρ ; Tij = −ρ δij
  return {
    T00: rho_J_per_m3,
    T11: -rho_J_per_m3,
    T22: -rho_J_per_m3,
    T33: -rho_J_per_m3,
  };
}

// ---------- Natário shift amplitude β_avg ----------
/**
 * β_avg ≈ √(8πG |ρ_avg| / c²) · R_geom
 * (We already used d_eff in ρ_avg, so do NOT apply √duty again here.)
 */
export function natarioShiftFromDensity(rho_avg: number, R_geom_m: number): number {
  const c2 = PHYSICS_CONSTANTS.C * PHYSICS_CONSTANTS.C;
  const pref = Math.sqrt((8 * Math.PI * G * Math.abs(rho_avg)) / c2);
  return pref * Math.max(1e-9, R_geom_m);
}

// ---------- One-shot adapter the pipeline can call ----------
/**
 * Produce time-averaged Tμν and β from the pipeline snapshot.
 * This is the entry you wire into energy-pipeline.ts.
 */
export function toPipelineStressEnergy(p: {
  gap_nm: number;
  gammaGeo: number;
  cavityQ: number;
  gammaVanDenBroeck: number;
  qSpoilingFactor: number;
  dutyCycle?: number;
  sectorStrobing?: number;
  dutyEffectiveFR?: number;
  lightCrossing?: { burst_ms?: number; dwell_ms?: number };
  R_geom_m?: number;               // ~ (abc)^(1/3) in meters
}) {
  const gap_m = Math.max(1e-12, (p.gap_nm ?? 1) * PHYSICS_CONSTANTS.NM_TO_M);
  const d_eff = resolveDutyEff({
    dutyCycle: p.dutyCycle,
    sectorStrobing: p.sectorStrobing,
    dutyEffectiveFR: p.dutyEffectiveFR,
    burst_ms: p.lightCrossing?.burst_ms,
    dwell_ms: p.lightCrossing?.dwell_ms
  });

  const rho_avg = enhancedAvgEnergyDensity({
    gap_m,
    gammaGeo: p.gammaGeo ?? 26,
    cavityQ: p.cavityQ ?? 1e9,
    gammaVanDenBroeck: p.gammaVanDenBroeck ?? 3.83e1,
    qSpoilingFactor: p.qSpoilingFactor ?? 1,
    dutyEff: d_eff
  });

  const T = stressEnergyFromDensity(rho_avg);
  const Rg = Math.max(1e-3, p.R_geom_m ?? 1); // be defensive
  const beta_avg = natarioShiftFromDensity(rho_avg, Rg);

  return { ...T, beta_avg, rho_avg, dutyEff: d_eff };
}