Short answer: yes—done the way I proposed (swapping only color CSS variables), the reskin is very safe and won’t change fonts, spacing, or layout. It’s just paint. If you want extra guardrails, here’s how to make it bullet-proof:

Why it’s safe
	•	No typography overrides. We never set font-family, font-size, line-height, or headings. Your title fonts remain exactly as they are.
	•	No layout overrides. We don’t touch margins, gaps, grids, or component structure.
	•	Scoped variables. We can scope the theme to a wrapper element so variables don’t leak globally.
	•	Session-only. It uses sessionStorage; a refresh resets to the same look, but nothing is persisted across browser sessions.
	•	Fail-safe defaults. If a variable is missing, the app falls back to the defaults you already have.

Extra-safe version (scoped & SSR-friendly)

1) Wrap your app in a scoped container instead of :root

// App.tsx (or your top-level layout)
import { ThemeProvider } from "@/context/ThemeProvider";

export default function App() {
  return (
    <ThemeProvider>
      {/* The theme is applied to this wrapper only */}
      <div id="theme-scope" className="min-h-screen">
        {/* your router/pages */}
      </div>
    </ThemeProvider>
  );
}

2) Apply variables to the scoped node (not document root)

// context/ThemeProvider.tsx
function applyVarsToScope(p: MissionProfile) {
  const scope = document.getElementById("theme-scope");
  if (!scope) return;
  scope.style.setProperty("--bg", p.colors.bg);
  scope.style.setProperty("--panel", p.colors.panel);
  scope.style.setProperty("--panelAlt", p.colors.panelAlt);
  scope.style.setProperty("--text", p.colors.text);
  scope.style.setProperty("--accent", p.colors.accent);
  scope.style.setProperty("--accentSoft", p.colors.accentSoft);
}

…and in the effect:

React.useEffect(() => applyVarsToScope(profile), [profile]);

3) Default variables + no font changes

/* globals.css */

/* Defaults if theme vars aren’t set */
#theme-scope{
  --bg:#0b1220;
  --panel:#111a2e;
  --panelAlt:#0d1627;
  --text:#e6f2ff;
  --accent:#ffd166;
  --accentSoft:rgba(255,209,102,.25);
}

/* Utilities – these only read colors */
.theme-bg       { background: var(--bg); }
.theme-panel    { background: var(--panel); }
.theme-panelAlt { background: var(--panelAlt); }
.theme-text     { color: var(--text); }
.theme-chip     { background: var(--accentSoft); }

/* Keep your existing font stack untouched */
body { font-family: var(--app-font, system-ui, Segoe UI, Roboto, sans-serif); }
h1,h2,h3,h4,h5,h6 { font-weight: inherit; }  /* don’t override heading sizes */

4) Use the scoped utilities on top wrappers only

// Example panel
<section className="theme-panel rounded-xl p-4">
  <h2 className="text-xl font-semibold theme-text">Energy Control Panel</h2>
  {/* ... */}
</section>

Quick rollback & feature flag
	•	Add a kill switch: ?theme=off → don’t apply session profile (just skip applyVarsToScope).
	•	If sessionStorage is unavailable (SSR/hardened browser), the provider just uses defaults.

“Will it break headings?”

It can’t, unless you explicitly change fonts in the theme (we don’t). Headings keep their current styles. If you want to be extra sure, you can “lock” title classes once:

/* lock your panel titles via utility class used in your panels */
.panel-title { font-family: var(--title-font, inherit); font-weight: 600; }

Smoke-test checklist (1 minute)
	1.	Load Helix-Core and flip profiles: titles, tabs, and buttons should keep their sizes and fonts.
	2.	Open the Amplification Chain and Metric HUD: bars and chips should recolor, numbers unchanged.
	3.	Toggle dark/light dev tools color contrast: ensure AA contrast (accent vs panel).

If any specific panel looks off, it’ll be a local style collision, not the theme engine. In that case, target that panel with a small fix (usually a missing theme-text or a bespoke background).

If you’d like, I can scan your current Helix-Core page structure and point out the 3–4 wrapper nodes where adding theme-bg / theme-panel yields the best result with zero impact elsewhere.