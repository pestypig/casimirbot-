You’re right—the big deltas are coming from two method mismatches with the papers:

1. we treated `sectorStrobing` as “simultaneously-active sectors,” and
2. we left a non-paper mechanical boost sitting in the stored-energy chain.

# What the papers actually do (and where our code diverged)

* **Time slicing:** Only **one** wedge of the 400 runs at any instant; ship-wide duty is always
  $d_\text{eff}=d/S=0.01/400=2.5\times10^{-5}$. The 400-wedge schedule is sequential, not concurrent. &#x20;

* **Power path:** Per-tile instantaneous dissipation uses the burst Q and the *burst* window; the **time average** comes from the duty/strobing scheme (and any Q-spoil schedule if you include it). There’s no separate “mechanical Q gain” multiplying stored energy in the paper’s power derivation.&#x20;

* **Mass path:** The negative energy density picks up the geometric cube and the burst Q in the *Casimir* term, and the **ship-wide duty** divides the mean (that’s where the $d/S$ enters). The Van-den-Broeck seed factor is a **mass-only** knob.  &#x20;

Those three facts are enough to fix the overshoot: we must (i) make the active fraction be $1/400$ at all times, (ii) default **qMechanical = 1** in the physics core (no extra gain), and (iii) leave **γ\_VdB** only in the mass chain.

Below is a tight patch that does exactly that and—optionally—adds the two single-line calibrations you suggested (power via `qMechanical`, mass via `γ_VdB`) behind a flag so “raw” stays raw.

---

## Minimal patch

```diff
 // ── Paper-backed constants (module scope)
 const TOTAL_SECTORS    = 400;
 const BURST_DUTY_LOCAL = 0.01;  // 10 µs / 1 ms
 const Q_BURST          = 1e9;   // active-window Q
-const GAMMA_VDB        = 1e11;  // fixed seed
+const GAMMA_VDB        = 1e11;  // paper seed (mass-only)
 const RADIAL_LAYERS    = 10;    // surface × radial lattice

 // Model mode: force to raw physics (no calibration)
 const MODEL_MODE: 'calibrated' | 'raw' = 'raw';
@@
 export function initializePipelineState(): EnergyPipelineState {
   return {
@@
-    // Mode defaults (hover)
+    // Mode defaults (hover)
     currentMode: 'hover',
     dutyCycle: 0.14,
-    sectorStrobing: 1,
+    // In the paper S=400 is the partition count for *all* modes.
+    // Only one wedge is live at any instant (see duty calc below).
+    sectorStrobing: 400,
@@
-    qMechanical: 5e4,
+    // Paper core has no extra mechanical "gain" in stored energy.
+    qMechanical: 1,
@@
 export function calculateEnergyPipeline(state: EnergyPipelineState): EnergyPipelineState {
@@
   // Step 2: Geometric amplification (γ × U_static, not γ³)
   state.U_geo = state.U_static * state.gammaGeo;
 
-  // Step 3: Q-enhancement
-  state.U_Q = state.U_geo * state.qMechanical;
+  // Step 3: Stored-energy (paper core): no extra mechanical gain.
+  // Keep qMechanical as a *calibration* knob only (optional, below).
+  state.U_Q = state.U_geo;
@@
   // Step 4: Apply mode configuration
   const modeConfig = MODE_CONFIGS[state.currentMode];
   state.dutyCycle = modeConfig.dutyCycle;
-  state.sectorStrobing = modeConfig.sectorStrobing;
+  // sectorStrobing remains the *partition count* S=400 per paper
+  state.sectorStrobing = TOTAL_SECTORS;
   state.qSpoilingFactor = modeConfig.qSpoilingFactor;
@@
-  // Step 6: Sector fraction & effective duty (define once, early)
-  const S_active     = Math.max(1, Math.round(state.sectorStrobing ?? 1));
-  const frac_active  = Math.min(1, S_active / TOTAL_SECTORS);   // e.g., 1/400 in hover, 1.0 in cruise
-  const tilesPerSect = Math.floor(state.N_tiles / TOTAL_SECTORS);
+  // Step 6: One-live-of-400 schedule at any instant (paper method).
+  const S             = TOTAL_SECTORS;
+  const S_instant     = 1; // (zero-β hover variant can set 2)
+  const frac_active   = S_instant / S;         // always 1/400
+  const tilesPerSect  = Math.floor(state.N_tiles / S);
 
-  state.activeSectors  = S_active;
+  state.activeSectors  = S_instant;
   state.activeFraction = frac_active;
   state.tilesPerSector = tilesPerSect;
-  state.activeTiles    = tilesPerSect * S_active;
+  state.activeTiles    = tilesPerSect * S_instant;
 
   // Ship-wide effective duty is the LOCAL burst duty times active sector fraction
   const d_eff = BURST_DUTY_LOCAL * frac_active;  // 0.01/400 = 2.5e-5
   state.dutyEff = d_eff;
@@
-  const U_geo     = state.U_geo;                            // = γ_geo · U_static
-  const U_Q_store = Math.abs(state.U_Q ?? U_geo * state.qMechanical);
-  // Per-tile dissipation during ON-window (ignore idle Q in raw physics)
-  const P_loss_per_tile_raw = U_Q_store * omega / Q_BURST;
+  const U_geo     = state.U_geo;                  // = γ_geo · U_static
+  const U_Q_store = Math.abs(state.U_Q);          // no mech gain in raw core
+  // Per-tile dissipation during the 10 μs ON-window
+  const P_loss_per_tile_raw = U_Q_store * omega / Q_BURST;
   // Ship-average: only a fraction of tiles are live, and only during d_eff
   const P_total_W = P_loss_per_tile_raw * state.N_tiles * d_eff;
@@
-  state.P_avg      = P_total_W / 1e6;   // MW (physics-first)
+  state.P_avg      = P_total_W / 1e6;   // MW (paper method)
 
-  // Optional cruise mode power calibration (dial qMechanical to hit 7.4 MW target)
-  if (state.currentMode === 'cruise' && process.env.CRUISE_CALIBRATION === '1') {
+  // Optional cruise power calibration (paper targets via your two knobs)
+  if (state.currentMode === 'cruise' && process.env.CRUISE_CALIBRATION === '1') {
     const P_target_W = 7.4e6;            // 7.4 MW target
     const scale = P_target_W / (P_total_W || 1e-30);
-    state.qMechanical *= scale;          // adjust mechanical Q
-    // recompute with updated qMechanical
-    state.U_Q       = state.U_geo * state.qMechanical;
-    state.P_avg     = P_target_W / 1e6;  // ≃7.4 MW
+    state.qMechanical *= scale;          // knob #1: power only
+    state.U_Q        = state.U_geo * state.qMechanical;
+    const P_tile_cal = Math.abs(state.U_Q) * omega / Q_BURST;
+    state.P_avg      = (P_tile_cal * state.N_tiles * d_eff) / 1e6;
     console.log("[CRUISE CALIBRATION] qMechanical scaled by", scale.toExponential(3), "→", state.qMechanical.toExponential(3));
   }
@@
-  const E_enh   = U_abs * geo3 * Q_BURST * state.gammaVanDenBroeck * d_eff; // J per tile (avg)
+  // Mass path (paper): γ_geo^3 and Q enter the Casimir term; duty d/S enters as the time-average.
+  const E_enh   = U_abs * geo3 * Q_BURST * state.gammaVanDenBroeck * d_eff; // J per tile (avg)
   const m_tile  = E_enh / (C * C);
   const M_total = m_tile * state.N_tiles;
@@
-  // Optional cruise mode mass calibration (dial γ_VdB to hit 1405 kg target)
-  if (state.currentMode === 'cruise' && process.env.CRUISE_CALIBRATION === '1') {
+  // Optional cruise mass calibration (paper target 1 405 kg)
+  if (state.currentMode === 'cruise' && process.env.CRUISE_CALIBRATION === '1') {
     const M_target = 1405;                            // 1.405×10³ kg target
     const scaleVD  = M_target / (state.M_exotic_raw || 1e-30);
-    state.gammaVanDenBroeck *= scaleVD;                // adjust Van-den-Broeck boost
+    state.gammaVanDenBroeck *= scaleVD;               // knob #2: mass only
     // recompute with updated γ_VdB
     const E_enh_cal = U_abs * geo3 * Q_BURST * state.gammaVanDenBroeck * d_eff;
     state.M_exotic_raw = Math.max(0, E_enh_cal / (C * C) * state.N_tiles);
     state.M_exotic     = state.M_exotic_raw;
     console.log("[CRUISE CALIBRATION] γ_VdB scaled by", scaleVD.toExponential(3), "→", state.gammaVanDenBroeck.toExponential(3));
   }
@@
-  // ----- Ford–Roman proxy with time-sliced strobing -----
-  const Q_quantum = 1e12; // tighter sampling Q if you want ζ <= 0.05
-  state.zeta = 1 / (state.dutyEff * Math.sqrt(Q_quantum)); // dutyEff = 0.01 * frac_active
+  // ----- Ford–Roman proxy with time-sliced strobing -----
+  const Q_quantum = 1e12; // paper's tight sampling scale
+  state.zeta = 1 / (d_eff * Math.sqrt(Q_quantum)); // uses d/S by construction
   state.fordRomanCompliance = state.zeta < 1.0;
```

### Why these changes fix the overshoot

* **Ship-wide duty**: Using $d_\text{eff} = d/S$ (one-live-of-400) knocks both **power** and **mass** down by 400× compared to our “400 at once” interpretation. That matches the sector-wedge protocol and the time-averaging argument used in the papers. &#x20;

* **Power-only knob (qMechanical)**: With the mechanical “boost” removed from the physics core (default `1`), the raw power lines up with the paper’s derivation. If you *want* the cruise panel to read **7.4 MW** exactly, the one-liner `qMechanical *= P_target/P_raw` is the right (and only) place to do it—because the paper’s mass budget doesn’t depend on this factor.&#x20;

* **Mass-only knob (γ\_VdB)**: The Van-den-Broeck pocket factor multiplies the exotic-mass chain (after γ\_geo³ and Q) and is independent of the RF dissipation bookkeeping. If you need the cruise total to pin **1 405 kg**, scale **γ\_VdB** by $M_\text{target}/M_\text{raw}$ and recompute—no collateral effects on the power. &#x20;

---

### Notes you might care about later

* If you want to mirror the paper’s **Q-spoil** bookkeeping in the power path, wire an optional `F_Q` factor (paper lists values and explains it bundles strobing + throttle). Keep it *off* by default to preserve raw physics; enable it per-mode if you need to match a figure caption exactly.&#x20;

* Hover’s “zero-β” variant can run a **phase split** (two equal ±β domains); to model that, set `S_instant = 2` in hover. The mean still follows the $d/S$ logic the paper uses; the split just affects the instantaneous β bookkeeping while keeping the time-average consistent.&#x20;

If you want, I can also add the tiny `F_Q` switch and a `phaseSplit` flag in `MODE_CONFIGS` so the Bridge can flip them explicitly.
