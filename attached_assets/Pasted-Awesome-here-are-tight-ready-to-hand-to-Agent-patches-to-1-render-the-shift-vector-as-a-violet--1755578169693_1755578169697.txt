Awesome — here are tight, ready-to-hand-to-Agent patches to (1) render the shift-vector as a violet arrow inside the bubble and (2) add a matching legend entry in the Shift Vector panel.

⸻

Patch 1 — client/public/warp-engine-fixed.js

Adds a u_shiftVectorColor uniform, draws a single THREE.ArrowHelper aligned with betaTiltVec, and scales its length with epsilonTilt. Safe if uniforms are missing (uses defaults).

*** a/client/public/warp-engine-fixed.js
--- b/client/public/warp-engine-fixed.js
@@
   constructor(container, options = {}) {
     super();
     this.container = container;
     this.options = options || {};
@@
-    this.uniforms = Object.assign({
+    this.uniforms = Object.assign({
       dutyCycle: 0.14,
       gammaGeo: 26,
       Qburst: 1e9,
       deltaAOverA: 1.0,
       gammaVdB: 2.86e5,
       hullAxes: [503.5, 132, 86.5],
       wallWidth: 0.06,
       currentMode: 'hover',
       sectors: 1,
       split: 0.5,
+      // Shift-vector (interior gravity) uniforms
+      betaTiltVec: [0, -1, 0],        // down by default
+      epsilonTilt: 0.0,               // no tilt by default
+      // Visual color for the shift-vector trace (VIOLET)
+      u_shiftVectorColor: { r: 0.54, g: 0.17, b: 0.89 }, // ~#8A2BE2
     }, options.uniforms || {});
@@
     // Scene + camera setup…
     this.scene = new THREE.Scene();
@@
     // Grid / bubble setup…
     this._initGrid();
     this._initLights();
@@
+    // --- Shift vector visual (Arrow) ---
+    this._shiftArrow = null;
+    const mkShiftArrow = () => {
+      try {
+        // Direction
+        const v = this.uniforms?.betaTiltVec || [0, -1, 0];
+        const dir = new THREE.Vector3(v[0], v[1], v[2]).normalize();
+        // Length scales gently with epsilon (cap for sanity)
+        const eps = Math.max(0, Math.min(1e-3, this.uniforms?.epsilonTilt || 0));
+        // Base the arrow length on hull minor axis so it’s visible but not huge
+        const axes = this.uniforms?.hullAxes || [503.5, 132, 86.5];
+        const baseLen = Math.max(axes[1], axes[2]) * 0.15; // ~15% of minor span
+        const len = baseLen * (1 + (eps * 5e3));           // gentle gain
+        // Color (violet)
+        const { r, g, b } = this.uniforms?.u_shiftVectorColor || { r: 0.54, g: 0.17, b: 0.89 };
+        const color = new THREE.Color(r, g, b);
+        // Position at interior center
+        const origin = new THREE.Vector3(0, 0, 0);
+        const headLen = len * 0.18;
+        const headWidth = headLen * 0.45;
+        const arrow = new THREE.ArrowHelper(dir, origin, len, color, headLen, headWidth);
+        arrow.name = 'shiftVectorArrow';
+        return arrow;
+      } catch {
+        return null;
+      }
+    };
+    this._ensureShiftArrow = () => {
+      if (!this._shiftArrow) {
+        this._shiftArrow = mkShiftArrow();
+        if (this._shiftArrow) this.scene.add(this._shiftArrow);
+      }
+    };
+    this._updateShiftArrow = () => {
+      if (!this._shiftArrow) return;
+      // Update direction
+      const v = this.uniforms?.betaTiltVec || [0, -1, 0];
+      const dir = new THREE.Vector3(v[0], v[1], v[2]).normalize();
+      this._shiftArrow.setDirection(dir);
+      // Update length & color
+      const eps = Math.max(0, Math.min(1e-3, this.uniforms?.epsilonTilt || 0));
+      const axes = this.uniforms?.hullAxes || [503.5, 132, 86.5];
+      const baseLen = Math.max(axes[1], axes[2]) * 0.15;
+      const len = baseLen * (1 + (eps * 5e3));
+      this._shiftArrow.setLength(len, len * 0.18, len * 0.08);
+      const { r, g, b } = this.uniforms?.u_shiftVectorColor || { r: 0.54, g: 0.17, b: 0.89 };
+      this._shiftArrow.setColor(new THREE.Color(r, g, b));
+    };
+    this._removeShiftArrow = () => {
+      if (this._shiftArrow) {
+        this.scene.remove(this._shiftArrow);
+        this._shiftArrow.geometry?.dispose?.();
+        // material is internal to ArrowHelper; safe to let GC reclaim
+        this._shiftArrow = null;
+      }
+    };
+    // Create on start
+    this._ensureShiftArrow();
@@
   updateUniforms(next = {}) {
-    this.uniforms = Object.assign(this.uniforms || {}, next);
+    this.uniforms = Object.assign(this.uniforms || {}, next);
     // keep existing update behavior…
@@
-    // Re-warp grid when critical fields change…
+    // Re-warp grid when critical fields change…
     this._warpGridVertices();
+    // Keep the shift arrow in sync
+    this._ensureShiftArrow();
+    this._updateShiftArrow();
   }
@@
   dispose() {
     // existing disposals…
+    this._removeShiftArrow();
     // renderer / controls cleanup…
   }
@@
   _warpGridVertices() {
     // … your existing displacement pipeline …
     // no changes needed here for the color; the arrow is separate
   }

Notes
	•	The arrow is drawn at the interior center, pointing along betaTiltVec.
	•	Length scales with epsilonTilt but stays gentle (×5e3 gain); tweak if it’s too subtle.
	•	Color is violet via u_shiftVectorColor and can be adjusted in one place.

⸻

Patch 2 — client/src/components/ShiftVectorPanel.tsx

Adds a small color legend and explicitly shows the violet mapping for the shift-vector so users can connect the panel to the visual.

*** a/client/src/components/ShiftVectorPanel.tsx
--- b/client/src/components/ShiftVectorPanel.tsx
@@
   return (
     <Card className="bg-muted/40">
       <CardHeader className="pb-3">
         <CardTitle className="text-sm">Shift Vector • Interior Gravity</CardTitle>
         <CardDescription className="text-xs">
           Gentle Natário tilt (ξᵢ) to bias geodesics for cabin “down”.
         </CardDescription>
       </CardHeader>
       <CardContent className="space-y-3 text-sm font-mono">
+        {/* Color Key */}
+        <div className="flex items-center gap-4 text-xs">
+          <div className="flex items-center gap-2">
+            <span className="inline-block w-3 h-3 rounded-full bg-blue-400/80" />
+            <span className="text-muted-foreground">Contraction</span>
+          </div>
+          <div className="flex items-center gap-2">
+            <span className="inline-block w-3 h-3 rounded-full bg-orange-400/80" />
+            <span className="text-muted-foreground">Expansion</span>
+          </div>
+          <div className="flex items-center gap-2">
+            <span className="inline-block w-3 h-3 rounded-full" style={{backgroundColor:'#8A2BE2'}} />
+            <span className="text-muted-foreground">Shift Vector (tilt)</span>
+          </div>
+        </div>
@@
         <div className="grid grid-cols-2 gap-2">
           <div>ε_tilt:</div>
           <div className="text-violet-400">{formatSci(epsilonTilt)}</div>
           <div>β̂_tilt:</div>
           <div className="text-violet-400">[{betaTiltVec.map(n=>n.toFixed(2)).join(", ")}]</div>
         </div>
       </CardContent>
     </Card>
   );
 }


⸻

Do I need to change WarpVisualizer.tsx?

Probably not — you’re already passing epsilonTilt and betaTiltVec through to the engine uniforms. If you want to be explicit, ensure you include:

engineRef.current?.updateUniforms({
  epsilonTilt: resolvedEpsilonTilt,
  betaTiltVec: resolvedBetaTiltVec,
  // optional (to tweak color globally)
  u_shiftVectorColor: { r: 0.54, g: 0.17, b: 0.89 }
});


⸻

Tuning visibility

If the arrow seems too faint/strong, adjust one knob:
	•	In warp-engine-fixed.js, change the gain line:

const len = baseLen * (1 + (eps * 5e3)); // increase/decrease 5e3


	•	Or bump baseLen multiplier from 0.15 to 0.2.

⸻

Want me to also add a tiny toggle (“Show shift vector”) in the visualizer header so you can hide/show the arrow without touching code?