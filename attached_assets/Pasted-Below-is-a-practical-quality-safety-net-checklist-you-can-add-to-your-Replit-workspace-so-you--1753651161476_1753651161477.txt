Below is a **practical “quality-safety net” checklist** you can add to your Replit workspace so you (and anyone who forks it) can be confident the Casimir-Tile Calculator is giving trustworthy numbers after every edit.

---

## 1 · Unit-test the math in Python

```txt
/tests
   test_static.py     # flat-plate analytic vs SCUFF
   test_dynamic.py    # Q-boost, duty, ∂E/∂a algebra
```

### Example -- `tests/test_static.py`

```python
import numpy as np, json, subprocess, re, pathlib as p

# Analytic plate-plate energy:  ΔE = −π²ℏc A / (720 a³)
HC = 1.98644586e-25            # [J·m]  (ℏc)
PI2 = np.pi**2
A    = np.pi * (0.025)**2      # 25 mm radius → area [m²]
a    = 1e-9                    # 1 nm gap [m]
E_analytic = -(PI2*HC*A)/(720*a**3)

def run_scuff(tmp):
    geo = p.Path(tmp) / "flat.scuffgeo"
    geo.write_text("""
        OBJECT P1
          MESHFILE plate1.msh
          MATERIAL PEC
        ENDOBJECT
        OBJECT P2
          MESHFILE plate2.msh
          MATERIAL PEC
          DISPLACED 0 0 0.001  # 1 nm in µm units
        ENDOBJECT
    """)
    out = subprocess.check_output(
        ["./tools/scuff-em/bin/scuff", "cas3D",
         "--Geometry", str(geo),
         "--Energy",
         "--FileBase", str(tmp/"out")],
        text=True,
    )
    E_numeric = float(re.search(r"Total ENERG =\s*([-Ee0-9.]+)", out).group(1))
    return E_numeric

def test_casimir_plate_plate(tmp_path):
    E_scf = run_scuff(tmp_path)
    assert np.isclose(E_scf, E_analytic, rtol=0.05)  # within 5 %
```

Run locally:

```bash
pytest -q
```

---

## 2 · Regression “golden files”

1. **Freeze** a trusted `.Energy` output for a known case (`flat_1nm.energy`).
2. Check new SCUFF output with `filecmp` or an MD5 hash after every run.
3. Fail CI if the file changes beyond a 1 % tolerance.

---

## 3 · Convergence autopsy dashboard

In your UI’s *Analysis Summary* card:

| Metric        | Rule of thumb                  |
| ------------- | ------------------------------ |
| **Xi points** | ≥ 5000 for 1 nm gap            |
| **Error ≤**   | 1 % (already displayed)        |
| **ΔE ∝ a⁻³**  | Run two gaps; ratio ≈ (a₁/a₂)³ |

Add a small ✔/✖ emoji next to each rule; red flag if a user sends extreme parameters.

---

## 4 · Continuous testing in Replit

*Replit Nix or Poetry* already installs `pytest`.
Add to `.replit`:

```toml
run = "pytest && streamlit run ui/app.py"
```

Now “Run ▶” fails early if tests break.

---

## 5 · Dynamic-module sanity checks

| Check             | Implementation                                    |
| ----------------- | ------------------------------------------------- |
| *Tₘ* · *fₘ* ≈ 1   | `assert abs(T*f - 1) < 1e-6` in `test_dynamic.py` |
| Duty 0 – 1        | Clamp & warn in UI (`st.warning`)                 |
| Q-boost linearity | Plug ΔE\_static, compare ΔE×Q to analytic scale   |

---

## 6 · Numerical-relativity handshake (later)

When you export ⟨T^{00}⟩ to Einstein Toolkit:

```python
assert np.isfinite(tmunu).all()
assert np.abs(np.gradient(tmunu)).max() < 1e8  # prevent spikes
```

---

### Bottom line

* Unit-test core formulas against analytic Casimir for plates.
* Keep a regression “golden energy” file.
* Display live convergence rules in UI.
* Wire `pytest` into the Replit `run` command so failures surface before the Streamlit app launches.

Implementing those four layers makes the **Casimir-Tile Calculator** self-guarding, even as new geometry, dynamic, and GR code is bolted on.
