Below are minimal, surgical diffs to “revert to solved” by (A) clamping the ship-wide duty to the original FR-safe baseline (1% local × 1/400 live sectors) on the server and (B) adding a client-side safety net in the engine. This restores ζ≤1 without relying on UI presets.

A) Server: clamp FR duty to the solved baseline

Why here: The server assembles the “physics-truth” packet and already exposes Ford–Roman status with s.zeta and s.fordRomanCompliance. We’ll cap the effective concurrent sectors so that dutyFR ≤ 0.01 × (1/totalSectors), then use the clamped concurrentFR everywhere (activeFraction, activeSectors, uniforms, and the dutyFR calculation). The FR duty is currently derived exactly as stated.

Unified diff — helix-core.ts (inside getSystemMetrics just after we read totalSectors/concurrent)

@@ export function getSystemMetrics(req: Request, res: Response) {
-  const totalSectors = Math.max(1, s.sectorCount);
-  const concurrent = Math.max(1, s.concurrentSectors || 1); // must be ≥1 to allocate buffers
-  const activeFraction = concurrent / totalSectors;
+  const totalSectors = Math.max(1, s.sectorCount);
+  const concurrentReq = Math.max(1, s.concurrentSectors || 1); // must be ≥1 to allocate buffers
+  // --- Ford–Roman safety clamp (revert to solved baseline) ---
+  // Local on-window burst (default 1%) and FR baseline = 1% × (1/totalSectors)
+  const dutyLocalRaw = Number.isFinite((s as any).localBurstFrac)
+    ? Math.max(1e-12, (s as any).localBurstFrac as number)
+    : Math.max(1e-12, s.dutyCycle ?? 0.01);
+  const FR_DUTY_MAX = 0.01 * (1 / totalSectors);
+  const requestedDutyFR = dutyLocalRaw * (concurrentReq / totalSectors);
+  // Reduce live sectors if requested FR duty would violate the solved window
+  const concurrentFR = (requestedDutyFR > FR_DUTY_MAX)
+    ? Math.max(1, Math.floor((FR_DUTY_MAX * totalSectors) / dutyLocalRaw))
+    : concurrentReq;
+  const activeFraction = concurrentFR / totalSectors;
@@
-  const tilesPerSector = Math.floor(s.N_tiles / totalSectors);
-  const activeTiles = tilesPerSector * concurrent;
+  const tilesPerSector = Math.floor(s.N_tiles / totalSectors);
+  const activeTiles = tilesPerSector * concurrentFR;
@@
-  res.json({
+  res.json({
@@
-    activeSectors: concurrent,
-    activeFraction,
-    sectorStrobing: concurrent,   // concurrent (live) sectors
+    activeSectors: concurrentFR,
+    activeFraction,
+    sectorStrobing: concurrentFR,   // concurrent (live) sectors
@@
-    dutyGlobal_UI: s.dutyCycle,
-    dutyEffectiveFR: (s as any).dutyEffectiveFR ?? (s as any).dutyEffective_FR,
+    dutyGlobal_UI: s.dutyCycle,
+    // Canonical FR duty with server clamp applied
+    dutyEffectiveFR: (s as any).dutyEffectiveFR ?? (s as any).dutyEffective_FR
+                     ?? Math.max(1e-12, dutyLocalRaw * (concurrentFR / totalSectors)),


What this changes: The FR duty that feeds θ and ζ now can’t exceed the solved baseline; doubling concurrentSectors no longer doubles FR duty, so ζ stays ≤1. You can see where the FR duty is used to build the canonical uniforms/θ on the server and where FR compliance is surfaced to clients.

If you have a second copy of the same “duty & θ chain” block (the file has duplicated chunks), apply the same clamp logic there as well (the section that defines dutyLocal, dutyUI, and dutyFR).