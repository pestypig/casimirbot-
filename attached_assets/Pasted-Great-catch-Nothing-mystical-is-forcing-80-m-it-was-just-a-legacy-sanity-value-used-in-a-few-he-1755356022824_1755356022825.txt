Great catch. Nothing “mystical” is forcing 80 m — it was just a legacy/sanity value used in a few helper branches. You already have the right place for the real geometry:

* The TS ratio you pasted is perfect: it uses the actual hull **(Lx, Ly, Lz)** and sets
  `TS_ratio = (max(Lx,Ly,Lz)/c) / (1/f_m)` (conservative), which is why you now see \~5 × 10^4 for 1007 m.

Where things can still go sideways is the **tile count** path. Your current `N_tiles` logic still has special-cases keyed off a “radius” and it scales an ellipsoid from a fixed exemplar before finally hard-coding 1.12e9 for large hulls. You don’t need any of those branches anymore. We can compute both **surface area** and **N\_tiles** directly from the true needle hull dimensions.

Below is a drop-in patch that:

1. removes the radius-based branches,
2. computes hull surface area from the **actual prolate ellipsoid** defined by (Lx, Ly, Lz), using the Knud–Thomsen approximation (good accuracy for needle-like shapes),
3. derives `N_tiles` from that area and the configured tile area, and
4. keeps your TS computation exactly as you showed.

---

### ✅ Minimal patch for `server/energy-pipeline.ts`

```ts
// 1) Add this helper near the top (with your other constants/helpers)

/** Ellipsoid surface area via Knud–Thomsen (very good for prolate/needle shapes). 
 *  a = Lx/2, b = Ly/2, c = Lz/2 (meters)
 */
function surfaceAreaEllipsoidFromHullDims(Lx_m: number, Ly_m: number, Lz_m: number): number {
  const a = Lx_m / 2;
  const b = Ly_m / 2;
  const c = Lz_m / 2;
  const p = 1.6075; // Knud–Thomsen exponent
  const term1 = Math.pow(a * b, p);
  const term2 = Math.pow(a * c, p);
  const term3 = Math.pow(b * c, p);
  return 4 * Math.PI * Math.pow((term1 + term2 + term3) / 3, 1 / p);
}
```

```ts
// 2) In calculateEnergyPipeline(...) replace your current “N_tiles” block with:

// --- Surface area & tile count from actual hull dims ---
const tileArea_m2 = state.tileArea_cm2 * CM2_TO_M2;

// If a full rectangular needle + rounded caps is added later, we can refine this.
// For now, the ellipsoid (a=Lx/2, b=Ly/2, c=Lz/2) is an excellent approximation.
const hullArea_m2 = surfaceAreaEllipsoidFromHullDims(state.hull!.Lx_m, state.hull!.Ly_m, state.hull!.Lz_m);

// Derived tile count (no hard-coding; lets geometry drive it)
state.N_tiles = Math.max(1, Math.floor(hullArea_m2 / tileArea_m2));
```

> With **Lx×Ly×Lz = 1007 m × 264 m × 173 m** and **tileArea = 5 cm²**, this produces:
>
> * Ellipsoid area ≈ **5.57×10^5 m²**
> * `N_tiles ≈ 5.57×10^5 / 5e-4 = 1.11×10^9` → matches your research baseline \~**1.12×10^9** within rounding.

```ts
// 3) Keep your TS-ratio block as-is (what you pasted is correct):

// --- Time-scale separation (TS) using actual hull size ---
const { Lx_m, Ly_m, Lz_m } = state.hull!;
const L_long = Math.max(Lx_m, Ly_m, Lz_m);
const L_geom = Math.cbrt(Lx_m * Ly_m * Lz_m);
const T_long = L_long / C;
const T_geom = L_geom / C;
state.TS_long = T_long / T_m;   // conservative
state.TS_geom = T_geom / T_m;   // typical
state.TS_ratio = state.TS_long; // exported value (unchanged)
```

---

### Why this fixes the “80 m” confusion

* The **80–85 m** number came from legacy branches that inferred a “radius” and scaled from a stock ellipsoid or just hard-coded `N_tiles` for “large” hulls.
* With the patch above, **everything is driven by your true hull dimensions**, so 1007 m is now the source of truth for both **tile count** and **light-crossing time**; no hidden scale factors remain.

### Sanity check (how you can verify)

* `/api/helix/metrics` should now report:

  * `totalTiles ≈ 1.11e9` (for 5 cm² tiles),
  * `timeScaleRatio ≈ 5.0e4` for `f_m = 15 GHz` (T\_m ≈ 6.67×10^-11 s),
  * and your per-mode **activeTiles** will follow from `sectorStrobing` as you already implemented.

If you ever switch from a pure ellipsoid to a **capsule** (elliptical cylinder body + ellipsoidal caps), I can give you a refined area function (Ramanujan ellipse perimeter × body length + two end-cap areas). For now, the ellipsoid is simple, fast, and within a couple percent for needle-like shapes — perfect for live UI and the pipeline.

Want me to also align the **Bridge** derivation cards (Step 6: TS\_ratio and Step 8: N\_tiles) so the displayed formulas reflect these exact inputs (Lx, Ly, Lz and tileArea)?
