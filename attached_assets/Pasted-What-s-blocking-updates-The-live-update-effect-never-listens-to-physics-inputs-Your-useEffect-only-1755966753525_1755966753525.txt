What’s blocking updates

The live-update effect never listens to physics inputs.
Your useEffect only depends on viz/camera fields, not on dutyCycle, sector*, gammaGeo, qSpoilingFactor, gammaVdB, dutyEffectiveFR, or lightCrossing.*. So mode changes don’t trigger a push of the new θ-scale.

resolveThetaScale ignores the FR window.
You’re always using √(duty/sectors). In Helix you intended to prefer dutyEffectiveFR (or burst/dwell) when present.

No strobe wiring in this component.
WarpVisualizer subscribed to the global setStrobingState mux; WarpBubbleCompare doesn’t, so sector index / counts never reach these canvases.

You’re force-zeroing onWindow in scrubOverlays().
That defeats FR-window gating even if you pass it.

Below is a minimal patch set that fixes all four.

1) Prefer FR window in θ-scale
function resolveThetaScale(p: any) {
-  const duty     = Number(p?.dutyCycle ?? 0.14);
-  const sectors  = Math.max(1, Number(p?.sectors ?? p?.sectorCount ?? 1));
+  const sectors  = Math.max(1, Number(p?.sectors ?? p?.sectorCount ?? p?.sectorStrobing ?? 1));
+  // Prefer FR-sampled duty if available
+  let duty = Number(p?.dutyCycle ?? 0.14);
+  if (Number.isFinite(p?.dutyEffectiveFR)) {
+    duty = Number(p.dutyEffectiveFR);
+  } else if (p?.lightCrossing &&
+             Number.isFinite(p.lightCrossing.burst_ms) &&
+             Number.isFinite(p.lightCrossing.dwell_ms) &&
+             p.lightCrossing.dwell_ms > 0) {
+    duty = p.lightCrossing.burst_ms / p.lightCrossing.dwell_ms;
+  }

2) Make the live effect fire on physics changes

Add a compact “physics key” and listen for it:

 export default function WarpBubbleCompare({...}) {
   const base = parameters ? JSON.parse(JSON.stringify(parameters)) : {};

+  // Fingerprint of physics inputs that should re-push uniforms
+  const physicsKey = JSON.stringify({
+    duty: base.dutyEffectiveFR ?? base.dutyCycle,
+    sectors: base.sectorStrobing ?? base.sectors ?? base.sectorCount,
+    gammaGeo: base.g_y ?? base.gammaGeo,
+    qSpoil: base.qSpoilingFactor ?? base.deltaAOverA,
+    gammaVdB: base.gammaVanDenBroeck ?? base.gammaVdB,
+    lc: base.lightCrossing ? {
+      phase: base.lightCrossing.phase,
+      sectorIdx: base.lightCrossing.sectorIdx,
+      dwell_ms: base.lightCrossing.dwell_ms,
+      burst_ms: base.lightCrossing.burst_ms,
+      tauLC_ms: base.lightCrossing.tauLC_ms
+    } : null
+  });

   ...
-  useEffect(() => {
+  useEffect(() => {
     if (!leftEngine.current || !rightEngine.current || !leftRef.current || !rightRef.current) return;
     const shared = frameFromHull(parityParams?.hull || showParams?.hull, parityParams?.gridSpan || showParams?.gridSpan);

     const parityPhys = physicsPayload(parityParams);
     const showPhys = physicsPayload(showParams);
     pushUniformsWhenReady(leftEngine.current,  parityPhys);
     pushUniformsWhenReady(rightEngine.current, showPhys);
+    // Also push FR-window/light-crossing controls if present
+    if (base.lightCrossing) {
+      const lc = base.lightCrossing;
+      const s = Math.max(1, Number(base.sectorStrobing ?? lc.sectorCount ?? showPhys.sectors ?? 1));
+      const lcPayload = {
+        phase: lc.phase,
+        onWindow: !!lc.onWindowDisplay,
+        sectorIdx: Math.max(0, lc.sectorIdx % s),
+        tauLC_ms: lc.tauLC_ms,
+        dwell_ms: lc.dwell_ms,
+        burst_ms: lc.burst_ms,
+        sectors: s
+      };
+      pushUniformsWhenReady(leftEngine.current,  lcPayload);
+      pushUniformsWhenReady(rightEngine.current, lcPayload);
+    }

     ...
-  }, [
+  }, [
     parityParams?.hull?.a, parityParams?.hull?.b, parityParams?.hull?.c,
     showParams?.hull?.a, showParams?.hull?.b, showParams?.hull?.c,
     parityParams?.gridSpan, showParams?.gridSpan,
     parityParams?.viz?.curvatureGainT, showParams?.viz?.curvatureGainT,
     parityParams?.viz?.curvatureBoostMax, showParams?.viz?.curvatureBoostMax,
     parityParams?.viz?.exposure, showParams?.viz?.exposure,
     parityParams?.viz?.zeroStop, showParams?.viz?.zeroStop,
     parityParams?.curvatureGainDec, showParams?.curvatureGainDec,
-    colorMode, heroX, parityX
+    colorMode, heroX, parityX,
+    physicsKey                       // ⬅️ new: react to mode/duty/sectors/LC
   ]);