You’re right: the physics is fine; the render break is coming from shader header duplication + bool/int mismatches. Here’s a tight set of patches that (a) fixes the compile/link loop, (b) carries your Purple shift uniforms end-to-end, and (c) keeps parity enforcement without redeclarations.

1) Pipe Purple shift through the uniform system
client/src/lib/warp-uniforms.ts

Add fields and pass-through during normalization + builders:

// 1) type
export type WarpUniforms = {
  ...
  // --- Purple shift (interior gravity) -------------------------------------
  epsilonTilt?: number;                     // ε (dimensionless)
  betaTiltVec?: [number, number, number];   // normalized β direction
};

// 2) normalizeWU()
const epsilonTilt = Number.isFinite(+raw.epsilonTilt) ? Math.max(0, +raw.epsilonTilt) : undefined;
let betaTiltVec: [number,number,number] | undefined;
if (Array.isArray(raw.betaTiltVec) && raw.betaTiltVec.length === 3) {
  const [x,y,z] = raw.betaTiltVec.map(Number);
  const n = Math.hypot(x,y,z) || 1;
  betaTiltVec = [x/n, y/n, z/n];
}

const wu: WarpUniforms = {
  ...raw,
  ...
  epsilonTilt,
  betaTiltVec,
  ...
};

// 3) buildREAL/buildSHOW: carry through unchanged
export function buildREAL(wu: WarpUniforms) {
  return {
    ...wu,
    ...
  } as const;
}
export function buildSHOW(wu: WarpUniforms, opts?: { T?:number; boost?:number; userGain?:number }) {
  const T = clamp(N(opts?.T, 0.70), 0, 1);
  const boost = Math.max(1, N(opts?.boost, 40));
  return {
    ...wu,
    ...
  } as const;
}


With this, anything you place on baseShared (e.g. epsilonTilt, betaTiltVec) will flow into both panes.

2) Map the new fields to engine uniform names (no duplication)
client/src/lib/warp-uniforms-gate.ts (or wherever gatedUpdateUniforms/applyToEngine lives)

Add a small mapper so the engine always sees canonical names, and do not synthesize duplicates:

const CANON = {
  physicsParityMode: 'uPhysicsParity',
  ridgeMode:         'uRidgeMode',
  epsilonTilt:       'uEpsilonTilt',
  betaTiltVec:       'uBetaTiltVec'
} as const;

export function gatedUpdateUniforms(engine: any, patch: any, src = 'client') {
  if (!engine || !patch) return;

  const u: Record<string, any> = {...patch};

  // sanitize + rename
  if ('physicsParityMode' in u) u[CANON.physicsParityMode] = !!u.physicsParityMode;
  if ('ridgeMode' in u)         u[CANON.ridgeMode]         = (u.ridgeMode|0) ? 1 : 0;

  if ('epsilonTilt' in u)       u[CANON.epsilonTilt]       = Math.max(0, +u.epsilonTilt || 0);
  if ('betaTiltVec' in u && Array.isArray(u.betaTiltVec)) {
    const [x=0,y=0,z=0] = u.betaTiltVec.map(Number);
    const n = Math.hypot(x,y,z) || 1;
    u[CANON.betaTiltVec] = [x/n, y/n, z/n] as [number,number,number];
  }

  // strip legacy keys so we never double-write engine params
  delete u.physicsParityMode; delete u.ridgeMode;
  delete u.epsilonTilt; delete u.betaTiltVec;

  // push once
  engine.updateUniforms?.(u);
  engine.forceRedraw?.();
}


This guarantees the engine only ever sees one set of names: uPhysicsParity, uRidgeMode, uEpsilonTilt, uBetaTiltVec.