Here are four focused patches to make your engine fully metric-aware. Each diff targets `warp-engine.js` at the indicated line ranges.

1) **Inject metric uniforms & GLSL helpers**  
```diff
--- a/warp-engine.js
+++ b/warp-engine.js
@@ -20,6 +20,22 @@ class WarpEngine {
-    _injectUniforms(fsBody) {
+    _injectUniforms(fsBody) {
         const header = `
+            // --- metric tensor uniforms (covariant & inverse) ---
+            uniform mat3 u_metric;
+            uniform mat3 u_metricInv;
+            uniform bool u_useMetric;
             precision highp float;
             uniform mat4 u_mvpMatrix;
             uniform vec3 u_axesScene;
+        `;

-        const utils = `
+        const utils = `
             // Purple shift weight (original)
-            float purpleShiftWeight(vec3 n) { … }
+            // --- metric-aware dot, norm, normalize helpers ---
+            float dotG(vec3 a, vec3 b) { return dot(a, u_metric * b); }
+            float normG(vec3 v) { return sqrt(max(1e-12, dotG(v,v))); }
+            vec3 normalizeG(vec3 v) { return v / max(1e-12, normG(v)); }
+
+            // Purple shift now uses metric if requested
+            float purpleShiftWeight(vec3 n) {
+              vec3 nn = u_useMetric ? normalizeG(n) : normalize(n);
+              vec3 bb = u_useMetric ? normalizeG(u_betaTiltVec) : normalize(u_betaTiltVec);
+              float p = dotG(bb, nn) / (u_useMetric ? (normG(bb)*normG(nn)) : 1.0);
+              float w = clamp(0.5 - 0.5*p, 0.0, 1.0);
+              return pow(w, 0.75);
+            }
         `;
```
[24-63](turn11file4)

2) **Cache the new uniform locations**  
```diff
--- a/warp-engine.js
+++ b/warp-engine.js
@@     _cacheGridLocations(program) {
         this.gridUniforms = {
             mvpMatrix:      gl.getUniformLocation(program, 'u_mvpMatrix'),
+            metric:         gl.getUniformLocation(program, 'u_metric'),
+            metricInv:      gl.getUniformLocation(program, 'u_metricInv'),
+            useMetric:      gl.getUniformLocation(program, 'u_useMetric'),
             axes:           gl.getUniformLocation(program, 'u_axesScene'),
             wallWidth:      gl.getUniformLocation(program, 'u_wallWidth'),
```
[1-16](turn11file0)

3) **Bind metric uniforms in the render loop**  
```diff
--- a/warp-engine.js
+++ b/warp-engine.js
@@     _render() {
         gl.uniform3fv(U.betaTiltVec, this.uniforms.betaTiltVec);
         gl.uniform1f(U.epsilonTilt, this.uniforms.epsilonTilt);
+        // — bind metric (default to identity if not provided) —
+        const M = this.uniforms.metric    || [1,0,0, 0,1,0, 0,0,1];
+        const iM= this.uniforms.metricInv || [1,0,0, 0,1,0, 0,0,1];
+        gl.uniformMatrix3fv(U.metric,    false, new Float32Array(M));
+        gl.uniformMatrix3fv(U.metricInv, false, new Float32Array(iM));
+        gl.uniform1i(U.useMetric,        this.uniforms.useMetric ? 1 : 0);
```
[1-12](turn11file1)

4) **Derive or accept metric in `updateUniforms`**  
```diff
--- a/warp-engine.js
+++ b/warp-engine.js
@@     _applyUniformsNow(parameters) {
-        // existing axesClip computation…
+        // existing axesClip computation…
         this.uniforms.axesClip = [a*s, b*s, c*s];
+        // — metric setup —
+        let { metric, metricInv, useMetric, metricMode } = parameters;
+        if (!metric) {
+          if (metricMode==='ellipsoid') {
+            const [ax,ay,az] = this.uniforms.axesClip;
+            const gxx=1/ax/ax, gyy=1/ay/ay, gzz=1/az/az;
+            metric    = [gxx,0,0, 0,gyy,0, 0,0,gzz];
+            metricInv = [1/gxx,0,0, 0,1/gyy,0, 0,0,1/gzz];
+            useMetric = true;
+          } else {
+            metric = metricInv = [1,0,0, 0,1,0, 0,0,1];
+            useMetric = false;
+          }
+        }
+        this.uniforms.metric     = metric;
+        this.uniforms.metricInv  = metricInv;
+        this.uniforms.useMetric  = !!useMetric;
```
[58-83](turn11file3)

With these four patches, your warp engine will accept a general metric tensor, make all distance/normal computations metric-aware in both JS and GLSL, and default to the Euclidean case when no custom metric is provided.