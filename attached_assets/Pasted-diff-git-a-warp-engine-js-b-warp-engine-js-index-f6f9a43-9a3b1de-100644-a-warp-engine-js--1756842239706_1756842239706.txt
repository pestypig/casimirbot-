diff --git a/warp-engine.js b/warp-engine.js
index f6f9a43..9a3b1de 100644
--- a/warp-engine.js
+++ b/warp-engine.js
@@ -66,17 +66,30 @@ class WarpEngine {
       _req(Number.isFinite(U.sectorStrobing) && U.sectorStrobing>=1, "sectorStrobing", U);
       _req(Number.isFinite(U.dutyEffectiveFR), "dutyEffectiveFR", U);
-      // Either authoritative theta OR all factors to recompute are present
-      if (!Number.isFinite(U.thetaScale)) {
-        _req(true, "thetaScale (pipeline) â€” required in strict mode for now", U);
-      }
+      // Either authoritative theta OR all factors to recompute must be present
+      if (!Number.isFinite(U.thetaScale)) {
+        const haveAll = Number.isFinite(U.gammaGeo)
+                     && Number.isFinite(U.deltaAOverA)
+                     && Number.isFinite(U.gammaVanDenBroeck)
+                     && Number.isFinite(U.dutyEffectiveFR);
+        _req(haveAll, "thetaScale or (gammaGeo,qSpoil,gammaVdB,dutyFR)", U);
+      }
       // Lock framing while validating strict 1:1
       U.lockFraming = true;
     }
@@ -104,9 +117,18 @@ class WarpEngine {
     // --- amplitude (theta) ---------------------------------------------------
-    let theta = U.thetaScale;
-    if (!Number.isFinite(theta)) {
-      // in non-strict mode we may recompute; in strict we refuse
-      if (this.strictPhysics) {
-        U.__error = "warp-engine: thetaScale missing in strict mode";
-        return;
-      } else {
-        theta = Math.pow(U.gammaGeo||1,3) * (U.deltaAOverA||1) * (U.gammaVanDenBroeck||1) * Math.sqrt(Math.max(1e-12, U.dutyEffectiveFR||0));
-      }
-    }
+    let theta = U.thetaScale;
+    if (!Number.isFinite(theta)) {
+      // Deterministic derive allowed when (and only when) all inputs are present
+      const haveAll = Number.isFinite(U.gammaGeo)
+                   && Number.isFinite(U.deltaAOverA)
+                   && Number.isFinite(U.gammaVanDenBroeck)
+                   && Number.isFinite(U.dutyEffectiveFR);
+      if (!haveAll && this.strictPhysics) {
+        U.__error = "warp-engine: thetaScale missing and inputs incomplete";
+        return;
+      }
+      if (haveAll) {
+        theta = Math.pow(U.gammaGeo, 3) * U.deltaAOverA * U.gammaVanDenBroeck * Math.sqrt(Math.max(1e-18, U.dutyEffectiveFR));
+      }
+    }
     this.uniforms.thetaScale_actual = theta;
 
     // draw...