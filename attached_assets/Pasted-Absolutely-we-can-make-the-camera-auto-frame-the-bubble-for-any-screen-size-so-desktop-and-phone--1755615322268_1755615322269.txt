Absolutely—we can make the camera “auto-frame” the bubble for any screen size, so desktop and phone both see the whole surface with a small margin.

Below is a drop-in patch for client/public/warp-engine-fixed.js that:
	•	Computes a fit distance from the bubble’s current axes (or grid span).
	•	Picks a slightly wider FOV on phones / tall aspect so more of the scene fits.
	•	Re-fits the camera on resize and whenever hullAxes or grid span change.
	•	Caps devicePixelRatio on mobile to avoid over-zoom blur & performance hits.

⸻

1) Add helpers (place near other private helpers)

// === Responsive camera helpers =============================================
_fitFovForAspect(aspect) {
  // Wider FOV when the canvas is tall (phones/portrait)
  // desktop ~60°, phone ~68°
  const fovDesktop = Math.PI / 3;      // 60°
  const fovPortrait = Math.PI / 2.65;  // ~68°
  const t = Math.min(1, Math.max(0, (1.2 - aspect) / 0.6)); // aspect<1.2 => more portrait
  return fovDesktop * (1 - t) + fovPortrait * t;
},

// axesScene is the ellipsoid semi-axes in scene units (what the renderer already uses)
// spanHint is optional fallback (grid span in scene units)
_fitCameraToBubble(axesScene, spanHint) {
  const aspect = this.canvas.width / Math.max(1, this.canvas.height);
  const fov = this._fitFovForAspect(aspect);

  // Bounding sphere radius of the ellipsoid (in scene units)
  const R = axesScene ? Math.max(axesScene[0], axesScene[1], axesScene[2]) : (spanHint || 1);
  const margin = 1.25; // add some breathing room

  // Distance along -Z so bubble fits vertically
  const dist = (margin * R) / Math.tan(fov * 0.5);

  // Lightly raise the camera with bubble size so horizon stays pleasing
  const eye = [0, 0.22 * R, -dist];
  const center = [0, -0.05 * R, 0];
  const up = [0, 1, 0];

  // Update projection & view
  this._perspective(this.projMatrix, fov, aspect, 0.1, 200.0);
  this._lookAt(this.viewMatrix, eye, center, up);
  this._multiply(this.mvpMatrix, this.projMatrix, this.viewMatrix);
},


⸻

2) Make resize truly responsive (replace your resize logic)

Find your resize handler and replace with:

_resizeCanvasToDisplaySize() {
  // Cap DPR on phones so we don’t oversample and “zoom in”
  const dprCap = (window.matchMedia && window.matchMedia("(max-width: 768px)").matches) ? 1.5 : 2.0;
  const dpr = Math.min(dprCap, window.devicePixelRatio || 1);

  const { clientWidth, clientHeight } = this.canvas;
  const width  = Math.max(1, Math.floor(clientWidth  * dpr));
  const height = Math.max(1, Math.floor(clientHeight * dpr));

  if (this.canvas.width !== width || this.canvas.height !== height) {
    this.canvas.width  = width;
    this.canvas.height = height;
    this.gl.viewport(0, 0, width, height);

    const axes = this.uniforms?.axesScene || this._lastAxesScene || [0.45, 0.25, 0.25];
    this._fitCameraToBubble(axes, this._gridSpan || 1);
  }
}

Call _resizeCanvasToDisplaySize() in your engine’s constructor and on window.onresize if you aren’t already.

⸻

3) Fit camera whenever hull axes or span change

In your updateUniforms() (where you already accept hullAxes / hull / hullAxesScene), cache the scene axes and call the fitter:

updateUniforms(parameters = {}) {
  // ... your existing assignments ...

  // Derive scene axes used by the renderer (these already exist in your code)
  // Prefer the ready-to-use scene-space axes if you have them.
  const axesScene =
    parameters.axesScene ||                       // direct scene units
    this.uniforms?.axesScene ||
    (function resolveFromHull(p) {
      if (!p) return null;
      // fall back from meters to scene units; keep your existing scale function
      const a = (p.hullAxes?.[0] ?? p.hull?.a) || 503.5;
      const b = (p.hullAxes?.[1] ?? p.hull?.b) || 132.0;
      const c = (p.hullAxes?.[2] ?? p.hull?.c) || 86.5;
      // Convert meters → scene (mirror whatever scaling you use elsewhere)
      const s = 1.0 / 1200.0; // example from earlier code paths
      return [a * s, b * s, c * s];
    })(parameters) ||
    this._lastAxesScene;

  if (axesScene) {
    this.uniforms.axesScene = axesScene;
    this._lastAxesScene = axesScene;
    this._fitCameraToBubble(axesScene, this._gridSpan || 1);
  }

  // If you compute/receive a grid span, remember it & refit
  if (typeof parameters.gridSpan === 'number') {
    this._gridSpan = Math.max(0.5, parameters.gridSpan);
    this._fitCameraToBubble(this._lastAxesScene || axesScene, this._gridSpan);
  }

  // ...rest of your method...
}

Notes
• If your code already computes the “grid span” (half-width of the rendered patch in scene units), pass it as parameters.gridSpan when you call updateUniforms. Otherwise the ellipsoid axes alone are sufficient.
• The scale constants (1/1200 etc.) should match the ones you use where you convert meters → clip/scene coordinates for the bubble. If your code already exports axesScene directly, prefer that.

⸻

4) (Optional) CSS height hint for better mobile framing

In your WarpVisualizer.tsx, make sure the canvas container has a sensible height:

<div className="relative w-full"
     style={{ height: 'min(56vh, 520px)' }}>
  <canvas ref={canvasRef} className="w-full h-full block" />
</div>

This gives the camera enough vertical space to fit on phones without becoming cramped.

⸻

What this gives you
	•	On desktop, the camera stays close and cinematic.
	•	On mobile/portrait, the engine automatically widens the FOV and adjusts the distance so the entire bubble fits (with margin), avoiding the too-close crop you saw.
	•	Any change to hull size, grid span, or window size triggers a refit.

If you want the camera even closer by default, reduce margin from 1.25 → 1.15. If you want more air around the bubble on mobile, increase it slightly for portrait aspect:

const baseMargin = 1.2;
const margin = baseMargin * (aspect < 1 ? 1.1 : 1.0);

Happy to tailor these numbers to your preferred look!