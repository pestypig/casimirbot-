--- a/client/src/components/WarpRenderInspector.tsx
+++ b/client/src/components/WarpRenderInspector.tsx
@@
-import { thetaCanonical } from "@/lib/warp-theta";
+// NOTE: Do NOT compute or send theta from the UI. The engine is authoritative.
 
@@
-// (existing helpers)
+// --- pane helpers -----------------------------------------------------------
+const sanitizeUniforms = (o: any) =>
+  Object.fromEntries(Object.entries(o ?? {}).filter(([_, v]) => v !== undefined));
+
+function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
+  const p = { ...patch };
+  if (pane === 'REAL') {
+    p.physicsParityMode = true;  p.parityMode = true;
+    p.viewAvg = true;            p.ridgeMode = 0;
+  } else {
+    p.physicsParityMode = false; p.parityMode = false;
+    p.viewAvg = false;           p.ridgeMode = 1;
+  }
+  // Never allow UI to inject theta
+  delete (p as any).thetaScale;
+  delete (p as any).u_thetaScale;
+  return p;
+}
+
+function buildRealPacket(parameters: any, base: any = {}) {
+  const dutyFR =
+    Math.max(1e-9, Math.min(1,
+      (parameters?.dutyEffectiveFR ?? parameters?.dutyFR ?? 0.000025)));
+  return {
+    ...base,
+    currentMode: parameters?.currentMode,
+    physicsParityMode: true,
+    viewAvg: true,
+    // REAL must use FR duty directly → collapse sectors
+    dutyEffectiveFR: dutyFR,
+    dutyCycle: dutyFR,
+    sectors: 1,
+    sectorCount: 1,
+    vShip: 0,
+    ridgeMode: 0,
+    // Mass-pocket gamma only for REAL (clamped physical range)
+    gammaVanDenBroeck_mass: Math.max(1, Math.min(1000,
+      parameters?.gammaVanDenBroeck_mass ??
+      parameters?.gammaVanDenBroeck ??
+      38.3)),
+    // Visual gamma can be logged but is not used by REAL
+    gammaVanDenBroeck_vis: Math.max(1, Math.min(1e9,
+      parameters?.gammaVanDenBroeck_vis ??
+      parameters?.gammaVanDenBroeck ??
+      2.86e5)),
+    // Avoid UI theta
+    thetaScale: undefined,
+    u_thetaScale: undefined,
+  };
+}
+
+function buildShowPacket(parameters: any, base: any = {}) {
+  return {
+    ...base,
+    currentMode: parameters?.currentMode,
+    physicsParityMode: false,
+    viewAvg: false,
+    dutyCycle: Math.max(0, Math.min(1, parameters?.dutyCycle ?? 0.14)),
+    sectorCount: Math.max(1, Math.floor(parameters?.sectorCount ?? 400)),
+    sectors:     Math.max(1, Math.floor(parameters?.sectors     ?? 1)),
+    vShip: parameters?.currentMode === 'standby' ? 0 : 1,
+    ridgeMode: 1,
+    // SHOW uses the “visual” pocket factor
+    gammaVanDenBroeck_vis: Math.max(1, Math.min(1e9,
+      parameters?.gammaVanDenBroeck_vis ??
+      parameters?.gammaVanDenBroeck ??
+      2.86e5)),
+    // Avoid UI theta
+    thetaScale: undefined,
+    u_thetaScale: undefined,
+  };
+}
 
@@
-  // push uniforms (existing code)
+  // push uniforms (engine is the single source of truth for theta)
   useEffect(() => {
-    if (!leftEngine.current || !rightEngine.current || !parameters) return;
-    // existing payload assembly...
-    leftEngine.current.updateUniforms(/* real */);
-    rightEngine.current.updateUniforms(/* show */);
-    leftEngine.current.forceRedraw?.();
-    rightEngine.current.forceRedraw?.();
+    if (!leftEngine.current || !rightEngine.current || !parameters) return;
+    const shared = {/* keep your shared hull/axes/etc. derivation here */};
+    const realPacket = paneSanitize('REAL', sanitizeUniforms(buildRealPacket(parameters, shared)));
+    const showPacket = paneSanitize('SHOW', sanitizeUniforms(buildShowPacket(parameters, shared)));
+    leftEngine.current.updateUniforms(realPacket);
+    rightEngine.current.updateUniforms(showPacket);
+    leftEngine.current.forceRedraw?.();
+    rightEngine.current.forceRedraw?.();
+    // Post-write θ sampler (logs what the engine actually uses)
+    requestAnimationFrame(() => {
+      try {
+        const Le = leftEngine.current, Re = rightEngine.current;
+        const Lθ = Number(Le?.uniforms?.thetaScale_actual ?? Le?.uniforms?.thetaScale);
+        const Rθ = Number(Re?.uniforms?.thetaScale_actual ?? Re?.uniforms?.thetaScale);
+        const parL = !!Le?.uniforms?.physicsParityMode, parR = !!Re?.uniforms?.physicsParityMode;
+        console.log('[WRI θ] REAL: θ(shader)=', Lθ, 'parity=', parL,
+          'dutyCycle=', Le?.uniforms?.dutyCycle, 'sectors=', Le?.uniforms?.sectors,
+          'sectorCount=', Le?.uniforms?.sectorCount, 'γ_VdB(mass)=', Le?.uniforms?.gammaVanDenBroeck_mass);
+        console.log('[WRI θ] SHOW: θ(shader)=', Rθ, 'parity=', parR,
+          'dutyCycle=', Re?.uniforms?.dutyCycle, 'sectors=', Re?.uniforms?.sectors,
+          'sectorCount=', Re?.uniforms?.sectorCount, 'γ_VdB(vis)=', Re?.uniforms?.gammaVanDenBroeck_vis);
+      } catch {}
+    });
   }, [parameters?.currentMode, parameters?.reloadToken]);
 
@@
-  // any places that call updateUniforms directly:
-  leftEngine.current?.updateUniforms(payload);
+  // Guard any other updateUniforms calls to go through paneSanitize + builders:
+  // leftEngine.current?.updateUniforms(paneSanitize('REAL', sanitizeUniforms(buildRealPacket(parameters, payload))));
+  // rightEngine.current?.updateUniforms(paneSanitize('SHOW', sanitizeUniforms(buildShowPacket(parameters, payload))));
