You nailed the two places that still **compute** the TS ratio locally—that’s why you’re seeing the old \~4.1k number in some views even though the server now calculates \~5.0×10⁴ from the 1007 m hull. The fix is simple: **read τₗ꜀, Tₘ, and TS\_ratio from the server everywhere** and stop re-deriving them on the client.

Here’s a clean, minimal patch set you can hand to the Agent.

---

# 1) Server: expose τₗ꜀ and Tₘ (already have TS\_ratio)

In `server/helix-core.ts` (the `/api/helix/metrics` endpoint), add two fields so the UI can display the exact inputs the server used:

```ts
// server/helix-core.ts
export function getSystemMetrics(req: Request, res: Response) {
  const state = getGlobalPipelineState();

  // derive once here from the pipeline state used to compute TS_ratio
  const f_m = state.modulationFreq_GHz * 1e9;   // Hz
  const T_m = 1 / f_m;                          // s
  const { Lx_m, Ly_m, Lz_m } = state.hull ?? { Lx_m: 82, Ly_m: 82, Lz_m: 82 };
  const L_long = Math.max(Lx_m, Ly_m, Lz_m);
  const tauLC = L_long / 299_792_458;           // s

  res.json({
    // …existing fields…
    timeScaleRatio: state.TS_ratio,     // unchanged
    tauLC,                              // NEW: light-crossing time actually used
    T_m,                                // NEW: modulation period actually used
    hull: { Lx_m, Ly_m, Lz_m },         // optional: handy for UI readout
  });
}
```

Nothing else server-side needs to change—you already compute `state.TS_ratio` conservatively from the 1007 m length.

---

# 2) Live Energy Pipeline (Step 6): stop re-computing, use metrics

In `client/src/components/live-energy-pipeline.tsx`, the *Time-Scale Separation* step is currently calculating its own τₗ꜀ from a legacy radius. Replace those local calcs with the metrics you just exposed:

```tsx
// client/src/components/live-energy-pipeline.tsx
import { useMetrics } from "@/hooks/use-metrics"; // already used elsewhere

export function LiveEnergyPipeline(/* … */) {
  const { metrics } = useMetrics(); // polls /api/helix/metrics
  // …

  // Step 6 view values from the server (authoritative)
  const tauLC = metrics?.tauLC;     // s
  const T_m   = metrics?.T_m;       // s
  const TS    = metrics?.timeScaleRatio; // dimensionless

  // …
  {/* Step 6: Time-Scale Separation */}
  <div className="bg-muted/50 rounded-lg p-4">
    <h4 className="font-semibold text-sm mb-2 flex items-center">
      <span className="bg-primary text-primary-foreground rounded-full w-6 h-6 flex items-center justify-center text-xs mr-2">6</span>
      Time-Scale Separation
    </h4>

    <div className="font-mono text-sm space-y-1">
      <div>TS_ratio = τ_LC / T_m</div>
      <div className="text-muted-foreground">
        τ_LC = {formatScientific(tauLC)} s,&nbsp; T_m = {formatScientific(T_m)} s
      </div>
      <div className="text-primary font-semibold">
        TS_ratio = {formatStandard(TS)} {TS && TS > 100 ? "✓" : "✗"}
      </div>
    </div>
  </div>
  // …
}
```

> Result: Step 6 will show \~3.36 µs / 66.7 ps → **\~5.04×10⁴**, matching the server.

---

# 3) Metrics Dashboard: ensure it **reads** (not recomputes)

In `client/src/components/metrics-dashboard.tsx`, you’re already displaying `metrics.TS_ratio`, but a couple of debug/normalization lines still reference a local TS calc. Make sure they use the server value:

```tsx
// client/src/components/metrics-dashboard.tsx
// inside whatever prepares the radar / debug strings:
const TS = metrics.timeScaleRatio;  // authoritative
debugLines.push(
  `TS_ratio: ${TS.toFixed(1)} → ${normalizedData[4].toFixed(2)} (min: ${currentConstraints.TS_min})`
);

// and anywhere TS_ratio was recomputed, delete that code and keep the server TS
```

---

# 4) Remove any leftover hardcoded hull radius in UI helpers (optional)

If you have snippets that still do things like `const R_hull = 82;` for TS displays, delete or gate them behind a null-check, because the server now sends `metrics.hull` for context.

---

## Why this fixes the mismatch

* The server computes **everything** from the real needle geometry (1007×264×173 m) and modulation frequency, so that’s the source of truth.
* Some UI panels were still **recomputing** TS using a legacy 82 m radius; those numbers drifted. Reading τₗ꜀/Tₘ/TS from the server makes all panels agree and guarantees consistency when you change hull size or f\_m.

If you’d like, I can also add a tiny “info” line under Step 6 like:

> Hull (L×W×H): 1007 m × 264 m × 173 m • τₗ꜀ = 3.36 µs • Tₘ = 66.7 ps • TS = 5.04×10⁴

—pulled directly from `metrics.hull`, `metrics.tauLC`, and `metrics.T_m`.
