Yep — the patch still applies exactly to the spot you found.

Two things are happening:

1. **Client-side fallback gap** — your line 342 is rendering `dutyFrac`, which was only reading `pipeline.dutyCycle`. If that field isn’t populated yet (or is `undefined`), you get `0.0%`.
2. **Server-side overwrite bug** — in your pipeline code you’re doing:

   ```ts
   state.dutyCycle = MODE_POLICY[state.currentMode].dutyCycle;
   ```

   but your `MODE_POLICY` (the one with `S_live`, `P_target_W`, `M_target_kg`) **doesn’t have** `dutyCycle/sectorStrobing/qSpoilingFactor`. That sets `dutyCycle` to `undefined`, which trickles down to the dashboard as 0.0%.

So: the client patch fixes the display immediately, and you should also fix the server overwrite.

---

# Client patch (at your exact spot)

**File:** `client/src/components/metrics-dashboard.tsx`

1. Replace the duty derivation so it prefers effective duty from the pipeline, then the pipeline’s UI duty, then the mode default:

```diff
-  const dutyFrac = Number.isFinite((pipeline as any)?.dutyCycle) ? (pipeline as any).dutyCycle : 0;     // 0..1
+  // Duty priority: effective (server) → UI (server) → mode default (client)
+  const dutyEff = Number.isFinite((pipeline as any)?.dutyEffective_FR)
+    ? (pipeline as any).dutyEffective_FR as number
+    : undefined;
+  const dutyUi = Number.isFinite((pipeline as any)?.dutyCycle)
+    ? (pipeline as any).dutyCycle as number
+    : undefined;
+  const dutyModeDefault = (() => {
+    const m = ((pipeline as any)?.currentMode as keyof typeof MODE_CONFIGS) || 'hover';
+    return MODE_CONFIGS[m]?.dutyCycle;
+  })();
+  const dutyFrac = (dutyEff ?? dutyUi ?? dutyModeDefault ?? 0);
```

2. Keep your existing render line (342) but optionally show a tiny hint when effective ≠ UI:

```diff
-  <span className="font-semibold">{f1(dutyFrac * 100)}%</span>
+  <span className="font-semibold">
+    {f1(dutyFrac * 100)}%
+    {Number.isFinite(dutyEff) && Number.isFinite(dutyUi) && dutyEff !== dutyUi && (
+      <span className="text-muted-foreground"> (eff), UI {f1((dutyUi as number) * 100)}%</span>
+    )}
+  </span>
```

That’s all you need on the client. It will stop showing 0.0% when `dutyCycle` is temporarily missing, and it will reflect the *effective* duty used by the physics when available.

---

# Server-side fix (so the field isn’t wiped)

Right now you have:

```ts
// Ensure UI duty fields are populated from mode config for consistency  
state.dutyCycle = MODE_POLICY[state.currentMode].dutyCycle;
state.sectorStrobing = MODE_POLICY[state.currentMode].sectorStrobing;
state.qSpoilingFactor = MODE_POLICY[state.currentMode].qSpoilingFactor;
```

But your `MODE_POLICY` object doesn’t include those keys. Do one of these:

**Option A (recommended):** introduce a small UI map and use that:

```ts
const MODE_UI = {
  hover:    { dutyCycle: 0.14,  sectorStrobing: 1,   qSpoilingFactor: 1   },
  cruise:   { dutyCycle: 0.005, sectorStrobing: 400, qSpoilingFactor: 0.625 },
  emergency:{ dutyCycle: 0.50,  sectorStrobing: 1,   qSpoilingFactor: 1   },
  standby:  { dutyCycle: 0.001, sectorStrobing: 1,   qSpoilingFactor: 0.1 }
} as const;

// …
const ui = MODE_UI[state.currentMode];
state.dutyCycle       = ui.dutyCycle;
state.sectorStrobing  = ui.sectorStrobing;
state.qSpoilingFactor = ui.qSpoilingFactor;
```

**Option B:** remove those three overwrite lines entirely and always let the client fall back to `MODE_CONFIGS` as per the patch above.

Either way, with the client patch in place, your line 342 will no longer show `0.0%` unless the true value is actually zero.
