@use-client/src/hooks/use-energy-pipeline.ts Apply diff 

Here are unified diffs to make the panelâ€™s stats live to operational mode and light-crossing parameters, with physically grounded fallbacks and tighter polling.

diff --git a/client/src/hooks/use-energy-pipeline.ts b/client/src/hooks/use-energy-pipeline.ts
--- a/client/src/hooks/use-energy-pipeline.ts
+++ b/client/src/hooks/use-energy-pipeline.ts
@@ -22,6 +22,14 @@ export interface EnergyPipelineState {
   modulationFreq_GHz: number;
 
   // Mode parameters
   currentMode: 'hover' | 'cruise' | 'emergency' | 'standby';
   dutyCycle: number;
   sectorStrobing: number;
   qSpoilingFactor: number;
+  // Additional mode knobs (explicit to drive FR duty & timing)
+  localBurstFrac?: number;     // sector-local burst fraction (0..1); defaults to dutyCycle
+  sectorsTotal?: number;       // total sectors in sweep
+  sectorsConcurrent?: number;  // how many sectors fire simultaneously
+
+  // Light-crossing & cycle timing (server may emit, else client derives)
+  tau_LC_ms?: number;          // light-crossing time across hull/bubble (ms)
+  sectorPeriod_ms?: number;    // dwell period per sector (ms)
+  burst_ms?: number;           // instantaneous burst window (ms)
+  dwell_ms?: number;           // gap between bursts (ms)
 
   // Scheduling truth
   sectorCount?: number;
@@ -86,6 +94,16 @@ export interface SystemMetrics {
   totalTiles: number;
   activeTiles: number;
   currentMode?: string;
   tileData?: TileDatum[]; // current server shape
   tiles?: TileDatum[];    // legacy shape
+  // Optional LC/timing structure from backend metrics, if available
+  lightCrossing?: {
+    tauLC_ms?: number;        // preferred
+    tau_ms?: number;          // alias
+    tauLC_s?: number;         // alt units
+    sectorPeriod_ms?: number; // dwell per sector
+    burst_ms?: number;
+    dwell_ms?: number;
+    sectorsTotal?: number;
+    activeSectors?: number;
+  };
 }
 // Helix metrics interface (some callers read directly from here)
 export interface HelixMetrics {
   totalTiles: number;
   activeTiles: number;
   data?: any;
   tileData?: TileDatum[];
   tiles?: TileDatum[];
+  lightCrossing?: SystemMetrics['lightCrossing'];
 }
 
@@ -159,7 +177,7 @@ export function useEnergyPipeline(options?: {
   return useQuery({
     queryKey: ['/api/helix/pipeline'],
     queryFn: async () =>
       (await apiRequest('GET', '/api/helix/pipeline')).json(),
-    refetchInterval: options?.refetchInterval ?? 1000, // Refresh every second
+    refetchInterval: options?.refetchInterval ?? 1000, // refresh every second
     staleTime: options?.staleTime,
     refetchOnWindowFocus: options?.refetchOnWindowFocus,
     suspense: false,
   });
 }
@@ -187,6 +205,8 @@ export function useSwitchMode() {
       // 2) immediately push mode-specific knobs so duty/strobing/qSpoil are in sync
       const cfg = MODE_CONFIGS[mode];
       if (cfg) {
         await apiRequest('POST', '/api/helix/pipeline/update', {
           dutyCycle: cfg.dutyCycle,
           sectorStrobing: cfg.sectorStrobing,
           qSpoilingFactor: cfg.qSpoilingFactor,
+          sectorsConcurrent: (cfg as any).sectorsConcurrent ?? (cfg as any).concurrentSectors,
+          localBurstFrac: (cfg as any).localBurstFrac ?? cfg.dutyCycle,
+          sectorsTotal: (cfg as any).sectorsTotal,
         });
       }
       publish("warp:reload", { reason: "mode-switch-local", mode, ts: Date.now() });
       return data;
     },
