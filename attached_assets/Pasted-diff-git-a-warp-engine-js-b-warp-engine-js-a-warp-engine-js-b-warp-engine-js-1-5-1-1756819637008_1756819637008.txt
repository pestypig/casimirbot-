diff --git a/warp-engine.js b/warp-engine.js
--- a/warp-engine.js
+++ b/warp-engine.js
@@ -1,5 +1,23 @@
 // WarpEngine (WebGL runtime)
 // ------------------------------------------------------------
+// Radius helpers (use harmonic mean for meters↔ρ)
+function _aHarmonic(ax, ay, az) {
+  const a = +ax || 0, b = +ay || 0, c = +az || 0;
+  const denom = (a>0?1/a:0) + (b>0?1/b:0) + (c>0?1/c:0);
+  return denom > 0 ? 3/denom : NaN;
+}
+function _guessAH(U) {
+  // prefer hull axes; fall back to scene axes
+  const H = U?.axesHull, S = U?.axesScene;
+  if (Array.isArray(H) && H.length>=3) return _aHarmonic(H[0],H[1],H[2]);
+  if (Array.isArray(S) && S.length>=3) return _aHarmonic(S[0],S[1],S[2]);
+  return NaN;
+}
+// single default for ρ-thickness everywhere (previously 0.016/0.02/0.06)
+const WALL_RHO_DEFAULT = 0.016;
+
@@ -78,14 +96,37 @@ class WarpEngine {
     const U = this.uniforms || (this.uniforms = {});
 
-    // Wall width (in ρ) – previous code had multiple fallbacks (0.02/0.06)
-    // Keep alias "wallWidth" for shader uniform binding.
-    if (Number.isFinite(parameters.wallWidth)) {
-      U.wallWidth = +parameters.wallWidth;
-    }
+    // --- Wall width ingestion (meters & ρ with harmonic mean) ----------------
+    // Accept wallWidth_rho and/or wallWidth_m; derive the other using a_H.
+    // Keep "wallWidth" as an alias of wallWidth_rho for shader use.
+    // 1) stash axes first so a_H can be computed
+    if (Array.isArray(parameters.axesHull))  U.axesHull  = parameters.axesHull.slice(0,3);
+    if (Array.isArray(parameters.axesScene)) U.axesScene = parameters.axesScene.slice(0,3);
+    let aH = _guessAH(U);
+
+    // 2) accept explicit wall inputs
+    const hasWrho = Number.isFinite(parameters.wallWidth_rho);
+    const hasWm   = Number.isFinite(parameters.wallWidth_m);
+    if (hasWrho) U.wallWidth_rho = +parameters.wallWidth_rho;
+    if (hasWm)   U.wallWidth_m   = +parameters.wallWidth_m;
+
+    // 3) alias legacy "wallWidth" to ρ-units if present
+    if (Number.isFinite(parameters.wallWidth)) {
+      U.wallWidth_rho = +parameters.wallWidth;
+    }
+
+    // 4) derive missing counterpart via a_H (if available)
+    aH = _guessAH(U);
+    if (!Number.isFinite(U.wallWidth_rho) && Number.isFinite(U.wallWidth_m) && Number.isFinite(aH)) {
+      U.wallWidth_rho = U.wallWidth_m / aH;
+    }
+    if (!Number.isFinite(U.wallWidth_m) && Number.isFinite(U.wallWidth_rho) && Number.isFinite(aH)) {
+      U.wallWidth_m = U.wallWidth_rho * aH;
+    }
+
+    // 5) final defaults + alias for shader
+    if (!Number.isFinite(U.wallWidth_rho)) U.wallWidth_rho = WALL_RHO_DEFAULT;
+    U.wallWidth = U.wallWidth_rho;
 
-    // Axes inputs
-    if (Array.isArray(parameters.axesHull))  U.axesHull  = parameters.axesHull.slice(0,3);
-    if (Array.isArray(parameters.axesScene)) U.axesScene = parameters.axesScene.slice(0,3);
+    // ------------------------------------------------------------------------
 
     // q aliases
     if (Number.isFinite(parameters.qSpoilingFactor)) U.deltaAOverA = +parameters.qSpoilingFactor;
@@ -132,11 +173,13 @@ class WarpEngine {
     // CPU interior window width uses wallWidth_rho (unified)
-    const w_int = Number.isFinite(this.uniforms?.intWidth)
-      ? Math.max(0.002, +this.uniforms.intWidth)
-      : Math.max(3.0 * (this.uniforms?.wallWidth || 0.016), 0.02);
+    const w_int = Number.isFinite(this.uniforms?.intWidth)
+      ? Math.max(0.002, +this.uniforms.intWidth)
+      : Math.max(3.0 * (this.uniforms?.wallWidth_rho ?? WALL_RHO_DEFAULT), 0.02);
 
     // ... rest of render pass ...
   }
 
   _createGrid() {
     const U = this.uniforms || {};
-    const minAxis = Math.max(1e-3, Math.min(U.axesHull?.[0]||1, U.axesHull?.[1]||1, U.axesHull?.[2]||1));
-    const span_rho = Math.max(0.01, (3 * (+U.wallWidth_m || 6)) / minAxis);
+    // Grid span should reflect actual wall thickness in ρ units
+    const span_rho = Math.max(0.01, 3 * (U.wallWidth_rho ?? WALL_RHO_DEFAULT));
     // ... build grid with span_rho ...
   }
 }