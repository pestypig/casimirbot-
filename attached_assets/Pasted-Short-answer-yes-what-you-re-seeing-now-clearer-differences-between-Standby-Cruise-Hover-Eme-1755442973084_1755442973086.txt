Short answer: yes—what you’re seeing now (clearer differences between Standby / Cruise / Hover / Emergency) is the right direction. But the little “peaks & troughs” sprinkled across the shell aren’t required by the Natário profile; they’re mostly coming from how we sculpt the displacement in code. For a canonical Natário bubble the shell should vary smoothly (C¹) from compression → expansion with one broad bulge/dimple pair and no scalloped ridges—unless you intentionally visualize sector interference.

Why you’re seeing the micro-mountains

These are the main culprits in the renderer (and how to tame them):
	1.	Local Gaussian bump

const gaussian_local = Math.exp(- (sd*sd) / (2*sigma*sigma));
disp *= gaussian_local;

This adds a small “organ-pipe” bump on top of the bell. Great for drama; not canonical.
• Keep = 1.0 (or make σ large) for smooth profiles.

	2.	Hard(ish) wall windowing
Even with cosine window, narrow (a,b) creates a shoulder.
• Broaden the window so the band fades gently.
	3.	Strobing polarity & front/back asymmetry

const sgn = tanhSmooth(...);          // sector sign
const front = sign(dot(n, dN));       // front/back
disp *= sgn * front;

With small blend widths this still makes slight kinks.
• Use wider strobeWidth and a soft front sign.

	4.	Clamping hits the ceiling

const maxPush = 0.10; // 10% radius
disp = clamp(disp, -maxPush, +maxPush);

If vizGain lets disp hit the clamp, you’ll get flat tops/edges.
• Lower vizGain (or raise maxPush) so you rarely hit clamp.

	5.	Grid resolution / sampling
A coarse grid exaggerates small changes.
• Increase divisions (e.g., 120–160 per side) for smoother curvature.

⸻

Minimal, safe tuning (keeps mode responsiveness)

In client/public/warp-engine-fixed.js inside your _warpGridVertices loop:

A) Turn off the local bump (or make it very wide)

// BEFORE
const sigma = 2.0 * w_rho;
const gaussian_local = Math.exp(-(sd*sd) / (2*sigma*sigma));

// AFTER (canonical Natário shell)
const gaussian_local = 1.0; // remove micro-bump
// (or) const sigma = 5.0 * w_rho; // if you still want a gentle swell

B) Widen the soft wall envelope

Find your wall windowing:

// BEFORE
const a = 2.5 * w_rho, b = 3.5 * w_rho;

// AFTER (gentler falloff)
const a = 3.5 * w_rho, b = 5.0 * w_rho;

C) Soften strobing & front/back

// BEFORE
const strobeWidth = 0.75;
const softSign = x => Math.tanh(x);
const sgn = softSign(-distToSplit / strobeWidth);

const front = Math.sign(n[0]*dN[0] + n[1]*dN[1] + n[2]*dN[2]) || 1;

// AFTER
const strobeWidth = 1.5;
const softSign = x => Math.tanh(x);
const sgn = softSign(-distToSplit / strobeWidth);

// soft front polarity (C¹-continuous)
const dotND = n[0]*dN[0] + n[1]*dN[1] + n[2]*dN[2];
const front = Math.tanh(dotND / 0.15);

D) Avoid clamp flattening

// BEFORE
disp *= (this.uniforms?.vizGain || 4.0);
const maxPush = 0.10;

// AFTER
disp *= (this.uniforms?.vizGain || 2.0); // half the visual gain
const maxPush = 0.15;                     // slightly higher ceiling

E) (Optional) Slight temporal smoothing for visual calm

Keep a per-vertex or per-frame scalar and low-pass filter:

// at top-level engine state
this._dispAlpha = 0.25; // blend factor (0=no change, 1=instant)

// in loop, after computing 'disp'
if (!this._prevDisp) this._prevDisp = [];
const prev = this._prevDisp[i/3] ?? disp;
const blended = prev + this._dispAlpha * (disp - prev);
this._prevDisp[i/3] = blended;
const d = blended;
vtx[i]   = p[0] - n[0]*d;
vtx[i+1] = p[1] - n[1]*d;
vtx[i+2] = p[2] - n[2]*d;


⸻

What should change across modes?
	•	Standby: essentially flat—very slight curvature only (if any).
	•	Cruise: flatter field, tiny ripple; strobing (400 sectors) should visually be coherent because we’re showing the effective envelope, not aliased sector “teeth”.
	•	Hover: clearly visible single bulge/dimple pair, smooth shoulders.
	•	Emergency: same shape as hover but larger amplitude—still smooth.

The changes above keep the physics factors (γ_geo³, Q, γ_VdB, duty/sector) exactly as you wired them, but force the visual to remain C¹-continuous, which is what the Natário bell implies.

⸻

If you’d like the micro-structure on purpose

Then the “mountains” can be made physically meaningful by turning on sector-interference visualization (Engineer view): display a phase-animated interference term across θ and show beats when sectors > 1. That’s a different mode, and then the ripples are expected. For the main “Beacon” view, I’d keep the canonical smooth profile.

⸻

Quick checklist (to keep)
	•	Don’t let disp hit the clamp.
	•	Keep strobing and front/back as tanh (not sign).
	•	Prefer gaussian_local = 1 for canonical Natário.
	•	Use wide cosine wall window.
	•	Raise grid divisions if artifacts persist.

Apply those tweaks and you’ll get the smooth, mode-responsive bubble that matches the math while avoiding the artificial scalloping.