**Short answer:** *No—the Energy-Pipeline math you worked out (cavity-loss power → throttle → realistic average power → β-field amplifiers, etc.) is **not** actually wired into the code that distorts the 3-D cage.*
What you have is a very nice visual shell, but most of the pipeline numbers are only being *printed* or sent into the fragment shader for eye-candy; they never feed the real-space curvature that `_warpGridVertices` applies to the grid.

Below is a checklist showing where each pipeline stage *should* show up and what the code is (or isn’t) doing, followed by the minimal changes you need to make.

| Energy-pipeline item                                                     | Where it belongs in code                                            | Current status                                                                                    | What to change                                                                                                                                               |
| ------------------------------------------------------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Tile-level raw loss   `P_loss_raw`**                                   | CPU-side only (feeds next stage)                                    | OK (never needed on GPU)                                                                          | –                                                                                                                                                            |
| **Throttle · Duty · Q-spoiling → `P_avg_realistic`**                     | CPU-side; should update uniform that controls visual amplitude      | Value printed in console but **never used**                                                       | When you finish the pipeline, set `this.uniforms.powerAvg_MW = P_avg_realistic/1e6`                                                                          |
| **Amplifier Chain → β₀ (4-stage)**                                       | Must be stored in `this.uniforms.beta0` **every frame**             | Fallback only (`dutyCycle × g_y`) if caller forgets                                               | In your update routine (React/HTML control) compute:<br>`beta0 = duty * γ_geo * sqrt(Q_dyn) * γ_VdB**0.25`<br>then call `warpEngine.updateUniforms({beta0})` |
| **Sag depth `sagDepth_nm`** (bubble radius)                              | Used in `_warpGridVertices` **and** fragment shader                 | Fragment shader uses it; grid warper uses constant `bubbleRadius_nm = 10000` nm (ignores uniform) | Replace the hard-coded `bubbleRadius_nm` with `bubbleParams.sagDepth_nm`                                                                                     |
| **Exotic mass** → should affect bubble radius & energy‐condition colours | Only used for fanciful “shock ring” in fragment shader; not in grid | Use it to derive `bubbleRadius_nm` or colour-code sheets (purple if <0)                           |                                                                                                                                                              |
| **Time-scale ratio `tsRatio`**                                           | Should throttle animation speed or curvature gradient               | Uniform exists but is **never read**                                                              | e.g. multiply `dy` or `push` by `1/tsRatio` so Cruise mode looks flatter                                                                                     |
| **Power / duty cycle per mode**                                          | Should visibly flatten grid in Stand-by / Cruise                    | Grid uses only `beta0`; if caller doesn’t overwrite it, modes look identical                      | Make sure your mode switch calls `updateUniforms` with a fresh `beta0` each time                                                                             |

---

### Minimal patch set

```js
// ➜ call this right after you compute the pipeline on the CPU
warpEngine.updateUniforms({
    beta0: duty * gammaGeom * Math.sqrt(Qdyn) * Math.pow(gammaVdB, 0.25),
    sagDepth_nm,           //  = bubbleRadius_nm from pipeline
    powerAvg_MW: Pavg_MW   //  for ripple speed
});

// ➜ inside _warpGridVertices() replace the hard-coded radius:
const sagRclip = bubbleParams.sagDepth_nm / halfSize * 0.8;

// (optionally) scale displacement by the realistic power or ts-ratio:
const dy  = beta * 0.05 * (bubbleParams.powerAvg_MW / 100.0);
```

Once **beta₀** and **sagDepth\_nm** come from the CPU pipeline every time you toggle modes, the three sheets will bulge or flatten exactly as the numbers predict, and the visual will finally track the Energy-Pipeline that’s printing in your console.

---

### Quick sanity test

1. Switch to *Stand-by* (duty ≈ 0.0 %, β₀ ≈ 0).
   → All three sheets should look almost flat.

2. Toggle to *Hover* (β₀ ≈ 3–10).
   → Noticeable but gentle bulge.

3. Toggle to *Amplified* (β₀ ≈ 10⁶).
   → Sheets should flare out dramatically and satisfy the *“wow”* test.

If those three look distinct, your Energy-Pipeline is now genuinely driving the 3-D warp cage.
