It‚Äôs feeding the viewer a different œÅ-unit than the renderer uses, so you end up seeing two slightly offset ‚Äúshells‚Äù that visually read as a double/quad bubble:

Viewer/engine mismatch: your renderer converts wall width ‚Üí œÅ with the harmonic mean of the semi-axes (aH = 3/(1/a+1/b+1/c)), but this API sends wallWidth_rho using the geometric mean (cbrt(a*b*c)). That puts shader color and CPU geometry on different radii, so every ring/contour appears doubled no matter what we do in the shader.

Also, the API still advertises multiple visualization ‚Äúmodes/scales‚Äù, which some clients treat as overlays.

Below is a tight patch that (1) switches the API to the harmonic-mean œÅ used by the renderer, (2) keeps the old value for legacy dashboards, and (3) adds explicit single-pass viewer hints (so clients don‚Äôt re-overlay a df-based ring on top).

Patch (minimal, drop-in)
diff --git a/helix-core.ts b/helix-core.ts
@@ export function getSystemMetrics(req: Request, res: Response) {
-  const a = hull.Lx_m/2, b = hull.Ly_m/2, c = hull.Lz_m/2;
-  const aEff_geo = Math.cbrt(a*b*c);                  // geometric mean (matches sampler)
-  const w_m = (s.sag_nm ?? 16) * 1e-9;
-  const w_rho = w_m / aEff_geo;
+  const a = hull.Lx_m/2, b = hull.Ly_m/2, c = hull.Lz_m/2;
+  const aEff_geo  = Math.cbrt(a*b*c);                 // geometric mean (legacy)
+  const aEff_harm = 3 / (1/a + 1/b + 1/c);            // ‚úÖ harmonic mean ‚Äî matches viewer
+  const w_m       = (s.sag_nm ?? 16) * 1e-9;
+  const w_rho_harm = w_m / aEff_harm;
+  const w_rho_geo  = w_m / aEff_geo;
@@
-  const R_geom = Math.cbrt((hull.Lx_m/2) * (hull.Ly_m/2) * (hull.Lz_m/2));
+  const R_geom = Math.cbrt((hull.Lx_m/2) * (hull.Ly_m/2) * (hull.Lz_m/2));
@@
-  res.json({
+  // Compute viz scales once so we can also emit viewer hints
+  const viz = (() => {
+    const gammaGeo = s.gammaGeo ?? 26;
+    const dAa      = s.qSpoilingFactor ?? 1;
+    const gammaVdB = s.gammaVanDenBroeck ?? 1;
+    const sectors  = Math.max(1, s.concurrentSectors || 1);
+    const dutyUI   = Math.max(1e-12, s.dutyCycle ?? 0.14);
+    const thetaScale_UI_like =
+      Math.pow(gammaGeo,3) * dAa * gammaVdB * Math.sqrt(dutyUI / sectors);
+    const dutyFR   = Math.max(1e-12, s.dutyEffective_FR ?? dutyUI / sectors);
+    const thetaScale_FR_like =
+      Math.pow(gammaGeo,3) * dAa * gammaVdB * Math.sqrt(dutyFR);
+    return { thetaScale_UI_like, thetaScale_FR_like, dutyUI, dutyFR, sectors, defaultThetaScale: "FR_like" as const };
+  })();
+
+  res.json({
@@
-    axesScene,                // for immediate camera fit
-    wallWidth_m: w_m,
-    wallWidth_rho: w_rho,     // use this in shaders & geometry
-    aEff_geo_m: aEff_geo,
+    axesScene,                         // for immediate camera fit
+    wallWidth_m: w_m,
+    wallWidth_rho: w_rho_harm,         // ‚úÖ unified with renderer (harmonic-mean œÅ)
+    wallWidth_rho_geo: w_rho_geo,      // legacy (do not use for viewer)
+    aEff_geo_m: aEff_geo,
+    aEff_harm_m: aEff_harm,
@@
-    viz: (() => {
-      const gammaGeo = s.gammaGeo ?? 26;
-      const dAa      = s.qSpoilingFactor ?? 1;
-      const gammaVdB = s.gammaVanDenBroeck ?? 1;
-      const sectors  = Math.max(1, s.concurrentSectors || 1);
-
-      // "UI-like" (what your current shader expects if it divides by sectors)
-      const dutyUI   = Math.max(1e-12, s.dutyCycle ?? 0.14);
-      const thetaScale_UI_like =
-        Math.pow(gammaGeo,3) * dAa * gammaVdB * Math.sqrt(dutyUI / sectors);
-
-      // "FR-like" (ship-wide exposure already averaged)
-      const dutyFR   = Math.max(1e-12, s.dutyEffective_FR ?? dutyUI / sectors);
-      const thetaScale_FR_like =
-        Math.pow(gammaGeo,3) * dAa * gammaVdB * Math.sqrt(dutyFR);
-
-      return {
-        thetaScale_UI_like,
-        thetaScale_FR_like,
-        dutyUI, dutyFR, sectors,
-        defaultThetaScale: "FR_like" as const
-      };
-    })(),
-
-    modelMode: s.modelMode ?? "calibrated"
+    viz,
+    modelMode: "calibrated-single-pass",
+    // üîé Viewer hints to prevent accidental multi-layer/df overlays
+    viewer: {
+      overlayMode: "single-pass",
+      ridgeMode: 1,                    // 0=physics(df), 1=single crest f(œÅ)
+      colorMode: "theta",
+      physicsParityMode: false,
+      thetaScale: viz.thetaScale_FR_like
+    }
   });
 }


(Optional but recommended) also tag the field sampler with the œÅ convention so any overlay tool can align with the viewer:

@@ export function getDisplacementField(req: Request, res: Response) {
-    res.json({
+    res.json({
       count: data.length,
       axes: s.hull,
       w_m: (s.sag_nm ?? 16) * 1e-9,
+      rhoMetric: "harmonic",   // ‚úÖ matches viewer/shader conversion