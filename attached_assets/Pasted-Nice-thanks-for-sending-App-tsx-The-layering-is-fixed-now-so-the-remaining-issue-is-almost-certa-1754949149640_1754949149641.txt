Nice—thanks for sending `App.tsx`. The layering is fixed now, so the remaining issue is almost certainly that your **3D BackgroundLuma isn’t drawing anything** (GLB didn’t render), which makes the layer look “invisible”.

Fastest way to prove it and unblock you:

## Option 1 (quickest): force the PNG background for now

This verifies the portal + z-order are correct. If you see the PNG, we know the 3D GLB was the only missing piece.

**Patch `App.tsx`:**

```diff
- import { BackgroundLuma } from "@/components/BackgroundLuma";
+ import BackgroundLumaPNG from "@/components/BackgroundLumaPNG";
```

```diff
- <LumaBackgroundPortal>
-   <BackgroundLuma opacity={0.12} blurPx={8} />
- </LumaBackgroundPortal>
+ <LumaBackgroundPortal>
+   <BackgroundLumaPNG opacity={0.18} blurPx={6} />
+ </LumaBackgroundPortal>
```

Reload. If you see the soft, blurred star now, great—your portal/layering are fine, and only the GLB render path needs love.

---

## Option 2 (keep 3D, add a built-in PNG fallback)

If you’d rather keep the Three.js component mounted, patch `BackgroundLuma.tsx` so it shows the PNG whenever the GLB fails to load (or WebGL isn’t available):

At the **top** of `BackgroundLuma.tsx` add:

```tsx
import BackgroundLumaPNG from "@/components/BackgroundLumaPNG";
```

Inside the component (before `return`), add a tiny WebGL check:

```tsx
const hasWebGL = React.useMemo(() => {
  try {
    const c = document.createElement("canvas");
    return !!(c.getContext("webgl") || c.getContext("experimental-webgl"));
  } catch { return false; }
}, []);
```

Then **replace** the current `return` with:

```tsx
return (
  <div style={{ width:"100%", height:"100%", opacity, filter:`blur(${blurPx}px)` }}>
    {hasWebGL ? (
      <Canvas
        camera={{ position: [0, 0, 16], fov: 35 }}
        dpr={[1, 1.5]}
        gl={{ antialias: true, powerPreference: "low-power" }}
        onCreated={({ gl }) => gl.setClearColor("#000000", 0)}
      >
        <ambientLight intensity={0.8} />
        <directionalLight position={[6, 8, 10]} intensity={1.1} />
        <React.Suspense fallback={null}>
          <LumaModel url={glbUrl} />
        </React.Suspense>
      </Canvas>
    ) : (
      <BackgroundLumaPNG opacity={opacity} blurPx={blurPx} />
    )}
  </div>
);
```

And inside `LumaModel`, if you currently `return null` on error, replace that with:

```tsx
catch {
  return <BackgroundLumaPNG opacity={0.18} blurPx={6} />;
}
```

That way you always see *something* even if the GLB/animations aren’t available yet.

---

## Why this helps

* Right now `App.tsx` mounts the **3D** `BackgroundLuma`. If the GLB didn’t load or render, that component draws **nothing**, so it looks invisible even though the layer is working.
* Forcing `BackgroundLumaPNG` proves the layer path. Once you see it, we can safely flip back to 3D and debug the model path/scale/animations without risking the rest of the site.

If you want, after you try Option 1 tell me what you see. If the PNG renders, I’ll give you a tiny GLB check (console asserts + auto-scale clamp) so the 3D version “just works” and falls back gracefully if anything is off.
