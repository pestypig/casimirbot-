Stop double-applying alpha
You compute mechAlpha = finalAlpha * alphaMod and also set ctx.globalAlpha = finalAlpha before stroking. That multiplies alpha twice. Fix: bake the whole alpha into the per-color RGBA and set globalAlpha = 1 while drawing shells.

Optional live animation for the â€œbreathingâ€ (right now it only updates on resize/prop changes). Easiest: if params.animate is true, just re-queue a frame at the end of _draw().

Make console quiet by default (guard logs behind params.debug).

Legend: show actual burst (ms) next to Ï„LC/Tsec so the FR window is visible numerically.

Tiny safety nits: clamp/normalize inputs you already read (done), and keep line widths in CSS pixels (youâ€™re good thanks to setTransform(pr,...)).

Minimal patch (drop-in)
   function OutlineEngine(canvas) {
     ...
     this.params = {
       ...
+      debug: false,
+      animate: false,
       ...
     };
     ...
   }

   OutlineEngine.prototype._draw = function () {
     const ctx = this.ctx;
     const p   = this.params;
     const clamp01 = (x) => Math.max(0, Math.min(1, x));
     ...
-    const finalAlpha = (0.9 + breathe) * modeAlpha;
+    const finalAlpha = (0.9 + breathe) * modeAlpha;

     // Shell styling that responds to mechanical resonance
     const alphaMod = 0.6 + 0.4 * mechGain;
     const thicknessMod = 1.0 + 0.5 * mechGain;
-    const mechAlpha = finalAlpha * alphaMod;
+    const shellAlpha = finalAlpha * alphaMod;

     ...
-    const baseInner = `rgba(${innerColor[0]},${innerColor[1]},${innerColor[2]},${0.60 * mechAlpha})`;
-    const baseCenter= `rgba(${centerColor[0]},${centerColor[1]},${centerColor[2]},${0.45 * mechAlpha})`;
-    const baseOuter = `rgba(${outerColor[0]},${outerColor[1]},${outerColor[2]},${0.60 * mechAlpha})`;
+    const baseInner = `rgba(${innerColor[0]},${innerColor[1]},${innerColor[2]},${0.60 * shellAlpha})`;
+    const baseCenter= `rgba(${centerColor[0]},${centerColor[1]},${centerColor[2]},${0.45 * shellAlpha})`;
+    const baseOuter = `rgba(${outerColor[0]},${outerColor[1]},${outerColor[2]},${0.60 * shellAlpha})`;

     ...
-    shells.forEach(s => {
+    // Use per-color alpha; no global alpha for shells
+    shells.forEach(s => {
-      ctx.globalAlpha = finalAlpha;
+      ctx.globalAlpha = 1.0;
       ctx.strokeStyle = s.color;
       ctx.lineWidth   = s.line;
       ...
     });

     ...
-    console.log(`ðŸ”§ OUTLINE ENGINE: mechGain=${mechGain.toFixed(3)}, mechMod=${mechMod.toFixed(2)}x, f_mod=${((p.fMod_Hz??15e9)/1e9).toFixed(1)}GHz, Î¶=${(p.mechZeta??0.005).toFixed(3)}`);
+    if (p.debug) {
+      console.log(`ðŸ”§ OUTLINE: mechGain=${mechGain.toFixed(3)}, mechMod=${mechMod.toFixed(2)}x, f_mod=${((p.fMod_Hz??15e9)/1e9).toFixed(1)}GHz, Î¶=${(p.mechZeta??0.005).toFixed(3)}`);
+    }

     // Mini legend with mode indicator
     ctx.globalAlpha = 0.9;
     ...
-    const tauLCs  = Number.isFinite(lc.tauLC_ms) ? `${(lc.tauLC_ms/1000).toFixed(3)}s` : 'â€”';
-    const dwellMs = Number.isFinite(lc.dwell_ms) ? `${lc.dwell_ms.toFixed(2)}ms` : 'â€”';
+    const tauLCs  = Number.isFinite(lc.tauLC_ms) ? `${(lc.tauLC_ms/1000).toFixed(3)}s` : 'â€”';
+    const dwellMs = Number.isFinite(lc.dwell_ms) ? `${lc.dwell_ms.toFixed(2)}ms` : 'â€”';
+    const burstMs = Number.isFinite(lc.burst_ms) ? `${lc.burst_ms.toFixed(2)}ms` : 'â€”';
     const frTxt   = Number.isFinite(p.zeta) ? `Î¶=${p.zeta.toFixed(3)} ${p.zeta>=1?'(WARN)':'(PASS)'}` : 'Î¶=â€”';
-    ctx.fillText(`Î³Â³=${gamma3.toExponential(1)} â€¢ duty_FR=${(dutyEff*100).toFixed(2)}% â€¢ mech:${mechStatus}`, 18, 74);
-    ctx.fillText(`Ï„LC=${tauLCs} â€¢ Tsec=${dwellMs} â€¢ ${frTxt}`, 18, 88);
+    ctx.fillText(`Î³Â³=${gamma3.toExponential(1)} â€¢ duty_FR=${(dutyEff*100).toFixed(2)}% â€¢ mech:${mechStatus}`, 18, 74);
+    ctx.fillText(`Ï„LC=${tauLCs} â€¢ Tsec=${dwellMs} â€¢ burst=${burstMs} â€¢ ${frTxt}`, 18, 88);

+    // Keep animating if requested (for breathing/tilt shimmer)
+    if (p.animate) this._requestDraw();
   };


You can now flip animate:true (and optionally debug:true) from the React wrapper when you want a live, subtle pulse.