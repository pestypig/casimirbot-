Here’s a minimal, safe patch that makes the renderer take the pipeline’s thetaScale and dutyEffectiveFR explicitly (single source of truth). The adapter already forwards dutyEffectiveFR and computes an audit thetaScaleExpected; this patch adds a thetaScale pass-through (preferring a server value if present, else the audit/derived value).

diff --git a/warp-pipeline-adapter.ts b/warp-pipeline-adapter.ts
index 9b2c1ab..e4c7f6d 100644
--- a/warp-pipeline-adapter.ts
+++ b/warp-pipeline-adapter.ts
@@ -31,6 +31,7 @@ export interface EnergyPipelineState {
   modelMode?: "calibrated" | "raw";
 
   // Optional for fallbacks
   dutyEffective_FR?: number;
   thetaScaleExpected?: number;           // precomputed server value for verification
+  thetaScale?: number;                   // NEW: authoritative θ from pipeline (if provided)
 }
 
 /**
@@ -55,6 +56,7 @@ export function driveWarpFromPipeline(engine: any, s: EnergyPipelineState): void
   const qSpoil = Math.max(1e-12, num(s.qSpoilingFactor) ?? 1);
 
   // Let the gate/engine compute authoritative θ. Provide only an audit value.
-  const thetaScaleExpected =
+  const thetaScaleExpected =
     Math.pow(gammaGeo, 3) *
     qSpoil *
     gammaVdB *
     Math.sqrt(Math.max(1e-12, d_ship));
+
+  // Prefer a server-provided θ; else fall back to server audit; else local calc
+  const thetaForEngine =
+    num(s.thetaScale) ??
+    num(s.thetaScaleExpected) ??
+    thetaScaleExpected;
@@ -72,6 +76,7 @@ export function driveWarpFromPipeline(engine: any, s: EnergyPipelineState): void
       // Do not set physicsParityMode/ridgeMode here; pass them from the caller (REAL/SHOW)
-      dutyCycle: d_ship, // ship-wide effective duty
-      dutyEffectiveFR: d_ship, // FR duty for calculations
+      dutyCycle: d_ship,          // ship-wide effective duty
+      dutyEffectiveFR: d_ship,    // FR duty for calculations (explicit)
+      thetaScale: thetaForEngine, // NEW: explicit θ for renderer (authoritative when present)
       sectorCount: sectorsTotal, // total wedges
       sectors: split, // +/- split for viz that expects half-count
       gammaGeo,
       gammaVanDenBroeck: gammaVdB,
       qSpoilingFactor: qSpoil,
@@ -82,6 +87,7 @@ export function driveWarpFromPipeline(engine: any, s: EnergyPipelineState): void
       wallWidth_rho: w_rho,
 
       // Audit-only; do not override engine θ
       thetaScaleExpected,
 
       // Visual defaults locked by gating system
       colorMode: "theta",
       viewAvg: true,
     },
     "server"
   );
 }

Why this is sufficient

Renderer already prefers host θ: nextUniforms.thetaScale uses the passed parameters.thetaScale if finite (falls back only if absent), so forwarding it makes the UI numerically identical to the pipeline’s θ and the amplitude read path uses this.uniforms?.thetaScale directly.

Explicit FR duty is already honored: the engine consumes dutyEffectiveFR when present; the adapter has been sending it as d_ship.

No other files need changing for this behavior.