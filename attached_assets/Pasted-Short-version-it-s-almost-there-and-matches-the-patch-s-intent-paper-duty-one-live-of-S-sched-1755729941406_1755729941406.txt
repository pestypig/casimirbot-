Short version: it’s **almost** there and matches the patch’s intent (paper duty, one-live-of-S scheduling, two calibration knobs). But there are a few correctness/consistency nits that will bite you at runtime/HUD:

### ✅ Looks good

* `tileArea_cm2 = 25` and `RADIAL_LAYERS = 10` with a packing factor → sane `N_tiles`.
* Paper duty is used: `d_eff = 0.01 * (S_live/400)` (S\_live=2 in hover, 1 otherwise).
* Power path is **raw** (no mech boost) unless cruise calibration is on.
* Mass path uses `γ_geo³ · Q_BURST · γ_VdB · d_eff` and the cruise calibration rescales `γ_VdB` only.
* Ford–Roman proxy uses **`d_eff`** and `Q_quantum = 1e12`.

### ⚠️ Needed fixes (small but important)

1. **Keep state consistent after power calibration**
   You recompute power with a boosted `U_geo_boost`, but you don’t reflect that in `state.U_Q` and `state.P_loss_raw`. Downstream/HUD can read stale values.

   **Fix:**

   ```ts
   // after scaling qMechanical in cruise calibration
   state.U_Q = U_geo * state.qMechanical;               // keep state consistent
   state.P_loss_raw = Math.abs(state.U_Q) * omega / Q_BURST; // per-tile ON-window
   ```

2. **`curvatureLimit` is checking the wrong thing**
   You currently compute:

   ```ts
   state.curvatureLimit = Math.abs(state.U_Q ?? 0) < 1e-10;
   ```

   That will almost always be false (U\_Q is not \~0), pushing status to WARNING/CRITICAL.

   **Fix (use the *duty-cycled* stored energy):**

   ```ts
   state.U_cycle = state.U_Q * d_eff;                 // you already have d_eff
   state.curvatureLimit = Math.abs(state.U_cycle ?? 0) < 1e-10;
   ```

3. **Expose sectoring consistently for the HUD**
   You compute `activeSectors/S_total`, but `state.sectorStrobing` may still be 1 (from UI). If the UI/HUD reads `sectorStrobing` to render, it will look inconsistent.

   **Fix (non-invasive):**

   ```ts
   state.sectorStrobing = S_total;   // 400 for paper partitioning in physics
   ```

   (UI can still show user‐mode duty however it wants; this keeps the physics view coherent.)

4. **Name/telemetry alignment for duties**
   You set:

   ```ts
   state.dutyBurst        = d_eff;
   state.dutyEffective_FR = d_eff;
   ```

   That’s fine numerically, but the **names** suggest different meanings (instantaneous vs averaged). If your client code expects the old semantics, this can be confusing.

   **Safer telemetry:**

   ```ts
   state.dutyBurst        = BURST_DUTY_LOCAL;  // 0.01 (10 µs / 1 ms)
   state.dutyEffective_FR = d_eff;             // 0.01 * (S_live/400)
   ```

5. **Audit guard (optional but handy)**
   Keep the pipeline self-consistent if a UI variable leaks back in:

   ```ts
   (function audit() {
     const P_tile = Math.abs(state.U_Q) * omega / Q_BURST;
     const P_exp  = P_tile * state.N_tiles * d_eff / 1e6;
     if (Math.abs(state.P_avg - P_exp) > 1e-6 * Math.max(1, P_exp)) {
       console.warn("[AUDIT] P_avg drift; correcting", {reported: state.P_avg, expected: P_exp});
       state.P_avg = P_exp;
     }

     const E_tile = Math.abs(state.U_static) * Math.pow(state.gammaGeo,3)
                  * Q_BURST * state.gammaVanDenBroeck * d_eff;
     const M_exp  = (E_tile / (C*C)) * state.N_tiles;
     if (Math.abs(state.M_exotic - M_exp) > 1e-6 * Math.max(1, M_exp)) {
       console.warn("[AUDIT] M_exotic drift; correcting", {reported: state.M_exotic, expected: M_exp});
       state.M_exotic_raw = state.M_exotic = M_exp;
     }
   })();
   ```

### Tiny diff you can paste

```ts
// === inside cruise calibration block, after scaling qMechanical ===
state.qMechanical *= scaleP;
state.U_Q = U_geo * state.qMechanical;                    // NEW: keep state coherent
state.P_loss_raw = Math.abs(state.U_Q) * omega / Q_BURST; // NEW: per-tile (ON-window)
P_total_W = state.P_loss_raw * state.N_tiles * d_eff;
state.P_avg = P_total_W / 1e6;

// === curvatureLimit ===
state.U_cycle = state.U_Q * d_eff;
state.curvatureLimit = Math.abs(state.U_cycle ?? 0) < 1e-10; // was U_Q

// === sectoring HUD coherence ===
state.sectorStrobing = S_total; // 400

// === telemetry naming ===
state.dutyBurst        = BURST_DUTY_LOCAL; // 0.01
state.dutyEffective_FR = d_eff;            // 0.01 * S_live/400
```

With those tweaks, the code faithfully implements the patch: **raw physics by default**, and when `CRUISE_CALIBRATION=1` you get the **same end values** as the old file but without any hidden multipliers—`qMechanical` (power-only) and `γ_VdB` (mass-only) are the only delegated knobs.
