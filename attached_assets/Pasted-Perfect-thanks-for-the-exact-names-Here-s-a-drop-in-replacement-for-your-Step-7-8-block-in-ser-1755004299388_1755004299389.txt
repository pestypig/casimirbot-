Perfect—thanks for the exact names. Here’s a drop-in replacement for your **Step 7–8** block in `server/energy-pipeline.ts` that uses `state.qCavity`, `state.sectorStrobing`, and `state.N_tiles` verbatim, removes the paper hard-locks, and keeps an optional, transparent mass calibration you can toggle via env.

### Replace your current Step 7–8 with this

```ts
/* ──────────────────────────────
   Step 7: Power (physics-first)
   P_loss_per_tile ≈ ω · |U_Q| / Q_eff
   Average power scales with duty and active fraction.
──────────────────────────────── */
const omega = 2 * PI * (state.modulationFreq_GHz ?? 15) * 1e9;

// Effective Q with spoiling
const Q_eff = Math.max(1, (state.qCavity ?? 1e9) * (state.qSpoilingFactor ?? 1));

// Raw per-tile dissipation (J/s)
const P_loss_per_tile_raw = Math.abs(state.U_Q ?? 0) * omega / Q_eff;

// Tiles & strobing
const N_tiles       = Math.max(1, Math.round(state.N_tiles ?? 1.96e9));
const sectorsActive = Math.max(1, Math.round(state.sectorStrobing ?? 1));
const activeFrac    = Math.min(1, sectorsActive / N_tiles);

// Duty
const duty          = Math.max(0, Math.min(1, state.dutyCycle ?? 0.14));

// Hull average power
const P_total_W     = P_loss_per_tile_raw * N_tiles * duty * activeFrac;

state.P_loss_raw    = P_loss_per_tile_raw;   // W per tile (raw)
state.P_avg         = P_total_W / 1e6;       // MW (physics value)

/* ──────────────────────────────
   Step 8: Exotic mass (physics-first)
   E_tile_enh = |U_static| · (γ_geo^3) · Q_burst · γ_VdB · duty
   M_raw_total = (E_tile_enh / c^2) · N_tiles
   Optional calibration scales MASS ONLY (never γ_VdB).
──────────────────────────────── */

// Physics truth: Van den Broeck seed factor (configurable)
const gammaVdBSeed = Number(process.env.GAMMA_VDB_SEED) || 1e11;
state.gammaVanDenBroeck = gammaVdBSeed;

// Geometric / DCE amplification
const gammaGeo  = state.gammaGeo ?? 26;
const geoAmp    = Math.pow(gammaGeo, 3);        // γ_geo^3
const qBurst    = state.qCavity ?? 1e9;         // use cavity Q as the DCE burst/Q factor

// Per-tile enhanced energy over a cycle
const U_static_abs = Math.abs(state.U_static ?? 0);   // J (from calculateStaticCasimir)
const E_tile_enh   = U_static_abs * geoAmp * qBurst * gammaVdBSeed * duty;

// Raw physics totals
const massPerTile_kg = E_tile_enh / (C * C);
const M_raw_total_kg = massPerTile_kg * N_tiles;

state.M_exotic_raw   = M_raw_total_kg;

// Optional paper-target lock (transparent + reversible)
const MASS_LOCK      = process.env.MASS_LOCK_TO_TARGET === "1";
const TARGET_MASS_KG = Number(process.env.MASS_TARGET_KG ?? 1405);
const massCalibration = MASS_LOCK && M_raw_total_kg > 0
  ? (TARGET_MASS_KG / M_raw_total_kg)
  : 1;

state.massCalibration = massCalibration;
state.M_exotic        = M_raw_total_kg * massCalibration;

/* ──────────────────────────────
   Additional metrics (derived)
──────────────────────────────── */

// Time-scale ratio TS ≡ T_hull / T_m
const R_hull   = 82;  // m
const f_m      = (state.modulationFreq_GHz ?? 15) * 1e9;
const T_m      = 1 / f_m;
const T_hull   = R_hull / C;
state.TS_ratio = T_hull / T_m;

// Ford–Roman proxy (use effective duty incl. strobing & spoiling)
const Q_quantum = 1e10;
const effectiveDuty = duty * (state.qSpoilingFactor ?? 1) * activeFrac;
state.zeta = 1 / (effectiveDuty * Math.sqrt(Q_quantum));

// Compliance flags
state.fordRomanCompliance = state.zeta < 1.0;
state.natarioConstraint   = true;
state.curvatureLimit      = Math.abs(state.U_cycle ?? 0) < 1e-10;
```

### Also update `calculateStaticCasimir` (remove the fudge)

Make sure your static Casimir baseline is clean (no 0.159 factor):

```ts
function calculateStaticCasimir(gap_nm: number, area_m2: number): number {
  const gap_m   = gap_nm * NM_TO_M;
  const E_overA = -(PI * PI * HBAR_C) / (720 * Math.pow(gap_m, 3)); // J/m^2
  return E_overA * area_m2; // J
}
```

### Env knobs you can flip (optional)

* `GAMMA_VDB_SEED=1e11` (or sweep for studies)
* `MASS_LOCK_TO_TARGET=0|1`
* `MASS_TARGET_KG=1405`

### Why this helps

* **No hard locks** to paper targets for power or mass; your outputs now reflect the actual pipeline values (`U_static`, `U_Q`, `gammaGeo`, `qCavity`, `duty`, `sectorStrobing`, `N_tiles`).
* If you *need* the paper’s 1,405 kg for demos, you can still achieve it with **massCalibration**, without corrupting γ\_VdB or the physics path.
* ζ/TS update consistently with duty + strobing + spoiling.

If you want, I can also give you a tiny unit test (node script) that plugs in your default Mark-1 numbers and prints the expected `P_loss_raw`, `P_avg`, and `M_exotic_raw` so you can verify regressions quickly after each change.
