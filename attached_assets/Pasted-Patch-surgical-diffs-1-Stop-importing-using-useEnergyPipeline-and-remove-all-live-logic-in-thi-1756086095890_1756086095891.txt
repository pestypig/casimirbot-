Patch (surgical diffs)

1) Stop importing/using useEnergyPipeline and remove all “live” logic in this component.

Delete:

import { useEnergyPipeline } from "@/hooks/use-energy-pipeline";


Delete everything related to live, liveForMode, snapAll, snapForMode, expectedThetaForPane, toSharedUniforms, toRealUniforms, toShowUniforms.

2) Remove the “7.3 — Push uniforms whenever live values change” effect.

Delete the entire effect that starts with:

// 7.3 — Push uniforms into both engines whenever live values change
useEffect(() => {
  if (!leftEngine.current || !rightEngine.current) return;
  ...
}, [ ... ]);


This is the second writer. Killing it removes the race.

3) Use parameters for panel subtitles (optional).
Replace the live-based subtitle with a simple formatter from props:

const subtitleFromParams = (p: any) => {
  const P = Number.isFinite(p?.powerAvg_MW) ? `${p.powerAvg_MW.toFixed(1)} MW` : '—';
  const M = Number.isFinite(p?.exoticMass_kg) ? `${Math.round(p.exoticMass_kg)} kg` : '— kg';
  const Z = Number.isFinite(p?.zeta) ? `ζ=${p.zeta.toFixed(3)}` : 'ζ=—';
  return `${P} • ${M} • ${Z}`;
};

const realPanelTitle = `REAL • ${subtitleFromParams(parameters)}`;
const showPanelTitle = `SHOW • ${subtitleFromParams(parameters)}`;


4) Keep the mount/init effect, but don’t seed uniforms from “live”.
Leave it as-is structurally, but build a tiny neutral payload or skip pushing until parameters lands. Your existing second effect (the parameters one) will immediately populate real values.

5) In the parameters effect, also set a deterministic camera for both panes.
Right after you compute shared, add:

const camZ = safeCamZ(compactCameraZ(leftRef.current!, shared.axesScene as [number,number,number]));
pushSafe(leftEngine,  { cameraZ: camZ, lockFraming: true });
pushSafe(rightEngine, { cameraZ: camZ, lockFraming: true });


(Then continue with your REAL/SHOW pushes exactly as you already do.)

6) Mirror strobing to the mux from parameters.lightCrossing (not from live).
Replace the current 7.4 effect with:

useEffect(() => {
  const lc = parameters?.lightCrossing;
  const total = Math.max(1, Math.floor(Number(parameters?.sectorCount) || 1));
  const live  = Math.max(1, Math.floor(Number(parameters?.sectors) || total));
  const cur   = Number.isFinite(lc?.sectorIdx) ? Math.max(0, Math.floor(lc.sectorIdx) % live) : 0;

  (window as any).setStrobingState?.({
    sectorCount: total,     // TOTAL only
    currentSector: cur,     // live pointer
    split: cur              // keep split aligned with current sector
  });
}, [
  parameters?.sectorCount,
  parameters?.sectors,
  parameters?.lightCrossing?.sectorIdx
]);


This keeps the engine’s strobe state in lock-step with the LC loop you’re already passing through parameters.