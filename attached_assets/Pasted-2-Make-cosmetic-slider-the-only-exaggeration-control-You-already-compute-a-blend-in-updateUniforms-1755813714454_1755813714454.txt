2) Make cosmetic slider the only exaggeration control

You already compute a blend in updateUniforms(). We’ll keep that, but ensure nothing else sneaks in.

2a) Keep the cosmetic blend (what you already added)

This part in updateUniforms is good and stays:

// NEW: cosmetic curvature blend (1 = real physics, 10 = current visuals)
const rawLevel = Number.isFinite(parameters.cosmeticLevel) ? +parameters.cosmeticLevel : 10;
const cosmeticT0 = Math.max(0, Math.min(1, (rawLevel - 1) / 9)); // 1→0, 10→1
const cosmeticT = physicsParityMode ? 0 : cosmeticT0;
...
if (cosmeticT < 1 && !physicsParityMode) {
  const EXPOSURE_BASE = 3.0;
  const ZEROSTOP_BASE = 1e-5;
  const USERGAIN_BASE = 1.0;

  const exposureTarget = Number.isFinite(parameters.exposure) ? +parameters.exposure : (this.uniforms?.exposure ?? 6.0);
  const zeroStopTarget = Number.isFinite(parameters.zeroStop) ? +parameters.zeroStop : (this.uniforms?.zeroStop ?? 1e-7);
  const userGainCurrent = this.uniforms.userGain || 1;

  const userGainEffective = USERGAIN_BASE + cosmeticT * (userGainCurrent - USERGAIN_BASE);
  const exposureEffective = EXPOSURE_BASE + cosmeticT * (exposureTarget - EXPOSURE_BASE);
  const zeroStopEffective = ZEROSTOP_BASE + cosmeticT * (zeroStopTarget - ZEROSTOP_BASE);

  this.uniforms.userGain = userGainEffective;
  this.uniforms.exposure = exposureEffective;
  this.uniforms.zeroStop = zeroStopEffective;
  this.uniforms.cosmeticT = cosmeticT;
} else {
  this.uniforms.exposure = Number.isFinite(parameters.exposure) ? +parameters.exposure : (this.uniforms?.exposure ?? 6.0);
  this.uniforms.zeroStop = Number.isFinite(parameters.zeroStop) ? +parameters.zeroStop : (this.uniforms?.zeroStop ?? 1e-7);
  this.uniforms.cosmeticT = cosmeticT;
}

2b) Remove/neutralize the hidden “mode” amplifiers for geometry

Replace the body of _calculateModeEffects with a purely visual-only result. Geometry won’t read these values anymore:

_calculateModeEffects(params) {
  // visual-only seasoning; geometry ignores this
  const mode = (params.currentMode || 'hover').toLowerCase();
  const config = {
    hover:     { baseScale: 1.0, strobingViz: 0.8 },
    cruise:    { baseScale: 1.0, strobingViz: 0.6 },
    emergency: { baseScale: 1.0, strobingViz: 1.0 },
    standby:   { baseScale: 1.0, strobingViz: 0.3 }
  }[mode] || { baseScale: 1.0, strobingViz: 0.8 };

  return {
    visualScale: config.baseScale,
    curvatureAmplifier: 1.0,   // <- neutralized for geometry
    strobingFactor: config.strobingViz
  };
}


And in _warpGridVertices, delete the unused modeAmp/modeViz reads:

// remove these two lines (they no longer affect geometry):
// const modeAmp = (this.currentParams.modeCurvatureAmplifier || 1.0);
// const modeViz = (this.currentParams.modeVisualScale || 1.0);

2c) Remove the “decades gain” backdoor path

There’s a second amplification path driven by curvatureGainDec (mapDecadesToBoost / visualBoostUniform). It lives in _warpGridVertices and bypasses the slider you want to own things.

Delete the whole block starting from:

// ---- NEW: Single visual-only multiplier injected AFTER physics ----
function mapDecadesToBoost(dec, maxBoost) { ... }

// These come in as uniforms from React:
const physicsParityOn   = !!this.uniforms?.physicsParity;
const gainDec           = Number.isFinite(this.uniforms?.curvatureGainDec) ? this.uniforms.curvatureGainDec : 0;
const boostMax          = Math.max(1, this.uniforms?.curvatureBoostMax || 1);

// When parity is on...
const visualBoostUniform = physicsParityOn ? 1 : mapDecadesToBoost(gainDec, boostMax);

// Final viz field...
const betaVisUniform = betaUsedUniform * visualBoostUniform;


…and any logs that reference it.
Your geometry amplitude already uses:

const val = xs_over_rs * df * thetaScale * userGain;
...
const A_geom = Math.pow(Math.min(1.0, num / denom), 0.85);


That’s perfect—userGain is now fully governed by the cosmetic slider blend.

If you still need the old 0–8 “decades” control for debugging, keep setCurvatureGainDec but don’t use curvatureGainDec anywhere in geometry. Let it only update userGain through updateUniforms (which your cosmetic blend will then tame).