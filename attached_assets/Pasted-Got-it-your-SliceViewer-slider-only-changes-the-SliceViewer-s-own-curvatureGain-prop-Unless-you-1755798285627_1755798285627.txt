Got it—your SliceViewer slider *only* changes the SliceViewer’s own `curvatureGain` prop. Unless you also forward that value into the `WarpEngine`, the mesh won’t react.

Here’s a small, drop-in way to wire the same 0–8 slider to **both**:

### 1) Keep this tiny helper on the engine (you already have it)

```ts
// WarpEngine.ts
setCurvatureGainDec(slider0to8: number, boostMax = 40) {
  const T = Math.max(0, Math.min(1, slider0to8 / 8));
  this.updateUniforms({ curvatureGainT: T, curvatureBoostMax: boostMax });
}
```

### 2) Lift the slider state and forward it to both the SliceViewer and the engine

```tsx
// Parent component that renders the canvas + SliceViewer + slider
import { useEffect, useRef, useState } from "react";

export function WarpUI() {
  const [gain, setGain] = useState(6);           // 0..8
  const engineRef = useRef<WarpEngine | null>(null);
  const rafLock = useRef<number | null>(null);

  // init engine (example)
  useEffect(() => {
    const canvas = document.getElementById("warp-canvas") as HTMLCanvasElement;
    const eng = new window.WarpEngine(canvas);
    engineRef.current = eng;
    // keep engine in sync with initial slider position
    eng.setCurvatureGainDec(gain, 40);
    return () => eng.destroy();
  }, []);

  // when the slider changes, update engine + viewer together
  const onGainChange = (v: number | number[]) => {
    const x = Array.isArray(v) ? v[0] : v;       // shadcn returns number[] sometimes
    setGain(x);

    // rAF to avoid flooding WebGL
    if (rafLock.current == null) {
      rafLock.current = requestAnimationFrame(() => {
        rafLock.current = null;
        engineRef.current?.setCurvatureGainDec(x, 40);
        // optional: sanity log
        console.log("[gain→engine] slider:", x);
      });
    }
  };

  return (
    <div className="grid gap-4">
      <div className="flex items-center gap-3">
        <span className="font-mono text-xs w-20">Gain</span>
        {/* your slider component here; range 0..8 */}
        <input
          type="range"
          min={0}
          max={8}
          step={0.1}
          value={gain}
          onChange={(e) => onGainChange(parseFloat(e.target.value))}
          className="w-72"
        />
        <span className="font-mono text-xs">{gain.toFixed(1)}</span>
      </div>

      {/* Your WebGL canvas */}
      <canvas id="warp-canvas" className="w-full h-[360px] rounded-lg" />

      {/* SliceViewer sees the exact same gain */}
      <SliceViewer
        className="mt-2"
        hullAxes={[503.5, 132, 86.5]}
        curvatureGain={gain}           // ← same value, 0..8
        curvatureBoostMax={40}
        // ...any other props
      />
    </div>
  );
}
```

### 3) Double-check the engine mapping is active

* In `updateUniforms`, make sure you **accept** the slider in any of these forms:

  * `curvatureGain` (0..8) **or** `curvatureGainDec` (0..8) **or** `curvatureGainT` (0..1)
* And compute `userGain` like SliceViewer does:

```ts
const boostMax   = Number.isFinite(parameters.curvatureBoostMax) ? Math.max(1, parameters.curvatureBoostMax) : (this.uniforms?.curvatureBoostMax ?? 40);
const T =
  Number.isFinite(parameters.curvatureGainT)   ? Math.max(0, Math.min(1, +parameters.curvatureGainT)) :
  Number.isFinite(parameters.curvatureGain)    ? Math.max(0, Math.min(1, +parameters.curvatureGain / 8)) :
  Number.isFinite(parameters.curvatureGainDec) ? Math.max(0, Math.min(1, +parameters.curvatureGainDec / 8)) :
  (this.uniforms?.curvatureGainT ?? 0.375);

const userGain = 1 + T * (boostMax - 1);
this.uniforms = { ...this.uniforms, curvatureBoostMax: boostMax, curvatureGainT: T, userGain };
```

### 4) Quick sanity checks

* Move the slider: you should see your console print the slider value.
* Add a temporary log in `_renderGridPoints` right before `gl.uniform1f(gridUniforms.userGain, …)`:

  ```js
  console.log("u_userGain:", this.uniforms?.userGain, "T:", this.uniforms?.curvatureGainT);
  ```

  You should see `u_userGain` sweep from \~1 (at 0) to \~40 (at 8).

If you still get no mesh response after wiring the handler, the usual culprits are:

* The slider callback returns an **array** and you weren’t pulling `v[0]`.
* The engine instance you update isn’t the one that’s rendering (stale ref / recreated canvas).
* Geometry path is still using a saturated amplitude (swap to the normalized `A_geom` as I outlined earlier).

Want me to give you a tiny diff that swaps the geometry amplitude to the normalized version too?
