Yes—your ladders are on the right track. Here’s a clean way to finish wiring them to the light-crossing loop (so physics is gated by the ON window) and tighten a couple labels/units.

1) Light-crossing loop: add cycles + a human-readable ON latch

Drop these two tiny additions into your useLightCrossingLoop hook so you can (a) guard physics with “enough RF cycles in a burst”, and (b) keep the UI “ON” badge visible long enough for humans to notice.

// add near the other deriveds
const cyclesPerBurst = (freqGHz * 1e9) * (burst_ms / 1000);

// simple 200ms latch for the UI badge (does NOT affect physics)
const [onWindowDisplay, setOnWindowDisplay] = useState(false);
useEffect(() => {
  if (onWindow) {
    setOnWindowDisplay(true);
    const t = setTimeout(() => setOnWindowDisplay(false), 200);
    return () => clearTimeout(t);
  }
}, [onWindow]);

return {
  sectorIdx, sectorCount: Math.max(1, sectorStrobing),
  phase, dwell_ms, tauLC_ms, burst_ms, duty, freqGHz,
  onWindow, onWindowDisplay, cyclesPerBurst, // <-- new fields
};

2) Derived physics + ladders (drop-in for your useMemo block)

Power uses Q_cav (correct) and is gated by the ON‐window plus a “minimum cycles” sanity check.

Mass/energy chain has no Q_cav (correct).

The labels now match the math exactly.

I’ve kept your formatting helper and chart usage intact.

// ------- thresholds for gating instant power --------
const MIN_CYCLES_PER_BURST = 10; // tune if needed

// ------- derived (drop-in) -------
const derived = useMemo(() => {
  if (!state || !metrics) return null;

  // authoritative duty for ship average: prefer backend metric; else LC ratio
  const d_eff =
    metrics.dutyEffectiveFR ??
    (lc ? (lc.burst_ms / lc.dwell_ms) : 0);

  // raw ON window + RF-cycles guard for instantaneous power
  const isBurstMeaningful = (lc?.cyclesPerBurst ?? Infinity) >= MIN_CYCLES_PER_BURST;
  const isOnRaw = !!lc?.onWindow && isBurstMeaningful;

  const U_static = state.U_static;                   // J per tile (signed)
  const gammaGeo = state.gammaGeo;
  const qMech    = state.qMechanical ?? 1;
  const N_tiles  = state.N_tiles ?? metrics.totalTiles;
  const gammaVdB = state.gammaVanDenBroeck ?? metrics.gammaVanDenBroeck ?? 1;

  // --- POWER CHAIN ---
  const U_geo     = U_static * gammaGeo;            // γ^1 for power
  const U_Q       = U_geo * qMech;                  // stored energy proxy during ON
  const P_tile_on = (omega * Math.abs(U_Q)) / qCav; // W per tile when ON (P = ωU/Q)
  const P_tile_instant_W = isOnRaw ? P_tile_on : 0; // physics-gated instantaneous
  const P_ship_avg_calc_MW = (P_tile_on * N_tiles * d_eff) / 1e6;
  const P_ship_avg_report_MW = state.P_avg;         // backend-calibrated, if provided

  // --- MASS/ENERGY CHAIN (no Q here) ---
  const geo3        = Math.pow(gammaGeo, 3);
  const E_tile_geo3 = Math.abs(U_static) * geo3;          // ×γ_geo³
  const E_tile_VdB  = E_tile_geo3 * gammaVdB;             // ×γ_VdB
  const E_tile_mass = E_tile_VdB * d_eff;                  // ×d_eff (averaged)
  const M_tile      = E_tile_mass / (C * C);
  const M_total_calc   = M_tile * N_tiles;
  const M_total_report = state.M_exotic ?? metrics.exoticMass;

  // --- Casimir theory (unchanged) ---
  const gap_m       = (state.gap_nm ?? 16) * 1e-9;
  const tileA_m2    = (state.tileArea_cm2 ?? 25) * 1e-4;
  const casimir_theory   = -(PI * PI / 720) * HBAR_C / Math.pow(gap_m, 4);
  const casimir_per_tile = casimir_theory * tileA_m2 * gap_m;

  return {
    // inputs
    U_static, gammaGeo, qMech, N_tiles, qCav, omega, d_eff, gammaVdB,
    // power
    U_geo, U_Q, P_tile_on, P_tile_instant_W, P_ship_avg_calc_MW, P_ship_avg_report_MW,
    // mass/energy
    geo3, E_tile_geo3, E_tile_VdB, E_tile_mass, M_tile, M_total_calc, M_total_report,
    // misc
    gap_m, tileA_m2, casimir_theory, casimir_per_tile,
    // gates
    isOnRaw, isBurstMeaningful
  };
}, [
  state, metrics, omega, qCav,
  lc?.onWindow, lc?.cyclesPerBurst, lc?.burst_ms, lc?.dwell_ms
]);

3) Your ladders (labels and units)

These match your component exactly; just paste:

// POWER ladder (units: W)
const powerLadder: LadderDatum[] = [
  { stage: "|U_static|",              value: Math.abs(derived.U_static) },
  { stage: "×γ_geo",                  value: Math.abs(derived.U_geo) },
  { stage: "×q_mech",                 value: Math.abs(derived.U_Q) },
  { stage: "→P_tile_on (ωU/Q_cav)",   value: derived.P_tile_on },                 // W
  { stage: "×N_tiles × d_eff",        value: derived.P_ship_avg_calc_MW * 1e6 }, // back to W
];

// MASS/ENERGY ladder (units: J)
const massLadder: LadderDatum[] = [
  { stage: "|U_static|", value: Math.abs(derived.U_static) },
  { stage: "×γ_geo³",    value: derived.E_tile_geo3 },
  { stage: "×γ_VdB",     value: derived.E_tile_VdB },
  { stage: "×d_eff",     value: derived.E_tile_mass },  // duty applied here (no Q_cav in mass)
];


And keep your rendering as-is:

<LadderChart title="Power Chain" unit="W" data={powerLadder} />
<LadderChart title="Mass Chain" unit="J" data={massLadder} />