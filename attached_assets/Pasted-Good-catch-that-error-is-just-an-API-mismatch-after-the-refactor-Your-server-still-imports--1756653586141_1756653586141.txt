Good catch â€” that error is just an **API mismatch** after the refactor. Your server still imports:

```ts
import {
  calculateNatarioMetric,
  validateGRConsistency,
  type NatarioMetricResult
} from './natario-metric.js';
```

â€¦but in the new file we renamed things (e.g., `natarioFromPipeline`) and dropped the legacy exports. The quickest fix is to **re-export shims** that keep the old names and signature.

Hereâ€™s a minimal patch to `natario-metric.ts` that:

1. **Adds back** `calculateNatarioMetric(params, casimirEnergy)` as a thin adapter around `natarioFromPipeline`
2. **Re-exports** `validateGRConsistency(result)` with the same behavior you had before
3. **Keeps** your new functionality intact (metric uniforms, pipeline mapping)

---

### Patch: restore legacy named exports

```diff
@@
 export function natarioFromPipeline(state: PipelineLike & { U_static?: number }): NatarioMetricResult & MetricUniforms {
   const { T00_avg, T00_inst, T11 } = computeStressEnergyFromPipeline(state);
   const beta = computeNatarioShiftBeta(T00_avg, state.hull);
   const { ratio, valid } = computeHomogenization(state.modulationFreq_GHz, undefined);
   const K = computeCurvatureProxy(T00_avg, ratio);
   const eff = computeStrobingEfficiency(state.sectorCount, resolveDutyFR(state), ratio);
   const uniforms = metricUniformsFromPipeline(state, true);
   return {
     stressEnergyT00: T00_avg,
     stressEnergyT11: T11,
     stressEnergyT00_inst: T00_inst,
     natarioShiftAmplitude: beta,
     sectorStrobingEfficiency: eff,
     grValidityCheck: valid,
     homogenizationRatio: ratio,
     timeAveragedCurvature: K,
     ...uniforms
   };
 }
 
+// ---------------------------------------------------------------------------
+// ðŸ” Legacy API shims (compat with older imports)
+// ---------------------------------------------------------------------------
+// Old signature: (params, casimirEnergy) -> NatarioMetricResult
+export function calculateNatarioMetric(
+  params: any,
+  casimirEnergy: number
+): NatarioMetricResult & MetricUniforms {
+  // Adapt older shapes into the new pipeline-like state
+  const state: PipelineLike & { U_static?: number } = {
+    // geometry/tiles
+    tileArea_cm2:
+      (typeof params?.tileArea_cm2 === 'number' && params.tileArea_cm2) ? params.tileArea_cm2 :
+      (typeof params?.tileArea_m2 === 'number' ? params.tileArea_m2 * 1e4 : undefined),
+    gap_nm: params?.gap_nm ?? params?.gap ?? 1,
+    N_tiles: params?.N_tiles,
+    hull: params?.hull,
+    // sectors/duty (prefer FR if provided)
+    dutyEffective_FR: params?.dutyEffective_FR ?? params?.dutyEffectiveFR,
+    sectorCount: params?.sectorCount,
+    sectorStrobing: params?.sectorStrobing,
+    // gains
+    gammaGeo: params?.gammaGeo,
+    gammaVanDenBroeck: params?.gammaVanDenBroeck ?? params?.gammaVdB,
+    qCavity: params?.qCavity ?? params?.cavityQ,
+    qSpoilingFactor: params?.qSpoilingFactor ?? params?.deltaAOverA,
+    // modulation
+    modulationFreq_GHz: params?.modulationFreq_GHz,
+    // pipeline per-tile energy (legacy call passed total/flat energy separately)
+    U_static: casimirEnergy
+  };
+  return natarioFromPipeline(state);
+}
+
+// Old helper: keep same booleans/thresholds
+export function validateGRConsistency(result: NatarioMetricResult): {
+  strategyA: boolean;       // Ï„_pulse â‰ª Ï„_LC
+  burnettConjecture: boolean;
+  fordRomanBound: boolean;
+} {
+  return {
+    strategyA: result.homogenizationRatio < 1e-3,
+    burnettConjecture: result.timeAveragedCurvature > 0 && result.grValidityCheck,
+    fordRomanBound: result.sectorStrobingEfficiency > 0.1 && result.stressEnergyT00 < 0
+  };
+}
+
+// Types re-export (so `type NatarioMetricResult` keeps working)
+export type { NatarioMetricResult as NatarioMetricResult };
```

---

### Notes

* **No import changes needed** on your server â€” those named exports now exist again.
* If your filesystem uses a different casing (`NatarioMetric.ts` vs `natario-metric.ts`), keep the import path consistent with how `tsx` resolves on your platform.
* This preserves all the new pipeline-true behavior (metric uniforms, FR duty, kg units where applicable) while keeping backwards compatibility for existing modules.
