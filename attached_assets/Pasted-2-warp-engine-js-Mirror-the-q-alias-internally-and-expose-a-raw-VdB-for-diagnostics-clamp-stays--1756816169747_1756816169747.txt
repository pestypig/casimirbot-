2) warp-engine.js

Mirror the q alias internally and expose a raw γVdB for diagnostics (clamp stays).

diff --git a/warp-engine.js b/warp-engine.js
@@
-  // Ingest parameters → uniforms
+  // Ingest parameters → uniforms
   const U = this.uniforms || (this.uniforms = {});
-  U.deltaAOverA = Number.isFinite(parameters.qSpoilingFactor) ? parameters.qSpoilingFactor : (U.deltaAOverA ?? 1);
+  // Accept either alias for q; keep both set for UI parity
+  const qIn = Number.isFinite(parameters.qSpoilingFactor) ? parameters.qSpoilingFactor
+            : Number.isFinite(parameters.deltaAOverA)    ? parameters.deltaAOverA
+            : (U.deltaAOverA ?? 1);
+  U.deltaAOverA    = qIn;
+  U.qSpoilingFactor = qIn;
@@
-  // γ_VdB with parity clamp
-  U.gammaVanDenBroeck = clampByParity(parameters.gammaVanDenBroeck, this.physicsParityMode);
+  // γ_VdB with parity clamp; also expose raw for inspector diagnostics
+  const gammaVdB_raw = Number.isFinite(parameters.gammaVanDenBroeck) ? parameters.gammaVanDenBroeck : (U.gammaVanDenBroeck ?? 1);
+  U.gammaVdBRaw = gammaVdB_raw;
+  U.gammaVanDenBroeck = clampByParity(gammaVdB_raw, this.physicsParityMode);
@@
-  // Duty: prefer FR if provided, else derive from local × S_live/S_total
+  // Duty: prefer FR if provided, else derive from local × S_live/S_total
   const FR = Number.isFinite(parameters.dutyEffectiveFR) ? parameters.dutyEffectiveFR : null;
   const local = clamp(parameters.dutyCycle, 0, 1);
   const S_total = Math.max(1, parameters.sectorCount|0);
   const S_live  = Math.max(1, (parameters.sectorStrobing|0) || 1);
   U.dutyEffectiveFR = FR ?? (local * (S_live / S_total));
@@
-  // θ chain (if host didn't specify thetaScale)
+  // θ chain (if host didn't specify thetaScale)
   if (Number.isFinite(parameters.thetaScale)) {
     U.thetaScale = parameters.thetaScale;
   } else {
     const dutyForTheta = U.dutyEffectiveFR;
     U.thetaScale = Math.pow(U.gammaGeo ?? 1, 3) * (U.deltaAOverA ?? 1) * (U.gammaVanDenBroeck ?? 1) * Math.sqrt(Math.max(1e-12, dutyForTheta));
   }


Why: Inspector/audits can now read either deltaAOverA or qSpoilingFactor; and if a mismatch appears, you can compare gammaVdBRaw vs clamped to understand why.