diff --git a/client/src/lib/warp-pipeline-adapter.ts b/client/src/lib/warp-pipeline-adapter.ts
--- a/client/src/lib/warp-pipeline-adapter.ts
+++ b/client/src/lib/warp-pipeline-adapter.ts
@@ -56,6 +56,7 @@ export function driveWarpFromPipeline(
   const natStress = (get(nat, ['stressEnergyTensor']) || {}) as any;
 
   // ---- 2) Duty authority (no recompute on client) ---------------------------
+  // Prefer live metrics.dutyFR when present; else pipeline chain
   let dutyUsed = finite(mx?.dutyFR ?? (pipeline as any).dutyUsed);
   if (!isF(dutyUsed)) dutyUsed = finite((pipeline as any).dutyEffectiveFR);
   if (!isF(dutyUsed)) {
@@ -67,13 +68,27 @@ export function driveWarpFromPipeline(
   }
 
   // ---- 3) Physics + tensors verbatim (top-level OR natario.*) ---------------
   const uniforms: any = {
     // Primary physics
     gammaGeo:        finite(pipeline.gammaGeo),
-    qSpoilingFactor: finite((pipeline as any).qSpoilingFactor ?? (pipeline as any).deltaAOverA),
-    gammaVdB:        finite((pipeline as any).gammaVdB ?? (pipeline as any).gammaVanDenBroeck),
+    // Accept either name; we’ll mirror both below
+    qSpoilingFactor: finite((pipeline as any).qSpoilingFactor ?? (pipeline as any).deltaAOverA),
+    gammaVdB:        finite((pipeline as any).gammaVdB ?? (pipeline as any).gammaVanDenBroeck),
     // θ: prefer explicit pipeline fields, else θ_expected, else Natário amplitude
     thetaScale:      thetaPrimary,
     sectorCount:     inty(pipeline.sectorCount),
     dutyUsed,
@@ -105,6 +120,23 @@ export function driveWarpFromPipeline(
     if (hasTensors) uniforms.metricMode = true;
   }
 
+  // ---- 3b) Alias reflection (non-destructive): keep UI/engine names in sync -
+  // θ aliases
+  if (isF(uniforms.thetaScale)) {
+    if (!isF((uniforms as any).thetaUniform))        (uniforms as any).thetaUniform = uniforms.thetaScale;
+    if (!isF((uniforms as any).thetaScaleExpected))  (uniforms as any).thetaScaleExpected = finite((pipeline as any).thetaScaleExpected);
+  } else if (isF((pipeline as any).thetaScaleExpected)) {
+    uniforms.thetaScale = finite((pipeline as any).thetaScaleExpected);
+    (uniforms as any).thetaUniform = uniforms.thetaScale;
+  }
+  // γ_VdB aliases
+  if (isF(uniforms.gammaVdB) && !isF((uniforms as any).gammaVanDenBroeck))
+    (uniforms as any).gammaVanDenBroeck = uniforms.gammaVdB;
+  if (!isF(uniforms.gammaVdB) && isF((uniforms as any).gammaVanDenBroeck))
+    uniforms.gammaVdB = (uniforms as any).gammaVanDenBroeck;
+  // q/δ aliases
+  if (isF(uniforms.qSpoilingFactor) && !isF((uniforms as any).deltaAOverA))
+    (uniforms as any).deltaAOverA = uniforms.qSpoilingFactor;
+  if (!isF(uniforms.qSpoilingFactor) && isF((uniforms as any).deltaAOverA))
+    uniforms.qSpoilingFactor = (uniforms as any).deltaAOverA;
+
   // ---- 4) Strict gate: refuse partial physics; viewers show __error ---------
   if (strict) {
     const miss:string[] = [];
@@ -114,7 +146,7 @@ export function driveWarpFromPipeline(
     if (!isF(uniforms.qSpoilingFactor)) miss.push('qSpoilingFactor');
     if (!isF(uniforms.gammaVdB))        miss.push('gammaVdB');
     if (!isF(uniforms.sectorCount))     miss.push('sectorCount');
     if (!isF(uniforms.dutyUsed))        miss.push('dutyUsed');
-    if (!isF(tauLC_ms) || !isF(dwell_ms) || !isF(burst_ms))
+    if (!isF(tauLC_ms) || !isF(dwell_ms) || !isF(burst_ms))
       miss.push('LC(tauLC_ms/dwell_ms/burst_ms)');
     if (miss.length) {
       engine.uniforms = engine.uniforms || {};
       engine.uniforms.__error = `adapter: missing ${miss.join(', ')}`;
@@ -123,9 +155,15 @@ export function driveWarpFromPipeline(
   }
 
   // ---- 5) Push to engine (single source of truth) ---------------------------
-  // Helpful for inspectors: record the active mode
-  const stamp:any = { currentMode: mode };
-  if (mx?.timestamp) stamp.__metricsTick = mx.timestamp;
-  engine.updateUniforms?.(stamp);
+  // Helpful for inspectors: record adapter + mode + ticks (consolidated stamp)
+  {
+    const stamp:any = {
+      currentMode: mode,
+      __pipelineMode: mode,
+      __pipelineTick: (pipeline?.tickId ?? pipeline?.timestamp ?? Date.now()),
+    };
+    if (mx?.timestamp != null) stamp.__metricsTick = mx.timestamp;
+    engine.updateUniforms?.(stamp);
+  }
   engine.setLightCrossing?.(lcPayload);
   engine.updateUniforms?.(uniforms);
   engine.requestRewarp?.();
 }