B) Fix duty & sectors in warp-pipeline-adapter.ts

Send local burst duty as dutyCycle, and Ford–Roman duty as dutyEffectiveFR. Also pass the concurrent sectors to sectors, and total to sectorCount.

*** a/warp-pipeline-adapter.ts
--- b/warp-pipeline-adapter.ts
@@
-  // --- Sectoring: use *total* wedges for York & geometry, never "concurrent" ---
-  const sectorsTotal =
+  // --- Sectoring (separate concurrent vs total) ---
+  const sectorsTotal =
     Math.max(
       1,
       Math.floor(
         num(s.sectorCount) ??
           num(s.sectorStrobing) ?? // server field name
           400
       )
     );
-
-  const split = Math.floor(sectorsTotal / 2); // canonical (+/–) split
+  // Prefer explicit concurrentSectors/sectorsConcurrent; fallback to sectorStrobing; else 1
+  const sectorsConc =
+    Math.max(1, Math.floor(
+      num((s as any).sectorsConcurrent) ??
+      num((s as any).concurrentSectors) ??
+      num(s.sectorStrobing) ?? 1
+    ));
+  const split = Math.floor(sectorsTotal / 2); // viz-only (+/–) split (kept for legacy UI)
@@
-  // --- Ship-wide effective duty (exactly HELIX's d_eff) ---
-  // Priority: precomputed FR → explicit ship duty → derive from UI dutyCycle & strobing
-  let d_ship =
-    num(s.dutyEffective_FR) ??
-    num(s.dutyShip) ??
-    (() => {
-      const d_ui = clamp(s.dutyCycle ?? 0.14, 0, 1);
-      const strobe = Math.max(1, num(s.sectorStrobing) ?? sectorsTotal);
-      // FR duty is ship-wide time-average per total sectors (do NOT include q here)
-      return clamp(d_ui / strobe, 0, 1);
-    })();
-
-  d_ship = clamp(d_ship, 0, 1);
+  // --- Duty resolution
+  // Local burst (sector-local on-fraction). Use explicit field if provided; else default to paper 1%.
+  const dutyLocal = clamp(
+    num((s as any).localBurstFrac) ?? num((s as any).burstLocal) ?? (s.dutyCycle ?? 0.01),
+    0, 1
+  );
+  // Ford–Roman (ship-wide): d_FR = dutyLocal × (S_concurrent / S_total)
+  const d_ship = clamp(
+    num(s.dutyEffective_FR) ??
+    num(s.dutyShip) ??
+    (dutyLocal * (sectorsConc / sectorsTotal)),
+    0, 1
+  );
@@
-  // Push everything into the renderer in one shot using gated uniforms
+  // Push everything into the renderer in one shot using gated uniforms
   gatedUpdateUniforms(
     engine,
     {
       // Physics/ops - include qSpoilingFactor in physics chain
       currentMode: s.currentMode,
-      // Do not set physicsParityMode/ridgeMode here; pass them from the caller (REAL/SHOW)
-      dutyCycle: d_ship, // ship-wide effective duty
-      dutyEffectiveFR: d_ship, // FR duty for calculations
-      sectorCount: sectorsTotal, // total wedges
-      sectors: split, // +/- split for viz that expects half-count
+      // Do not set physicsParityMode/ridgeMode here; caller (REAL/SHOW) decides
+      dutyCycle: dutyLocal,            // ⟵ sector-local burst duty
+      dutyEffectiveFR: d_ship,         // ⟵ Ford–Roman duty (ship-wide)
+      sectorCount: sectorsTotal,       // ⟵ total wedges
+      sectors: sectorsConc,            // ⟵ concurrent/live sectors
@@
-      // Audit-only; do not override engine θ
+      // Audit-only; do not override engine θ
       thetaScaleExpected,
@@
-      // Visual defaults locked by gating system
-      colorMode: "theta",
-      viewAvg: true,
+      // Visual defaults (safe)
+      colorMode: "theta",
+      viewAvg: true,
     },
     "server"
   );


Why this matters:

Your old code produced d_FR ≈ 0.14 (with sectorStrobing=1), which exactly explains θ≈1.88e9 (26³·286k·√0.14).

The engine expects dutyCycle=local and reconstructs FR when needed, or uses dutyEffectiveFR when provided. Sending the right pair removes the inflation source.