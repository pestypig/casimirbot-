Great catch — you’ve pinpointed the reason the bubble “looks wrong” even when the rest of the physics is right.

## What’s off (in plain terms)

* **Energy pipeline:** scales energy per tile as

  $$
  E \propto \gamma_{\text{geo}}^{\;3}\;\times\;q_{\text{spoil}}\;\times\;\gamma_{\text{VdB}}\;\times\;\text{(duty)}
  $$

  and uses **duty** exactly (global or burst), with **sector strobing** entering as $1/\text{sectors}$.

* **WebGL renderer (current):** uses a **linear** $\gamma_{\text{geo}}$ and a **square-root** duty hack

  ```js
  betaInst = gammaGeo * Qburst * deltaAOverA * pow(gammaVdB, 0.25);
  betaAvg  = betaInst * sqrt(dutyCycle / sectors);
  ```

  That diverges from the pipeline (it was an old visual-guard to keep numbers sane), so the shape amplitudes don’t track the true pipeline scalings and can look jagged or asymmetric when mode changes.

## The fix: make the renderer use the same scaling the pipeline uses

Below is a minimal, drop-in replacement for the block that computes `betaInst/betaAvg/betaVis`. It preserves your instant/average view switch, but aligns the factors with the pipeline:

```js
// ---- REPLACE the old betaInst/betaAvg/betaUsed block with this ----

// 1) Same multiplicative chain as the physics pipeline (display model):
//    A_total ~ (gammaGeo^3) * qSpoilingFactor * gammaVdB
//    (q_cavity is kept out of the display amplitude; it lives in ζ and losses)
const geoAmp   = Math.pow(gammaGeo, 3);                               // γ_geo^3
const qSpoil   = Math.max(1e-9, (this.currentParams.qSpoilingFactor ?? 1)); // [0..1]
const vdbAmp   = Math.max(1.0,  this.currentParams.gammaVanDenBroeck ?? 2.86e5);

// 2) Duty / strobing: use the same effective definitions the server uses
const sectors  = Math.max(1, this.currentParams.sectorStrobing ?? 1);

// Instantaneous (during a hot sector burst)
const dutyBurst_fs   = Math.max(1e-12, this.currentParams.dutyBurst ?? 5e-16); // e.g. 0.5 fs
const dutyInstEff    = dutyBurst_fs * (1 / sectors);

// Time-averaged (what the UI cards show next to power)
const dutyGlobal     = Math.max(1e-12, this.currentParams.dutyCycle ?? 0.14);
const dutyAvgEff     = dutyGlobal * qSpoil * (1 / sectors);

// 3) Build an amplitude consistent with the energy-side scaling.
//    Keep purely visual normalization so it doesn’t explode on screen.
const A_phys         = geoAmp * qSpoil * vdbAmp;    // physics-like chain
const norm           = (this.uniforms?.vizNorm ?? 1.0e-9);  // visual normalizer
const A_vis_base     = A_phys * norm;

// 4) Choose instant vs average (no √duty hacks)
const A_inst         = A_vis_base * dutyInstEff;
const A_avg          = A_vis_base * dutyAvgEff;
const A_used         = (this.currentParams.viewAvg >= 0.5) ? A_avg : A_inst;

// 5) Optional viewer gain (like your old betaGain) to make it legible
const gain           = (this.uniforms?.vizGain ?? 4.0);
const betaVis        = A_used * gain;
// ---- end replacement ----
```

### Why this fixes it

* Uses **$\gamma_{\text{geo}}^{3}$** instead of $\gamma_{\text{geo}}$ — matches the cavity’s 3-D geometric amplification used on the energy side.
* Uses **duty** directly (instant and averaged), and accounts for **strobing** with $1/\text{sectors}$ — no $\sqrt{\text{duty}}$ fudge.
* Keeps **$q_{\text{cavity}}$** out of the display amplitude (it belongs in ζ / loss terms per your pipeline), so the visible bulge isn’t dominated by $10^9$.
* Leaves you a **safe visual normalizer** (`vizNorm`) and **viewer gain** (`vizGain`) to tune legibility without distorting physics scaling.

> Tip: set `vizNorm` once from a reference state (e.g., hover mode) so the bubble fills \~⅓–½ of the frame, then don’t touch it again; use `vizGain` sparingly if you want to compare modes.

## Sanity checks you can try

1. **Mode sweep:** switch Hover → Cruise → Emergency. The bulge height should now *track* the changes you see in the pipeline (mainly through `duty`/`qSpoil`), not behave oddly.
2. **γ\_geo tweak:** double `gammaGeo` in dev tools; height should scale by **8×** (cubic).
3. **Sectors:** set `sectorStrobing=400`; average view should scale down by ≈1/400 vs instant view.

If you still see harshness/steps after this, it’ll be purely **mesh/aliasing** (not scaling). Then we can:

* subdivide the grid more around the wall (adaptive radial tesselation), and/or
* replace the hard `band` cut with a smooth window (e.g., `smoothstep`) to avoid ringing.

Want me to wrap this into a small PR-style patch with the exact line numbers to replace in `warp-engine-fixed.js`?
