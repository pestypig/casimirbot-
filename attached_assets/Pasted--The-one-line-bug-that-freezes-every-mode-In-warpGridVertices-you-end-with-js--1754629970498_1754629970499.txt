### The one-line bug that freezes every mode

In **\_warpGridVertices (…)** you end with

```js
// CRITICAL FIX: Reset vertices to prevent drift accumulation
if (this.originalGridVertices) {
    vtx.set(this.originalGridVertices);   // <-- executed **after** you warp
}
```

That line copies the pristine grid **after** you have just bent it, so every displacement you computed in the loop is wiped out before the buffer is uploaded.
Result: whatever β₀ you pass in – Hover, Stand-by, Amplified – the mesh you draw is always the flat original, therefore “no visual change per mode”.

---

### Fix: reset **before** you warp, not after

```js
_updateGrid() {
    // 1) start from a clean grid
    this.gridVertices.set(this.originalGridVertices);

    // 2) apply the deformation that depends on the current mode
    this._warpGridVertices(
        this.gridVertices,
        this.gridHalf,
        this.gridY0,
        this.uniforms
    );

    // 3) upload to the GPU
    const gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.gridVbo);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.gridVertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
}
```

and **remove** the `vtx.set(this.originalGridVertices);` at the bottom of `_warpGridVertices`.

---

### Two other places that can mask the mode switch

| Issue                                                           | Symptom                                                                                                                                         | Quick check & cure                                                                                                                                                            |
| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `this.uniforms.beta0` is **never updated** when you change mode | Fragment shader shows correct color difference (it uses `u_beta0`), but the grid stays the same (warp function uses stale `bubbleParams.beta0`) | After you compute the new amplifier chain on the UI side call:<br>`warpEngine.updateUniforms({ beta0: newBeta0 });`                                                           |
| CPU warp uses `beta0 = duty × g_y` as a fallback                | In Stand-by & Hover you may not supply `beta0`, so the grid is always bent with the same low value                                              | In `_warpGridVertices` keep **only**<br>`const beta0 = bubbleParams.beta0;`<br>and throw if it is `undefined` – this guarantees you remember to pass the mode specific value. |

---

### Minimal patch

```diff
diff --git a/WarpEngine.js b/WarpEngine.js
@@ function _warpGridVertices(vtx, halfSize, originalY, bubbleParams) {
-    const beta0 = bubbleParams.beta0 || (bubbleParams.dutyCycle * bubbleParams.g_y);
+    const beta0 = bubbleParams.beta0;          // MUST be supplied per mode
+    if (beta0 === undefined) return;           // or early-out with warning
@@
-    // CRITICAL FIX: Reset vertices to prevent drift accumulation
-    if (this.originalGridVertices) {
-        vtx.set(this.originalGridVertices);
-    }
 }
```

With the reset moved and `beta0` really changing, the grid will now inflate / deflate when you toggle **Stand-by → Hover → Amplified** just as the fragment-shader colors already do.

---

#### TL;DR

The grid never reacts because it is restored to its flat state **after** you warp it. Reset first, warp afterwards, and make sure you feed the fresh `beta0` into `updateUniforms` each time a mode changes.
