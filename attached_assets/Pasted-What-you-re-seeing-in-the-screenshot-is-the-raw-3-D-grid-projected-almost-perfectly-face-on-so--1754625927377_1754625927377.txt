What you’re seeing in the screenshot is the **raw 3-D grid projected almost perfectly face-on**, so every turquoise segment lies at (almost) the same *screen* depth.
Because the camera is looking straight down the bubble’s symmetry axis, any gentle Natário bulge turns into a barely-visible one-pixel offset; only in the thin magenta diagnostic points do you glimpse a few vertices that have drifted out of the main plane.

Below is a quick checklist to turn that “flat neon waffle” into something you can read at a glance.

---

### 1  Tilt the camera a few degrees

```js
// in _renderGridPoints()
const eye   = [0.0, 0.25, 1.4];    // raise & pull back a little
const center= [0.0, 0.00, 0.00];    // still looking at origin
const up    = [0.0, 1.0, 0.0];

mat4.lookAt(view, eye, center, up);
```

Even a 10–15 ° pitch lets you see Y-displacements as real height instead of sub-pixel colour fringing.

---

### 2  Colour-code the vertical displacement

Add in `_warpGridVertices` **after** you write `vtx[i+1]`:

```js
// encode Y into the vertex colour (RGB packed in the last 3 floats)
vtxColors[i]   = 0.1 + clamp((vtx[i+1] - y_original) * 10.0, 0.0, 0.9); // R
vtxColors[i+1] = 0.6;                                                    // G
vtxColors[i+2] = 1.0 - vtxColors[i];
```

…and wire a tiny 3-component colour VBO through the grid shader (`a_color → v_color`).
Turquoise stays flat, hot-pink shows the crest, deep-blue shows the trough.

---

### 3  Verify the uniforms really *are* updating

Put this once at the top of `_draw`:

```js
if ((time|0) % 2 === 0) {           // once every ~2 s
  console.log('β₀', (this.uniforms.dutyCycle * this.uniforms.g_y).toFixed(3),
              'sag', this.uniforms.sagDepth_nm,
              'power', this.uniforms.powerAvg_MW);
}
```

Turn a slider → numbers in the console should change immediately.
If they don’t, `updateUniforms()` isn’t being called from React (or you forgot to pass the new props down to the visualiser).

---

### 4  Scale the warp while you debug

Right now the **push and dy multipliers ( 0.05 )** keep every vertex inside the clip cube.
For hover mode that’s physically correct *but* it hides the curvature.  During development:

```js
const exaggeration = 5.0;           // dial this back later…
const push = beta * 0.05 * exaggeration;
const dy   = beta * 0.05 * exaggeration;
```

You’ll immediately see a pillow-shaped warp; once confident, reduce `exaggeration` to 1.

---

### 5  Pay attention to grid density

At 50 × 50 divisions you have **2 000 lines** but only a few dozen pixels of sag.
For subtle modes (hover / cruise) drop to 20 × 20 divisions so each vertex shift claims more screen real-estate.

---

### 6  Make sure the *metric* is consistent

You changed to the correct Natário profile:

```
β(r) = β₀ (r/R) e^{-r²/R²}
```

but the “clip-space radius” you feed into it is

```js
r = sqrt(x² + z²)      // already scaled to ±0.8
```

so the **effective physical R** is

```
Rclip = sagDepth_nm / halfSize * 0.8   // ~6.4 × 10⁻⁴
```

That is only 0.06 % of the clip cube → microscopic curvature.
If you really need to see it without exaggeration, zoom the camera until the grid fills the viewport, or work in a *physical-unit* pass first and let the vertex shader do the nm→clip conversion.

---

### Quick test sequence

1. **Add the camera tilt** – grid becomes a pale turquoise sheet with a faint ridge.
2. **Set `exaggeration = 5`** – pillow/bulge obvious.
3. **Drag Duty-cycle slider** – ridge height should track the console β₀ print-outs.
4. **Colour-coding** – hotspots match the ridge.
5. **Re-enable physical scale** (`exaggeration = 1`) and fine-tune camera zoom.

By the end you’ll be able to switch between *Hover*, *Cruise*, *Emergency* etc. and immediately *see* the relative curvature without ever leaving physical units.
