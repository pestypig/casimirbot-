Great catch on cruise mode — your backend is already targeting **7.437 W** (not kW) for cruise, so there’s **no unit bug** in the power targets. The pipeline is doing exactly what we discussed: it calibrates **power** with `qMechanical` and **mass** with `gammaVanDenBroeck` to hit the paper targets (Hover ≈ 83.3 MW / 1000 kg, Cruise ≈ 7.437 W / 1000 kg, Emergency ≈ 297.5 MW / 1000 kg).

Here’s how the current code maps to the papers and where I’d tweak it:

# Quick comparison: papers → code

* **Time-sliced sector strobing (GR-valid proxy)**
  Paper idea: slice the surface into many sectors; only a small fraction is “hot” at any instant to respect light-crossing/causality.
  **Code:** `TOTAL_SECTORS = 400`, `BURST_DUTY_LOCAL = 0.01`, and effective ship-average duty `d_eff = 0.01 * S_live/400`. This is right on the mark.

* **Geometry amplification (γ\_geo)**
  Paper theme: geometry boosts the static Casimir energy/posture.
  **Code:** `U_geo = U_static * gammaGeo` (power path) and **mass path** uses `geo3 = gammaGeo^3` as part of the energy→mass mapping. That matches your write-ups where mass scales more steeply with geometry selection than simple dissipation.

* **Van den Broeck pocket (γ\_VdB)**
  Paper theme: geometry/topology selection increases the effective pocket/bubble scale without paying full energy.
  **Code:** seeds `GAMMA_VDB = 1e11` then **scales it only to hit mass** (`M_target_kg`). Power is held by `qMechanical`, so mass & power are decoupled — exactly what we wanted.

* **Quantum inequality guard (Ford–Roman)**
  Paper theme: keep the time-averaged negative energy within QI bounds.
  **Code:** uses a conservative `Q_quantum = 1e12` with `zeta = 1/(d_eff*sqrt(Q_quantum))`. With cruise’s tiny `d_eff`, ζ stays ≪ 1 (PASS), which aligns with the paper’s safety posture.

* **Time-scale separation (T\_S)**
  Paper theme: modulation slower than relevant light-crossing ensures homogenization ahead of drive.
  **Code:** computes both `TS_long` (conservative, longest dimension) and `TS_geom` (geometric mean), exposes `TS_ratio = TS_long`. That’s the conservative pick we wanted.

* **Shift vector / interior “tilt”** (visual/ops layer)
  Paper theme: gentle interior tilt as a whisper of artificial gravity.
  **Code:** kept out of energy accounting (good), used only as a viewer-side visual with ε\_tilt controls — consistent with the doc.

# One real inconsistency worth fixing

You’ve got **two different cruise `qSpoilingFactor` defaults** in the same module:

* Early `MODE_CONFIGS.cruise.qSpoilingFactor = **0.625**`
* Late `MODE_UI.cruise.qSpoilingFactor = **0.001**`

That can yield unexpected UI readbacks vs engine state and confuse the slice viewer/3D engine when they mirror pipeline values.

# Tiny diff (patches 1–3)

**Goal:** keep your 7.437 W cruise target, remove the `qSpoilingFactor` inconsistency, and make intent around units unmistakable.

```diff
--- a/server/energy-pipeline.ts
+++ b/server/energy-pipeline.ts
@@
-const MODEL_MODE: 'calibrated' | 'raw' = 
-  (process.env.HELIX_MODEL_MODE === 'raw') ? 'raw' : 'calibrated';
+// Explicit default: paper-calibrated targets; set HELIX_MODEL_MODE=raw to bypass
+const MODEL_MODE: 'calibrated' | 'raw' =
+  (process.env.HELIX_MODEL_MODE === 'raw') ? 'raw' : 'calibrated';
@@
-// --- Mode power/mass policy (targets are *hit* by scaling qMechanical, γ_VdB) ---
+// --- Mode power/mass policy (targets are *hit* by scaling qMechanical for power and γ_VdB for mass) ---
+// NOTE: All P_target_* values are in **watts** (W).
 const MODE_POLICY = {
   hover:     { S_live: 'all' as const, P_target_W: 83.3e6,   M_target_kg: 1_000 },
-  cruise:    { S_live: 1 as const,     P_target_W: 7.437,    M_target_kg: 1_000 }, // 7.437 W
+  cruise:    { S_live: 1 as const,     P_target_W: 7.437,    M_target_kg: 1_000 }, // 7.437 **W**
   emergency: { S_live: 'all' as const, P_target_W: 297.5e6,  M_target_kg: 1_000 },
   standby:   { S_live: 0 as const,     P_target_W: 0,        M_target_kg: 0     },
 } as const;
@@
 export const MODE_CONFIGS = {
   hover: {
     dutyCycle: 0.14,
     sectorStrobing: 1,
     qSpoilingFactor: 1,
     description: "High-power hover mode for station-keeping"
   },
   cruise: {
     dutyCycle: 0.005,
     sectorStrobing: 400,
-    qSpoilingFactor: 0.625,
+    qSpoilingFactor: 0.625,  // keep this consistent with UI defaults below
     description: "Low-power cruise mode for sustained travel"
   },
@@
   standby: {
     dutyCycle: 0.001,
     sectorStrobing: 1,
     qSpoilingFactor: 0.1,
     description: "Minimal power standby mode"
   }
 };
@@
-  const MODE_UI = {
+  // Keep UI mirrors consistent with MODE_CONFIGS (avoid confusing readbacks)
+  const MODE_UI = {
     hover:    { dutyCycle: 0.14,  sectorStrobing: 1,   qSpoilingFactor: 1     },
-    cruise:   { dutyCycle: 0.005, sectorStrobing: 400, qSpoilingFactor: 0.001 },
+    cruise:   { dutyCycle: 0.005, sectorStrobing: 400, qSpoilingFactor: 0.625 },
     emergency:{ dutyCycle: 0.50,  sectorStrobing: 1,   qSpoilingFactor: 1     },
     standby:  { dutyCycle: 0.001, sectorStrobing: 1,   qSpoilingFactor: 0.1   }
   } as const;
```

**Why this helps**

* Keeps cruise at **7.437 W** (as per the updated paper), no unit confusion.
* Ensures the **same `qSpoilingFactor`** value flows through the pipeline and the UI so the viewer/slice get consistent inputs.
* Comments make it obvious that `P_target_W` is in **watts**, which prevents the earlier MW↔W ambiguity from creeping back in.

# Optional niceties (safe, low-risk)

* Export the paper constants so the UI and docs can reference the single source of truth:

  ```ts
  export const PAPER = { TOTAL_SECTORS, BURST_DUTY_LOCAL, Q_BURST, GAMMA_VDB };
  ```
* Add a runtime assert in dev:

  ```ts
  if (process.env.NODE_ENV !== 'production') {
    const isWatt = MODE_POLICY.cruise.P_target_W < 1000;
    if (!isWatt) console.warn("[PIPELINE] Cruise P_target looks >1kW; targets must be in watts.");
  }
  ```

If you’d like, I can also hand you tiny diffs for the **SliceViewer/WarpVisualizer** so their “diff-vs-hover” reference pulls the corrected UI defaults directly from the pipeline (eliminating any stale constants in the components).
