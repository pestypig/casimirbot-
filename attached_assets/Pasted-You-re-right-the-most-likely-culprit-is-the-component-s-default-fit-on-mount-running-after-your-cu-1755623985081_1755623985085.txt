You’re right—the most likely culprit is the component’s default “fit on mount” running after your custom fit, clobbering the zoom/offset you set for Earth↔Saturn. Let’s make the Solar viewer explicitly skip its default-fit when you pass fitToIds, and then do a priority fit that runs last (after layout), so it sticks.

Below is a tight two-file patch.

⸻

1) client/src/components/SolarMap.tsx

Skip default-fit when fitToIds is provided, and add a “priority fit” that runs after layout.

@@
 export interface SolarMapProps {
   width: number;
   height: number;
   routeIds: string[];
   centerOnId?: string;
+  /** If provided, the map will auto-fit to keep ALL of these bodies visible */
+  fitToIds?: string[];
+  /** Optional padding (px) for fitToIds auto-fit */
+  fitMarginPx?: number;
   onPickBody?: (id: string) => void;
 }
 
@@
-// assume you have: const [zoom, setZoom] = useState(1);
-//                  const [offset, setOff] = useState({x:0,y:0});
+// assume you have:
+//   const [zoom, setZoom] = useState(1);
+//   const [offset, setOff] = useState({x:0,y:0});
+// and a bodiesById[id] -> { pos: {x,y} } map in AU
 
+// --- helpers for fitting -----------------------------------------------------
+function fitToBBox(
+  bbox: {minX:number; minY:number; maxX:number; maxY:number},
+  viewW: number, viewH: number, margin: number
+) {
+  const w = Math.max(1e-9, bbox.maxX - bbox.minX);
+  const h = Math.max(1e-9, bbox.maxY - bbox.minY);
+  const zx = (viewW - 2*margin) / w;
+  const zy = (viewH - 2*margin) / h;
+  const newZoom = Math.max(0.0001, Math.min(zx, zy));
+  const cx = (bbox.minX + bbox.maxX) * 0.5;
+  const cy = (bbox.minY + bbox.maxY) * 0.5;
+  const offX = viewW*0.5 - cx*newZoom;
+  const offY = viewH*0.5 - cy*newZoom;
+  return { zoom: newZoom, offset: { x: offX, y: offY } };
+}
+
+const didPriorityFit = React.useRef(false);
+
 // ---------------------------------------------------------------------------
 // DEFAULT FIT (existing effect)
 // ---------------------------------------------------------------------------
-React.useEffect(() => {
-  // typical “fit image/canvas to container” logic…
-  // computes a default zoom + offset
-  setZoom(fitZoom);
-  setOff({ x: fitX, y: fitY });
-}, [width, height, /*nat or init deps*/]);
+React.useEffect(() => {
+  // If caller wants an explicit fit to bodies, skip the default-fit.
+  if (props.fitToIds && props.fitToIds.length > 0) return;
+  // otherwise run your existing default-fit
+  setZoom(fitZoom);
+  setOff({ x: fitX, y: fitY });
+}, [props.fitToIds?.length, width, height /*, nat/init deps*/]);
 
 // ---------------------------------------------------------------------------
 // DRAWING EFFECT (unchanged)
 // ---------------------------------------------------------------------------
 
+// ---------------------------------------------------------------------------
+// PRIORITY FIT-TO-IDS (runs after layout so it wins over defaults)
+// ---------------------------------------------------------------------------
+React.useLayoutEffect(() => {
+  if (!props.fitToIds || props.fitToIds.length === 0) return;
+  // Gather target points from bodies
+  const pts = props.fitToIds
+    .map(id => bodiesById[id]?.pos)
+    .filter(Boolean) as {x:number;y:number}[];
+  if (pts.length === 0) return;
+  // Defer to next frame to ensure any default sizing has applied
+  const raf = requestAnimationFrame(() => {
+    const minX = Math.min(...pts.map(p=>p.x));
+    const maxX = Math.max(...pts.map(p=>p.x));
+    const minY = Math.min(...pts.map(p=>p.y));
+    const maxY = Math.max(...pts.map(p=>p.y));
+    const margin = Number.isFinite(props.fitMarginPx) ? (props.fitMarginPx as number) : 24;
+    const { zoom: z, offset: off } = fitToBBox({minX,minY,maxX,maxY}, props.width, props.height, margin);
+    setZoom(z);
+    setOff(off);
+    didPriorityFit.current = true;
+  });
+  return () => cancelAnimationFrame(raf);
+// include bodies + dimensions so we refit on resize/ephemeris tick
+}, [props.width, props.height, props.fitToIds?.join(','), /* add ephemeris tick key if you have one */]);
+
 return (
-  <div className="relative" style={{ width, height }}>
+  <div className="relative overflow-hidden" style={{ width, height }}>
     <canvas
       ref={canvasRef}
       width={width}
       height={height}
       className="block"
     />
-    <div className="absolute right-3 top-3">
+    {/* keep controls anchored inside visible area */}
+    <div className="absolute right-3 top-3 z-20 pointer-events-auto">
       <button className="px-2 py-1 bg-white/10 rounded mr-1" onClick={() => setZoom(z=>z*1.2)}>+</button>
       <button className="px-2 py-1 bg-white/10 rounded" onClick={() => setZoom(z=>z/1.2)}>−</button>
     </div>
   </div>
 );

What changed
	•	The default-fit now bails if fitToIds is present.
	•	A useLayoutEffect + requestAnimationFrame runs the priority fit after layout, so your fit “wins” reliably.
	•	Added overflow-hidden to keep content tidy in the panel.

⸻

2) client/src/pages/helix-core.tsx

Tell SolarMap exactly what to fit, with a bit of margin.

@@
-      <SolarMap
-        width={720}
-        height={360}
-        routeIds={route}
-        centerOnId="EARTH"
+      <SolarMap
+        width={720}
+        height={360}
+        routeIds={route}
+        /* New: ask the map to auto-fit BOTH Earth & Saturn into view */
+        fitToIds={["EARTH","SATURN"]}
+        fitMarginPx={28}
+        centerOnId="EARTH"  // safe fallback if you keep keyboard recenter logic
         onPickBody={(id) => {
           setRoute(r => r.length ? [...r.slice(0,-1), id, r[r.length-1]] : [id]);
           publish("luma:whisper", { text: "Waypoint selected. Route updated." });
         }}
       />

If your component still has a centerBetweenIds prop from earlier experiments, drop it—the new fitToIds does both centering and scaling.

⸻

Why this should fix the “default wins” symptom
	•	Many map/canvas components run a “fit on mount” effect after first render; if we fit earlier, we get overwritten. By skipping that default path and doing a layout-priority fit after the component settles, your chosen framing sticks every time (including after resizes).

If you’d like, we can apply the same fitToIds pattern to the galactic viewer so both maps behave the same way.