Absolutelyâ€”hereâ€™s a small, safe patch that (1) **pushes the tilt uniforms into the WebGL engine** and (2) gives each **operational mode** a sensible default tilt strength so you can immediately see the interior slope. Iâ€™m also bumping the engine script query to force a fresh load.

---

# 1) `client/src/components/WarpVisualizer.tsx`

### What this does

* Computes a **mode-specific `epsilonTilt`** (dimensionless strength):
  `standby=0`, `cruiseâ‰ˆ0.012`, `hoverâ‰ˆ0.02`, `emergencyâ‰ˆ0.035`
  (tweak as you likeâ€”these are just good â€œsee-it-clearlyâ€ demo values).
* Uses **downward** cabin direction `[0,-1,0]` unless you pass one in props.
* Sends both `epsilonTilt` and `betaTiltVec` to `WarpEngine.updateUniforms(...)`.
* Bumps engine script to `?v=9` to avoid cache.

> **Unified diff** (apply as-is):

```diff
--- a/client/src/components/WarpVisualizer.tsx
+++ b/client/src/components/WarpVisualizer.tsx
@@ -42,6 +42,25 @@
   const canvasRef = useRef<HTMLCanvasElement | null>(null);
   const [engineReady, setEngineReady] = useState(false);

+  // --- Simple per-mode defaults for interior tilt (demo-friendly) ---
+  // You can later replace this with the exact value from the Shift Vector panel
+  // (epsilonTilt = g_target * R_geom / c^2) and pass it via props.parameters.epsilonTilt.
+  const modeEpsilonTilt = (mode: string | undefined) => {
+    switch ((mode || 'hover').toLowerCase()) {
+      case 'standby':   return 0.000; // perfectly flat
+      case 'cruise':    return 0.012; // subtle
+      case 'hover':     return 0.020; // noticeable
+      case 'emergency': return 0.035; // stronger
+      default:          return 0.015;
+    }
+  };
+
+  // Default cabin "down" (can be overridden via props.parameters.betaTiltVec)
+  const defaultBetaTilt: [number, number, number] = [0, -1, 0];
+
   useEffect(() => {
     if (!canvasRef.current) return;
-    const script = document.createElement('script');
-    script.src = '/warp-engine-fixed.js?v=8'; // Syntax fix + defensive initialization
+    const script = document.createElement('script');
+    // bump query to force cache-bust after engine changes
+    script.src = '/warp-engine-fixed.js?v=9';
     console.log('Loading 3D WarpEngine from:', script.src);
     script.onload = () => {
       console.log('WarpEngine loaded, window.WarpEngine available:', !!(window as any).WarpEngine);
@@ -150,6 +169,9 @@
     if (!engineRef.current) return;
     if (!parameters) return;

+    // Resolve mode + tilt uniforms
+    const mode = (parameters.currentMode || 'hover').toLowerCase();
+
     // Coerce helpers
     const num = (v: any, def = 0) => (typeof v === 'number' && isFinite(v)) ? v : def;

@@ -160,13 +182,27 @@
     const sectors = num(parameters.sectorStrobing, 1);
     const phaseSplit = num((parameters as any).phaseSplit, undefined);

+    // Interior gravity uniforms (use panel values if present, else demo defaults)
+    const epsilonTilt =
+      num((parameters as any).epsilonTilt, modeEpsilonTilt(mode));
+    const betaTiltVec = Array.isArray((parameters as any).betaTiltVec)
+      ? (parameters as any).betaTiltVec
+      : defaultBetaTilt;
+
     // Hull geometry
     const hull = parameters.hull || {};
     const wallWidth = num((parameters as any).wallWidth_m, 6.0); // meters; your pipeline default

     // Map to engine uniforms
     engineRef.current.updateUniforms({
       dutyCycle: dutyFrac,
       gammaGeo: num(parameters.g_y, 26),
       Qburst: num(parameters.cavityQ, 1e9),
       deltaAOverA: num(parameters.qSpoilingFactor, 1),
       gammaVdB: num(parameters.gammaVanDenBroeck, 1),
-      currentMode: (parameters.currentMode || 'hover'),
+      currentMode: (parameters.currentMode || 'hover'),
       sectors,
       split: typeof phaseSplit === 'number'
         ? phaseSplit
         : (mode === 'cruise' ? 0.65 : mode === 'emergency' ? 0.70 : 0.50),
+      // NEW: interior gravity uniforms
+      epsilonTilt,
+      betaTiltVec,
+
       // Hull axes (semi-axes order a,b,c) and wall width
       hullAxes: [num(hull.a, 503.5), num(hull.b, 132.0), num(hull.c, 86.5)],
       wallWidth: wallWidth,
@@ -178,6 +214,11 @@
       console.log('ðŸ”„ WarpVisualizer uniforms â†’', {
         mode: (parameters.currentMode || 'hover'),
         dutyFrac, sectors,
+        epsilonTilt,
+        betaTiltVec,
         hullAxes: [num(hull.a, 503.5), num(hull.b, 132.0), num(hull.c, 86.5)],
         wallWidth,
       });
```

> If you **already** pass `epsilonTilt` and `betaTiltVec` from a parent (e.g., your Shift Vector panel), they will override these defaults automatically.

---

# 2) (Optional) `client/src/pages/helix-core.tsx`

If you want the value to come **directly from the Shift Vector computation**, pass them into the `WarpVisualizer` `parameters` prop here. For example (pseudo-context):

```tsx
<WarpVisualizer
  parameters={{
    currentMode: currentMode,
    // â€¦your existing fieldsâ€¦
    epsilonTilt: shiftVector?.epsilonTilt,        // from panel/pipeline
    betaTiltVec: shiftVector?.betaTiltVec || [0,-1,0],
  }}
/>
```

This will supersede the mode defaults from the patch above.

---

## What to expect after this patch

* In **hover** and **emergency**, the interior grid should visibly slope â€œdownâ€ near the cabin.
* In **cruise**, itâ€™s subtle but present; increase to \~0.02 if you want it clearer.
* In **standby**, it will be flat (`epsilonTilt = 0`).

If you still donâ€™t *see* the slope: the camera may be looking at a region **outside** the ellipsoidal shell (Ï>1), where the interior tilt window fades to zero. Two quick ways to make it obvious:

1. temporarily set `epsilonTilt: 0.04` to exaggerate; and/or
2. zoom/pan so youâ€™re clearly viewing nodes **inside** the bubble.

Want me to wire the panelâ€™s `g_target â†’ epsilonTilt` formula directly so the value tracks the **exact** physics? I can write that patch too.
