2) Kill the SHOW black screen (size/NaN/StrictMode/cosmetic fallbacks)

What likely happened (from your agent logs + symptoms):

The second WebGL context (SHOW) sometimes comes up with a 0×0 canvas or NaN uniforms during first frames, or is created twice under React 18 StrictMode and loses the context. With cosmeticLevel: 10, some engines also expect LUTs; if those aren’t ready yet you get a black draw.

Fixes (safe, minimal):

2a) Ensure the canvas has pixels before engine creation
function ensureCanvasSize(canvas: HTMLCanvasElement) {
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const cw = (canvas.clientWidth  || 800) * dpr;
  const ch = (canvas.clientHeight || 320) * dpr;
  if (canvas.width !== cw)  canvas.width  = cw;
  if (canvas.height !== ch) canvas.height = ch;
}


Call this right before new WarpCtor(...) and also in your resize observer.

2b) Guard NaNs for camera/axes
const safeCamZ = (cv: number) => (Number.isFinite(cv) && Math.abs(cv) > 1e-9) ? cv : 2.0;

const camZ = safeCamZ(compactCameraZ(canvas, shared.axesScene));
pushUniformsWhenReady(e, { ...shared, cameraZ: camZ, lockFraming: true, /* ... */ });

2c) StrictMode re-mount guard (prevents double constructor crashes in dev)
const busy = (window as any).__warpCompareBusy ?? false;
if (busy) return;
(window as any).__warpCompareBusy = true;

try {
  ensureCanvasSize(leftRef.current!);
  ensureCanvasSize(rightRef.current!);
  leftEngine.current  = new WarpCtor(leftRef.current);
  rightEngine.current = new WarpCtor(rightRef.current);
  leftEngine.current?._resize?.();
  rightEngine.current?._resize?.();
} finally {
  (window as any).__warpCompareBusy = false;
}

2d) Cosmetic safety fallback for SHOW

If the first two frames are black (no grid/points), drop cosmetics to 0 and retry once:

let showSafeFallbackDone = false;

function applyShowSafe(e:any, payload:any) {
  pushUniformsWhenReady(e, payload);
  requestAnimationFrame(() => {
    const anyVerts = (e?.gridVertices?.length || 0) + (e?.originalGridVertices?.length || 0);
    const anyReady = anyVerts > 0 && Number.isFinite(e?.uniforms?.cameraZ);
    if (!anyReady && !showSafeFallbackDone) {
      showSafeFallbackDone = true;
      pushUniformsWhenReady(e, { cosmeticLevel: 0, exposure: 5.5, vizGain: 1.0 });
      e.setDisplayGain?.(1);
      e.requestRewarp?.();
      console.warn('[SHOW] cosmetics disabled as safety fallback');
    }
  });
}


Use applyShowSafe(rightEngine.current, {/* the same payload you pass to applyShow */}).