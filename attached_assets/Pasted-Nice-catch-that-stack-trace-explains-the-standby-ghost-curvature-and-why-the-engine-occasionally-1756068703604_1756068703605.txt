Nice catch — that stack trace explains the standby “ghost curvature” and why the engine occasionally black-screens: you’re instantiating a second WarpEngine on the same canvas, which your ctor explicitly forbids. That also means two draw paths can overlap (one “static”, one “dynamic”).

Here’s a surgical fix + a true-zero standby patch.

1) Stop double-attaching the engine (fixes the runtime error + double draw)

In WarpBubbleCompare.tsx, replace the line that does new W(cv) with a re-use guard. Add this helper near the top of the file (outside the component or inside, above the effect):

// Reuse-or-create guard so we never attach twice to the same canvas
const ENGINE_KEY = '__warpEngine';

function getOrCreateEngine<WarpType = any>(Ctor: new (c: HTMLCanvasElement) => WarpType, cv: HTMLCanvasElement): WarpType {
  const existing = (cv as any)[ENGINE_KEY];
  if (existing && !existing._destroyed) return existing as WarpType;
  const eng = new Ctor(cv);
  (cv as any)[ENGINE_KEY] = eng;
  return eng;
}


Then change your init:

// BEFORE
// const eng = new W(cv);

// AFTER
const eng = getOrCreateEngine(W, cv);


Add a robust cleanup so HMR/StrictMode don’t leak:

useEffect(() => {
  const left = leftRef.current;
  const right = rightRef.current;

  if (!left || !right) return;

  const leftEng  = getOrCreateEngine(W, left);
  const rightEng = getOrCreateEngine(W, right);

  // ... set viewport, push uniforms, etc.

  return () => {
    try {
      if ((left as any)[ENGINE_KEY] && !(left as any)[ENGINE_KEY]._destroyed) {
        (left as any)[ENGINE_KEY].destroy?.();
      }
      delete (left as any)[ENGINE_KEY];
    } catch {}

    try {
      if ((right as any)[ENGINE_KEY] && !(right as any)[ENGINE_KEY]._destroyed) {
        (right as any)[ENGINE_KEY].destroy?.();
      }
      delete (right as any)[ENGINE_KEY];
    } catch {}
  };
  // IMPORTANT: keep deps minimal; do not include uniforms objects that change every tick
}, [leftRef.current, rightRef.current]);


If you construct in multiple places, apply the same guard wherever you do new W(canvas).