diff --git a/WarpBubbleCompare.tsx b/WarpBubbleCompare.tsx
--- a/WarpBubbleCompare.tsx
+++ b/WarpBubbleCompare.tsx
@@ -1,6 +1,18 @@
 import React, { useEffect } from "react";
 // ...existing imports...
 
+// Use harmonic mean for meters↔ρ conversions (match engine)
+function aHarmonic(ax: number, ay: number, az: number) {
+  const a = +ax || 0, b = +ay || 0, c = +az || 0;
+  const denom = (a>0?1/a:0) + (b>0?1/b:0) + (c>0?1/c:0);
+  return denom > 0 ? 3/denom : NaN;
+}
+function toWallRhoFromMeters(w_m: number, axes: [number,number,number]) {
+  const aH = aHarmonic(axes[0], axes[1], axes[2]);
+  return Number.isFinite(aH) ? (w_m / aH) : undefined;
+}
+
 export function WarpBubbleCompare(props: CompareProps) {
   const { leftEngine, rightEngine, parameters, real, show } = props;
   // ...existing code...
@@ -20,14 +32,20 @@ export function WarpBubbleCompare(props: CompareProps) {
   // Compute wall thickness in ρ using harmonic mean (engine parity)
-  const aEff = Math.cbrt(shared.axesHull[0]*shared.axesHull[1]*shared.axesHull[2]); // geometric mean (old)
-  const wallWidth_rho = Math.max(1e-4, Math.min(0.25, (parameters.wallWidth_m ?? 6) / Math.max(1e-6, aEff)));
+  const aH  = aHarmonic(shared.axesHull[0], shared.axesHull[1], shared.axesHull[2]);
+  const wallWidth_rho = (() => {
+    const w_m = +(parameters.wallWidth_m ?? 6);
+    if (!Number.isFinite(aH)) return undefined;
+    return Math.max(1e-4, Math.min(0.25, w_m / aH));
+  })();
 
   // REAL payload (no parity enforcement here)
   const realPhysicsPayload = {
     ...shared,
-    wallWidth_rho,
-    wallWidth_m: parameters.wallWidth_m ?? (wallWidth_rho * aEff),
+    wallWidth_rho,
+    wallWidth_m: (() => {
+      const w_m = +(parameters.wallWidth_m ?? NaN);
+      return Number.isFinite(w_m) ? w_m : (Number.isFinite(aH) && Number.isFinite(wallWidth_rho!) ? wallWidth_rho! * aH : undefined);
+    })(),
     // ...rest...
   };
@@ -38,8 +56,12 @@ export function WarpBubbleCompare(props: CompareProps) {
   const showPhysicsPayload = {
     ...shared,
-    wallWidth_rho,
-    wallWidth_m: parameters.wallWidth_m ?? (wallWidth_rho * aEff),
+    wallWidth_rho,
+    wallWidth_m: (() => {
+      const w_m = +(parameters.wallWidth_m ?? NaN);
+      return Number.isFinite(w_m) ? w_m : (Number.isFinite(aH) && Number.isFinite(wallWidth_rho!) ? wallWidth_rho! * aH : undefined);
+    })(),
     // ...rest...
   };