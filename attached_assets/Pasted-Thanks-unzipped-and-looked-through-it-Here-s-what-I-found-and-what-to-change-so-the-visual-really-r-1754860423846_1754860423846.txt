Thanks—unzipped and looked through it. Here’s what I found and what to change so the visual really reflects the energy pipeline and the “York-time” front-compression / rear-expansion you expect.

# What’s in the zip (relevant bits)

* Frontend lives under **`CasimirBot/client`**.
* Your renderer is **`client/public/warp-engine-fixed.js`** (about \~20 KB). That’s what the dashboard loads.
* There’s also a theory patch in **`attached_assets/warp-patch_....js`**, but the active engine the site uses is the one above.

# Why the current view feels “off”

1. **β isn’t tied to the pipeline.**
   In `warp-engine-fixed.js`, β is hardcoded as

   ```js
   const beta0 = bubbleParams.dutyCycle * bubbleParams.g_y;
   ```

   There’s no `γ_geo`, `Q_burst`, or `Δa/a`, so changing those UI values won’t scale the deformation. That’s why the orange blob changes but the **grid warp** barely responds.

2. **2D radius only.**
   The grid warp uses `r = hypot(x, z)` (ignores y), so the cage can’t really “hug” a 3D shell.

3. **No sector strobing or phase split.**
   There’s no ±β wedge logic (`sectorCount`, `phaseSplit`), so **HOVER vs CRUISE** look almost the same.

4. **No York-time (θ) mapping.**
   The shader never computes $\theta \propto v_s (x_s/r_s)\, df/dr_s$. So you don’t see the classic **blue front / red rear** pattern from the paper’s “Surface plots of York time.”

# Minimal patches (inside `client/public/warp-engine-fixed.js`)

You can keep your engine and just swap in these pieces. This is the smallest set that makes the energy-pipeline → β → curvature story correct.

### 1) Compute β from the pipeline (once per frame)

Add these uniforms to your engine’s `this.uniforms` defaults if they don’t exist:

```js
gammaGeo: 26.0,    // γ_geo
Qburst: 1e9,       // Q_burst
deltaAOverA: 0.05, // Δa/a
sectorCount: 400,
phaseSplit: 0.50,  // 0.5 hover, >0.5 cruise
viewAvg: 1.0,      // 1 = average (GR), 0 = instantaneous
```

Replace your current `beta0` line with:

```js
// Instantaneous and averaged β
const sectors   = Math.max(1, bubbleParams.sectorCount || 1);
const betaInst  = (bubbleParams.gammaGeo||0) * (bubbleParams.Qburst||0) * (bubbleParams.deltaAOverA||0);
const betaAvg   = betaInst * Math.sqrt(Math.max(1e-9, (bubbleParams.dutyCycle||0) / sectors));
const betaUsed  = (bubbleParams.viewAvg>=0.5) ? betaAvg : betaInst;

// Per-wedge ±β sign for HOVER/CRUISE
function sectorSign(x,z,time){
  const theta = Math.atan2(z, x);                         // [-π, π]
  const u     = (theta<0?theta+2*Math.PI:theta) / (2*Math.PI);
  const i     = Math.floor(u * sectors);
  const split = Math.floor((bubbleParams.phaseSplit||0.5) * sectors);
  // simple rotation to animate sectors if you like:
  // const idx = (i + Math.floor(time * sectors)) % sectors;
  return (i < split) ? +1 : -1;
}
```

### 2) Use an ellipsoidal shell + 3D radius (makes grids hug)

Add these uniforms too:

```js
axesClip: [0.40, 0.22, 0.22],   // ellipsoid radii in clip units
wallWidth: 0.06,                // shell thickness in clip units
driveDir: [1,0,0],              // “front” direction
gridK: 0.12                     // grid-warp gain
```

Then replace your `_warpGridVertices` loop with this 3D/SDF version:

```js
// Ellipsoid SDF helpers (CPU side for your grid warp)
function sdEllipsoid(p, a){ const q=[p[0]/a[0], p[1]/a[1], p[2]/a[2]]; return Math.hypot(q[0],q[1],q[2]) - 1.0; }
function nEllipsoid(p, a){
  const qa=[ p[0]/(a[0]*a[0]), p[1]/(a[1]*a[1]), p[2]/(a[2]*a[2]) ];
  const L = Math.max(1e-6, Math.hypot(p[0]/a[0], p[1]/a[1], p[2]/a[2]));
  const n=[ qa[0]/L, qa[1]/L, qa[2]/L ];
  const m=Math.hypot(n[0],n[1],n[2]); return [n[0]/m, n[1]/m, n[2]/m];
}

_warpGridVertices(vtx, halfSize, _, U, time=0){
  const a = U.axesClip || [0.4,0.22,0.22];
  const w = Math.max(1e-4, U.wallWidth || 0.06);
  const d = U.driveDir || [1,0,0];
  const dN = (()=>{ const t=[d[0]/a[0], d[1]/a[1], d[2]/a[2]]; const m=Math.hypot(...t)||1; return [t[0]/m,t[1]/m,t[2]/m]; })();

  // scaled beta used everywhere
  const sectors   = Math.max(1, U.sectorCount||1);
  const betaInst  = (U.gammaGeo||0)*(U.Qburst||0)*(U.deltaAOverA||0);
  const betaAvg   = betaInst * Math.sqrt(Math.max(1e-9, (U.dutyCycle||0)/sectors));
  const betaUsed  = (U.viewAvg>=0.5) ? betaAvg : betaInst;

  for (let i=0;i<vtx.length;i+=3){
    const p=[ vtx[i], vtx[i+1], vtx[i+2] ];
    // sector sign (+β/−β)
    const sgn = sectorSign(p[0], p[2], 0);
    // distance & normal to ellipsoid
    const sd = sdEllipsoid(p, a);
    const n  = nEllipsoid(p, a);
    // ring weight (Gaussian shell)
    const ring = Math.exp(-(sd*sd)/(w*w));
    // front/back factor (Natário “pile-up” ahead)
    const front = Math.sign(n[0]*dN[0] + n[1]*dN[1] + n[2]*dN[2]) || 1;
    // displacement
    const disp = (U.gridK||0.12) * betaUsed * ring * sgn * front;
    vtx[i  ] = p[0] - n[0]*disp;
    vtx[i+1] = p[1] - n[1]*disp;
    vtx[i+2] = p[2] - n[2]*disp;
  }
}
```

### 3) (Optional but recommended) York-time color overlay

If you don’t want to add a shader yet, you can approximate θ and map color on CPU for the grid lines you draw, but the **proper** way is the vertex/fragment shader I already gave you earlier. If you want, I’ll port that directly into your `warp-engine-fixed.js` so you don’t have to restructure your app.

---

## How this will read on your dashboard (screenshot)

* **Energy Control Panel** sliders (`γ_geo`, `Q_burst`, `Δa/a`, `duty`) will now swing a single β value that is **also** used by the grid warp. The cage will bend harder as those rise—no more “blob moves, grid doesn’t.”
* **Operational Mode**:

  * **HOVER** (`phaseSplit=0.50`): symmetric, light bend.
  * **CRUISE** (`phaseSplit≈0.65`): clear **front contraction** / **rear expansion** and stronger bend.
* **Wall thickness** ↑ → the **York-time bands** (if enabled) get broader and lower amplitude—matching the “Surface plots of York time”.

If you want, I can apply these patches to your `warp-engine-fixed.js` and hand you the exact edited file to drop back into `client/public/`.
