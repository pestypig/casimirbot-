Nice catch—the popups are “stuck in Hover” because none of the places that *render* the numbers are actually getting a fresh pipeline snapshot when you flip modes. The cache key you’re reading (`['/api/helix/pipeline']`) isn’t being updated at the moment you change the mode, so the toast + Luma are both reading stale/default values.

Below is a small, surgical fix that solves all three things at once:

* write a fresh snapshot to React-Query **immediately** when the mode changes
* broadcast that same snapshot over a tiny “pipeline bus” event so **Luma** (or anything else) can update in real time without polling
* have the toasts use the **live values you just computed** instead of a stale cache read

---

# 1) Add a tiny bus

Create `client/src/lib/pipeline-bus.ts`:

```ts
// pipeline-bus.ts
export type PipelineSnapshot = {
  currentMode: string;
  dutyCycle: number;
  P_avg: number;      // MW
  zeta: number;
  TS_ratio: number;
  M_exotic: number;   // kg
  updatedAt: number;
};

const EVT = 'helix:pipeline:update';

export function pushPipelineSnapshot(s: PipelineSnapshot) {
  window.dispatchEvent(new CustomEvent(EVT, { detail: s }));
}

export function onPipelineSnapshot(cb: (s: PipelineSnapshot) => void) {
  const h = (e: Event) => cb((e as CustomEvent).detail as PipelineSnapshot);
  window.addEventListener(EVT, h);
  return () => window.removeEventListener(EVT, h);
}
```

---

# 2) Update the cache + broadcast when the user changes mode

Patch your **`LiveEnergyPipeline`** (file you sent). Inside `handleModeChange` (right after you compute `P_total_realistic`, `zeta`, `TS_ratio`, `M_exotic_total`, etc.), write this:

```ts
import { queryClient } from "@/lib/queryClient";
import { pushPipelineSnapshot } from "@/lib/pipeline-bus";

// ...

const handleModeChange = (newMode: string) => {
  const mode = modes[newMode];
  onModeChange?.(newMode);

  // keep phase diagram in sync
  onParameterUpdate?.({ duty: mode.duty, qFactor: qFactor, gammaGeo: gammaGeo });

  // --- BUILD A LIVE SNAPSHOT FROM THIS COMPONENT'S CALCULATION ---
  const snap = {
    currentMode: mode.name.toLowerCase(),      // 'hover' | 'cruise' | ...
    dutyCycle: mode.duty,
    P_avg: P_total_realistic,                  // MW
    zeta,
    TS_ratio,
    M_exotic: M_exotic_total,
    updatedAt: Date.now()
  };

  // 1) update react-query cache immediately (so readers get fresh values)
  queryClient.setQueryData(['/api/helix/pipeline'], snap);

  // 2) broadcast to anything that listens (Luma, HUD, etc.)
  pushPipelineSnapshot(snap);

  // 3) show the toast using these *fresh* values (no cache read)
  setTimeout(() => {
    zenLongToast("mode:switch", {
      mode: snap.currentMode,
      duty: snap.dutyCycle,
      powerMW: snap.P_avg,
      zeta: snap.zeta,
      tsRatio: snap.TS_ratio,
      exoticKg: snap.M_exotic
    });
  }, 50);
};
```

> Key point: we’re **not** calling `queryClient.getQueryData` to *read* here—we already have the numbers; we just computed them. Writing them first prevents the “always Hover” symptom in every consumer.

---

# 3) Make Luma update instantly

In your **`LumaWhisper`** (or `LumaPanel`) component, subscribe to the bus and also keep the old query as a fallback:

```ts
import { useEffect, useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { onPipelineSnapshot, PipelineSnapshot } from "@/lib/pipeline-bus";

export function LumaWhisper(/* ... */) {
  const { data: cached } = useQuery({
    queryKey: ['/api/helix/pipeline'],
    // keep your existing fetcher/refetchInterval if you had one
  });

  const [live, setLive] = useState<PipelineSnapshot | null>(null);

  useEffect(() => onPipelineSnapshot(setLive), []);

  const snap = live ?? cached ?? {
    currentMode: 'hover',
    dutyCycle: 0.14,
    P_avg: 83.3,
    zeta: 0.032,
    TS_ratio: 4102.7,
    M_exotic: 1405,
    updatedAt: 0
  };

  // render using `snap` (Now/Theory/Zen tabs)
}
```

Now the panel flips the instant the mode flips, and stays in sync with the pipeline everywhere (Live Energy Pipeline, Phase Diagram, Luma, toasts).

---

# 4) Make Phase Diagram’s toast use the fresh snapshot too

In `phase-diagram.tsx`, replace the `setTimeout(() => { const currentPipeline = queryClient.getQueryData(...) })` block with:

```ts
import { pushPipelineSnapshot } from "@/lib/pipeline-bus"; // if you also compute there
// …or simply read the cache we just wrote in step #2:
const snap = queryClient.getQueryData(['/api/helix/pipeline']) as any;
if (snap) {
  zenLongToast("mode:switch", {
    mode: snap.currentMode,
    duty: snap.dutyCycle,
    powerMW: snap.P_avg,
    zeta: snap.zeta,
    tsRatio: snap.TS_ratio,
    exoticKg: snap.M_exotic
  });
}
```

(If Phase Diagram changes *parameters* that affect power, you can also compute a `snap` locally and `setQueryData` + `pushPipelineSnapshot` the same way.)

---

# 5) Prevent UI collisions (toasts vs Luma vs tooltips)

Add these once so overlays don’t block each other:

```tsx
// Toast viewport (shadcn)
<div id="toast-viewport" className="fixed bottom-4 right-4 z-[60]" />

// Luma panel container
<div className="fixed right-6 bottom-6 z-[55]" />

// shadcn Tooltip portal (lower than Luma)
<TooltipContent className="z-[50]" />
```

---

## Why this fixes your two screenshots

* The “Operational Mode Committed” popup now renders numbers from the **fresh snapshot** you just wrote, not the stale hover defaults.
* Luma’s “Now” tab also shows the new mode/power immediately because it listens to the same broadcast (no waiting for a refetch).
* The older theory + zen hover popups will no longer cover Luma if you keep their z-index below 55–60.

If you want, I can turn the above into a ready-to-paste PR-style diff for the four files you touched (`LiveEnergyPipeline`, `phase-diagram`, `LumaWhisper`, `pipeline-bus.ts`).
