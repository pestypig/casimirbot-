Here’s a robust drop-in fix for WarpBubbleCompare.tsx that handles both. It lazy-loads the engine if missing, and then safely grabs the constructor (.default ?? fallback):

// add near the top of WarpBubbleCompare.tsx
function loadScript(src: string) {
  return new Promise<void>((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.async = true;
    s.onload = () => resolve();
    s.onerror = () => reject(new Error(`Failed to load ${src}`));
    document.head.appendChild(s);
  });
}

async function ensureWarpEngineCtor(): Promise<any> {
  const w = window as any;
  let Ctor = w.WarpEngine?.default || w.WarpEngine;
  if (typeof Ctor === 'function') return Ctor;

  // try fixed then fallback bundle—same paths your TSX loader uses
  const candidates = ['/warp-engine-fixed.js?v=tilt2', '/warp-engine.js?v=fallback'];
  for (const src of candidates) {
    try { await loadScript(src); } catch { /* keep trying */ }
    Ctor = (w.WarpEngine?.default || w.WarpEngine);
    if (typeof Ctor === 'function') return Ctor;
  }
  throw new Error('WarpEngine constructor not found after script load');
}


Then replace the failing useEffect block with this guarded version:

- useEffect(() => {
-   if (!leftRef.current || !rightRef.current) return;
-   leftEngine.current  = new window.WarpEngine(leftRef.current);
-   rightEngine.current = new window.WarpEngine(rightRef.current);
- }, []);
+ useEffect(() => {
+   let cancelled = false;
+   (async () => {
+     if (!leftRef.current || !rightRef.current) return;
+     try {
+       const WarpCtor = await ensureWarpEngineCtor();
+       if (cancelled) return;
+       leftEngine.current  = new WarpCtor(leftRef.current);
+       rightEngine.current = new WarpCtor(rightRef.current);
+     } catch (e) {
+       console.error('[WarpBubbleCompare] init failed:', e);
+     }
+   })();
+   return () => {
+     cancelled = true;
+     try { leftEngine.current?.destroy?.(); } catch {}
+     try { rightEngine.current?.destroy?.(); } catch {}
+   };
+ }, []);


If you want to be extra safe when multiple viewers are on the page, add the strobing mux wrapper after you create the engines (prevents anyone overwriting anyone):

function ensureStrobeMux() {
  const w = window as any;
  const prev = w.setStrobingState;
  if (!w.__strobeListeners) w.__strobeListeners = new Set();
  w.setStrobingState = (payload: any) => {
    try { typeof prev === 'function' && prev(payload); } catch {}
    for (const fn of w.__strobeListeners) { try { fn(payload); } catch {} }
  };
  w.__addStrobingListener = (fn: Function) => { w.__strobeListeners.add(fn); return () => w.__strobeListeners.delete(fn); };
}


…and call ensureStrobeMux() right after both new WarpCtor(...) lines.