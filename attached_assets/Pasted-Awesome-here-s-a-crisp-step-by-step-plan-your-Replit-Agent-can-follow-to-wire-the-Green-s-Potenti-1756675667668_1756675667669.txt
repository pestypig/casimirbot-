Awesome—here’s a crisp, step-by-step plan your Replit Agent can follow to wire the **Green’s Potential (φ = G·ρ)** into the pipeline so the Bridge panel shows live values (no more “NONE / —”).

---

# 0) Objective + “source of truth”

* **Publisher**: something in the app must publish a *canonical Greens payload* to:

  * React Query cache key: `["helix:pipeline:greens"]`
  * Window event: `"helix:greens"`
* **Subscribers (cards/panels)**: Bridge/Derivation card(s) and Energy Pipeline card *already* listen to those; they’ll populate as soon as that payload exists.

Your Energy Pipeline component *can* publish manually (the “Publish to renderer” button), but we want **automatic** publishing so it works even when the pipeline page isn’t mounted.

---

# 1) Standardize keys & event names (avoid typos)

Create a tiny constants module (or add to an existing one):

```ts
// client/src/lib/greens-bridge.ts
export const GREENS_CACHE_KEY = ["helix:pipeline:greens"] as const;
export const GREENS_EVENT = "helix:greens";
```

Use these everywhere (publisher & subscriber).

---

# 2) Add a canonical publisher utility

Still in `greens-bridge.ts`:

```ts
import { queryClient } from "@/lib/queryClient";
import { GREENS_CACHE_KEY, GREENS_EVENT } from "./greens-bridge";

export type GreensPayload = {
  kind: "poisson" | "helmholtz";
  m?: number;               // Helmholtz mass param (optional)
  normalize?: boolean;      // default true
  phi: Float32Array;        // the array
  size: number;             // convenience
  source: "server" | "client";
};

export function publishGreens(payload: GreensPayload) {
  queryClient.setQueryData(GREENS_CACHE_KEY, payload);
  try {
    window.dispatchEvent(new CustomEvent(GREENS_EVENT, { detail: payload }));
  } catch {}
}
```

---

# 3) Add subscriber hook (if you don’t already have one)

This lets any card read the latest φ, both from cache and live events.

```ts
// client/src/hooks/use-greens.ts
import { useEffect, useState } from "react";
import { queryClient } from "@/lib/queryClient";
import { GREENS_CACHE_KEY, GREENS_EVENT } from "@/lib/greens-bridge";
import type { GreensPayload } from "@/lib/greens-bridge";

export function useGreens() {
  const [data, setData] = useState<GreensPayload | null>(
    () => (queryClient.getQueryData(GREENS_CACHE_KEY) as GreensPayload | undefined) ?? null
  );
  useEffect(() => {
    const onEvt = (e: Event) => {
      const detail = (e as CustomEvent).detail as GreensPayload;
      setData(detail);
      queryClient.setQueryData(GREENS_CACHE_KEY, detail); // keep cache in sync
    };
    window.addEventListener(GREENS_EVENT, onEvt as any);
    return () => window.removeEventListener(GREENS_EVENT, onEvt as any);
  }, []);
  return data;
}
```

> Your cards already use the same cache key + event; if you have a similar hook, keep it—just ensure it uses the constants above.

---

# 4) Provide CPU kernel + stats helpers (one place)

Put these where both bridge and pipeline can import them (or reuse your existing copies).

```ts
// client/src/lib/greens-kernels.ts
export type Vec3 = [number, number, number];
export type Kernel = (r: number) => number;

export const poissonKernel: Kernel = r => 1/(4*Math.PI*Math.max(r,1e-6));
export const helmholtzKernel = (m:number): Kernel =>
  r => Math.exp(-m*Math.max(r,1e-6)) / (4*Math.PI*Math.max(r,1e-6));

export function computeGreenPotential(
  positions: Vec3[],
  rho: number[],
  kernel: Kernel,
  normalize = true
): Float32Array {
  const N = positions.length;
  const out = new Float32Array(N);
  for (let i=0;i<N;i++){
    let sum=0;
    const [xi,yi,zi]=positions[i];
    for (let j=0;j<N;j++){
      const [xj,yj,zj]=positions[j];
      const dx=xi-xj, dy=yi-yj, dz=zi-zj;
      const r=Math.hypot(dx,dy,dz)+1e-6;
      sum += kernel(r) * rho[j];
    }
    out[i]=sum;
  }
  if (normalize) {
    let min=+Infinity, max=-Infinity;
    for (let i=0;i<N;i++){ const v=out[i]; if (v<min) min=v; if (v>max) max=v; }
    const span = max-min || 1;
    for (let i=0;i<N;i++) out[i] = (out[i]-min)/span;
  }
  return out;
}

export function stats(arr: ArrayLike<number>) {
  let min=+Infinity, max=-Infinity, sum=0;
  const N = arr.length;
  for (let i=0;i<N;i++){
    const v = arr[i] as number;
    if (v<min) min=v;
    if (v>max) max=v;
    sum += v;
  }
  return { min, max, mean: N? sum/N : 0, N };
}
```

---

# 5) Build the **Bridge** hook that auto-publishes φ

This is the missing piece. It should run even when the Energy Pipeline page isn’t open.

```ts
// client/src/pages/helix-core.tsx (or a nearby file imported by that page)
import { useEffect, useMemo } from "react";
import { useEnergyPipeline } from "@/hooks/use-energy-pipeline";
import { useQuery } from "@tanstack/react-query";
import { publishGreens } from "@/lib/greens-bridge";
import { poissonKernel, helmholtzKernel, computeGreenPotential } from "@/lib/greens-kernels";

function useGreensBridge() {
  // 1) Live pipeline (may include server-provided greens or tiles)
  const { data: pipeline } = useEnergyPipeline({ refetchInterval: 1000 });
  // 2) Metrics (usually contains tiles: [{pos:[x,y,z], t00}])
  const { data: metrics } = useQuery({ queryKey: ["/api/helix/metrics"], refetchInterval: 5000 });

  // Resolve source: prefer server φ, else compute from tiles
  const resolved = useMemo(() => {
    // server path
    const srv = (pipeline as any)?.greens as { phi?: number[]|Float32Array, kind?: "poisson"|"helmholtz", m?: number, normalize?: boolean } | undefined;
    if (srv?.phi && (srv.phi as any).length > 0) {
      return {
        phi: srv.phi instanceof Float32Array ? srv.phi : new Float32Array(srv.phi),
        kind: srv.kind ?? "poisson",
        m: srv.m ?? 0,
        normalize: srv.normalize !== false,
        source: "server" as const,
      };
    }

    // client path (needs tiles)
    const tiles = (pipeline as any)?.tiles ?? (metrics as any)?.tiles;
    if (Array.isArray(tiles) && tiles.length > 0) {
      const positions = tiles.map((t:any)=>t.pos);
      const rho       = tiles.map((t:any)=>t.t00);
      const kind = "poisson" as const; // default; switch to helmholtz if you carry m
      const kernel = poissonKernel;
      const phi = computeGreenPotential(positions, rho, kernel, true);
      return { phi, kind, m: 0, normalize: true, source: "client" as const };
    }

    return null;
  }, [pipeline, metrics]);

  // Publish to cache + event
  useEffect(() => {
    if (!resolved) return;
    publishGreens({
      kind: resolved.kind,
      m: resolved.m,
      normalize: resolved.normalize,
      phi: resolved.phi,
      size: resolved.phi.length,
      source: resolved.source,
    });
  }, [resolved]);
}
```

**Call the hook once** at the top of your Helix Core page:

```diff
// client/src/pages/helix-core.tsx
 export default function HelixCore() {
+  // Always keep Greens payload alive, regardless of which panel is open
+  useGreensBridge();
   …
 }
```

> This single call ensures φ is computed or adopted + published continuously. No panel needs to be open for Greens to flow.

---

# 6) Verify the **Energy Pipeline** can also publish (optional)

You’ve already got a “Publish to renderer” button in `energy-pipeline.tsx`. Make it use the same publisher:

```ts
import { publishGreens } from "@/lib/greens-bridge";
// …
const payload = {
  kind: greenKind,
  m: mHelm,
  normalize: normalizeGreens,
  phi: greenPhi.phi,
  size: greenPhi.phi.length,
  source: greenPhi.source
};
publishGreens(payload);
```

(You already do this—just confirm it’s the same publisher and constants.)

---

# 7) Ensure Bridge/Derivation card subscribes the same way

If the card currently hand-reads React Query and the event, that’s fine. Otherwise, switch to the hook:

```ts
// client/src/components/BridgeDerivationCards.tsx
import { useGreens } from "@/hooks/use-greens";
import { stats } from "@/lib/greens-kernels";
// …
const greens = useGreens();
const gstats = greens?.phi ? stats(greens.phi) : { min: NaN, max: NaN, mean: NaN, N: 0 };
// Render:
// greens?.source ?? "none"
// greens?.kind ?? "poisson"
// (gstats.N || "—"), and φ_min/max/mean via toExponential(3)
```

---

# 8) Backend: provide at least one source of truth

You need **either**:

* `/api/helix/pipeline` → `{ …, greens: { phi:number[]|Float32Array, kind?, m?, normalize? }, tiles?: [{pos:[x,y,z], t00}] }`
* **OR** `/api/helix/metrics` → `{ tiles: [{pos:[x,y,z], t00}] }`

> If you don’t want to send full φ from the server, **send tiles** (positions + T00). The bridge will compute φ on the client.

---

# 9) Performance guard (optional but smart)

If `tiles.length > 2500` the O(N²) CPU path will stutter. Add a guard in `useGreensBridge()`:

```ts
if (Array.isArray(tiles) && tiles.length > 2500) {
  // Skip compute or switch to a downsample / GPU path
  return null;
}
```

…and show a tooltip “N too large; computation disabled”.

---

# 10) QA checklist

1. Open **Helix Core** (any tab).

   * Confirm `useGreensBridge()` is called (add a console “GreensBridge active” once).
2. Ensure the server returns either:

   * pipeline.greens.phi (server-provided) **or**
   * metrics.tiles (client-computable).
3. Look at the **Greens card**:

   * “Kernel”: “Poisson” (or “Helmholtz (m=…)”)
   * “N (tiles)”: > 0
   * φ\_min/φ\_max/φ\_mean: numbers (e.g., `1.23e-3`)
   * “Status: server | client | none” should be **server** or **client**, not **none**.
4. Flip mode (hover/cruise/emergency) → verify the card still updates (bridge continues to publish).
5. Optional: click “Publish to renderer” on Energy Pipeline; confirm the Bridge card updates immediately (same event & cache key).

---

# 11) Common failure modes & fixes

* **Still shows “NONE / Size: 0”**

  * `useGreensBridge()` not called (add it to HelixCore).
  * No tiles & no server φ (fix backend to return either).
  * Cache key typo (use `GREENS_CACHE_KEY` constant).
  * Event name mismatch (use `GREENS_EVENT` constant).
* **Numbers “—” but Status shows server/client**

  * You publish an empty `Float32Array`; verify `size > 0` before publish.
* **Compute too slow**

  * Downsample tiles, switch to Helmholtz with larger `m` (shorter range), or move to GPU.

---

That’s the whole loop. Once the **bridge** runs, your **Green’s Potential** cards will switch from:

```
NONE
Kernel — · norm
N (tiles) —
φ_min —
φ_max —
φ_mean —
```

to live, non-empty stats—whether or not the Energy Pipeline page is open.
