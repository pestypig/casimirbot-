Below is a recipe for extending your `computeResults()` pipeline (and your UI) so that every one of those theory‐slides equations gets its variables filled in, computed, and displayed.

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
1) In your back-end “computeResults” (or Redux thunk), after you’ve already read in  

• E_static ← (–2.55×10⁻³ J from `E_interaction`)  
• γ_geo ← geometry amp (≈ 25)  
• Q ← 1×10⁹  
• f_m ← 15 GHz  
• t_burst ← 10 µs, t_cycle ← 1 ms  
• R_hull, A_tile, N_tiles ← hull area / tile area (≈ 1.96×10⁹)  

add the following JS:  
```js
// constants
const c      = 299_792_458;              // m/s
const ω      = 2*Math.PI * f_m;          // angular freq [rad/s]

// 1) Q-factor amplification
const U_static = E_static;               // per-cavity static Casimir energy
const U_Q      = Q * U_static;            // U_Q = Q·U_static

// 2) Geometric amplification (Van den Broeck)
const U_geo    = γ_geo * U_Q;             // U_geo = γ·U_Q

// 3) Fractional stroke / duty cycle
const d        = t_burst / t_cycle;       // d = t_burst / t_cycle

// 4) Stored energy per cycle
const U_cycle  = U_geo * d;               // ⟨E⟩_cycle = U_geo·d

// 5) Power loss per cavity
//    P_loss = U_geo / (Q/ω) = U_geo·ω / Q
const P_loss   = U_geo * ω / Q;

// 6) Time-scale separation check
//    τ_pulse = t_burst,   T_LC = 2·R_hull / c  (round-trip light time)
const τ_pulse  = t_burst;
const T_LC     = 2 * R_hull / c;
const TS_ratio = τ_pulse / T_LC;          // ≪1?

// 7) Per-tile negative energy
const E_tile   = U_cycle;                 // E_tile = U_geo·d

// 8) Total exotic energy & mass
const E_total  = E_tile * N_tiles;
const m_exotic = Math.abs(E_total) / (c*c); // via E=mc²

// Gather into your results object
return {
  …,
  U_static, U_Q, U_geo, d, U_cycle, P_loss,
  TS_ratio, E_tile, N_tiles, E_total, m_exotic
};
```

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
2) Wire each new variable into your UI  

a) In your “Warp Bubble Analysis” card (or create a new “Energy Pipeline” section) show:  
• U_Q (J)  
• U_geo (J)  
• U_cycle (J)  
• P_loss (W)  
• τ_pulse/T_LC (no units)  

b) In your “Design Ledger” (Target Verification) add rows:  
• Stored/cycle U_cycle (target ≈ 4×10⁶ J per tile)  
• P_loss (compare vs. ideal loss budget, e.g. show green if P_loss ≪ P_avg)  
• Time-scale ratio TS_ratio (green if < .1)  

c) In your existing Exotic Mass / Power block you already have  
• E_tile → map to U_cycle  
• Exotic mass → m_exotic  
• Power draw → P_loss (or your mitigated P_avg)  

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
3) UI implementation sketch (React)  
```jsx
function EnergyPipeline({ r }) {
  return (
    <div className="energy-pipeline">
      <h4>Energy Pipeline</h4>
      <ul>
        <li>U_Q = Q·U_static : {r.U_Q.toExponential(2)} J</li>
        <li>U_geo = γ·U_Q     : {r.U_geo.toExponential(2)} J</li>
        <li>⟨U⟩_cycle = U_geo·d: {r.U_cycle.toExponential(2)} J</li>
        <li>P_loss = U_geo·ω/Q: {r.P_loss.toExponential(2)} W</li>
        <li>τ_pulse / T_LC     : {r.TS_ratio.toExponential(2)}</li>
      </ul>
    </div>
  );
}

// in your Results page
<WarpBubbleAnalysis results={r} />
<EnergyPipeline       results={r} />
<DesignLedger         results={r} />
```

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
4) Targets & traffic-lighting  

– U_cycle (per tile) → ~ 4×10⁶ J  
– m_exotic             → 1.4×10³ kg ± 5 %  
– P_loss or P_avg      → 8.3×10⁷ W ± 10 %  
– TS_ratio             → ≪ 1 (green if < 0.1)  

Use the same `<CheckIcon>` / `<XIcon>` pattern you already have to flag each row.  

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
Once wired this way, your app will have a complete “from T_{00} → metric checks” pipeline:  

1. T_{μν} sourcing via static Casimir (E_static)  
2. Q and geometric amplification  
3. Duty-cycle averaging  
4. Power‐loss and time-scale checks  
5. Per-tile and full exotic mass  
6. Display all intermediate and final variables  

Every theory slide is now linked to one entry in your Replit results, and you can verify each step by comparing to the analytic targets.