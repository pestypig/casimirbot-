That error is the classic temporal-dead-zone problem: a let/const variable is read before itâ€™s initialized (or a destructure grabs a field from undefined). With our recent tweaks to viewAvg/uniforms itâ€™s very likely happening in the WebGL engine (or the React bridge) where we use this.uniforms.viewAvg before the uniforms object has been created.

Hereâ€™s a safe, drop-in way to eliminate it.

â¸»

1) Give the engine hard defaults (constructor)

client/public/warp-engine-fixed.js

class WarpEngine {
  constructor(canvas) {
    // ...
    this.uniforms = {
      // physics defaults
      dutyCycle: 0.14,
      gammaGeo: 26,
      Qburst: 1e9,
      deltaAOverA: 1,
      gammaVdB: 2.86e5,
      sectors: 1,

      // viz defaults
      viewAvg: 0,        // 0 = instantaneous, 1 = averaged
      vizGain: 4,

      // geometry defaults
      hullAxes: [503.5, 132, 86.5], // semi-axes (m)
      wallWidth: 0.06               // normalized wall thickness
    };
  }

2) Merge updates safely

  updateUniforms(next) {
    // never replace, always merge
    this.uniforms = { ...this.uniforms, ...(next || {}) };
  }

3) Read uniforms with defaults (no TDZ)

At the top of _warpGridVertices(...) (or the function that does the displacement):

  const {
    dutyCycle = 0.14,
    gammaGeo = 26,
    Qburst = 1e9,
    deltaAOverA = 1,
    gammaVdB = 2.86e5,
    sectors = 1,
    viewAvg = 0,
    vizGain = 4,
    hullAxes = [503.5, 132, 86.5],
    wallWidth = 0.06
  } = this.uniforms || {};

Important: Do not declare const viewAvg again later. Just use this one.

Then your beta selection becomes:

  const betaInst = Math.pow(gammaGeo, 3) * Qburst * deltaAOverA * Math.pow(gammaVdB, 0.25);
  const betaAvg  = betaInst * Math.sqrt(Math.max(1e-9, dutyCycle / Math.max(1, sectors)));
  const betaUsed = (viewAvg >= 0.5) ? betaAvg : betaInst;

4) React bridge: send numbers, not undefined

client/src/components/WarpVisualizer.tsx

const num = (v: unknown, d = 0) => (v == null ? d : Number(v));

engineRef.current?.updateUniforms({
  dutyCycle:          num(parameters.dutyCycle, 0.14),
  gammaGeo:           num(parameters.g_y, 26),
  Qburst:             num(parameters.cavityQ, 1e9),
  deltaAOverA:        num(parameters.qSpoilingFactor, 1),
  gammaVdB:           num(parameters.gammaVanDenBroeck, 2.86e5),
  sectors:            num(parameters.sectorStrobing, 1),
  viewAvg:            num(parameters.viewAvg, 0),   // <- NEW, safe default
  vizGain:            num(parameters.vizGain, 4),
  hullAxes:           parameters.hull ? [parameters.hull.a, parameters.hull.b, parameters.hull.c] : [503.5,132,86.5],
  wallWidth:          num(parameters.wallWidth, 0.06)
});

5) Common TDZ traps to check
	â€¢	A variable declared with const/let below is referenced above (move the declaration up).
	â€¢	Two declarations of the same name in one scope (e.g., const viewAvg = ... twice). Keep one.
	â€¢	Destructuring from undefined:

const {x} = maybeUndefined; // ðŸ’¥
// Use: const {x=1} = maybeUndefined || {};



After making these changes, do a hard reload (HMR can cache the old scope) and the â€œCannot access uninitialized variableâ€ error should disappear.

If it still fires, grab the exact file/line from the stack and Iâ€™ll pinpoint that spot with the same pattern.