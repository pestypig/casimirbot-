Nice—thanks for pasting the file. Your component is solid; two things are causing the weirdness:

1. **It fits the whole image**, not “center on Sol.” If the PNG isn’t centered the same way as the SVG, your route looks offset.
2. **Panning isn’t clamped**, so you can drag the image completely out of frame (black background shows).

Here’s a tiny patch you can drop in.

---

### A) Center on Sol at load (instead of fit-whole-image)

Replace your “fit-to-screen” effect with this “center-on-origin” version:

```ts
// after nat is known, center Sol (originPx) in the viewport
React.useEffect(()=>{
  if (!nat) return;
  const zx = width / nat.w, zy = height / nat.h;
  const fit = Math.min(zx, zy);
  setZoom(fit);
  // put SOL at the middle of the viewport
  const ox = width/2  - originPx.x * fit;
  const oy = height/2 - originPx.y * fit;
  setOff({ x: ox, y: oy });
}, [nat, width, height, originPx.x, originPx.y]);
```

> If you want a bit more of the map around Sol, multiply `fit` by \~1.1 before computing `ox/oy`.

---

### B) Clamp panning so the image can’t “pop out”

Add this helper:

```ts
function clampOffset(off:{x:number;y:number}, zoom:number, nat:{w:number;h:number}, view:{w:number;h:number}) {
  const imgW = nat.w * zoom, imgH = nat.h * zoom;
  const margin = 80; // allow a little breathing room
  const minX = Math.min(margin, view.w - imgW - margin);
  const maxX = Math.max(view.w - imgW - margin, margin);
  const minY = Math.min(margin, view.h - imgH - margin);
  const maxY = Math.max(view.h - imgH - margin, margin);
  return {
    x: Math.max(minX, Math.min(maxX, off.x)),
    y: Math.max(minY, Math.min(maxY, off.y)),
  };
}
```

Use it wherever you set `offset`:

```ts
// on load/center
setOff(prev => clampOffset({ x: ox, y: oy }, fit, nat, {w:width, h:height}));

// on drag
setOff(prev => clampOffset({ x: e.clientX - dragging.current!.dx, y: e.clientY - dragging.current!.dy }, zoom, nat!, {w:width,h:height}));

// on wheel (after computing newZoom/newOff)
const newOff = { x: mx - sx*newZoom, y: my - sy*newZoom };
setOff(prev => clampOffset(newOff, newZoom, nat!, {w:width,h:height}));
setZoom(newZoom);
```

Also add `overflow-hidden` to the container (so edges don’t show):

```tsx
<div
  ref={containerRef}
  ...
  className="relative rounded-lg border bg-black overflow-hidden"
>
```

---

### C) Make sure your calibration matches the **PNG you’re drawing**

If you haven’t already, compute `originPx` and `scalePxPerPc` from the SVG → PNG mapping (so Sol is the true pixel in *this* image):

```ts
// once, when image loads
import { calibrateToImage } from "@/lib/galaxy-calibration";

const { originPx, pxPerPc } = calibrateToImage(imgNaturalWidth, imgNaturalHeight);
// then pass originPx and scalePxPerPc={pxPerPc} into <GalaxyMapPanZoom/>
```

(Values hard-coded like `{x:512,y:200}, 0.8` will misalign.)

---

With those three tweaks:

* the map will **open centered on Sol**,
* you won’t be able to drag it off-screen,
* and the routes should line up with the PNG.

If anything still feels off after that, send me the `originPx/scalePxPerPc` you’re using and the **natural size** of the PNG (right-click → open image in new tab, check dimensions). I’ll sanity-check the numbers.
