Good catch—if the view didn’t change, it means something else is re-applying the old “low” pose after the fitter runs, or the fitter isn’t being called on first paint for your current code path. The safest fix is to centralize the camera into a single “overhead fit” function and call it at every place that can affect the view (initialization, resize, grid span changes, and uniform updates). Below is a robust patch that:
	•	Forces a single overhead camera solution.
	•	Calls it from _setupCamera, bootstrap, _resizeCanvasToDisplaySize, and updateUniforms.
	•	Ignores the legacy “low” pose even if other helpers run later.
	•	Still allows an explicit cameraZ override if you intentionally pass it.

⸻

Patch — client/public/warp-engine-fixed.js

@@
   constructor(canvas) {
     this.canvas = canvas;
     this.gl = this.canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true });
     // ...
+    this.cameraMode = 'overhead';         // new: single source of truth for camera pose
+    this._lastFittedR = 1;                // cache last fit radius for stability
   }
 
+  // --- central overhead camera (single place to change the pose) ---
+  _applyOverheadCamera(opts = {}) {
+    const gl = this.gl;
+    if (!gl) return;
+    const aspect = this.canvas.width / Math.max(1, this.canvas.height);
+    const fov = this._fitFovForAspect(aspect);      // your existing helper
+
+    // bubble radius in scene units
+    const axes = (this.currentParams && this.currentParams.hullAxes) || [1,1,1];
+    const R = Math.max(axes[0], axes[1], axes[2], opts.spanHint || 1);
+    this._lastFittedR = R;
+
+    const baseMargin = 1.22;
+    const margin = baseMargin * (aspect < 1 ? 1.12 : 1.00);
+    const dist = (margin * R) / Math.tan(fov * 0.5);
+
+    // ↑ raise camera; ↓ look slightly down so bubble isn’t on the horizon
+    const eye    = [0, 0.45 * R, -dist];
+    const center = [0, -0.08 * R, 0];
+    const up     = [0, 1, 0];
+
+    this._perspective(this.projMatrix, fov, aspect, 0.08, 100.0);
+    this._lookAt(this.viewMatrix, eye, center, up);
+    this._multiply(this.mvpMatrix, this.projMatrix, this.viewMatrix);
+  }
+
   _setupCamera() {
-    const aspect = this.canvas.width / this.canvas.height;
-    this._perspective(this.projMatrix, Math.PI / 3, aspect, 0.1, 100.0);
-    const eye = [0, 0.5, -1.8];
-    const center = [0, -0.1, 0];
-    const up = [0, 1, 0];
-    this._lookAt(this.viewMatrix, eye, center, up);
-    this._multiply(this.mvpMatrix, this.projMatrix, this.viewMatrix);
+    // always start in the overhead fitted view
+    this._applyOverheadCamera();
   }
 
   // existing helper
   _fitFovForAspect(aspect) {
     const fovDesktop = Math.PI / 3;
     const fovPortrait = Math.PI / 2.65;
     const t = Math.min(1, Math.max(0, (1.2 - aspect) / 0.6));
     return fovDesktop * (1 - t) + fovPortrait * t;
   }
 
   _resizeCanvasToDisplaySize() {
     const dpr = window.devicePixelRatio || 1;
     const w = Math.floor(this.canvas.clientWidth * dpr);
     const h = Math.floor(this.canvas.clientHeight * dpr);
     if (this.canvas.width !== w || this.canvas.height !== h) {
       this.canvas.width = w;
       this.canvas.height = h;
-      this._adjustCameraForSpan(this._gridSpan || 1.0);
+      // after resize, reapply overhead fit (no low pose flash)
+      this._applyOverheadCamera({ spanHint: this._gridSpan || 1.0 });
     }
   }
 
   // called when we know the grid span
   _adjustCameraForSpan(span) {
-    // Respect a manual override if provided
-    if (Number.isFinite(this.currentParams?.cameraZ)) {
-      const eye = [0, 0.35, -this.currentParams.cameraZ];
-      const center = [0, -0.05, 0];
-      const up = [0, 1, 0];
-      this._lookAt(this.viewMatrix, eye, center, up);
-      this._multiply(this.mvpMatrix, this.projMatrix, this.viewMatrix);
-      return;
-    }
-    const desired = Math.max(1.20, span * 0.90);
-    const eye = [0, 0.35, -desired];
-    const center = [0, -0.05, 0];
-    const up = [0, 1, 0];
-    this._lookAt(this.viewMatrix, eye, center, up);
-    this._multiply(this.mvpMatrix, this.projMatrix, this.viewMatrix);
+    // prefer overhead fit unless the user explicitly set cameraZ
+    if (Number.isFinite(this.currentParams?.cameraZ)) {
+      const aspect = this.canvas.width / Math.max(1, this.canvas.height);
+      const eye = [0, 0.50, -this.currentParams.cameraZ];
+      const center = [0, -0.08, 0];
+      const up = [0, 1, 0];
+      this._perspective(this.projMatrix, this._fitFovForAspect(aspect), aspect, 0.08, 100.0);
+      this._lookAt(this.viewMatrix, eye, center, up);
+      this._multiply(this.mvpMatrix, this.projMatrix, this.viewMatrix);
+    } else {
+      this._applyOverheadCamera({ spanHint: span });
+    }
   }
 
   // on initial boot
   bootstrap(uniforms = {}) {
     this.currentParams = Object.assign({}, uniforms);
     // ... your existing GL setup
-    this._setupCamera();
+    this._setupCamera();               // sets overhead once
+    this._applyOverheadCamera();       // and again after uniforms are in
   }
 
   updateUniforms(next) {
     this.currentParams = Object.assign(this.currentParams || {}, next || {});
-    // keep prior behavior, but ensure camera uses the overhead fit afterwards
-    this._adjustCameraForSpan(this._gridSpan || this._lastFittedR || 1.0);
+    // if explicit cameraZ provided, respect it; otherwise enforce overhead
+    if (Number.isFinite(this.currentParams?.cameraZ)) {
+      this._adjustCameraForSpan(this._gridSpan || this._lastFittedR || 1.0);
+    } else {
+      this._applyOverheadCamera({ spanHint: this._gridSpan || this._lastFittedR || 1.0 });
+    }
   }

Why this fixes your symptom
	•	Previously, a later call (resize/span change) could reapply the legacy “low” pose. Now, every path funnels through _applyOverheadCamera, so you won’t see the horizon-hugging view return.
	•	If you do pass cameraZ, we still respect it (and use a higher y and lower center.y).

⸻

(Optional) client/src/components/WarpVisualizer.tsx

To be extra sure nothing overrides the fit on mount, avoid passing a cameraZ by mistake and ask the engine to use auto-fit on every uniform update:

@@
   const initialUniforms = useMemo(() => ({
-    // do not set cameraZ here unless you want to override
+    cameraZ: undefined,          // ensure no accidental override
     // ...other uniforms
   }), []);
 
   useEffect(() => {
     if (!engineRef.current) return;
-    engineRef.current.updateUniforms({ /* physics uniforms only */ });
+    engineRef.current.updateUniforms({
+      /* physics uniforms only; no cameraZ here */
+    });
   }, [/* dependencies that change uniforms */]);


⸻

Quick verification checks
	1.	Open the console and ensure you never see code paths that reapply a literal:

eye = [0, 0.35, -desired]  // or -1.8 legacy
center = [0, -0.05, 0]

If you do, you missed one old path.
	2.	Temporarily log inside _applyOverheadCamera to confirm it runs on mount and on resize:

console.log('Overhead fit', {R: this._lastFittedR, canvas: [this.canvas.width, this.canvas.height]});

	3.	Make sure you’re not passing cameraZ from React unless you’re testing the manual override.

⸻

If you drop this patch in, the camera should immediately come up higher and stay that way—no more “snapping low” after the first frame, and the bubble will sit well below the horizon on both desktop and mobile.