Minimal code changes to make it pipeline-true

Use the pipeline’s energy to set T₀₀
Replace the “paper target” block with a straight mapping from casimirEnergy:

function calculateStressEnergyTensor(
  casimirEnergy: number,
  params: SimulationParameters,
  sectorDutyEff: number // pass d_eff in
){
  const tile = params.lattice; // supply these in SimulationParameters
  const tileArea = tile?.sizeX_m * tile?.sizeY_m;
  const gap = tile?.gap_m;
  const tileVolume = Math.max(1e-18, tileArea * gap); // clamp small

  // signed energy density from pipeline (negative for Casimir if that’s your convention)
  const rho = casimirEnergy / Math.max(1, params.tileCount) / tileVolume;

  // Optionally apply *configured* amplification factors (not hard-coded):
  const gammaGeo = params.gammaGeo ?? 26;
  const gammaVdB = params.dynamicConfig?.gammaVdB ?? 3.83e1;
  const qFactor  = params.dynamicConfig?.cavityQ ?? 1e9;
  const qGain    = params.dynamicConfig?.qGainModel === 'sqrt' ? Math.sqrt(qFactor) : qFactor;

  const rhoAmp = rho * Math.pow(gammaGeo, 3) * gammaVdB * qGain * sectorDutyEff;

  return {
    stressEnergyT00: rhoAmp,     // keep sign
    stressEnergyT11: -rhoAmp,    // EOS w = -1 if that’s your model
  };
}


Pass effective duty everywhere
Before calling the above and β:

const sectors = Math.max(1, dynamicConfig.sectorCount ?? 1);
const duty    = dynamicConfig.sectorDuty ?? params.dutyCycle ?? 0;
const d_eff   = duty / sectors;


Geometric factor from hull (even simple is better than 1.0):

const geomFactorFromEllipsoid = (a: number, b: number, c: number) => {
  // crude but pipeline-driven: normalize to a sphere’s radius
  const Reff = Math.cbrt(a*b*c);
  return Reff / Math.max(a, b, c); // in [0,1]
};


Then in calculateNatarioShift, use:

const geometricFactor = geomFactorFromEllipsoid(params.hull.a, params.hull.b, params.hull.c);
const timeAveragedShift = baseShift * Math.sqrt(d_eff) * geometricFactor;


Homogenization & validation thresholds → read from config:

const maxRatio = params.gr?.homogenizationMax ?? 1e-3;
const kAvg     = params.gr?.avgKernelK ?? 1.0;
const kTemp    = params.gr?.temporalPenaltyK ?? 10.0;

const homogenizationRatio = τ_pulse / τ_LC;
const grValidityCheck     = homogenizationRatio < maxRatio;

const timeAveragedCurvature =
  (8*Math.PI*G / (PHYSICS_CONSTANTS.C**4)) * Math.abs(t00) * Math.exp(-kAvg*homogenizationRatio);

const temporalEfficiency = Math.exp(-kTemp*homogenizationRatio);


Fix radial profile units (and keep the zero-expansion shape):

const radialProfile = (r: number): number => {
  const rho = r / Math.max(1e-12, bowlRadiusM); // both in meters
  if (rho <= 1) return shiftAmplitude * (rho*rho) * (3 - 2*rho); // C¹ smooth
  return shiftAmplitude / (rho*rho);
};