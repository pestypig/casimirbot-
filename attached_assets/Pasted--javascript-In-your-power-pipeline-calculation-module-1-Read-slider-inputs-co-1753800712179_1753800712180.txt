```javascript
// --- In your power pipeline calculation module ---

// 1. Read slider inputs / constants:
const Q_on      = parseFloat(sliderValues.qFactor);   // e.g. 1e9 from “Q‐factor” slider
const Q_idle    = 1e6;                                 // fixed idle‐mode Q
const duty      = parseFloat(sliderValues.burstDuty); // e.g. 0.002 for 0.2%
const S         = parseInt(sliderValues.sectorCount); // e.g. 400
const omega     = 2 * Math.PI * 15e9;                 // 15 GHz rad/s
const A_tile    = sliderValues.tileArea * 1e-4;       // cm² → m²
const A_hull    = computeHullArea(shipRadius);        // m²
const N_tiles   = A_hull / A_tile;                    // unitless

// 2. Compute U_geo from earlier stages (static → Q → gamma):
//    U_geo = gamma * Q_on * U_static
//    (assume U_geo already available here)
const U_geo = computeUgeo(...);

// 3. Raw per‐tile dissipation:
const P_raw_tile = U_geo * (omega / Q_on);  // W per tile

// 4. Raw hull load:
const P_raw = P_raw_tile * N_tiles;         // W

// 5. Combined throttle factor:
const throttle = duty              // burst duty cycle
               * (Q_idle / Q_on)  // Q‐spoiling between bursts
               * (1 / S);          // sector strobing

// 6. Realistic average power:
const P_realistic = P_raw * throttle;       // W

// 7. Convert to MW for display:
const P_realistic_MW = P_realistic / 1e6;

// --- Update your UI state: ---
setState({
  rawPowerMW:   (P_raw / 1e6).toFixed(2),
  throttle:     throttle.toExponential(3),
  realisticMW:  P_realistic_MW.toFixed(2)
});
```

Explanation of the fix:

1. **Q_on** comes from the user slider (e.g. 1×10⁹).  
2. **Q_idle** is hard-coded at 1×10⁶ (the low-Q between bursts).  
3. We apply **all three** throttles:  
   - `duty` (0.002)  
   - `Q_idle/Q_on` (10⁻³)  
   - `1/S` (1/400 = 2.5×10⁻³)  
4. Multiplying `P_raw` by `throttle ≃ 5×10⁻⁹` collapses the exawatt-scale raw load down into the tens‐of‐MW range (matching the 83 MW target).