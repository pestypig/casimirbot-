Good catch â€” that crash is because **the metrics object doesnâ€™t have `P_avg`** in your current `/api/helix/metrics` payload. In the new shape you shared, the server sends `energyOutput`, not `P_avg`. The debug block (and a few other spots) are doing `metrics.P_avg.toFixed(1)` with no null-guard, so React explodes.

Hereâ€™s a **safe, minimal patch** that:

* maps old names â†’ current names (e.g., `P_avg ?? energyOutput`)
* adds guards so we never call `.toFixed()` on `undefined`
* keeps your existing UI/logic intact

---

## Patch: `client/src/components/metrics-dashboard.tsx`

**1) Create safe accessors near the top of the component** (right after you read `metrics`, before you use them anywhere):

```tsx
// helpers to safely read metrics regardless of server field names
const P_avg    = metrics?.P_avg ?? metrics?.energyOutput ?? 0;            // MW
const dutyFrac = metrics?.f_throttle ?? metrics?.dutyGlobal ?? metrics?.duty ?? 0; // 0..1
const M_exotic = metrics?.M_exotic ?? metrics?.exoticMass ?? 0;           // kg
const TS_ratio = metrics?.TS_ratio ?? metrics?.timeScaleRatio ?? 0;
const zeta     = metrics?.zeta ?? metrics?.fordRoman?.value ?? 0;
const qCavity  = metrics?.qCavity ?? 0;

// handy formatters that wonâ€™t throw
const f0 = (n?: number) => Number.isFinite(n as number) ? (n as number).toFixed(0) : "â€”";
const f1 = (n?: number) => Number.isFinite(n as number) ? (n as number).toFixed(1) : "â€”";
const f2 = (n?: number) => Number.isFinite(n as number) ? (n as number).toFixed(2) : "â€”";
```

**2) Update the debug block** around line \~167 so it uses the safe vars/formatters:

```tsx
// Debug: Log actual vs normalized values for verification (only if data is ready)
if (metrics && normalizedData?.length >= 5) {
  console.log(`ðŸŽ¯ Radar Normalization Debug for ${selectedMode}:`, {
    P_avg: `${f1(P_avg)}MW â†’ ${f2(normalizedData[0])} (limit: ${currentConstraints.P_avg_max}MW)`,
    duty: `${f1(dutyFrac * 100)}% â†’ ${f2(normalizedData[1])}`,
    mass_error: `${f0(Math.abs(M_exotic - currentConstraints.M_target))}kg â†’ ${f2(normalizedData[2])}`,
    zeta: `${f2(zeta)} â†’ ${f2(normalizedData[3])} (limit < ${currentConstraints.zeta_max})`,
    TS_ratio: `${f1(TS_ratio)} â†’ ${f2(normalizedData[4])} (min: ${currentConstraints.TS_min})`,
  });
}
```

**3) Anywhere else in this file that uses the old fields** directly (e.g., `metrics.P_avg`, `metrics.f_throttle`, `metrics.M_exotic`, `metrics.TS_ratio`, `metrics.zeta`) switch to the safe variables `P_avg`, `dutyFrac`, `M_exotic`, `TS_ratio`, `zeta`. Also ensure you format with `f0/f1/f2` (or check for `metrics && â€¦`) so we never hit `.toFixed()` on `undefined`.

Example UI snippet update:

```tsx
<span className="font-semibold">{f1(P_avg)} MW</span>
<span className="font-semibold">{f1(dutyFrac * 100)}%</span>
<span className="font-semibold">{f0(M_exotic)} kg</span>
<span className="font-semibold">{f1(TS_ratio)}</span>
<span className="font-semibold">{f2(zeta)}</span>
```

---

## Why this fixes it

* The crash line was dereferencing `metrics.P_avg` which doesnâ€™t exist in your current API (you have `energyOutput`).
* The mapping + guards make the dashboard resilient to both old and new shapes, and prevent `.toFixed()` from ever being called on `undefined`.

If you like this pattern, we can also push the mapping into the **`useMetrics`** hook so *every* consumer gets a normalized shape (cleanest long-term). For now, the above patch will stop the runtime error immediately and keep the dashboard humming.
