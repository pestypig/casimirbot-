*** a/client/src/components/WarpRenderInspector.tsx
--- b/client/src/components/WarpRenderInspector.tsx
@@
-import React, {useEffect, useMemo, useRef, useState, startTransition} from "react";
+import React, {useEffect, useMemo, useRef, useState, startTransition} from "react";
@@
-import Grid3DEngine from '@/components/engines/Grid3DEngine';
-import { thetaCanonical } from "@/lib/warp-theta";
+import Grid3DEngine from '@/components/engines/Grid3DEngine';
+import { thetaCanonical } from "@/lib/warp-theta";
@@
-async function firstCorrectFrame({
+async function firstCorrectFrame({
   engine, canvas, sharedAxesScene, pane
 }: {
   engine: any; canvas: HTMLCanvasElement | null; sharedAxesScene: [number,number,number]; pane: 'REAL'|'SHOW';
 }) {
@@
-  const packet = paneSanitize(pane, { cameraZ: cz, lockFraming: true, viewAvg: true });
+  // Let paneSanitize set viewAvg per pane (REAL=true, SHOW=false)
+  const packet = paneSanitize(pane, { cameraZ: cz, lockFraming: true });
@@
-function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
-  return {
-    ...patch,
-    physicsParityMode: pane === 'REAL',
-    ridgeMode: pane === 'REAL' ? 0 : 1
-  };
-}
+function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
+  const forcedParity = (pane === 'REAL');
+  const forcedRidge  = forcedParity ? 0 : 1;
+  return {
+    ...patch,
+    // Engine-facing booleans
+    physicsParityMode: forcedParity,
+    ridgeMode: forcedRidge,
+    viewAvg: forcedParity, // REAL averages (âˆšd_FR), SHOW does not
+    // Shader uniform names (underscore style)
+    u_physicsParityMode: forcedParity,
+    u_ridgeMode: forcedRidge,
+  };
+}
@@
-  // Also provide u_* aliases explicitly to match shader names
+  // Also provide u_* aliases explicitly to match shader names
   s.u_useMetric   = s.useMetric;
   s.u_metric      = s.metric;
   s.u_metricInv   = s.metricInv;
-  s.u_epsilonTilt = s.epsilonTilt ?? 0;
-  s.u_betaTiltVec = s.betaTiltVec ?? [0,-1,0];
+  s.u_epsilonTilt = s.epsilonTilt ?? 0;
+  s.u_betaTiltVec = s.betaTiltVec ?? [0,-1,0];
+  // Ensure parity/ridge shader names are carried when present
+  if ('physicsParityMode' in s) s.u_physicsParityMode = s.physicsParityMode;
+  if ('ridgeMode' in s)         s.u_ridgeMode         = s.ridgeMode;
 
   return s;
 }
@@
-  function lockPane(engine: any, pane: 'REAL' | 'SHOW') {
+  function lockPane(engine: any, pane: 'REAL' | 'SHOW') {
     if (!engine || engine.__locked) return;
     engine.__locked = true;
 
     // enforce at uniform *values* only â€“ no source rebuilds:
-    const forcedParity = (pane === 'REAL');
-    const forcedRidge  = (pane === 'REAL') ? 0 : 1;
+    const forcedParity = (pane === 'REAL');
+    const forcedRidge  = forcedParity ? 0 : 1;
 
     const enforce = (patch: any = {}) => ({
       ...patch,
-      physicsParityMode: forcedParity,
-      uPhysicsParity: forcedParity,
-      uRidgeMode: forcedRidge,
-      ridgeMode: forcedRidge
+      // Engine-side flags
+      physicsParityMode: forcedParity,
+      ridgeMode: forcedRidge,
+      viewAvg: forcedParity,
+      // Shader uniform flags (correct names)
+      u_physicsParityMode: forcedParity,
+      u_ridgeMode: forcedRidge,
     });
 
     const origUpdate = engine.updateUniforms?.bind(engine);
     engine.updateUniforms = (p: any) => origUpdate?.(enforce(p));
     // also set once immediately
     origUpdate?.(enforce());
 
-    console.log(`[${pane}] Parity locked: parity=${forcedParity}, ridge=${forcedRidge}`);
+    console.log(`[${pane}] Parity locked: parity=${forcedParity}, ridge=${forcedRidge}`);
   }
@@
-          const realInitUniforms = {
+          const realInitUniforms = {
             exposure: 5.0,
             zeroStop: 1e-7,
             physicsParityMode: true,
+            u_physicsParityMode: true,
             ridgeMode: 0,
+            u_ridgeMode: 0,
+            viewAvg: true,
             colorMode: 2, // shear/"truth"
             lockFraming: true,
             epsilonTilt: epsilonTilt,
             betaTiltVec: betaTiltVecN,
           };
@@
-          if (leftEngine.current.uniforms) {
-            leftEngine.current.uniforms.physicsParityMode = true;
-            leftEngine.current.uniforms.ridgeMode = 0;
-          }
+          if (leftEngine.current.uniforms) {
+            const U = leftEngine.current.uniforms;
+            U.physicsParityMode = true;
+            U.u_physicsParityMode = true;
+            U.ridgeMode = 0;
+            U.u_ridgeMode = 0;
+            U.viewAvg = true;
+          }
@@
-          // Add gentle parity correction with debouncing
-          let lastParityCheck = 0;
-          const enforceParityREAL = () => {
-            const now = Date.now();
-            if (now - lastParityCheck < 1000) return; // Check max once per second
-            lastParityCheck = now;
-
-            const U = leftEngine.current?.uniforms;
-            if (U && U.physicsParityMode !== true) {
-              console.warn("ğŸ”§ REAL parity drift detected - applying gentle correction");
-              U.physicsParityMode = true;
-              U.parityMode = true;
-              U.ridgeMode = 0;
-            }
-          };
-
-          // Hook into render loop for gentle enforcement
-          if (leftEngine.current._render) {
-            const originalRender = leftEngine.current._render.bind(leftEngine.current);
-            leftEngine.current._render = function(...args: any[]) {
-              enforceParityREAL();
-              return originalRender(...args);
-            };
-          }
+          // (removed) render-loop parity patcher; lockPane + correct names are enough
@@
-          const showInitUniforms = {
+          const showInitUniforms = {
             exposure: 7.5,
             zeroStop: 1e-7,
             physicsParityMode: false,
+            u_physicsParityMode: false,
             ridgeMode: 1,
+            u_ridgeMode: 1,
+            viewAvg: false,
             curvatureGainT: 0.70,
             curvatureBoostMax: 40,
             userGain: 1.25,
             colorMode: 1, // theta/cosmetic
             lockFraming: true,
             epsilonTilt: epsilonTilt,
             betaTiltVec: betaTiltVecN,
           };
@@
-      // Subscribe to canonical uniforms
+      // Subscribe to canonical uniforms
       const unsubscribeHandler = subscribe('warp:uniforms', (u: any) => {
         setHaveUniforms(true);
         // strip any external theta (engine computes it)
-        const { thetaScale, u_thetaScale, thetaScale_actual, ...uSafe } = u || {};
+        const { thetaScale, u_thetaScale, thetaScale_actual, parityMode, ...uSafe } = u || {};
@@
-        if (leftEngine.current) {
-          applyToEngine(leftEngine.current, { ...uSafe, ...purple, ...metricU, physicsParityMode: true,  ridgeMode: 0 });
-        }
-        if (rightEngine.current) {
-          applyToEngine(rightEngine.current, { ...uSafe, ...metricU, ...purple, physicsParityMode: false, ridgeMode: 1 });
-        }
+        if (leftEngine.current) {
+          applyToEngine(leftEngine.current, {
+            ...uSafe, ...purple, ...metricU,
+            physicsParityMode: true,  ridgeMode: 0, viewAvg: true,
+            u_physicsParityMode: true, u_ridgeMode: 0
+          });
+        }
+        if (rightEngine.current) {
+          applyToEngine(rightEngine.current, {
+            ...uSafe, ...purple, ...metricU,
+            physicsParityMode: false, ridgeMode: 1, viewAvg: false,
+            u_physicsParityMode: false, u_ridgeMode: 1
+          });
+        }
       });
@@
-      const publishStableUniforms = () => {
+      const publishStableUniforms = () => {
         const wu = (systemMetrics as any)?.warpUniforms;
         if (!wu) return;
@@
-        const sanitized = sanitizeUniforms(wu);
+        const sanitized = sanitizeUniforms(wu);
         const sig = JSON.stringify(stableWU(sanitized));
         if (sig === lastWUHashRef.current) return;   // ğŸ”‡ nothing meaningful changed
 
         lastWUHashRef.current = sig;
-        publish("warp:uniforms", { ...sanitized, __version: version });
+        // Strip any parity alias + Î¸ fields on publish; engine & shader get the canonical fields
+        const { thetaScale, u_thetaScale, thetaScale_actual, parityMode, ...clean } = sanitized as any;
+        publish("warp:uniforms", { ...clean, __version: version });
       };
@@
-      if (!haveUniforms) {
+      if (!haveUniforms) {
         if (leftEngine.current) {
           leftEngine.current.updateUniforms?.({
             physicsParityMode: true,
             exposure: TONEMAP_LOCK.exp,
             zeroStop: TONEMAP_LOCK.zero,
             colorMode: TONEMAP_LOCK.colorMode,
-            viewAvg: TONEMAP_LOCK.viewAvg
+            viewAvg: true,
+            u_physicsParityMode: true,
+            u_ridgeMode: 0,
           });
         }
         if (rightEngine.current) {
           rightEngine.current.updateUniforms?.({
             physicsParityMode: false,
             exposure: TONEMAP_LOCK.exp,
             zeroStop: TONEMAP_LOCK.zero,
             colorMode: TONEMAP_LOCK.colorMode,
-            viewAvg: TONEMAP_LOCK.viewAvg
+            viewAvg: false,
+            u_physicsParityMode: false,
+            u_ridgeMode: 1,
           });
         }
       }
@@
-  // De-spam the bus: publish only on real changes
+  // De-spam the bus: publish only on real changes
   useEffect(() => {
     const wu = (systemMetrics as any)?.warpUniforms;
     if (!wu) return;
@@
-    const sanitized = sanitizeUniforms(wu);
+    const sanitized = sanitizeUniforms(wu);
     const sig = JSON.stringify(stableWU(sanitized));
     if (sig === lastWUHashRef.current) return;   // ğŸ”‡ nothing meaningful changed
 
     lastWUHashRef.current = sig;
-    // Never publish any thetaScale fields downstream; engine is authoritative.
-    const { thetaScale, u_thetaScale, thetaScale_actual, ...clean } = sanitized as any;
+    // Never publish any thetaScale fields downstream; engine is authoritative.
+    const { thetaScale, u_thetaScale, thetaScale_actual, parityMode, ...clean } = sanitized as any;
     publish("warp:uniforms", { ...clean, __version: version });
   }, [systemMetrics]);
@@
-  const gammaVdB_vis = N(live?.gammaVanDenBroeck_vis ?? live?.gammaVanDenBroeck, 1e11);
-  const gammaVdB_mass = N(live?.gammaVanDenBroeck_mass ?? live?.gammaVanDenBroeck, 1e11);
+  const gammaVdB_vis = N(live?.gammaVanDenBroeck_vis ?? live?.gammaVanDenBroeck, 1e11);
+  const gammaVdB_mass = N(live?.gammaVanDenBroeck_mass ?? live?.gammaVanDenBroeck, 1e11);
@@
-          <div><code>Î¸ âˆ v_ship Â· (x_s/r_s) Â· (âˆ’2(rsâˆ’1)/wÂ²) Â· exp(âˆ’((rsâˆ’1)/w)Â²)</code></div>
-          <div>engine Î¸-scale (Î³_geoÂ³ Â· q Â· Î³_VdB Â· âˆšd_eff): <b>{Number.isFinite(s.thetaPhys)? s.thetaPhys.toExponential(2):'â€”'}</b></div>
+          <div><code>Î¸ âˆ v_ship Â· (x_s/r_s) Â· (âˆ’2(rsâˆ’1)/wÂ²) Â· exp(âˆ’((rsâˆ’1)/w)Â²)</code></div>
+          <div>engine Î¸-scale (Î³_geoÂ³ Â· q Â· Î³_VdB Â· âˆšd_eff): <b>{Number.isFinite(s.thetaCanon)? s.thetaCanon.toExponential(2):'â€”'}</b></div>
