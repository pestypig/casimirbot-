Good eye. That ridge isn’t a “physics” cusp in the Natário bell—it's a rendering artifact. From the loop you shared and the screenshot, the jagged seam between compression/expansion is almost certainly coming from **three non-physical discretizations** working together:

## Likely culprits (in order of impact)

1. **Hard saturation**

```js
const maxPush = 0.10;
if (disp > maxPush) disp = maxPush;
if (disp < -maxPush) disp = -maxPush;
```

This creates a *flat cap* wherever the displacement would exceed the clamp. The edge of that cap is a sharp ring—exactly the ridge you see. Because neighbors cross the clamp at slightly different places, you get a jagged outline.

2. **Wall thickness in the wrong units / single global width**
   You compute the bell in **ellipsoidal coordinates** (ρ from a,b,c), but use one scalar `w_rho`. If `w_rho` was derived in meters (e.g. 6 m) and then compared against `sd = ρ − 1` (unitless), the width is effectively **way too thin**, so a coarse grid can’t resolve it → “stair-step” boundary. Also, one global width isn’t right on an ellipsoid: the physical 6 m corresponds to a **different Δρ** depending on direction.

3. **Mesh resolution vs. feature size**
   If the bell wall is only a few vertex spacings wide in screen space, you’ll see aliasing regardless of smoothing.

---

## Fixes (drop-ins)

### A) Soft clamp (removes the ring)

Replace the hard clamp with a smooth saturation:

```js
// viewer-only cap: smooth, avoids a sharp ring
const maxPush = 0.10;           // keep same visual limit
const softness = 0.6;           // 0.5–0.8
disp = maxPush * Math.tanh(disp / (softness * maxPush));
```

### B) Use **local wall thickness** in ellipsoidal ρ (correct units)

Your bell argument is `s = sd / w_rho` with `sd = ρ − 1`. The physical wall thickness δ (meters) maps to a **direction-dependent Δρ**:

$$
\Delta \rho \approx \frac{\delta}{R_\text{eff}}, \quad 
R_\text{eff}=\frac{1}{\sqrt{(n_x/a)^2+(n_y/b)^2+(n_z/c)^2}}
$$

Add this inside the loop (you already have `n` and the semi-axes `a,b,c` in meters):

```js
// semi-axes in meters (not the clip-scaled ones)
const a_m = this.currentParams?.hullAxesM?.[0] ?? 503.5;
const b_m = this.currentParams?.hullAxesM?.[1] ?? 132.0;
const c_m = this.currentParams?.hullAxesM?.[2] ?? 86.5;

const wall_m = this.currentParams?.wall_m ?? 6.0;  // physical shell half-width

// direction-dependent mapping of meters → Δρ
const invR = Math.sqrt(
  (n[0]/a_m)*(n[0]/a_m) +
  (n[1]/b_m)*(n[1]/b_m) +
  (n[2]/c_m)*(n[2]/c_m)
);
const R_eff = 1.0 / Math.max(invR, 1e-6);
const w_rho_local = wall_m / R_eff;   // thickness in ρ-units

const s = sd / w_rho_local;           // use local normalized coordinate
const gaussian = Math.exp(-s*s);

// compact C² window to avoid multiplying by a hard band
const window = (() => {
  const smooth = (A,B,x)=>{ const t=Math.max(0,Math.min(1,(x-A)/(B-A))); return t*t*t*(t*(t*6-15)+10); };
  return smooth(-3,-2,s) * (1 - smooth(2,3,s)) + smooth(-2,2,s);
})();
```

Then use `gaussian * window` in your `disp` product.

> If you don’t want the per-vertex `a_m,b_m,c_m` in the loop, precompute and pass the **meter** axes in your params (`hullAxesM`) just once.

### C) Ensure `vizGain` / `modeVisualScale` aren’t driving you into saturation

While testing, set:

```js
const betaVis = 1.0;
const modeViz = 1.0;
const vizGain = (this.uniforms?.vizGain = 2.0); // smaller
```

so the soft cap rarely kicks in.

### D) Increase grid resolution relative to wall sharpness

If the wall is thin in ρ, increase divisions so the bell spans **at least \~8–12 vertices**:

```js
const baseDiv = 160;
const targetVertsAcrossWall = 12;
const span = Math.max(1e-3, (3 * wall_m) / Math.min(a_m,b_m,c_m)); // ρ-span of ±3σ
const scale = Math.max(1.0, targetVertsAcrossWall / (span * baseDiv));
const divisions = Math.min(512, Math.floor(baseDiv * scale));
```

(Or, more simply, try 256–320 divisions to check the effect.)

---

## Quick checklist to verify the cause

* **Turn off strobing** (sectors = 1) and set `front = 1`. If the jagged ridge remains → it’s not strobe; it’s clamp/width/mesh.
* **Disable the clamp** for one frame (comment it) → if the ridge disappears but the surface overshoots, the clamp was the ring.
* **Double divisions** → if the jaggedness reduces proportionally, it’s under-sampling.
* **Log your `w_rho_local` histogram** → if it’s \~1e-3 or less in many places, you’re below the mesh’s resolvable scale.

---

## Why the earlier smoothing “made it worse”

We smoothed the *sign changes* (good), but the **hard clamp** still imposed a sharp level set in `disp`. Smoothing the inputs can actually push more vertices to the same cap value, making the ring more visually obvious. The fix is to **soft-saturate** and **match units** so the bell is resolved by the mesh.

If you apply A (soft clamp) + B (local wall thickness) first, you should already see that ridge go silky. Then tune D (divisions) to taste.
