Getting there! Nice cleanup on units, DPR, RAF cancel, and throttled logs. A few important nits before this is “safe”:

1. you still compute amplitude twice

* Early you build `A_phys → A_used → betaVis` (good).
* Inside the per-vertex loop you **recompute** another chain (`A_gross…A_vis`).
  → Pick one. Easiest: compute once outside the loop and use that scalar in the loop.

```js
// outside the for-loop
const gammaGeo = this.uniforms?.gammaGeo ?? 26;
const qSpoil   = this.uniforms?.deltaAOverA ?? 1.0;
const gammaVdB = this.uniforms?.gammaVdB ?? 3.83e1;
const sectors  = Math.max(1, this.uniforms?.sectors ?? 1);
const duty     = Math.max(1e-12, this.uniforms?.dutyCycle ?? 0.14);
const viewAvg  = !!(this.uniforms?.viewAvg ?? true);

const A_geo    = gammaGeo ** 3;
const dutyEff  = viewAvg ? (duty / sectors) : (1 / sectors);
const A_gross  = A_geo * qSpoil * gammaVdB * dutyEff;

const knee = 1e10;
const A_log = Math.log10(1 + A_gross / knee);
const mode  = (this.uniforms?.currentMode || 'hover').toLowerCase();
const modeScale = mode==='standby'?0.05:mode==='cruise'?0.25:mode==='hover'?0.60:mode==='emergency'?0.90:0.50;
const vizGain = (this.uniforms?.vizGainOverride ?? 0) || modeScale;
const A_vis_scalar = Math.min(1, A_log * vizGain);
```

Then, inside the loop, replace your second amplitude block with `const A_vis = A_vis_scalar;`.

2. local wall-thickness math (units)
   You derive `w_rho` correctly, but then set:

```js
const w_rho_local = w_rho / R_eff; // <- unit mismatch
```

`w_rho` is dimensionless; `R_eff` is meters. Use the *ratio* of directional radius to the harmonic mean:

```js
const w_rho_local = w_rho * (aH / R_eff);
```

This keeps it in ρ-units and varies correctly with orientation.

3. variable shadowing bug
   Inside the loop you reuse the name `a`:

```js
const asd = Math.abs(sd), a = 3.5*w_rho_local, b = 5.0*w_rho_local;
```

This shadows the semi-axis `a` you defined earlier. Rename those window params:

```js
const asd = Math.abs(sd), aWin = 3.5*w_rho_local, bWin = 5.0*w_rho_local;
const wallWin = (asd<=aWin) ? 1 : (asd>=bWin) ? 0
  : 0.5*(1 + Math.cos(Math.PI*(asd-aWin)/(bWin-aWin)));
```

4. unused params still hanging around
   `_updateGrid()` passes `halfSize, originalY` into `_warpGridVertices`, but they’re not used. Remove them from the call and the function signature to avoid confusion.

5. shader & uniforms naming
   You’re now setting `this.uniforms.wallWidth = w_rho;` (nice). The fragment shader’s `u_wallWidth` is treated as a normalized shell width, so that’s consistent. Just update any comments that still say “16 nm default”.

6. tiny cleanups (optional but good)

* Drop `gl_PointSize` from the grid vertex shader—you’re drawing `LINES`.
* Consider context-loss handlers so the canvas doesn’t brick on mobile GPUs.
* `this.uniforms?.axesScene` is read by the camera but never set; you rely on `_lastAxesScene` (fine). If you want, mirror it: `this.uniforms.axesScene = axesScene;`.

If you make the three core fixes (single amplitude, `w_rho_local` formula, and the shadowed `a`), the patch will be coherent and unit-safe. Want me to inline those diffs into your current file verbatim?
