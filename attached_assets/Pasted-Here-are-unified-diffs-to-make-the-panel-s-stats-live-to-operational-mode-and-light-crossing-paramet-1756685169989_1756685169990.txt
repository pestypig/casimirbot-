Here are unified diffs to make the panel’s stats live to operational mode and light-crossing parameters, with physically grounded fallbacks and tighter polling.

---

```diff
diff --git a/client/src/hooks/use-energy-pipeline.ts b/client/src/hooks/use-energy-pipeline.ts
--- a/client/src/hooks/use-energy-pipeline.ts
+++ b/client/src/hooks/use-energy-pipeline.ts
@@ -22,6 +22,14 @@ export interface EnergyPipelineState {
   modulationFreq_GHz: number;
 
   // Mode parameters
   currentMode: 'hover' | 'cruise' | 'emergency' | 'standby';
   dutyCycle: number;
   sectorStrobing: number;
   qSpoilingFactor: number;
+  // Additional mode knobs (explicit to drive FR duty & timing)
+  localBurstFrac?: number;     // sector-local burst fraction (0..1); defaults to dutyCycle
+  sectorsTotal?: number;       // total sectors in sweep
+  sectorsConcurrent?: number;  // how many sectors fire simultaneously
+
+  // Light-crossing & cycle timing (server may emit, else client derives)
+  tau_LC_ms?: number;          // light-crossing time across hull/bubble (ms)
+  sectorPeriod_ms?: number;    // dwell period per sector (ms)
+  burst_ms?: number;           // instantaneous burst window (ms)
+  dwell_ms?: number;           // gap between bursts (ms)
 
   // Scheduling truth
   sectorCount?: number;
@@ -86,6 +94,16 @@ export interface SystemMetrics {
   totalTiles: number;
   activeTiles: number;
   currentMode?: string;
   tileData?: TileDatum[]; // current server shape
   tiles?: TileDatum[];    // legacy shape
+  // Optional LC/timing structure from backend metrics, if available
+  lightCrossing?: {
+    tauLC_ms?: number;        // preferred
+    tau_ms?: number;          // alias
+    tauLC_s?: number;         // alt units
+    sectorPeriod_ms?: number; // dwell per sector
+    burst_ms?: number;
+    dwell_ms?: number;
+    sectorsTotal?: number;
+    activeSectors?: number;
+  };
 }
 // Helix metrics interface (some callers read directly from here)
 export interface HelixMetrics {
   totalTiles: number;
   activeTiles: number;
   data?: any;
   tileData?: TileDatum[];
   tiles?: TileDatum[];
+  lightCrossing?: SystemMetrics['lightCrossing'];
 }
 
@@ -159,7 +177,7 @@ export function useEnergyPipeline(options?: {
   return useQuery({
     queryKey: ['/api/helix/pipeline'],
     queryFn: async () =>
       (await apiRequest('GET', '/api/helix/pipeline')).json(),
-    refetchInterval: options?.refetchInterval ?? 1000, // Refresh every second
+    refetchInterval: options?.refetchInterval ?? 1000, // refresh every second
     staleTime: options?.staleTime,
     refetchOnWindowFocus: options?.refetchOnWindowFocus,
     suspense: false,
   });
 }
@@ -187,6 +205,8 @@ export function useSwitchMode() {
       // 2) immediately push mode-specific knobs so duty/strobing/qSpoil are in sync
       const cfg = MODE_CONFIGS[mode];
       if (cfg) {
         await apiRequest('POST', '/api/helix/pipeline/update', {
           dutyCycle: cfg.dutyCycle,
           sectorStrobing: cfg.sectorStrobing,
           qSpoilingFactor: cfg.qSpoilingFactor,
+          sectorsConcurrent: (cfg as any).sectorsConcurrent ?? (cfg as any).concurrentSectors,
+          localBurstFrac: (cfg as any).localBurstFrac ?? cfg.dutyCycle,
+          sectorsTotal: (cfg as any).sectorsTotal,
         });
       }
       publish("warp:reload", { reason: "mode-switch-local", mode, ts: Date.now() });
       return data;
     },
```

---

```diff
diff --git a/client/src/components/energy-pipeline.tsx b/client/src/components/energy-pipeline.tsx
--- a/client/src/components/energy-pipeline.tsx
+++ b/client/src/components/energy-pipeline.tsx
@@ -67,10 +67,13 @@
 const { data: live } = useEnergyPipeline({ refetchInterval: 1000 });
 
 // Metrics (system snapshot)
-const { data: systemMetrics } = useQuery({
+const { data: systemMetrics } = useQuery({
   queryKey: ["/api/helix/metrics"],
-  refetchInterval: 5000,
+  // Make stats visibly live with mode changes & LC updates
+  refetchInterval: 1000,
 });
 
+const C_M_PER_S = 299_792_458;
+const ms = (s: number) => s * 1000;
 const isFiniteNum = (x: any): x is number => typeof x === 'number' && Number.isFinite(x);
 const clamp01 = (v: number) => Math.max(0, Math.min(1, v));
 
@@ -83,27 +86,56 @@
 // ------------------------------
 // FR duty reconstruction (panel truth)
 // ------------------------------
-const dutyEffectiveFR: number = useMemo(() => {
-  const frFromPipeline =
-    (live as any)?.dutyEffectiveFR ??
-    (live as any)?.dutyShip ??
-    (live as any)?.dutyEff;
-  if (isFiniteNum(frFromPipeline)) return clamp01(frFromPipeline);
-  const burst = Number((live as any)?.burst_ms);
-  const dwell = Number((live as any)?.dwell_ms);
-  const dutyLocal = (Number.isFinite(burst) && Number.isFinite(dwell) && dwell > 0)
-    ? burst / dwell : 0.01;
-  const S_total = Math.max(1, Math.floor((systemMetrics as any)?.totalSectors ?? 400));
-  const concurrentSectors = Math.max(1, Math.min(S_total, Math.floor((live as any)?.sectorsConcurrent ?? (systemMetrics as any)?.activeSectors ?? 1)));
-  const S_live = Math.max(1, Math.min(S_total, Math.floor(concurrentSectors || 1)));
-  return clamp01(dutyLocal * (S_live / S_total));
-}, [live, systemMetrics]);
+const dutyEffectiveFR: number = useMemo(() => {
+  // 0) explicit from pipeline
+  const frFromPipeline =
+    (live as any)?.dutyEffectiveFR ??
+    (live as any)?.dutyShip ??
+    (live as any)?.dutyEff;
+  if (isFiniteNum(frFromPipeline)) return clamp01(frFromPipeline);
+
+  // 1) timing
+  const burst_ms = Number((live as any)?.burst_ms ?? (systemMetrics as any)?.lightCrossing?.burst_ms);
+  const dwell_ms = Number((live as any)?.dwell_ms ?? (systemMetrics as any)?.lightCrossing?.dwell_ms);
+  let dutyLocal: number | undefined =
+    (Number.isFinite(burst_ms) && Number.isFinite(dwell_ms) && dwell_ms > 0)
+      ? (burst_ms / dwell_ms)
+      : undefined;
+
+  // 2) mode-local burst fraction as physics default
+  const localBurstFrac = Number((live as any)?.localBurstFrac ?? (live as any)?.dutyCycle);
+  if (!isFiniteNum(dutyLocal) && isFiniteNum(localBurstFrac)) dutyLocal = clamp01(localBurstFrac);
+  if (!isFiniteNum(dutyLocal)) dutyLocal = 0.01; // ultra-conservative fallback
+
+  // 3) sectorization
+  const S_total =
+    Math.max(1, Math.floor(
+      Number((systemMetrics as any)?.lightCrossing?.sectorsTotal) ??
+      Number((systemMetrics as any)?.totalSectors) ??
+      Number((live as any)?.sectorsTotal) ??
+      Number((live as any)?.sectorCount) ?? 400
+    ));
+  const S_live =
+    Math.max(1, Math.min(S_total, Math.floor(
+      Number((live as any)?.sectorsConcurrent) ??
+      Number((systemMetrics as any)?.lightCrossing?.activeSectors) ??
+      Number((systemMetrics as any)?.activeSectors) ??
+      Number((live as any)?.concurrentSectors) ?? 1
+    )));
+
+  return clamp01((dutyLocal as number) * (S_live / S_total));
+}, [live, systemMetrics]);
 
 // ------------------------------
 // Derived snapshot share
 // ------------------------------
 useEffect(() => {
-  const tau_LC_ms = (live as any)?.tau_LC_ms ?? (live as any)?.tauLC_ms;
+  // Light-crossing: prefer server/metrics, else derive from geometry (≈ diameter/c)
+  const tau_LC_ms =
+    Number((live as any)?.tau_LC_ms ?? (live as any)?.tauLC_ms) ??
+    Number((systemMetrics as any)?.lightCrossing?.tauLC_ms) ??
+    (Number.isFinite((live as any)?.shipRadius_m)
+      ? ms((2 * Number((live as any)?.shipRadius_m)) / C_M_PER_S)
+      : undefined);
+  const sectorPeriod_ms =
+    Number((live as any)?.sectorPeriod_ms) ??
+    Number((systemMetrics as any)?.lightCrossing?.sectorPeriod_ms);
+
   queryClient.setQueryData(["helix:pipeline:derived"], {
     mode,
     dutyUI,
     dutyEffectiveFR,
     P_tile_on_W: P_tile_on,
     P_total_W: P_avg_W,
@@ -114,10 +146,22 @@ useEffect(() => {
     τ_LC_ms: tau_LC_ms,
     N_tiles: N,
     f_GHz: fGHz,
     gammaGeo: γ_geo,
     Q,
     sectorsTotal: (systemMetrics as any)?.totalSectors ?? (live as any)?.sectorCount,
     sectorsConcurrent: (live as any)?.sectorsConcurrent ?? (systemMetrics as any)?.activeSectors,
+    // timing mirror for HUDs
+    sectorPeriod_ms,
+    burst_ms: (live as any)?.burst_ms ?? (systemMetrics as any)?.lightCrossing?.burst_ms,
+    dwell_ms: (live as any)?.dwell_ms ?? (systemMetrics as any)?.lightCrossing?.dwell_ms,
+    localBurstFrac: (live as any)?.localBurstFrac ?? (live as any)?.dutyCycle,
+    // instantaneous reciprocity indicator for consumers
+    reciprocity: (() => {
+      const b = Number((live as any)?.burst_ms ?? (systemMetrics as any)?.lightCrossing?.burst_ms);
+      if (Number.isFinite(b) && Number.isFinite(tau_LC_ms))
+        return b < (tau_LC_ms as number)
+          ? { status: "BROKEN_INSTANT", message: "burst < τ_LC → inst. non-reciprocal" }
+          : { status: "PASS_AVG", message: "burst ≥ τ_LC → avg. reciprocal" };
+      return { status: "UNKNOWN", message: "missing burst/τ_LC" };
+    })(),
   });
-}, [mode, dutyUI, dutyEffectiveFR, P_tile_on, P_avg_W, τ_Q_ms, live, N, fGHz, γ_geo, Q, systemMetrics, queryClient]);
+}, [mode, dutyUI, dutyEffectiveFR, P_tile_on, P_avg_W, τ_Q_ms, live, N, fGHz, γ_geo, Q, systemMetrics, queryClient]);
 
 // ------------------------------
 // Client tile ingestion (metrics → tiles)
 // ------------------------------
@@ -255,6 +299,8 @@ const publishGreens = useCallback(() => {
   const tauLC_ms = (live as any)?.tau_LC_ms ?? (live as any)?.tauLC_ms;
   const burst_ms = Number((live as any)?.burst_ms);
   const reciprocity =
     Number.isFinite(burst_ms) && Number.isFinite(tauLC_ms)
       ? (burst_ms < tauLC_ms
           ? { status: "BROKEN_INSTANT", message: "burst < τ_LC → inst. non-reciprocal" }
           : { status: "PASS_AVG",       message: "burst ≥ τ_LC → avg. reciprocal" })
       : { status: "UNKNOWN", message: "missing burst/τ_LC" };
+  // If the derived cache has a fresher reciprocity, prefer it
+  const derived = queryClient.getQueryData(["helix:pipeline:derived"]) as any;
   const payload = {
     kind: greenKind,
     m: mHelm,
     normalize: normalizeGreens,
     phi: greenPhi.phi,     // Float32Array
     size: greenPhi.phi.length,
     source: greenPhi.source,
-    reciprocity
+    reciprocity: (derived?.reciprocity ?? reciprocity)
   };
```

---

```diff
diff --git a/client/src/components/BridgeDerivationCards.tsx b/client/src/components/BridgeDerivationCards.tsx
--- a/client/src/components/BridgeDerivationCards.tsx
+++ b/client/src/components/BridgeDerivationCards.tsx
@@ -186,6 +186,17 @@ const [greens, setGreens] = React.useState<{
   // 1) try cache (EnergyPipeline publishes here)
   const cached = qc.getQueryData(["helix:pipeline:greens"]) as any;
   if (cached) return cached;
   // 2) fall back to whatever the metrics snapshot might carry
   const snap = (m as any)?.pipeline?.greens as any;
   return snap || { source: "none" };
 });
+
+// Also mirror the latest derived duty/LC for display without re-deriving
+const derived = qc.getQueryData(["helix:pipeline:derived"]) as any;
+const dEff = Number.isFinite(derived?.dutyEffectiveFR)
+  ? derived.dutyEffectiveFR
+  : (
+      num(uexp?.live?.dutyEffectiveFR) ??
+      num(uexp?.fordRomanDuty?.computed_d_eff) ??
+      num((m as any)?.dutyEffectiveFR) ??
+      num((m as any)?.pipeline?.dutyEffectiveFR) ?? num((m as any)?.pipeline?.dutyEff)
+    );
```

---

```diff
diff --git a/client/src/components/LightSpeedStrobeScale.tsx b/client/src/components/LightSpeedStrobeScale.tsx
--- a/client/src/components/LightSpeedStrobeScale.tsx
+++ b/client/src/components/LightSpeedStrobeScale.tsx
@@ -20,6 +20,12 @@
 export function LightSpeedStrobeScale(props: Props) {
   const qc = useQueryClient();
   const hud = useHUD(); // if you have one
+  // Prefer the pipeline’s derived snapshot for consistent τ_LC/duty across panels
+  const derived = qc.getQueryData(["helix:pipeline:derived"]) as any;
+  const dutyFR = Number.isFinite(derived?.dutyEffectiveFR) ? derived.dutyEffectiveFR : (props.dutyFR ?? 0);
+  const burst = Number.isFinite(derived?.burst_ms) ? derived.burst_ms : props.burstMs;
+  const dwell = Number.isFinite(derived?.dwell_ms) ? derived.dwell_ms : props.dwellMs;
+  const sectorsTotal = Number.isFinite(derived?.sectorsTotal) ? derived.sectorsTotal : undefined;
 
   // modulation period (ms)
   const Tm = React.useMemo(() => (props.fGHz ? 1e-6 / props.fGHz : 0), [props.fGHz]);
@@ -27,6 +33,7 @@ const tauLC: number = React.useMemo(() => {
   // 1) explicit prop (ms)
   if (Number.isFinite(props.tauLcMs)) return (props.tauLcMs as number) / 1000;
   // 2) HUD/metrics common shapes
+  if (Number.isFinite(derived?.τ_LC_ms)) return (derived?.τ_LC_ms as number) / 1000;
   const lc = (metrics as any)?.lightCrossing ?? {};
   const fromHUDs =
     (hud as any)?.tauLC_s ??
     (hud as any)?.tau_lc_s ??
@@ -43,7 +50,7 @@
   return Number.isFinite(dwellMs) ? (
     (dwellMs as number) / 1000
   ) : (
-    (Number.isFinite(sectorsTotal) && sectorsTotal! > 0 ? (sectorsTotal as number) * Tm : Tm)
+    (Number.isFinite(sectorsTotal) && sectorsTotal! > 0 ? (sectorsTotal as number) * Tm : Tm)
   );
 }, [props.dwellMs, hud, metrics, Tm]);
 
@@ -141,7 +148,7 @@
 <div className="flex items-center gap-2">
   <span className="inline-block w-2 h-2 rounded-full bg-white/70" />
-  Duty (FR): {(Math.max(0, dutyFR) * 100).toFixed(3)}% • burst {fmtSI(burst)}
+  Duty (FR): {(Math.max(0, dutyFR) * 100).toFixed(3)}% • burst {fmtSI(burst)} • dwell {fmtSI(dwell)}
   {Number.isFinite(burstOffset) && burstOffset > 0 ? ` • phase ${fmtSI(burstOffset)}` : ""}
 </div>
```

---

### Notes for Agent Replit

* Apply all hunks exactly as shown.
* No new imports are required beyond what already exists; helper constants/functions are local.
* This keeps server truth authoritative when present, but ensures **mode + light-crossing** changes instantly flow to the panel via tighter polling, robust τ\_LC derivation, and an FR duty computed from **(burst/dwell or localBurstFrac) × (S\_live/S\_total)**.
