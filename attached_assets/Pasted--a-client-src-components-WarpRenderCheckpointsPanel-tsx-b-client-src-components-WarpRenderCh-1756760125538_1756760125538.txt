--- a/client/src/components/WarpRenderCheckpointsPanel.tsx
+++ b/client/src/components/WarpRenderCheckpointsPanel.tsx
@@
 import React, {useEffect, useMemo, useRef, useState} from "react";
 import { checkpoint, Check, Side, Stage, within, onCheck } from "@/lib/checkpoints";
 import { thetaScaleExpected } from "@/lib/expectations";
 import CheckpointViewer from "./CheckpointViewer";
 
@@
 const N = (x: any, d = 0) => (Number.isFinite(+x) ? +x : d);
 const clamp01 = (x: number) => Math.max(0, Math.min(1, x));
 
+// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
+// Projection helpers: take a point on the ellipsoid shell and project to NDC/pixels
+// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
+type Vec3 = [number, number, number];
+type NDC = { x: number; y: number; z: number; w: number };
+
+function shellPointOnDir(axes: Vec3, dir: Vec3): Vec3 {
+  // Solve s so that ((s*dx)/ax)^2 + ((s*dy)/ay)^2 + ((s*dz)/az)^2 = 1  with p = s*dir
+  const [ax, ay, az] = axes.map(v => Math.max(1e-9, +v)) as Vec3;
+  const [dx, dy, dz] = dir as Vec3;
+  const denom = (dx*dx)/(ax*ax) + (dy*dy)/(ay*ay) + (dz*dz)/(az*az);
+  const s = (denom > 0) ? (1 / Math.sqrt(denom)) : 0;
+  return [s*dx, s*dy, s*dz];
+}
+
+function projectToNDC(mvp: Float32Array | number[], p: Vec3): NDC | null {
+  if (!mvp || (mvp as any).length !== 16) return null;
+  const m = mvp as any;
+  const x = p[0], y = p[1], z = p[2];
+  const X = m[0]*x + m[4]*y + m[8 ]*z + m[12];
+  const Y = m[1]*x + m[5]*y + m[9 ]*z + m[13];
+  const Z = m[2]*x + m[6]*y + m[10]*z + m[14];
+  const W = m[3]*x + m[7]*y + m[11]*z + m[15];
+  if (Math.abs(W) < 1e-9) return { x: 0, y: 0, z: Z, w: W };
+  return { x: X / W, y: Y / W, z: Z / W, w: W };
+}
+
+function ndcToPixels(ndc: NDC | null, canvas?: HTMLCanvasElement | null) {
+  if (!ndc || !canvas) return null;
+  const w = canvas.clientWidth || canvas.width || 0;
+  const h = canvas.clientHeight || canvas.height || 0;
+  if (!w || !h) return null;
+  // NDC (-1..1) ‚Üí pixels
+  const px = Math.round((ndc.x * 0.5 + 0.5) * w);
+  const py = Math.round((1 - (ndc.y * 0.5 + 0.5)) * h); // invert Y for screen space
+  const onScreen = ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1 && ndc.w > 0;
+  return { px, py, onScreen };
+}
+
 // Enhanced canvas/GL inspection that works with both slice2d and grid3d engines
   const getCanvasEngine = (engineRef: React.MutableRefObject<any>, canvasRef: React.MutableRefObject<HTMLCanvasElement | null>) => {
     const engine = engineRef.current;
     const canvas = canvasRef.current;
@@
   return viewAvg ? base * Math.sqrt(dFR) : base; // (no ‚àö term when not averaging)
 }
 
 // ‚úÖ Prefer pipeline/engine d_FR; fall back to dutyCycle/sectors
 function computeThetaScaleFromParams(v: any) {
@@
   return averaged ? base * Math.sqrt(dFR) : base;
 }
 
 function useEngineHeartbeat(engineRef: React.MutableRefObject<any | null>) {
   const [tickMs, setTickMs] = useState<number>(0);
@@
   return (
     <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-4 max-h-96 overflow-y-auto">
       <div className="flex items-center justify-between mb-3">
         <h4 className="font-medium text-sm">Live Checkpoints</h4>
         <div className="flex items-center gap-3">
@@
 function validateEngine(side: 'LEFT' | 'RIGHT', engineRef: React.MutableRefObject<any | null>, canvasRef: React.RefObject<HTMLCanvasElement | null>) {
   const { engine: e, canvas: cv } = getCanvasEngine(engineRef, canvasRef); // Use the utility function
 
   if (!e || !cv) {
@@
   });
 }
 
 function useCheckpointList(
   label: string,
@@
 ) {
   const hb = useEngineHeartbeat(engineRef);
 
   return useMemo(() => {
     const { engine: e, canvas: cv } = getCanvasEngine(engineRef, canvasRef); // Use the utility function
     const rows: { label: string; detail?: string; state: "ok" | "warn" | "fail" }[] = [];
     const side: Side = label === "REAL" ? "REAL" : "SHOW";
 
     // üëÇ Publish the engine's current physics authority for other UI bits
     publishWarpEcho(e, side, liveSnap);
 
+    // ‚îÄ‚îÄ Gather geometry & view for projection checks
+    const u = e?.uniforms || {};
+    const axesScene: Vec3 = (Array.isArray(u?.axesClip) && u.axesClip.length === 3)
+      ? [u.axesClip[0], u.axesClip[1], u.axesClip[2]]
+      : (Array.isArray(u?.axesScene) && u.axesScene.length === 3 ? [u.axesScene[0], u.axesScene[1], u.axesScene[2]] : [1,1,1]);
+    const driveRaw: Vec3 = (Array.isArray(u?.driveDir) && u.driveDir.length === 3) ? [u.driveDir[0], u.driveDir[1], u.driveDir[2]] : [1,0,0];
+    // normalize drive dir in scene-scaled space (same as engine)
+    const dN = (() => {
+      const t: Vec3 = [driveRaw[0] / axesScene[0], driveRaw[1] / axesScene[1], driveRaw[2] / axesScene[2]];
+      const m = Math.hypot(t[0], t[1], t[2]) || 1;
+      return [t[0]/m, t[1]/m, t[2]/m] as Vec3;
+    })();
+    // Points on the ellipsoid shell along ¬±drive direction
+    const pFront = shellPointOnDir(axesScene, dN);
+    const pRear  = shellPointOnDir(axesScene, [-dN[0], -dN[1], -dN[2]]);
+    const ndcF   = projectToNDC(e?.mvpMatrix, pFront);
+    const ndcR   = projectToNDC(e?.mvpMatrix, pRear);
+    const pixF   = ndcToPixels(ndcF as any, cv);
+    const pixR   = ndcToPixels(ndcR as any, cv);
+
     // === DAG Stage 1: INPUT CHECKPOINTS ===
@@
-    const u = e?.uniforms || {};
+    // (u defined above)
     const ts = N(u?.thetaScale, NaN);
 
     // Expected uniforms Œ∏ from the same chain the engine uses (RAW)
     const thetaUniformExpected = expectedThetaForPane(liveSnap, e);
@@
       checkpoint({
         id: 'uniforms.theta_display_info',
         side,
         stage: 'uniforms',
         pass: true,
@@
       });
     }
 
+    // ‚îÄ‚îÄ NEW: Shader amplitude estimate (what the FS multiplies with)
+    // amp = u_thetaScale * max(1, u_userGain) * showGain * vizSeason * (1 + tBlend*(tBoost-1))
+    {
+      const parity = !!(u.physicsParityMode ?? u.parityMode);
+      const showGain  = parity ? 1.0 : Math.max(1, N(u?.displayGain, 1));
+      const vizSeason = parity ? 1.0 : Math.max(1, N(u?.vizGain, 1));
+      const tBlend    = parity ? 0.0 : clamp01(N(u?.curvatureGainT, 0));
+      const tBoostMax = parity ? 1.0 : Math.max(1, N(u?.curvatureBoostMax, 40));
+      const userGain  = Math.max(1, N(u?.userGain, 1));
+      const ampEst    = (Number.isFinite(ts) ? ts : 0) * userGain * showGain * vizSeason * (1 + tBlend * (tBoostMax - 1));
+
+      checkpoint({
+        id: 'uniforms.theta_shader_amp_est',
+        side,
+        stage: 'uniforms',
+        pass: Number.isFinite(ampEst) && ampEst >= 0,
+        msg: `Œ∏(shader) amp‚âà${Number.isFinite(ampEst) ? ampEst.toExponential(2) : '‚Äî'} (parity=${parity})`,
+        expect: 'info-only',
+        actual: { ts, userGain, showGain, vizSeason, tBlend, tBoostMax },
+        sev: 'info'
+      });
+    }
+
     // === DAG Stage 4: GPU STATE ===
@@
     rows.push({ label: "Œ∏-scale", detail: tsDetail, state: tsState });
 
+    // ‚îÄ‚îÄ NEW: WebGL projection rows (front/rear shell along drive direction)
+    if (ndcF && pixF) {
+      const detailF = `NDC=(${ndcF.x.toFixed(3)}, ${ndcF.y.toFixed(3)}, ${ndcF.z.toFixed(3)}) ‚Ä¢ px=(${pixF.px}, ${pixF.py}) ${pixF.onScreen ? '' : '‚Ä¢ offscreen'}`;
+      rows.push({ label: "Front (œÅ=1) projection", detail: detailF, state: pixF.onScreen ? "ok" : "warn" });
+      checkpoint({
+        id: 'gpu.mvp_front',
+        side,
+        stage: 'gpu',
+        pass: pixF.onScreen,
+        msg: detailF,
+        expect: 'inside frustum',
+        actual: detailF,
+        sev: pixF.onScreen ? 'info' : 'warn'
+      });
+    }
+    if (ndcR && pixR) {
+      const detailR = `NDC=(${ndcR.x.toFixed(3)}, ${ndcR.y.toFixed(3)}, ${ndcR.z.toFixed(3)}) ‚Ä¢ px=(${pixR.px}, ${pixR.py}) ${pixR.onScreen ? '' : '‚Ä¢ offscreen'}`;
+      rows.push({ label: "Rear (œÅ=1) projection", detail: detailR, state: pixR.onScreen ? "ok" : "warn" });
+      checkpoint({
+        id: 'gpu.mvp_rear',
+        side,
+        stage: 'gpu',
+        pass: pixR.onScreen,
+        msg: detailR,
+        expect: 'inside frustum',
+        actual: detailR,
+        sev: pixR.onScreen ? 'info' : 'warn'
+      });
+    }
+
     // Show detailed breakdown from bound uniforms if available
     if (echo && echo.terms) {
@@
 
     // Heartbeat (did diagnostics run in the last ~2s?)
     const dt = Date.now() - hb;
     const beatOk = hb !== 0 && dt < 2000;
     rows.push({ label: "Diagnostics heartbeat", detail: beatOk ? `${dt}ms ago` : "stale", state: beatOk ? "ok" : "warn" });
@@
     rows.push({ label: "Render loop", detail: rafAlive ? "active" : "stopped", state: rafAlive ? "ok" : "warn" });
 
+    // ‚îÄ‚îÄ Frame console line for quick triage
+    try {
+      const parity = !!(u.physicsParityMode ?? u.parityMode);
+      const showGain  = parity ? 1.0 : Math.max(1, N(u?.displayGain, 1));
+      const vizSeason = parity ? 1.0 : Math.max(1, N(u?.vizGain, 1));
+      const tBlend    = parity ? 0.0 : clamp01(N(u?.curvatureGainT, 0));
+      const tBoostMax = parity ? 1.0 : Math.max(1, N(u?.curvatureBoostMax, 40));
+      const userGain  = Math.max(1, N(u?.userGain, 1));
+      const ampEst    = (Number.isFinite(ts) ? ts : 0) * userGain * showGain * vizSeason * (1 + tBlend * (tBoostMax - 1));
+
+      console.log(`[WRC Œ∏] ${label}`, {
+        theta_uniform: ts,
+        theta_expected_chain: thetaUniformExpected,
+        shader_amp_est: ampEst,
+        parity,
+        viewAvg: (u?.viewAvg ?? true),
+        sectors: { live: u?.sectors, total: u?.sectorCount },
+        dutyUsed: u?.dutyUsed ?? u?.dutyEffectiveFR,
+        front_ndc: ndcF, rear_ndc: ndcR,
+        front_px: pixF, rear_px: pixR
+      });
+    } catch {}
+
     return rows;
   }, [engineRef.current, canvasRef.current, liveSnap, hb, label, dutyFR, thetaExpectedFn]);
 }
