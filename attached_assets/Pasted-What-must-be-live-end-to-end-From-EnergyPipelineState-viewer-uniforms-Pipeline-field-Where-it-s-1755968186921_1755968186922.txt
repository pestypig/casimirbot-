What must be live end-to-end

From EnergyPipelineState → viewer uniforms:

Pipeline field	Where it should land in viewer	Notes (naming gotchas)
gammaGeo (or g_y fallback)	resolveThetaScale() → thetaScale	You already support g_y in the fallback — keep both.
qSpoilingFactor (aka deltaAOverA)	resolveThetaScale() → thetaScale	Keep both names accepted.
gammaVanDenBroeck (aka gammaVdB)	resolveThetaScale() → thetaScale	Accept both names.
dutyCycle (UI duty)	SHOW pane’s thetaScale	Makes modes visibly different.
dutyEffective_FR / dutyShip (ship-wide FR duty)	REAL pane’s thetaScale	Keeps parity pane conservative + FR-correct.
sectorCount (= 400)	resolveThetaScale()’s sectors	Use total sectors here (400) for averaging.
sectorStrobing (= concurrent live sectors, 1/2)	strobe sync uniforms (sectors,split,sectorIdx)	This is for the sweep timing, not the averaging divisor.
hull (Lx/Ly/Lz → a/b/c)	frameFromHull()	You already do this.
modulationFreq_GHz, qCavity	(optional) not used in shader	Keep for HUD/diagnostics; viewer doesn’t need them.
Light crossing (burst_ms,dwell_ms,tauLC_ms)	optional lightCrossing passthrough	Use for FR duty calc and strobe UI.
Fix the two things that block “live” behavior
1) Don’t feed sectorStrobing where you mean total sectors

Right now the value that reaches resolveThetaScale() is often 1 (concurrent sectors), not 400 (total sectors), so the averaging term √(duty/sectors) barely moves between modes. That’s why you “don’t see a difference”.

Patch (HelixCore): send both; use 400 for averaging, keep sectorStrobing for sweep sync.

// BEFORE (simplified)
const sectorsResolved = useMemo(() => {
  const s = Number(systemMetrics?.totalSectors ?? systemMetrics?.sectorStrobing);
  if (Number.isFinite(s) && s > 0) return Math.max(1, Math.floor(s));
  const u = Number(sectorsUI);
  return Math.max(1, Math.floor(Number.isFinite(u) ? u : 1));
}, [...]);

// AFTER: hard-wire total sectors (400) for averaging, keep strobing separately.
const totalSectors = Number.isFinite(systemMetrics?.totalSectors)
  ? Math.max(1, Math.floor(systemMetrics!.totalSectors!))
  : 400;

const concurrentSectors = Number.isFinite(systemMetrics?.sectorStrobing)
  ? Math.max(1, Math.floor(systemMetrics!.sectorStrobing!))
  : (pipeline?.sectorStrobing ?? 1);


Then build the params like this (next patch).