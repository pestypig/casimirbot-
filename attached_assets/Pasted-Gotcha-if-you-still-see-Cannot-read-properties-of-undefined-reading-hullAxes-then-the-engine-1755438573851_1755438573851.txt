Gotcha ‚Äî if you still see ‚ÄúCannot read properties of undefined (reading ‚ÄòhullAxes‚Äô)‚Äù then the engine is still trying to read uniforms.hullAxes before those uniforms exist (or a cached JS file didn‚Äôt pick up the last fix).

Here‚Äôs a small, bullet-proof patch that removes the crash no matter the call order, plus two quick checks to avoid cache issues.

‚∏ª

0) Hard-refresh / bust cache

Browsers happily cache /warp-engine-fixed.js.
	‚Ä¢	In WarpVisualizer.tsx set:
script.src = '/warp-engine-fixed.js?v=9' (change the number).
	‚Ä¢	Do a hard refresh (Ctrl/Cmd+Shift+R).

‚∏ª

1) Add global defaults and always fall back

File: client/public/warp-engine-fixed.js
Put these at the very top of the file:

// ----- GLOBAL DEFAULTS (never undefined) -----
const DEFAULT_AXES = [503.5, 132.0, 86.5];   // meters, semi-axes a,b,c
const DEFAULT_UNIFORMS = {
  hullAxes: DEFAULT_AXES.slice(),
  wallWidth: 0.06,          // renderer-normalized shell half-thickness
  sectors: 1,
  sectorCount: 1,
  phaseSplit: 0.5,
  split: 0,
  gammaGeo: 26,
  Qburst: 1e9,
  deltaAOverA: 1,
  gammaVdB: 2.86e5,
  dutyCycle: 0.14
};

In the engine constructor (or right after you define the class)

// Ensure uniforms always exist with defaults
this.uniforms = Object.assign({}, DEFAULT_UNIFORMS, this.uniforms || {});

In updateUniforms(parameters = {})

(keep whatever you already have, just add this geometry acceptance + merge)

if (!this.uniforms) this.uniforms = Object.assign({}, DEFAULT_UNIFORMS);

// ‚Ä¶ your existing scalar mappings ‚Ä¶

// Geometry: accept either hullAxes or a {hull:{a,b,c,Lx_m,Ly_m,Lz_m}}
let axes = null;
if (Array.isArray(parameters.hullAxes) && parameters.hullAxes.length === 3) {
  axes = parameters.hullAxes.map(Number);
} else if (parameters.hull) {
  const h = parameters.hull;
  const a = Number(h.a ?? h.Lx_m / 2);
  const b = Number(h.b ?? h.Ly_m / 2);
  const c = Number(h.c ?? h.Lz_m / 2);
  if (Number.isFinite(a) && Number.isFinite(b) && Number.isFinite(c)) {
    axes = [a, b, c];
  }
}
if (axes) this.uniforms.hullAxes = axes;

if (parameters.wallWidth != null) {
  this.uniforms.wallWidth = Number(parameters.wallWidth);
}

In _warpGridVertices() (and anywhere else you read them)

Never read this.uniforms.hullAxes directly. Guard and fallback:

const u = this.uniforms || DEFAULT_UNIFORMS;

const hullAxes = (Array.isArray(u.hullAxes) && u.hullAxes.length === 3)
  ? u.hullAxes
  : DEFAULT_AXES;

const wallWidth = Number(u.wallWidth ?? DEFAULT_UNIFORMS.wallWidth);

const sectors = Math.max(
  1,
  Number(u.sectors ?? u.sectorCount ?? u.sectorStrobing ?? 1)
);

const phaseSplit = Number(u.phaseSplit ?? DEFAULT_UNIFORMS.phaseSplit);
const split = Number(u.split ?? Math.floor(phaseSplit * sectors));

This guarantees the renderer always has a valid hullAxes (and friends), even if updateUniforms() hasn‚Äôt run yet or React sends only hull instead of hullAxes.

‚∏ª

2) (Optional) Send both forms from React

This makes the mapping future-proof:

engine.updateUniforms({
  // physics + mode‚Ä¶
  hullAxes: [hull.a, hull.b, hull.c],
  hull: { a: hull.a, b: hull.b, c: hull.c, Lx_m: hull.Lx_m, Ly_m: hull.Ly_m, Lz_m: hull.Lz_m },
  wallWidth
});


‚∏ª

3) Quick verification

After redeploy + hard refresh, open DevTools console:

You should see a uniforms dump like:

üõ∞ uniforms {
  hullAxes: [503.5, 132, 86.5],
  wallWidth: 0.06,
  sectors: 1,
  phaseSplit: 0.5,
  gammaGeo: 26,
  ‚Ä¶
}

If that prints and the error still appears, it‚Äôs almost certainly a stale cached JS (bump the ?v= again). If the print doesn‚Äôt show hullAxes, then your constructor patch didn‚Äôt run ‚Äî confirm it‚Äôs at the very top and that this.uniforms isn‚Äôt being overwritten later.

This set of changes removes the crash and makes the bubble react correctly to different operational modes while you continue refining the visuals.