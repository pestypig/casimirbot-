You‚Äôre right: the parity split is mostly cosmetic right now, so both panes end up with the same Œ∏ chain. There are also a couple of small logic bugs that make the mismatch worse.

Here‚Äôs a tight fix-set to make REAL vs SHOW truly diverge and to clean up mode handling.

1) Parity-aware Œ∏ pipeline (the core problem)

File: client/public/warp-engine.js
Method: _applyUniformsNow(parameters)

Make viewAvg, sectorCount, and the duty term depend on parity. Also fix a clamp bug (see ¬ß2).

@@
-        const parity = (parameters?.physicsParityMode !== undefined)
+        const parity = (parameters?.physicsParityMode !== undefined)
           ? !!parameters.physicsParityMode
           : !!prev?.physicsParityMode;
         const zeroStandby = parity && isStandby;  // only REAL gets hard-zero in standby
@@
-        const sectorsConcurrent =
+        const sectorsConcurrent =
           Math.max(1, Math.floor(
             Number(parameters?.sectors ?? prev?.sectors ?? 1)
           ));
         const sectorsTotal =
           Math.max(1, Math.floor(
             Number(parameters?.sectorCount ?? prev?.sectorCount ?? this.strobingState?.sectorCount ?? sectorsConcurrent)
           ));
         const dutyLocal = Math.max(0, Number(parameters?.dutyCycle ?? prev?.dutyCycle ?? 0.14));
 
+        // Parity-aware defaults
+        const isREAL = !!parity;
+        // SHOW should be "instantaneous" (no ‚àö(FR) averaging), REAL uses FR-averaged
+        const viewAvgResolved = (parameters?.viewAvg !== undefined) ? !!parameters.viewAvg : isREAL;
+        // What sectorCount should the pane *think* it sees
+        const sectorCountOut  = isREAL ? sectorsTotal : sectorsConcurrent;
+
+        // Duty used in the chain:
+        //  - REAL: Ford‚ÄìRoman averaged (dutyLocal √ó S_live/S_total)
+        //  - SHOW: instantaneous local burst (‚âà dutyLocal)
+        let dutyEffFR;
+        if (zeroStandby) {
+          dutyEffFR = 0;
+        } else if (frFromParams != null) {
+          dutyEffFR = Math.max(0, Math.min(1, +frFromParams));
+        } else {
+          dutyEffFR = isREAL
+            ? Math.max(0, Math.min(1, dutyLocal * (sectorsConcurrent / Math.max(1, sectorsTotal))))
+            : Math.max(0, Math.min(1, dutyLocal));
+        }
@@
-        const nextUniforms = {
+        const nextUniforms = {
           ...prev,
@@
-          colorMode, exposure, zeroStop,
+          colorMode, exposure, zeroStop,
           vizGain,
           curvatureGainT: curvT,
           curvatureBoostMax: curvMax,
           cosmeticLevel: cosmetic,
@@
-          sectors: Math.max(1, Math.floor(sectorsIn)),
-          split: Math.max(0, Math.min(sLive - 1, splitIn|0)),
-          viewAvg: parameters.viewAvg ?? prev.viewAvg ?? true,
+          sectors: Math.max(1, Math.floor(sectorsConcurrent)),
+          sectorCount: Math.max(1, Math.floor(sectorCountOut)),
+          // clamp split against the *live* sectors for this pane
+          split: Math.max(0, Math.min(Math.max(1, Math.floor(sectorsConcurrent)) - 1, (splitIn|0))),
+          viewAvg: viewAvgResolved,
+          viewMassFraction: isREAL ? (1 / Math.max(1, sectorCountOut)) : 1.0,
           gammaGeo: N(parameters?.gammaGeo ?? parameters?.g_y, prev.gammaGeo ?? 26),
           deltaAOverA: N(parameters?.deltaAOverA ?? parameters?.qSpoilingFactor, prev.deltaAOverA ?? 1),
           gammaVdB: gammaVdBIn,
           currentMode: parameters.currentMode ?? prev.currentMode ?? 'hover',
         };
@@
-        let dutyEffFR;
-        if (zeroStandby) {
-          dutyEffFR = 0;                    // üîí TRUE ZERO in standby
-        } else if (frFromParams != null) {
-          dutyEffFR = Math.max(0, +frFromParams);
-        } else {
-          // ‚úÖ Ford‚ÄìRoman fallback: duty_local √ó (S_concurrent / S_total)
-          dutyEffFR = dutyLocal * (sectorsConcurrent / sectorsTotal);
-        }
+        // dutyEffFR already resolved above (parity-aware)

         // build theta scale
-        const thetaScaleFromChain = zeroStandby ? 0 :
+        const thetaScaleFromChain = zeroStandby ? 0 :
           Math.pow(Math.max(1, nextUniforms.gammaGeo ?? 1), 3) *
           Math.max(1e-12, nextUniforms.deltaAOverA ?? 1) *
           Math.max(1, nextUniforms.gammaVdB ?? 1) *
-          (nextUniforms.viewAvg ? Math.sqrt(Math.max(0, dutyEffFR)) : 1);
+          (viewAvgResolved ? Math.sqrt(Math.max(0, dutyEffFR)) : 1.0);
@@
         nextUniforms.thetaScale = Number.isFinite(parameters?.thetaScale)
           ? +parameters.thetaScale
           : thetaScaleFromChain;
-        nextUniforms.dutyUsed   = dutyEffFR;   // üîç for checkpoints UI
-        nextUniforms.dutyEffectiveFR = dutyEffFR; // <- for UI & future patches
+        nextUniforms.dutyUsed   = dutyEffFR;
+        nextUniforms.dutyEffectiveFR = dutyEffFR;


Effect:

REAL (u_physicsParityMode = true): viewAvg=true, sectorCount=total, Œ∏ ‚àù ‚àö(d_FR_FR-avg).

SHOW (false): viewAvg=false, sectorCount=concurrent, Œ∏ ‚àù instantaneous (no ‚àöd_FR), so its Œ∏ will diverge from REAL immediately (and won‚Äôt collapse to 0 when FR=0 in standby).