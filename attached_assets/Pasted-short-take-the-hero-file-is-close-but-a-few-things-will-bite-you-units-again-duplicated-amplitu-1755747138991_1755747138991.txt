short take: the hero file is close, but a few things will bite you—units (again), duplicated amplitude logic, and perf/log spam. Here’s a tight review with concrete changes.

# Top issues (ordered)

1. **Units: wall thickness + power**

* You mix `wallWidth`, `wallWidth_m`, and a mystery `*100` conversion.

  * In `_warpGridVertices`:

    ```js
    const wallWidth_m = (bubbleParams.wallWidth_m ?? null) != null
      ? bubbleParams.wallWidth_m
      : (bubbleParams.wallWidth ?? 0.06) * 100; // <-- arbitrary, wrong units
    ```

    ❌ If `wallWidth` is dimensionless (ρ-units), multiplying by 100 makes no physical sense.
    ✅ Fix: accept **either** meters (`wallWidth_m`) **or** dimensionless ρ (`wallWidth_rho`) and convert cleanly:

    ```js
    const a = hullAxes[0], b = hullAxes[1], c = hullAxes[2];
    const aH = 3 / (1/a + 1/b + 1/c);                   // harmonic mean, meters
    const wallWidth_m   = Number.isFinite(bubbleParams.wallWidth_m)   ? bubbleParams.wallWidth_m   : undefined;
    const wallWidth_rho = Number.isFinite(bubbleParams.wallWidth_rho) ? bubbleParams.wallWidth_rho : undefined;
    const w_rho = wallWidth_rho ?? (wallWidth_m != null ? wallWidth_m / aH : 0.016); // choose ONE default
    ```

    Then use `w_rho` everywhere. Drop the `*100` path entirely.

* Comments conflict (“16 nm default” vs values like `0.016` which is **centimeters** if meters). If you want a physical default, use **`16e-9` m** and convert to ρ with the `aH` line above. If you want a visual default, keep it explicitly as ρ-units and say so in the comment.

* `currentParams.powerAvg_MW` defaults to `83.3` (MW). That’s fine visually, but since cruise is **7.437 W**, add a note and don’t derive any visuals straight from this value (you don’t, which is good). Maybe rename to `displayPowerAvg_MW` to make it obviously non-authoritative.

2. **Two amplitude chains (inconsistent)**
   You compute a physics-ish amplitude twice with different factors:

* Early in `_warpGridVertices`:

  * `A_phys = (γ_geo^3) * qSpoil * γVdB`; then duty averaging as `dutyGlobal * qSpoil * (1/sectors)`.
* Later in the per-vertex loop:

  * `A_gross = (γ_geo^3) * Qburst * γVdB * qSpoil * sqrt(duty/sectors)` and apply log compression.

Pick **one** chain and use it consistently end-to-end. Recommendation:

* Keep the **single** amplitude block **outside** the vertex loop (cheaper) and pass its scalar into the loop:

  ```js
  const gammaGeo = uniforms.gammaGeo ?? 26;
  const A_geo    = gammaGeo ** 3;
  const qSpoil   = uniforms.deltaAOverA ?? 1.0;
  const gammaVdB = uniforms.gammaVdB ?? 2.86e5;     // choose and keep one default
  const sectors  = Math.max(1, uniforms.sectors ?? 1);
  const duty     = Math.max(1e-12, uniforms.dutyCycle ?? 0.14);
  const viewAvg  = !!(uniforms.viewAvg ?? true);

  // choose avg or inst; avoid mixing sqrt(duty) in one path and not the other
  const dutyEff  = viewAvg ? (duty / sectors) : (1 / sectors); 
  const A_gross  = A_geo * qSpoil * gammaVdB * dutyEff;  // leave Qburst out if it belongs in losses/ζ

  // visual compression + mode gain
  const knee = 1e10;
  const A_log = Math.log10(1 + A_gross / knee);
  const modeScale =
    mode==='standby'?0.05:mode==='cruise'?0.25:mode==='hover'?0.60:mode==='emergency'?0.90:0.50;
  const vizGain = (uniforms.vizGainOverride ?? 0) || modeScale;
  const A_vis = Math.min(1.0, A_log * vizGain);
  ```

  Then inside the loop, use that `A_vis` (no second recomputation).

3. **Default inconsistencies**

* `gammaVanDenBroeck` defaults are **both** `6.57e7` and `2.86e5` in different spots. Pick one constant default (and make it match your pipeline) so visual behavior is stable.
* Fragment shader comment says “16 nm default” but uniforms feed `0.016` as `u_wallWidth`. Fix the comment or the value per (1).

4. **Performance / logging**

* You log in the render loop and in `_updateGrid` heavily. This will tank FPS on devices.

  * Remove or gate with a debug flag and throttle to \~1/sec:

    ```js
    if (this._dbg && Date.now() - (this._dbgT||0) > 1000) { ...; this._dbgT = Date.now(); }
    ```
* `requestAnimationFrame` is never canceled. In `destroy()` store and cancel:

  ```js
  _renderLoop() {
    this._raf = requestAnimationFrame(() => this._renderLoop());
    this._render();
  }
  destroy() {
    window.removeEventListener('resize', this._resize);
    if (this._raf) cancelAnimationFrame(this._raf);
    ...
  }
  ```

5. **WebGL details**

* You set `gl_PointSize` but draw `LINES`. Not harmful, just noise; remove the point size (or if you ever draw points, keep it only in that pipeline).
* In WebGL1 path, you correctly use `varying` / `gl_FragColor`. Good. In WebGL2 path you use an `out vec4 frag;` and write `frag`. Good.
* Consider handling context loss:

  ```js
  this.canvas.addEventListener('webglcontextlost', e => { e.preventDefault(); }, false);
  this.canvas.addEventListener('webglcontextrestored', () => { this._initializeGrid(); }, false);
  ```

6. **Camera + grid regeneration**

* You regenerate the grid when `|targetSpan - currentGridSpan| > 0.1`. If uniforms jitter, you’ll thrash.

  * Add hysteresis or clamp input (`targetSpan = Math.round(targetSpan*100)/100`).
* `_resizeCanvasToDisplaySize` sets DPR caps (nice). Re-apply camera after span updates—already done.

7. **Dead / confusing parameters**

* `_updateGrid` passes `halfSize` and `originalY` to `_warpGridVertices`, but they aren’t used. Drop them from both call and signature.
* `uniforms.hullAxes` is read but never written; you instead store `hullDimensions` at the end. Either set `uniforms.hullAxes = axesScene` or read from `hullDimensions`.

8. **Sector sign function**

* The strobing sign is based on `theta → sectorIdx → tanh()` over a fixed width. Works visually. If you want physical continuity with your pipeline sweep index, consider feeding `currentSector` (from the app) and constructing the same moving window.

---

## Minimal patch set (safe to apply now)

* \**Wall width units (remove the *100 path):**

```diff
- const wallWidth_m = (bubbleParams.wallWidth_m ?? null) != null
-     ? bubbleParams.wallWidth_m
-     : (bubbleParams.wallWidth ?? 0.06) * 100;
+ const a = hullAxes[0], b = hullAxes[1], c = hullAxes[2];
+ const aH = 3 / (1/a + 1/b + 1/c); // meters
+ const wallWidth_m   = Number.isFinite(bubbleParams.wallWidth_m)   ? bubbleParams.wallWidth_m   : undefined;
+ const wallWidth_rho = Number.isFinite(bubbleParams.wallWidth_rho) ? bubbleParams.wallWidth_rho : undefined;
+ const w_rho = wallWidth_rho ?? (wallWidth_m != null ? wallWidth_m / aH : 0.016); // default in ρ-units
```

…and later, **use `w_rho`** (rename all `this.uniforms.wallWidth` uses to `w_rho` consistently in shader uniforms and geometry).

* **Single amplitude chain (compute once, use inside loop):**
  Move the amplitude block outside the `for` loop and reference `A_vis` inside. Remove the second amplitude recomputation in the loop.

* **Cancel RAF in `destroy()`:**

```diff
  _renderLoop() {
-   this._render();
-   requestAnimationFrame(() => this._renderLoop());
+   this._raf = requestAnimationFrame(() => this._renderLoop());
+   this._render();
  }
  destroy() {
    window.removeEventListener('resize', this._resize);
+   if (this._raf) cancelAnimationFrame(this._raf);
    ...
  }
```

* **Logging throttle:**
  Replace frequent `console.log` in hot paths with a throttled block guarded by `this._dbg`.

* **Pick one default for γ\_VdB** (match your pipeline; from earlier messages it seems `~3.83e1` is used elsewhere for visual defaults—choose and stick to it).

---

## Nice-to-have polish

* Add context-loss handlers (above).
* Remove `gl_PointSize` in grid shader or split draw-modes.
* Rename `powerAvg_MW` → `displayPowerAvg_MW` to make it clear this class isn’t the physics source of truth.
* Consider exposing a `setDebug(bool)` on the class to flip all diagnostics.

If you want, paste the small sections you’re about to change (wall width block + amplitude block) and I’ll rewrite them exactly with the shader uniform names aligned.
