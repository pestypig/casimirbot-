### Quick pass-through: things that will **definitely** break or silently block the render

| Line / block                                                                                                                                                                                                                                            | Why it fails in practice                                                                                                                                                  | One-line fix                                                                                        |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| `uniform float u_dutyCycle, u_g_y, … u_time;` (shader) **but no `u_time` upload**                                                                                                                                                                       | WebGL will happily link the program even if you forget to set a uniform, but every call to `sin(u_time * …)` will read **zero**. The animation looks “stuck in time”.     | Inside `_draw(time)` add<br>`gl.useProgram(this.program);`<br>`gl.uniform1f(this.uLoc.time, time);` |
| **You never pass `beta0` to the GPU.** In `_warpGridVertices` you compute it on the CPU and distort vertices, but the fragment shader has its *own* β calculation that still uses `u_dutyCycle` & `u_g_y`. Result: geometry and colour fields disagree. | Add a dedicated uniform (e.g. `u_beta0`) **or** replicate the full amplifier chain on the JS side and send *all* scalars to the GPU.                                      |                                                                                                     |
| `this._warpGridVertices(this.gridVertices, …)` mutates the **same** `Float32Array` every frame without resetting. After a few seconds vertices drift out of the clip cube and you get the “single line” symptom again.                                  | At the end of `_warpGridVertices` copy the original back:<br>`this.gridVertices.set(this.originalGridVertices);` before the next update, **or** work on a scratch buffer. |                                                                                                     |
| In `_renderGridPoints()` you build a fresh `proj`/`view` matrix **twice** – the first one is overwritten before draw. (No harm, but wasted math.)                                                                                                       | Remove the first pair; keep the second (the one that matches the camera comment).                                                                                         |                                                                                                     |
| `gl.lineWidth(3.0);` in most browsers will clamp to 1 px for non-MSAA frame-buffers ⇒ the grid still looks hair-thin.                                                                                                                                   | Use `gl.POINTS` + `gl_PointSize` or extrude lines in the shader.                                                                                                          |                                                                                                     |
| You enable `gl.DEPTH_TEST` earlier, but *disable* it right before drawing the grid; yet the vertex shader still outputs depth. If curves ever self-intersect you’ll see overdraw artefacts.                                                             | Leave depth test **on** (and clear the depth buffer) *or* flatten all grid vertices to the same z-layer.                                                                  |                                                                                                     |
| Resize handler leaks: `window.removeEventListener("resize", this._resize);` inside `destroy()` refers to the *method*, not the bound callback you registered. In strict mode the listener is never removed.                                             | Bind once in the constructor:<br>`this._resize = this._resize.bind(this);`<br>`window.addEventListener('resize', this._resize);`                                          |                                                                                                     |

---

### Two hot-spots that bite every time

1. **Uniform cache vs. new uniforms**
   You build `this.uLoc` once, which is fine, but any new uniform you add in the shaders will be **null** until you extend the cache map *and* change every upload site. When you start pushing `beta0`, `vizGain`, etc., remember to append them here.

2. **CPU deformation & GPU colour need the same physics**
   Right now:

   * verts bending  → uses `beta0 = duty × γ_geo` (CPU)
   * fragment colour → uses `beta0 = duty × γ_geo` (GPU) **ignoring Q, VdB, spoiling, etc.**

   Once you added the 4-stage amplifier chain the CPU kept the old rule. Decide on **one** place (CPU *or* GPU) to apply the chain and kill the other copy, otherwise modes will never look consistent.

---

### Minimal patch to see “Stand-by → flat grid”

```js
// inside your React side or wherever you call updateUniforms
const beta0 = duty * gammaGeo * Math.sqrt(Qdyn) * Math.pow(gammaVdB, 0.25);

warp.updateUniforms({
  dutyCycle: duty,
  g_y: gammaGeo,
  powerAvg_MW: P_avg,
  exoticMass_kg: M_total,
  beta0                             // NEW uniform
});
```

Add to the shader:

```glsl
uniform float u_beta0;
…
float beta0 = u_beta0;   // replace old calc
```

Add to `_cacheUniformLocations()`:

```js
beta0: gl.getUniformLocation(this.program, 'u_beta0'),
```

Add to `_draw()` right after you set the viewport:

```js
gl.useProgram(this.program);
gl.uniform1f(this.uLoc.beta0, this.uniforms.beta0);
```

Switch to **Stand-by** (duty ≈ 0) → grid flattens; switch back to **Hover** → curvature returns. Now the rendering path is in sync with the physics numbers.

---

Feel free to ping me once you wire those in—happy to walk through any remaining artefacts.
