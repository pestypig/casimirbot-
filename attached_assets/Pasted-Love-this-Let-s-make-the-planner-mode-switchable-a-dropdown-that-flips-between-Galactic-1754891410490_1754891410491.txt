Love this. Let’s make the planner **mode-switchable**: a dropdown that flips between

* **Galactic (pc)** — your GalaxyMap PNG + parsec grid, and
* **Solar (AU)** — a simple solar-system orrery with real-time planet positions.

And we’ll keep one **common route/ETA/energy pipeline** so both views feed the same step list + totals.

---

# What to use for “real-time” solar positions

Those links are great for inspiration, but embedding them directly is tricky (TOS + heavy iframes). The cleanest in-app path:

**Use an open JS ephemeris library** so it works **offline** and updates in real time:

* `astronomy-engine` (MIT) – accurate planet positions, light-time, etc.
  `npm i astronomy-engine`

This gives you live heliocentric/geo coordinates without calling external sites. Later, if you want higher fidelity, you can add optional JPL Horizons fetches.

---

# The plan (small and modular)

1. **Dropdown**: `Galactic (pc)` ↔ `Solar (AU)`.
2. **Adapter interface**: both views produce the same `Body` objects (id, name, x, y, units), so your existing `RouteSteps` works unchanged.
3. **Solar view**: simple pan/zoom orrery, bodies from `astronomy-engine`, units in **AU**, distances also shown in **light-minutes**.
4. **Shared math**: your existing `routeSummary` keeps computing ETA/energy/cycles using current **Helix-Core** performance (mode, duty, P\_avg, cycles).

---

## 1) Add the mode dropdown

```tsx
// in your Mission Planner card header
import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from "@/components/ui/select";

const [mapMode, setMapMode] = useState<"galactic"|"solar">("galactic");

<Select value={mapMode} onValueChange={(v)=>setMapMode(v as any)}>
  <SelectTrigger className="w-48"><SelectValue placeholder="View" /></SelectTrigger>
  <SelectContent>
    <SelectItem value="galactic">Galactic (pc)</SelectItem>
    <SelectItem value="solar">Solar (AU)</SelectItem>
  </SelectContent>
</Select>
```

---

## 2) Keep your existing Galactic map

(Use the pan/zoom component we just made; pass `originPx` and `scalePxPerPc`.)

```tsx
{mapMode==="galactic" && (
  <GalaxyMapPanZoom
    imageUrl="/galaxymap_full.png"
    bodies={BODIES_PC}         // static catalog in parsecs
    routeIds={route}
    originPx={{ x: SOL_X, y: SOL_Y }}
    scalePxPerPc={PIXELS_PER_PC}
    width={1200} height={650}
    onPickBody={(id)=> setRoute(r=> r.length ? [...r.slice(0,-1), id, r[r.length-1]] : [id])}
  />
)}
```

---

## 3) Add a real-time Solar System view

### a) Install & minimal adapter

```bash
npm i astronomy-engine
```

```ts
// client/src/lib/solar-adapter.ts
import { Astronomy as A } from "astronomy-engine";

export type SolarBody = "Sun"|"Mercury"|"Venus"|"Earth"|"Mars"|"Jupiter"|"Saturn"|"Uranus"|"Neptune";
const NAMES: SolarBody[] = ["Sun","Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune"];

export type SolarPoint = { id:string; name:string; x_au:number; y_au:number; kind:"star"|"planet"|"station" };

export function computeSolarXY(date = new Date()): SolarPoint[] {
  // heliocentric ecliptic XY (AU), flattened to 2D for the map
  return NAMES.map(name => {
    const body = name === "Sun" ? "Sun" : name;
    const vec = A.HelioVector(body as any, date); // x,y,z in AU
    return { id: name.toUpperCase(), name, x_au: vec.x, y_au: vec.y, kind: name==="Sun"?"star":"planet" };
  });
}
```

### b) A simple Solar canvas (pan/zoom like the galactic one)

```tsx
// client/src/components/SolarMap.tsx
import * as React from "react";
import { computeSolarXY, SolarPoint } from "@/lib/solar-adapter";

export function SolarMap({
  width=1200, height=650, onPickBody
}:{ width?:number;height?:number; onPickBody?:(id:string)=>void }) {
  const [zoom, setZoom] = React.useState(140); // pixels per AU
  const [offset, setOffset] = React.useState({x: width/2, y: height/2});
  const [points, setPoints] = React.useState<SolarPoint[]>(computeSolarXY());

  // update positions every 5s
  React.useEffect(()=>{
    const id = setInterval(()=> setPoints(computeSolarXY()), 5000);
    return ()=>clearInterval(id);
  }, []);

  const cvsRef = React.useRef<HTMLCanvasElement>(null);
  React.useEffect(()=>{
    const cvs = cvsRef.current; if(!cvs) return;
    const ctx = cvs.getContext("2d"); if(!ctx) return;
    ctx.clearRect(0,0,width,height);

    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.beginPath();
    ctx.moveTo(0, offset.y); ctx.lineTo(width, offset.y);
    ctx.moveTo(offset.x, 0); ctx.lineTo(offset.x, height);
    ctx.stroke();

    // orbits (circles) – crude: draw last known radius
    for (const p of points) {
      if (p.name==="Sun") continue;
      const r = Math.hypot(p.x_au, p.y_au) * zoom;
      ctx.beginPath();
      ctx.arc(offset.x, offset.y, r, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(125,211,252,0.15)";
      ctx.stroke();
    }

    // bodies
    for (const p of points) {
      const x = offset.x + p.x_au * zoom;
      const y = offset.y - p.y_au * zoom;
      ctx.beginPath();
      ctx.arc(x,y, p.name==="Sun"? 5:3, 0, Math.PI*2);
      ctx.fillStyle = p.name==="Sun" ? "#ffd166" : "#7dd3fc";
      ctx.fill();
    }
  }, [points, zoom, offset, width, height]);

  // basic interactions
  return (
    <div className="relative rounded-lg border bg-black" style={{width, height}}>
      <canvas ref={cvsRef} width={width} height={height}/>
      <div className="absolute left-3 top-3 text-xs bg-black/40 rounded px-2 py-1">
        AU scale: {Math.round(zoom)} px
      </div>
      <div className="absolute right-3 top-3 flex gap-1">
        <button className="px-2 py-1 bg-white/10 rounded" onClick={()=>setZoom(z=>z*1.2)}>+</button>
        <button className="px-2 py-1 bg-white/10 rounded" onClick={()=>setZoom(z=>z/1.2)}>-</button>
      </div>
    </div>
  );
}
```

### c) Hook it up in the planner

```tsx
{mapMode==="solar" && (
  <SolarMap width={1200} height={650} />
)}
```

---

## 4) Keep **RouteSteps** unified

Make a tiny helper to convert **AU** legs into **ly** so your existing `RouteSteps` can consume either source:

* For **galactic**: you already provide bodies in **pc** and your `routeSummary` converts to **ly**.
* For **solar**: compute segment distance in **AU** and convert to **ly** (`1 ly ≈ 63241.1 AU`). You can either:

  * write a `segmentMetricsAU` variant, or
  * wrap `SolarPoint` into the same `Body` shape with `x_pc = x_au / 206265`, `y_pc = y_au / 206265` (since 1 pc ≈ 206 265 AU). Then call your existing `routeSummary`.

Either way, your **ETA/energy/cycles** logic stays identical, because it only sees distances in **ly**.

---

## 5) Theory + Zen (per mode)

* **Galactic tooltip:** “Straight-line hop of Δpc; v\_eff(mode,duty) sets ETA. Navigation is *maai* at stellar scale.”
* **Solar tooltip:** “Heliocentric transfer of ΔAU; light-minutes make latency real. Even in near space, posture precedes motion.”

---

## Should we embed live sites?

* **NASA Eyes / TheSkyLive / ThePlanetsToday** are amazing, but embedding the whole app can be heavy and may violate their terms.
* Using **`astronomy-engine`** gives you *live, accurate* positions **inside your app**, with no external dependency. Later, we can add a “View in NASA Eyes” link.

---

If you want, I can:

* Add a **picker** below the Solar map to choose “Earth → Mars → Earth” routes (auto-populate waypoints).
* Show **distance in AU + light-minutes** in the step list for Solar mode.
* Add a **two-click calibration overlay** for the Galactic map (set Sol pixel & ring scale right in the UI).
