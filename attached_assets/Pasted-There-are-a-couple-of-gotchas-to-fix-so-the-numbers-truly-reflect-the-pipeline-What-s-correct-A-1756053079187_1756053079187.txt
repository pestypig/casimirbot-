There are a couple of gotchas to fix so the numbers truly reflect the pipeline:

✅ What’s correct

Averaged (“avg”) value
avgTiles = totalTiles * dutyEffectiveFR — and your dutyEffectiveFR comes from the light-crossing loop (burst_ms/dwell_ms) times the concurrent/total sector fraction. That exactly matches the Ford–Roman ship-wide duty used by the EnergyPipeline math.

Instant (“now”) value
instantTiles = (inBurstNow ? S_live * tilesPerSector : 0) with a light EMA is the right instantaneous picture, provided lc.phase, burst_ms, and dwell_ms are all live.

Tiles-per-sector
Falling back to floor(totalTiles / totalSectors) when the server doesn’t give tilesPerSector is fine and consistent with the scheduler model.

⚠️ Tighten these to ensure “true values”

Use one authority for S_total and dutyEffectiveFR
If totalSectors comes from /metrics (e.g., 384 or 512 in future configs) but dutyEffectiveFR was computed assuming 400, the avg will drift. Compute dutyEffectiveFR from the same S_total you pass to the hook (or pass the server-provided FR duty straight through).

Make sure lc.phase is flowing
If phase isn’t advancing (or burst_ms, dwell_ms are NaN), inBurstNow stays false and the “now” line looks stagnant. Quick guard:

// when building lc:
const lc = useLightCrossingLoop({ /* ... */ });
// sanity ping somewhere:
if (!Number.isFinite(lc?.phase) || !Number.isFinite(lc?.burst_ms) || !Number.isFinite(lc?.dwell_ms)) {
  console.warn("[HELIX] LC loop missing timing — 'now' tiles will be flat");
}


Unit mismatch in the Energy Output panel (important)
In the small panel you render:

{fmtPowerUnit(pipeline?.P_avg ?? systemMetrics?.energyOutput)}


Your fmtPowerUnit helper expects MW, but systemMetrics.energyOutput is typically W. So when pipeline?.P_avg is absent, you’ll format W as MW and wildly overstate the number.

Fix:

{Number.isFinite(pipeline?.P_avg)
  ? fmtPowerUnit(pipeline!.P_avg)            // P_avg is MW
  : fmtPowerUnitFromW(systemMetrics?.energyOutput)} // energyOutput is W