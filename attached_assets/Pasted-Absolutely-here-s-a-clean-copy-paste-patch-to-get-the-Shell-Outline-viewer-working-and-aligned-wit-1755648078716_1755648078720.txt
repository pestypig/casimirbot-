Absolutely—here’s a clean, copy-paste patch to get the Shell Outline viewer working (and aligned with the strobing/averaging theory). It fixes the “black screen” by guaranteeing sane defaults, sizing the canvas immediately, and drawing the three ρ-surfaces (inner, center, outer) plus the violet shift vector.

I’m giving you two drop-in files:

⸻

1) client/public/warp-engine-outline.js  (full replace)

<script>
/**
 * Warp Bubble • Shell Outline (ρ = 1 ± Δ)
 * - Ellipsoidal wireframes for inner / center / outer shell (Natário)
 * - Optional interior shift vector (violet) to visualize cabin "down"
 * Renders on a 2D canvas for light weight + easy integration.
 */
(function () {
  const TAU = Math.PI * 2;

  // Safe helpers --------------------------------------------------------------
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const lerp  = (a, b, t) => a + (b - a) * t;

  // Compute ellipsoid point from angles and semi-axes (scene units)
  function ellipsoidPoint(a, b, c, theta, phi) {
    // theta: [0..2π) around x-z plane, phi: [-π/2..π/2] latitude
    const cosPhi = Math.cos(phi), sinPhi = Math.sin(phi);
    const cosTh  = Math.cos(theta), sinTh = Math.sin(theta);
    const x = a * cosPhi * cosTh;
    const y = b * sinPhi;
    const z = c * cosPhi * sinTh;
    return [x, y, z];
  }

  // Project simple perspective to 2D (fixed camera)
  function project(p, cam) {
    // cam: {eye:[x,y,z], center:[x,y,z], up:[x,y,z], f: focal, w, h, scale}
    // We keep a simplified “look-at” aligned frame (up = +Y), so:
    const [x, y, z] = p;
    const pe = [x - cam.eye[0], y - cam.eye[1], z - cam.eye[2]];
    // Forward is along -Z (eye looks toward -Z)
    const Z = -pe[2];
    const X = pe[0];
    const Y = pe[1];

    // Simple perspective
    const sx = cam.cx + cam.f * (X / Math.max(1e-6, Z));
    const sy = cam.cy - cam.f * (Y / Math.max(1e-6, Z));
    return [sx, sy, Z];
  }

  // OutlineEngine -------------------------------------------------------------
  class OutlineEngine {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx    = canvas.getContext('2d', { alpha: false });
      this.pixelRatio = Math.max(1, window.devicePixelRatio || 1);

      // uniforms / parameters with safe defaults
      this.params = {
        hullAxes: [0.42, 0.11, 0.09], // scene units (roughly matching main viz)
        wallWidth: 0.06,              // normalized wall thickness in ρ-space
        epsilonTilt: 0.0,
        betaTiltVec: [0, -1, 0],
        gridColor: '#0b1022',
      };

      this._needsFrame = false;
      this._resize = this._resize.bind(this);
      window.addEventListener('resize', this._resize);
      this._resize();
    }

    bootstrap(params = {}) {
      this.updateUniforms(params);
      this._draw(); // immediate first paint
    }

    updateUniforms(params = {}) {
      // Merge + sanitize
      const p = { ...this.params, ...params };
      // Ensure hullAxes defined
      if (!Array.isArray(p.hullAxes) || p.hullAxes.length !== 3) {
        p.hullAxes = this.params.hullAxes.slice();
      }
      // wallWidth must be >0
      p.wallWidth = Number.isFinite(p.wallWidth) && p.wallWidth > 0 ? p.wallWidth : this.params.wallWidth;

      // Normalize β tilt dir for arrow
      const v = Array.isArray(p.betaTiltVec) ? p.betaTiltVec.slice(0,3) : [0, -1, 0];
      const L = Math.hypot(v[0], v[1], v[2]) || 1;
      p.betaTiltVec = [v[0]/L, v[1]/L, v[2]/L];
      this.params = p;

      // After any change, redraw once
      this._requestDraw();
    }

    destroy() {
      window.removeEventListener('resize', this._resize);
    }

    // sizing & camera ---------------------------------------------------------
    _resize() {
      const pr = this.pixelRatio;
      const w = this.canvas.clientWidth  || this.canvas.parentElement.clientWidth  || 800;
      const h = this.canvas.clientHeight || this.canvas.parentElement.clientHeight || 400;
      this.canvas.width  = Math.floor(w * pr);
      this.canvas.height = Math.floor(h * pr);
      this.canvas.style.width  = w + 'px';
      this.canvas.style.height = h + 'px';
      this.ctx.setTransform(pr, 0, 0, pr, 0, 0);
      this._requestDraw();
    }

    _camera() {
      const { hullAxes } = this.params;
      const a = hullAxes[0], b = hullAxes[1], c = hullAxes[2];
      const R = Math.max(a, b, c);

      const w = this.canvas.width  / this.pixelRatio;
      const h = this.canvas.height / this.pixelRatio;
      const aspect = w / Math.max(1, h);

      // Slightly higher overhead than the main viz
      const eye  = [0, 0.40 * R,  1.8 * R];   // camera in +Z looking toward center
      const fov  = aspect > 1 ? Math.PI/3.2 : Math.PI/2.8; // modestly wide on phones
      const f    = (0.5 * h) / Math.tan(0.5 * fov);

      return {
        eye,
        center: [0, 0, 0],
        up: [0, 1, 0],
        f,
        w, h,
        cx: w * 0.5,
        cy: h * 0.5,
      };
    }

    // drawing ----------------------------------------------------------------
    _requestDraw() {
      if (!this._needsFrame) {
        this._needsFrame = true;
        requestAnimationFrame(() => {
          this._needsFrame = false;
          this._draw();
        });
      }
    }

    _draw() {
      const ctx = this.ctx;
      const { hullAxes, wallWidth, epsilonTilt, betaTiltVec } = this.params;

      // Clear
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, this.canvas.width / this.pixelRatio, this.canvas.height / this.pixelRatio);

      const cam = this._camera();

      // Colors (match main visual semantics)
      const colOuter   = '#1e90ff';  // blue → expansion (+)
      const colInner   = '#ff9b3a';  // orange → compression (−)
      const colCenter  = '#cccccc';  // mid shell
      const colShift   = '#9b5cff';  // violet shift vector
      const alphaWire  = 0.9;

      const a0 = hullAxes[0], b0 = hullAxes[1], c0 = hullAxes[2];

      // ρ surfaces: (1 - Δ), (1), (1 + Δ)
      const Δ = clamp(wallWidth, 0.005, 0.40);
      const shells = [
        { scale: 1 - Δ, color: colInner,  line: 1.5 },
        { scale: 1.00, color: colCenter, line: 1.0 },
        { scale: 1 + Δ, color: colOuter,  line: 1.5 },
      ];

      // Wireframe sampling
      const Nθ = 96;  // meridians
      const Nφ = 40;  // latitudes

      shells.forEach(s => {
        const a = a0 * s.scale, b = b0 * s.scale, c = c0 * s.scale;
        ctx.globalAlpha = alphaWire;
        ctx.strokeStyle = s.color;
        ctx.lineWidth   = s.line;

        // Latitudes
        for (let j = 1; j < Nφ; j++) {
          const t = j / Nφ;
          const phi = lerp(-Math.PI/2, Math.PI/2, t);
          let first = true;
          ctx.beginPath();
          for (let i = 0; i <= Nθ; i++) {
            const th = (i / Nθ) * TAU;
            const p3 = ellipsoidPoint(a, b, c, th, phi);
            const [x, y] = project(p3, cam);
            if (first) {
              ctx.moveTo(x, y); first = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }

        // Meridians
        for (let i = 0; i < Nθ; i += 6) {
          const th = (i / Nθ) * TAU;
          let first = true;
          ctx.beginPath();
          for (let j = 0; j <= Nφ; j++) {
            const t = j / Nφ;
            const phi = lerp(-Math.PI/2, Math.PI/2, t);
            const p3 = ellipsoidPoint(a, b, c, th, phi);
            const [x, y] = project(p3, cam);
            if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
          }
          ctx.stroke();
        }
      });

      // Shift vector (violet), scaled to radius with epsilonTilt gain
      if (epsilonTilt > 0) {
        const R = Math.max(a0, b0, c0);
        const head = epsilonTilt * 1.2 * R; // visual gain
        const base = [0, 0, 0];
        const tip  = [
          base[0] + betaTiltVec[0] * head,
          base[1] + betaTiltVec[1] * head,
          base[2] + betaTiltVec[2] * head,
        ];
        const [x0, y0] = project(base, cam);
        const [x1, y1] = project(tip,  cam);

        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = colShift;
        ctx.fillStyle   = colShift;
        ctx.lineWidth   = 2.0;

        // shaft
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();

        // arrow head
        const angle = Math.atan2(y1 - y0, x1 - x0);
        const ah = 10, aw = 6;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x1 - ah * Math.cos(angle - Math.PI/8), y1 - ah * Math.sin(angle - Math.PI/8));
        ctx.lineTo(x1 - aw * Math.cos(angle + Math.PI/2), y1 - aw * Math.sin(angle + Math.PI/2));
        ctx.closePath();
        ctx.fill();
      }

      // Tiny legend badge (optional)
      const w = this.canvas.width / this.pixelRatio;
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(12, 12, 220, 56);
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system';
      ctx.fillText('Shell Outline • ρ-surfaces (inner/center/outer)', 18, 28);
      ctx.fillStyle = colInner;  ctx.fillRect(18, 36, 10, 10); ctx.fillStyle = '#b0b8c0'; ctx.fillText('Compression (inner)', 34, 45);
      ctx.fillStyle = colOuter;  ctx.fillRect(138, 36, 10, 10); ctx.fillStyle = '#b0b8c0'; ctx.fillText('Expansion (outer)',   154, 45);
      ctx.fillStyle = '#b0b8c0';
      ctx.fillText('Shift vector shown in violet', 18, 60);
    }
  }

  // Expose to window (like WarpEngine)
  window.OutlineEngine = OutlineEngine;
})();
</script>


⸻

2) client/src/components/ShellOutlineVisualizer.tsx  (full replace)

import React, { useEffect, useRef } from "react";

type Props = {
  parameters?: {
    hull?: { a:number; b:number; c:number };
    wallWidth?: number;           // meters or normalized? we treat as normalized like main viz
    epsilonTilt?: number;         // dimensionless tilt gain
    betaTiltVec?: [number,number,number];
  };
};

declare global {
  interface Window { OutlineEngine?: any; }
}

export default function ShellOutlineVisualizer({ parameters }: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const engineRef = useRef<any>(null);

  // Load the outline engine script once
  useEffect(() => {
    if (window.OutlineEngine) return;
    const s = document.createElement("script");
    s.src = "/warp-engine-outline.js?v=2"; // cache-bust
    document.body.appendChild(s);
    return () => { /* script stays */ };
  }, []);

  // Bootstrap engine
  useEffect(() => {
    if (!window.OutlineEngine || !canvasRef.current) return;
    if (!engineRef.current) {
      engineRef.current = new window.OutlineEngine(canvasRef.current);
    }
    const hull = parameters?.hull || { a:0.42, b:0.11, c:0.09 };
    const uniforms = {
      hullAxes: [hull.a, hull.b, hull.c],
      wallWidth: typeof parameters?.wallWidth === 'number' ? parameters!.wallWidth : 0.06,
      epsilonTilt: typeof parameters?.epsilonTilt === 'number' ? parameters!.epsilonTilt : 0.0,
      betaTiltVec: (parameters?.betaTiltVec || [0,-1,0]) as [number,number,number],
    };
    engineRef.current.bootstrap(uniforms);
  }, [parameters]);

  // Update uniforms when props change later
  useEffect(() => {
    if (!engineRef.current) return;
    const hull = parameters?.hull || { a:0.42, b:0.11, c:0.09 };
    engineRef.current.updateUniforms({
      hullAxes: [hull.a, hull.b, hull.c],
      wallWidth: typeof parameters?.wallWidth === 'number' ? parameters!.wallWidth : 0.06,
      epsilonTilt: typeof parameters?.epsilonTilt === 'number' ? parameters!.epsilonTilt : 0.0,
      betaTiltVec: (parameters?.betaTiltVec || [0,-1,0]) as [number,number,number],
    });
  }, [parameters?.hull, parameters?.wallWidth, parameters?.epsilonTilt, parameters?.betaTiltVec]);

  // Responsive canvas: set CSS size so engine can pick it up
  return (
    <div className="rounded-xl overflow-hidden bg-black">
      <canvas ref={canvasRef} style={{ width: "100%", height: "420px", display: "block" }} />
    </div>
  );
}


⸻

Why this matches the theory
	•	The viewer deliberately shows ρ=1±Δ shells as wireframes, making clear that the true curvature amplitude is small but spatially well-distributed over the ellipsoidal wall.
	•	The violet interior vector visualizes the shift vector (β-tilt) direction you compute from the Shift Vector • Interior Gravity panel.
	•	This presentation complements the sector-strobing logic: in high-frequency limits the cycle-averaged stress–energy sources the same smooth curvature as a continuous shell; the outline helps viewers separate geometry (shell placement) from instantaneous micro-pulsing.  ￼

If anything still renders black after these drops, it means the panel’s container is height-collapsed before mount. In that case, keep the inline height: "420px" in the canvas wrapper (or replace with any fixed/tailwind class like h-[420px]) so the first draw has pixels to fill.