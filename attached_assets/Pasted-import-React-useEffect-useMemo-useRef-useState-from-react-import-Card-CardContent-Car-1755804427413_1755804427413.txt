import React, { useEffect, useMemo, useRef, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select";
import { Activity, Zap, Sigma, Atom, Gauge, RadioReceiver, Thermometer, CircuitBoard, ScanSearch, ShieldCheck } from "lucide-react";
import {
  ResponsiveContainer,
  CartesianGrid,
  Tooltip,
  XAxis,
  YAxis,
  Bar,
  BarChart,
  LineChart,
  Line,
  ReferenceLine
} from "recharts";

/**
 * HelixCasimirAmplifier.tsx
 *
 * A physics-first visualizer for the Needle Hull energy pipeline showing how the Casimir effect
 * is amplified in the cavity chain. It pulls true values from HELIX-CORE endpoints and renders:
 *  - Cavity equation card (E/A = -π² ħc / (720 a³))
 *  - Amplification Ladder (power chain): U_static → γ_geo → q_mech → duty (d_eff)
 *  - Mass Ladder (mass chain): |U_static| → γ_geo^3 → Q_BURST → γ_VdB → duty (d_eff) → M_total
 *  - Live displacement field heatmap from /api/helix/displacement
 *  - Mode switcher (hover / cruise / emergency / standby)
 *  - GR compliance chips (Ford–Roman ζ, time-scale TS, Natário)
 *
 * Assumed routes (adjust if your server mounts differently):
 *  - GET    /api/helix/metrics         -> getHelixMetrics
 *  - GET    /api/helix/state           -> getPipelineState
 *  - GET    /api/helix/displacement    -> getDisplacementField
 *  - POST   /api/helix/mode            -> switchOperationalMode { mode }
 */

// ------------------------- Types from your backend -------------------------

type EnergyPipelineState = {
  // inputs / config
  tileArea_cm2: number;
  gap_nm: number;
  sag_nm: number;
  temperature_K: number;
  modulationFreq_GHz: number;
  dutyCycle: number;
  sectorStrobing: number;
  qSpoilingFactor: number;
  gammaGeo: number;
  qMechanical: number;
  qCavity: number;
  gammaVanDenBroeck: number;
  exoticMassTarget_kg: number;
  N_tiles: number;
  modelMode?: "calibrated" | "raw";

  // calculated (authoritative)
  U_static: number;
  U_geo: number;
  U_Q: number;
  U_cycle: number;
  P_loss_raw: number; // per tile during ON [W]
  P_avg: number;      // ship average [MW]
  M_exotic: number;   // mass [kg]
  M_exotic_raw: number;
  dutyBurst?: number; // local burst duty (0.01)
  dutyEffective_FR?: number; // effective duty used for FR sampling

  hull?: { Lx_m: number; Ly_m: number; Lz_m: number };
};

type HelixMetrics = {
  energyOutput: number;     // MW
  exoticMass: number;       // kg
  exoticMassRaw: number;    // kg
  totalTiles: number;
  tilesPerSector: number;
  totalSectors: number;
  activeSectors: number;
  activeFraction: number;
  gammaVanDenBroeck: number;
  gammaGeo: number;
  qCavity: number;
  dutyGlobal: number;
  dutyInstant: number;
  dutyEffectiveFR: number;  // authoritative d_eff
  fordRoman: { value: number; limit: number; status: "PASS" | "FAIL" };
  natario:    { value: number; status: "VALID" | "WARN" };
  curvatureMax: number;
  timeScaleRatio: number;
  modelMode?: "calibrated" | "raw";
};

// --------------------------- Constants (UI only) ---------------------------

const HBAR_C = 1.98644586e-25; // J·m
const PI = Math.PI;
const C = 299_792_458;
const Q_BURST = 1e9; // keep in sync with backend PAPER.Q_BURST

// ---------------------------- Helper utilities ----------------------------

function sci(n: number | undefined | null, digits = 3) {
  if (n == null || !isFinite(n)) return "—";
  const e = n === 0 ? 0 : Math.floor(Math.log10(Math.abs(n)));
  const m = n / Math.pow(10, e);
  return `${m.toFixed(digits)}e${e}`;
}

function fmtNum(n: number | undefined | null, unit = "", digits = 3) {
  if (n == null || !isFinite(n)) return "—";
  const abs = Math.abs(n);
  if (abs === 0) return `0${unit ? " " + unit : ""}`;
  if (abs >= 1e6 || abs <= 1e-3) return `${sci(n, digits)}${unit ? " " + unit : ""}`;
  return `${n.toFixed(digits)}${unit ? " " + unit : ""}`;
}

function usePolling<T>(url: string, ms = 1500, deps: any[] = []) {
  const [data, setData] = useState<T | null>(null);
  const [err, setErr] = useState<string | null>(null);
  useEffect(() => {
    let alive = true;
    async function tick() {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const json = await res.json();
        if (!alive) return;
        setData(json);
        setErr(null);
      } catch (e: any) {
        if (!alive) return;
        setErr(e?.message ?? "fetch failed");
      }
    }
    tick();
    const id = setInterval(tick, ms);
    return () => { alive = false; clearInterval(id); };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
  return { data, err } as const;
}

// ------------------------- Heatmap (displacement) -------------------------

type FieldSample = { p: [number, number, number]; bell: number; sgn: number; disp: number };

type FieldResponse = {
  count: number;
  data: FieldSample[];
  physics: { gammaGeo: number; qSpoiling: number; sectorStrobing: number };
};

function DisplacementHeatmap({ endpoint }: { endpoint: string }) {
  const [params, setParams] = useState({ nTheta: 128, nPhi: 64, sectors: 400, split: 200 });
  const q = new URLSearchParams({
    nTheta: String(params.nTheta),
    nPhi: String(params.nPhi),
    sectors: String(params.sectors),
    split: String(params.split)
  }).toString();
  const { data } = usePolling<FieldResponse>(`${endpoint}?${q}`, 2500, [endpoint, q]);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  useEffect(() => {
    if (!data || !canvasRef.current) return;
    const cvs = canvasRef.current;
    const W = cvs.width;
    const H = cvs.height;
    const ctx = cvs.getContext("2d");
    if (!ctx) return;

    // draw background
    ctx.fillStyle = "#0b1020";
    ctx.fillRect(0, 0, W, H);

    // data is in scanline order: theta-major then phi.
    const nTh = params.nTheta;
    const nPh = params.nPhi;
    const cellW = W / nTh;
    const cellH = H / nPh;

    // Compute min/max of disp for scaling
    let min = Infinity, max = -Infinity;
    for (const s of data.data) { min = Math.min(min, s.disp); max = Math.max(max, s.disp); }
    const span = Math.max(1e-12, max - min);

    function colormap(v: number) {
      // v in [min,max] → 0..1
      const t = (v - min) / span;
      // blue → black → red diverging
      const r = t;
      const b = 1 - t;
      const g = 0.08 + 0.2 * (1 - Math.abs(t - 0.5) * 2);
      return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
    }

    // Paint
    let idx = 0;
    for (let i = 0; i < nTh; i++) {
      for (let j = 0; j < nPh; j++) {
        const s = data.data[idx++];
        ctx.fillStyle = colormap(s.disp);
        ctx.fillRect(i * cellW, (nPh - 1 - j) * cellH, Math.ceil(cellW), Math.ceil(cellH));
      }
    }

    // sector split line
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.lineWidth = 1;
    const splitX = (params.split / params.sectors) * W;
    ctx.beginPath();
    ctx.moveTo(splitX, 0);
    ctx.lineTo(splitX, H);
    ctx.stroke();
  }, [data, params]);

  return (
    <Card className="bg-slate-900/40 border-slate-800">
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2 text-slate-100"><ScanSearch className="w-5 h-5"/> Displacement Field (Natário bell)</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        <div className="flex flex-wrap gap-3 items-end">
          <div>
            <Label htmlFor="th">θ samples</Label>
            <Input id="th" type="number" min={32} max={512} value={params.nTheta}
              onChange={e=>setParams(p=>({...p, nTheta: Number(e.target.value)||128}))}/>
          </div>
          <div>
            <Label htmlFor="ph">φ samples</Label>
            <Input id="ph" type="number" min={16} max={256} value={params.nPhi}
              onChange={e=>setParams(p=>({...p, nPhi: Number(e.target.value)||64}))}/>
          </div>
          <div>
            <Label htmlFor="sec">Sectors</Label>
            <Input id="sec" type="number" min={1} max={400} value={params.sectors}
              onChange={e=>setParams(p=>({...p, sectors: Math.max(1,Math.min(400, Number(e.target.value)||400))}))}/>
          </div>
          <div>
            <Label htmlFor="split">Split</Label>
            <Input id="split" type="number" min={1} max={params.sectors-1} value={params.split}
              onChange={e=>setParams(p=>({...p, split: Math.max(1, Math.min(p.sectors-1, Number(e.target.value)||200))}))}/>
          </div>
        </div>
        <div className="rounded-xl overflow-hidden ring-1 ring-slate-800 shadow-inner">
          <canvas ref={canvasRef} width={960} height={360} className="w-full h-[240px]"/>
        </div>
        <p className="text-xs text-slate-400">Heatmap shows signed displacement amplitude on the ellipsoidal shell; white line marks the +/− sector split. Colormap is blue (−) → red (+).</p>
      </CardContent>
    </Card>
  );
}

// -------------------------- Amplification ladders -------------------------

type LadderDatum = { stage: string; value: number };

function LadderChart({ title, unit, data }: { title: string; unit: string; data: LadderDatum[] }) {
  return (
    <Card className="bg-slate-900/40 border-slate-800">
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2 text-slate-100"><Atom className="w-5 h-5"/> {title}</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[220px]">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={data} margin={{ top: 8, right: 24, bottom: 8, left: 8 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#1e293b" />
              <XAxis dataKey="stage" tick={{ fill: "#94a3b8" }} interval={0} angle={-15} textAnchor="end" height={50}/>
              <YAxis tick={{ fill: "#94a3b8" }} tickFormatter={(v)=>fmtNum(v, "", 2)} domain={[0, "auto"]}/>
              <Tooltip formatter={(v:number)=>fmtNum(v, unit)} contentStyle={{ background: "#0b1220", border: "1px solid #1f2937" }}/>
              <Bar dataKey="value" fill="#60a5fa" radius={[6,6,0,0]} />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}

function EquationChip({ eq }: { eq: string }) {
  return <code className="px-2 py-1 rounded-md bg-slate-800/70 text-slate-200 text-xs font-mono border border-slate-700">{eq}</code>;
}

// ------------------------------- Main UI ----------------------------------

export default function HelixCasimirAmplifier({
  metricsEndpoint = "/api/helix/metrics",
  stateEndpoint = "/api/helix/state",
  fieldEndpoint = "/api/helix/displacement",
  modeEndpoint = "/api/helix/mode"
}: {
  metricsEndpoint?: string;
  stateEndpoint?: string;
  fieldEndpoint?: string;
  modeEndpoint?: string;
}) {
  const { data: metrics } = usePolling<HelixMetrics>(metricsEndpoint, 1500, [metricsEndpoint]);
  const { data: state }   = usePolling<EnergyPipelineState>(stateEndpoint, 3000, [stateEndpoint]);

  // derived quantities (robust to partial data)
  const derived = useMemo(() => {
    if (!state || !metrics) return null;

    const U_static = state.U_static;                 // J per tile (signed)
    const gammaGeo = state.gammaGeo;
    const qMech    = state.qMechanical ?? 1;
    const d_eff    = metrics.dutyEffectiveFR ?? 0;   // authoritative duty for FR & ship averaging
    const N_tiles  = state.N_tiles ?? metrics.totalTiles;
    const omega    = 2 * Math.PI * (state.modulationFreq_GHz ?? 15) * 1e9;

    // Power chain (per tile → ship)
    const U_geo    = U_static * gammaGeo;            // note: power chain uses γ^1 (as in backend)
    const U_Q      = U_geo * qMech;                  // per tile (ON-window stored energy proxy)
    const U_cycle  = U_Q * d_eff;                    // per tile average contribution

    const P_tile_on = Math.abs(U_Q) * omega / Q_BURST;  // W per tile during ON
    const P_ship_avg_calc_MW = (P_tile_on * N_tiles * d_eff) / 1e6;
    const P_ship_avg_report_MW = state.P_avg;           // authoritative from backend calibration

    // Mass chain (per tile energy that maps to exotic mass via E/c^2)
    const geo3    = Math.pow(gammaGeo, 3);
    const E_tile_mass = Math.abs(U_static) * geo3 * Q_BURST * (state.gammaVanDenBroeck ?? metrics.gammaVanDenBroeck) * d_eff;
    const M_total_calc = (E_tile_mass / (C * C)) * N_tiles; // kg
    const M_total_report = state.M_exotic;

    return {
      U_static,
      U_geo,
      U_Q,
      U_cycle,
      P_tile_on,
      P_ship_avg_calc_MW,
      P_ship_avg_report_MW,
      E_tile_mass,
      M_total_calc,
      M_total_report,
      d_eff,
      N_tiles,
      gammaGeo,
      qMech,
      gammaVdB: state.gammaVanDenBroeck,
      omega
    };
  }, [state, metrics]);

  const ladderPower: LadderDatum[] = useMemo(() => {
    if (!derived) return [];
    return [
      { stage: "|U_static| per tile", value: Math.abs(derived.U_static) },
      { stage: "× γ_geo → U_geo", value: Math.abs(derived.U_geo) },
      { stage: "× q_mech → U_Q", value: Math.abs(derived.U_Q) },
      { stage: "× d_eff → U_cycle", value: Math.abs(derived.U_cycle) }
    ];
  }, [derived]);

  const ladderMass: LadderDatum[] = useMemo(() => {
    if (!derived || !state || !metrics) return [];
    const geo3 = Math.pow(derived.gammaGeo, 3);
    const d_eff = derived.d_eff;
    const gammaV = derived.gammaVdB;
    const U = Math.abs(derived.U_static);
    return [
      { stage: "|U_static|", value: U },
      { stage: "× γ_geo^3", value: U * geo3 },
      { stage: "× Q_BURST", value: U * geo3 * Q_BURST },
      { stage: "× γ_VdB", value: U * geo3 * Q_BURST * (gammaV ?? metrics.gammaVanDenBroeck) },
      { stage: "× d_eff → E_tile", value: U * geo3 * Q_BURST * (gammaV ?? metrics.gammaVanDenBroeck) * d_eff }
    ];
  }, [derived, state, metrics]);

  // Mode switching
  const [mode, setMode] = useState<string>("hover");
  const [pendingMode, setPendingMode] = useState(false);
  async function switchMode(newMode: string) {
    setPendingMode(true);
    try {
      await fetch(modeEndpoint, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ mode: newMode }) });
      setMode(newMode);
    } finally {
      setPendingMode(false);
    }
  }

  return (
    <div className="w-full mx-auto max-w-7xl p-4 md:p-6 space-y-6">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 className="text-2xl md:text-3xl font-semibold tracking-tight text-slate-100 flex items-center gap-2">
            <CircuitBoard className="w-7 h-7"/> Casimir Cavity Amplifier — Helix Core
          </h1>
          <p className="text-slate-400 text-sm mt-1">Live, physics-backed visualization of the cavity → geometry → Q → duty → mass chain.</p>
        </div>
        <div className="flex items-center gap-2">
          <Badge variant="secondary" className="bg-slate-800 text-slate-200">model: {state?.modelMode ?? metrics?.modelMode ?? "—"}</Badge>
          <Badge className={metrics?.fordRoman.status === "PASS" ? "bg-emerald-700" : "bg-rose-700"}>
            ζ {fmtNum(metrics?.fordRoman.value)} ({metrics?.fordRoman.status})
          </Badge>
          <Badge className="bg-indigo-700">TS {fmtNum(metrics?.timeScaleRatio)}</Badge>
        </div>
      </div>

      {/* Top row: Cavity equation & mode */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <Card className="bg-slate-900/40 border-slate-800 lg:col-span-2">
          <CardHeader className="pb-2">
            <CardTitle className="flex items-center gap-2 text-slate-100"><Sigma className="w-5 h-5"/> Cavity physics</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="flex flex-wrap items-center gap-2 text-slate-200">
              <EquationChip eq="E/A = -π² ħc / (720 a³)"/>
              <span className="text-slate-400 text-sm">(parallel-plate Casimir energy density)</span>
            </div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <Stat label="Gap (a)" value={fmtNum(state?.gap_nm, "nm")} icon={<RadioReceiver className="w-4 h-4"/>}/>
              <Stat label="Tile area" value={fmtNum(state ? state.tileArea_cm2 * 1e-4 : undefined, "m²")} icon={<Activity className="w-4 h-4"/>}/>
              <Stat label="|U_static|/tile" value={fmtNum(state ? Math.abs(state.U_static) : undefined, "J")} icon={<Zap className="w-4 h-4"/>}/>
              <Stat label="Temp" value={fmtNum(state?.temperature_K, "K")} icon={<Thermometer className="w-4 h-4"/>}/>
            </div>
            <p className="text-xs text-slate-400">All downstream values are driven from the true backend state (no magic numbers). Power chain uses γ_geo linearly; mass chain uses γ_geo cubed, matching the backend pipeline.</p>
          </CardContent>
        </Card>

        <Card className="bg-slate-900/40 border-slate-800">
          <CardHeader className="pb-2">
            <CardTitle className="flex items-center gap-2 text-slate-100"><Gauge className="w-5 h-5"/> Mode</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <Select value={mode} onValueChange={switchMode} disabled={pendingMode}>
              <SelectTrigger className="bg-slate-800/60 border-slate-700 text-slate-100">
                <SelectValue placeholder="Select mode" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="hover">hover</SelectItem>
                <SelectItem value="cruise">cruise</SelectItem>
                <SelectItem value="emergency">emergency</SelectItem>
                <SelectItem value="standby">standby</SelectItem>
              </SelectContent>
            </Select>
            <div className="grid grid-cols-2 gap-3 text-slate-200">
              <StatSmall label="Sectors live" value={fmtNum(metrics?.activeSectors)} />
              <StatSmall label="d_eff" value={fmtNum(metrics?.dutyEffectiveFR)} />
              <StatSmall label="γ_geo" value={fmtNum(state?.gammaGeo)} />
              <StatSmall label="q_mech" value={fmtNum(state?.qMechanical)} />
              <StatSmall label="γ_VdB" value={fmtNum(metrics?.gammaVanDenBroeck)} />
              <StatSmall label="N_tiles" value={fmtNum(metrics?.totalTiles)} />
            </div>
            <div className="flex gap-2">
              <Badge className="bg-amber-700/70">P_avg ≈ {fmtNum(state?.P_avg, "MW")}</Badge>
              <Badge className="bg-sky-700/70">M_exotic ≈ {fmtNum(metrics?.exoticMass, "kg")}</Badge>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Ladders */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <LadderChart title="Amplification Ladder (Power chain)" unit="J"
          data={ladderPower} />
        <LadderChart title="Amplification Ladder (Mass chain energy per tile)" unit="J"
          data={ladderMass} />
      </div>

      {/* Power & mass cross-checks */}
      <Card className="bg-slate-900/40 border-slate-800">
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-slate-100"><ShieldCheck className="w-5 h-5"/> Pipeline cross-checks</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-3 gap-4 text-slate-200">
          <div className="space-y-1">
            <div className="text-xs text-slate-400 mb-1">Ship power</div>
            <div className="text-sm">calc: {fmtNum(derived?.P_ship_avg_calc_MW, "MW")}</div>
            <div className="text-sm">report: {fmtNum(derived?.P_ship_avg_report_MW, "MW")}</div>
            <div className="text-xs text-slate-400">calc uses: P_tile = |U_Q|·ω/Q, P_ship = P_tile·N·d_eff</div>
          </div>
          <div className="space-y-1">
            <div className="text-xs text-slate-400 mb-1">Exotic mass</div>
            <div className="text-sm">calc: {fmtNum(derived?.M_total_calc, "kg")}</div>
            <div className="text-sm">report: {fmtNum(derived?.M_total_report, "kg")}</div>
            <div className="text-xs text-slate-400">calc uses: E_tile = |U_static|·γ³·Q·γ_VdB·d_eff; M = E_total/c²</div>
          </div>
          <div className="space-y-1">
            <div className="text-xs text-slate-400 mb-1">Timing</div>
            <div className="text-sm">ω = 2π·f = {fmtNum(derived?.omega, "rad/s")}</div>
            <div className="text-sm">d_eff = {fmtNum(derived?.d_eff)}</div>
            <div className="text-xs text-slate-400">d_eff comes from HELIX-CORE (sector-aware)</div>
          </div>
        </CardContent>
      </Card>

      {/* Field heatmap */}
      <DisplacementHeatmap endpoint={fieldEndpoint} />

      {/* Footnote */}
      <p className="text-xs text-slate-500 text-center">
        Display values are derived from the live backend state. Negative Casimir energy is displayed as magnitudes for clarity; signs are preserved in equations.
      </p>
    </div>
  );
}

function Stat({ label, value, icon }: { label: string; value: string; icon?: React.ReactNode }) {
  return (
    <div className="rounded-2xl bg-slate-800/40 border border-slate-700 px-3 py-2 flex items-center gap-2">
      {icon}
      <div>
        <div className="text-xs text-slate-400">{label}</div>
        <div className="text-slate-100 font-medium">{value}</div>
      </div>
    </div>
  );
}

function StatSmall({ label, value }: { label: string; value: string }) {
  return (
    <div className="rounded-xl bg-slate-800/40 border border-slate-700 px-3 py-2">
      <div className="text-[10px] text-slate-400">{label}</div>
      <div className="text-slate-100 text-sm font-medium">{value}</div>
    </div>
  );
}
