1) Compute a slice mass fraction for REAL

In WarpRenderInspector.tsx, derive a slice band coverage (how much of the wall thickness your slice covers) and combine it with the sector fraction:

// after you compute sTotal etc.
const wallWidth_m      = N(props.baseShared?.wallWidth_m ?? live?.hull?.wallThickness_m, 1.0);
// let callers optionally provide a thinner analytical slice (else assume full wall)
const sliceThickness_m = N(props.baseShared?.sliceThickness_m, wallWidth_m);

// 0..1 of the wall band covered by the slice grid
const bandCover = Math.max(0, Math.min(1, sliceThickness_m / Math.max(1e-9, wallWidth_m)));

// sector (azimuthal) fraction already represented by REAL's “one pane”
const sectorFrac = 1 / Math.max(1, sTotal);

// final view mass fraction for REAL’s diagnostics & proxies
const viewMassFracREAL = sectorFrac * bandCover;


Use it in two places:

Uniforms you send to the REAL engine:

gatedUpdateUniforms(leftEngine.current, {
  ...shared,
  physicsParityMode: true,
  viewMassFraction: viewMassFracREAL,
}, 'inspector-real');


Pane overlay for REAL (so mass proxy keeps using the same fraction):

<PaneOverlay title="REAL · per-pane slice" flavor="REAL" engineRef={leftEngine} viewFraction={viewMassFracREAL}/>


SHOW stays at viewFraction={1} (whole ship).

2) Show pane-scaled curvature in the overlay (UI-only)

In PaneOverlay (where you read diagnostics):

const f = (flavor === 'REAL') ? Math.max(1e-12, viewFraction) : 1;

// previously:
const frontMax = diag.theta_front_max, rearMin = diag.theta_rear_min;

// display-only pane scaling: keep mass law correct (θ²·V·f) and show reduced curvature
const frontShown = Number.isFinite(frontMax) ? frontMax * Math.sqrt(f) : frontMax;
const rearShown  = Number.isFinite(rearMin)  ? rearMin  * Math.sqrt(f)  : rearMin;

setSnap({
  // ...
  frontMax: frontShown,
  rearMin:  rearShown,
});


You don’t change theta (the engine’s θ-scale) or any rendering gain — only the numbers reported in the REAL overlay are reduced by √f. SHOW remains unchanged.

Mass proxy already includes viewFraction, so it will continue to read lower on REAL without double counting.