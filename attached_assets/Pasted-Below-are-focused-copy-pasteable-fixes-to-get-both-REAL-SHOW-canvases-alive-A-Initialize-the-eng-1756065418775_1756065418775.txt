Below are focused, copy-pasteable fixes to get both REAL/SHOW canvases alive.

A) Initialize the engines in WarpBubbleCompare.tsx

Add a mount effect that:

ensures the global engine is loaded,

creates one engine per canvas,

sizes the canvas & sets viewport,

waits until the program + buffers exist,

applies safe uniforms,

starts the render loop,

and cleans up.

// near imports
import { useEffect, useRef } from "react";

// inside component (you already have these)
const leftRef = useRef<HTMLCanvasElement>(null);
const rightRef = useRef<HTMLCanvasElement>(null);
const leftEngine = useRef<any>(null);
const rightEngine = useRef<any>(null);

// helper
const sizeCanvas = (cv: HTMLCanvasElement) => {
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const r = cv.getBoundingClientRect();
  const w = Math.max(1, Math.floor(r.width * dpr));
  const h = Math.max(1, Math.floor(r.height * dpr));
  if (cv.width !== w || cv.height !== h) { cv.width = w; cv.height = h; }
  return { w, h };
};

useEffect(() => {
  const W = (window as any).WarpEngine;
  if (!leftRef.current || !rightRef.current) return;
  if (!W) { console.error("[Warp] window.WarpEngine not loaded"); return; }

  // idempotent cleanup if StrictMode remounts
  const kill = (ref: any) => {
    const s = ref.current;
    if (!s) return;
    s.stop?.(); s.dispose?.();
    ref.current = null;
  };
  kill(leftEngine); kill(rightEngine);

  const initOne = async (cv: HTMLCanvasElement, parityPhys: boolean) => {
    const eng = new W(cv);                // ctor creates gl & initial grid
    const { w, h } = sizeCanvas(cv);
    eng.gl.viewport(0, 0, w, h);
    // wait until grid program + buffers exist (async path safe)
    await new Promise<void>((resolve) => {
      const tick = () => {
        if (eng.gridProgram && eng.gridVbo && eng._vboBytes > 0) return resolve();
        requestAnimationFrame(tick);
      };
      tick();
    });

    // defensive, physics-safe defaults (prevents “θ-scale — invalid” & “ridge undefined”)
    const sectorsTotal = Math.max(1, +parameters?.sectorCount || +parameters?.sectors || 1);
    const dutyFR = Number.isFinite(parameters?.dutyEffectiveFR)
      ? Math.max(1e-12, +parameters.dutyEffectiveFR)
      : Math.max(1e-12, (+parameters?.dutyCycle || 0.14) / sectorsTotal);
    const thetaScale =
      Math.pow(+parameters?.gammaGeo || 26, 3) *
      (+parameters?.qSpoilingFactor || 1) *
      (+parameters?.gammaVanDenBroeck || 2.86e5) *
      Math.sqrt(dutyFR);

    eng.setParameters?.({
      thetaScale: Number.isFinite(thetaScale) && thetaScale > 0 ? thetaScale : 5.03e3,
      physicsParityMode: !!parityPhys, // REAL=true, SHOW=false
      ridgeMode: 1,
      colorMode: "theta",
      viewAvg: true,
      sectorCount: sectorsTotal,
      split: Math.max(0, (+parameters?.split | 0) % sectorsTotal),
    });

    // start loop & resize observer
    eng.start?.();
    const ro = new ResizeObserver(() => {
      const { w, h } = sizeCanvas(cv);
      eng.gl.viewport(0, 0, w, h);
      eng.resize?.(w, h);
    });
    ro.observe(cv);
    eng.__ro = ro;
    eng.isLoaded = true;                  // satisfies “Engine ready — isLoaded=true”
    return eng;
  };

  (async () => {
    leftEngine.current  = await initOne(leftRef.current!,  /*REAL*/ true);
    rightEngine.current = await initOne(rightRef.current!, /*SHOW*/ false);
  })();

  return () => {
    for (const ref of [leftEngine, rightEngine]) {
      const s = ref.current;
      if (!s) continue;
      s.__ro?.disconnect?.();
      s.stop?.();
      s.dispose?.();
      ref.current = null;
    }
  };
  // re-init only when canvases or the engine script changes
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [leftRef.current, rightRef.current]);


Also make sure the engine file is actually loaded in your HTML shell:

<!-- index.html (or _document) -->
<script src="/warp-engine.js" defer></script>