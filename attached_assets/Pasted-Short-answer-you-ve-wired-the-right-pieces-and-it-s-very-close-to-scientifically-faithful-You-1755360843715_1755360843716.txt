Short answer: youâ€™ve wired the right pieces, and itâ€™s *very close* to â€œscientifically faithful.â€ Your server is the source of truth for the needle hull (1007Ã—264Ã—173 m â†’ semi-axes a=503.5, b=132, c=86.5), you pass those through `/api/helix/metrics` into `WarpVisualizer`, and your WebGL core computes an **ellipsoidal normalized radius** Ï with a smooth bell $B(\rho)$. Thatâ€™s exactly how the NatÃ¡rio bell should be driven.

Where to tighten it so â€œwhat you seeâ€ = â€œwhat the physics computesâ€:

---

## âœ… Whatâ€™s already correct

* **Ellipsoidal radius:** `rho = sqrt((x/a)^2 + (y/b)^2 + (z/c)^2)` â€” good.
* **Canonical bell:** a $C^\infty$ bump centered at Ï=1 â€” good.
* **Hull from physics:** values come from the pipeline (not hardcoded) â€” good.
* **TS (Ï„LC/Tm)** and geometry on server â€” aligned.

---

## âš ï¸ Likely drifts to remove

1. **Clip-space scaling magic numbers**
   You currently do:

   ```js
   const axesClip = [ a/1200, b/600, c/400 ];
   ```

   These divisors are arbitrary; they can distort the aspect ratio and decouple the renderer from physics. Prefer a **single scene scale** based on the long semi-axis:

   ```js
   // Keep aspect exact; just choose a global scene scale
   const s = 1.0 / (a);           // make long semi-axis ~1 scene unit
   const axesScene = [ a*s, b*s, c*s ];  // becomes [1, b/a, c/a]
   ```

   Then use `axesScene` everywhere you compute Ï. Camera framing handles how it fits on screen.

2. **Wall width mapping**
   `wallWidth = 0.06` is in *normalized Ï* units. Make sure that matches the *physical* wall thickness you assume in the pipeline (e.g., \~meters). A clean contract:

   * Server sends either `w_rho` (dimensionless, around 0.03â€“0.1) **or** a **physical** wall thickness `w_m`.
   * If itâ€™s physical, convert to Ï-space by dividing by **local radius scale** along the surface normal. For an ellipsoid, a good constant approximation is use the **harmonic mean** of (a,b,c):

     ```js
     const aH = 3 / (1/a + 1/b + 1/c);
     const w_rho = w_m / aH;  // simple, aspect-respecting
     ```

3. **Divergence-free check in the visual**
   Your NatÃ¡rio badge on the panel is â€œVALID,â€ but letâ€™s sanity-check the renderer: numerically estimate $\nabla\cdot\xi$ on a coarse grid (central differences) and show `max|âˆ‡Â·Î¾|` in a tiny overlay. It should be small and unaffected by re-scaling.

4. **Pocket gain Î³VdB shouldnâ€™t morph shape**
   The bell *shape* must not change with Î³VdB; only intensity/opacity of the deformation cue should respond. Ensure your shader uses Î³VdB to modulate *amplitude*, not the axes.

---

## ğŸ” Quick verification checklist (5 minutes)

* **Aspect test:** temporarily set (Lx,Ly,Lz) to (1000,1000,1000). Bubble renders spherical? Switch back to (1007,264,173) and itâ€™s stretched \~1:0.26:0.17? âœ”ï¸
* **Ï=1 contour:** draw a faint line/iso surface where `|Ïâˆ’1|<Îµ`. It should match the visual â€œwall.â€

  ```js
  const eps = 0.01;
  const onWall = Math.abs(rho-1.0) < eps ? 1.0 : 0.0;
  ```
* **Wall width:** halve `w_rho`; the ring visibly narrows. Double it; it thickens. âœ”ï¸
* **Mode changes:** switching hoverâ†’cruise alters intensity, **not** axes. âœ”ï¸
* **TS coupling:** changing f\_m server-side updates TS on panel; renderer *doesnâ€™t* change shape (correct). âœ”ï¸

---

## ğŸ§© Small, targeted code tweaks

**A) Replace per-axis magic divisors with a single scene scale**

```js
// from metrics or defaults
let a = hullAxes[0], b = hullAxes[1], c = hullAxes[2];

// choose a scene scale so the long semi-axis is 1
const sceneScale = 1.0 / a;
const axesScene = [ a*sceneScale, b*sceneScale, c*sceneScale ];

function rhoEllipsoidal(p) {
  const x = p[0], y = p[1], z = p[2];
  return Math.hypot(x/axesScene[0], y/axesScene[1], z/axesScene[2]);
}
```

**B) Keep wall width in Ï-space (or convert from meters once)**

```js
// if you receive w_m from server:
const aH = 3 / (1/a + 1/b + 1/c);
const w_rho = wallWidth_m / aH;

// if server already sends w_rho, just use it
function bell(rho) {
  const t = (rho - 1.0) / w_rho;
  return Math.exp(-t*t);
}
```

**C) Optional: numerical âˆ‡Â·Î¾ check overlay**

```js
// sample a small 3D lattice around the camera focus
// compute xi via your curl(A) construction, then:
function divXi(xi, p, h) {
  // central differences; xi = [Î¾x(x,y,z), Î¾y(...), Î¾z(...)]
  const dxi_dx = (xi(p+[h,0,0])[0] - xi(p+[-h,0,0])[0]) / (2*h);
  const dxi_dy = (xi(p+[0,h,0])[1] - xi(p+[0,-h,0])[1]) / (2*h);
  const dxi_dz = (xi(p+[0,0,h])[2] - xi(p+[0,0,-h])[2]) / (2*h);
  return dxi_dx + dxi_dy + dxi_dz;
}
// show max |divXi| as a tiny HUD number for sanity
```

---

## ğŸ›ï¸ Nice-to-have knobs (read-only from physics)

Expose these in `/api/helix/metrics` (you already have most):

* `hull: { Lx_m, Ly_m, Lz_m, a, b, c }`
* `wall: { w_rho }` (or `w_m`)
* `natario: { divMaxSampled }` (from the optional check)
* `amplitude: { P_avg_MW, gammaVdB, gammaGeo }` (purely for visual intensity, not shape)

---

### Bottom line

* **Yes**, your path and math are correct for an ellipsoidal NatÃ¡rio bell driven by real hull geometry.
* Swap the **magic divisors** for a single **scene scale**, keep **wall width** consistent, and (optionally) display a tiny $\max|\nabla\cdot\xi|$ to prove the field is divergence-free.
* With those adjustments, the bubble you *see* is the bubble your pipeline *flies*.
