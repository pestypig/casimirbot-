diff --git a/energy-pipeline.tsx b/energy-pipeline.tsx
--- a/energy-pipeline.tsx
+++ b/energy-pipeline.tsx
@@ -1,7 +1,7 @@
 /**
  * Energy Pipeline Display Component (aligned with Helix-Core)
  * Shares pipeline mode + FR duty with the rest of the app
- * + Green's-function (φ = G * ρ) stage with live stats and publish-to-renderer
+ * + Green's-function (φ = G · ρ) stage with live stats and publish-to-renderer
  */
 
@@ -... +... @@
-  // 2) Use any available client tiles from metrics (fallback - main Green's data comes from HelixCore hook now)
-  const clientTiles = useMemo(() => {
-    // NOTE: old builds only emitted `tiles`
-    const tiles = (systemMetrics as any)?.tiles;
-    if (!Array.isArray(tiles)) return undefined;
-    return tiles.map((t: any) => ({
-      pos: t.pos as Vec3,
-      t00: t.t00 || 0
-    }));
-  }, [systemMetrics]);
+  // 2) Use any available client tiles from metrics (server now emits `tileData`, legacy was `tiles`)
+  const clientTiles = useMemo(() => {
+    const tiles =
+      (systemMetrics as any)?.tileData ||
+      (systemMetrics as any)?.tiles;
+    if (!Array.isArray(tiles)) return undefined;
+    return tiles.map((t: any) => ({
+      pos: t.pos as Vec3,
+      t00: t.t00 || 0,
+    }));
+  }, [systemMetrics]);
 
@@ -... +... @@
-  // Compute or adopt φ (server wins)
-  const greenPhi = useMemo(() => {
-    if (serverGreens?.phi && (serverGreens.phi as any).length > 0) {
-      const arr = serverGreens.phi instanceof Float32Array
-        ? serverGreens.phi
-        : new Float32Array(serverGreens.phi);
-      return { phi: arr, source: "server" as const };
-    }
-    return { phi: new Float32Array(0), source: "none" as const };
-  }, [serverGreens]);
+  // Compute or adopt φ (server-provided wins; else derive from tiles)
+  const greenPhi = useMemo(() => {
+    // 1) Adopt server φ if present
+    if (serverGreens?.phi && (serverGreens.phi as any).length > 0) {
+      const arr = serverGreens.phi instanceof Float32Array
+        ? serverGreens.phi
+        : new Float32Array(serverGreens.phi);
+      return { phi: arr, source: "server" as const };
+    }
+    // 2) Otherwise, compute φ = G · ρ from tiles on the client
+    if (clientTiles && clientTiles.length > 0) {
+      const positions: Vec3[] = clientTiles.map(t => t.pos);
+      const rho: number[]   = clientTiles.map(t => t.t00);
+      const kernel = (greenKind === "helmholtz")
+        ? helmholtzKernel(Math.max(0, mHelm))
+        : poissonKernel;
+      const phi = computeGreenPotential(positi
