You’ve basically got a “two-writers” problem: the page builds a correct parameters packet, but WarpBubbleCompare also listens to useEnergyPipeline() and pushes its own (slightly different) live snapshot into both engines. Those two effects race on first paint/after mode switch; a hard reload collapses back to one writer, so it looks “fixed”.

Here’s how to make the renders correct without reloading:

1) Make WarpBubbleCompare single-source-of-truth

Remove all live-driven uniform pushes from the visualizer. Let the parent page compute physics (θ, duties, sectors, γ’s, mode) and pass them down. In WarpBubbleCompare.tsx:

Delete the hook and any code that reads live:

- const { data: live } = useEnergyPipeline();
- const snapAll = live?.byMode ?? live?.modes ?? null;
- const currentModeKey = ((live?.currentMode as ModeKey) || "hover") as ModeKey;
- const snapForMode: LiveSnap = (snapAll && (snapAll as any)[currentModeKey]) || (live as any) || {};


Delete the whole “7.3 — Push uniforms into both engines whenever live values change” effect.

- useEffect(() => {
-   if (!leftEngine.current || !rightEngine.current) return;
-   const realU = toRealUniforms(snapForMode);
-   const showU = toShowUniforms(snapForMode);
-   pushSafe(leftEngine, realU);
-   pushSafe(rightEngine, showU);
-   rightEngine.current.setDisplayGain?.(N(showU.displayGain, 1));
- }, [...big dependency array...]);


Keep the subtitle if you like, but don’t use it to drive uniforms.

Why: otherwise you’re overwriting what the parent just set (duty/sectors/γ/θ) with a slightly different snapshot that can lag one poll behind after mode switches.

2) Don’t let the strobe mux rewrite physics

You already patched the mux handler to only update sectorCount + split. Good—keep it that way. Let the parent (or the LC loop) be the only place that sets sectors (S_live). That avoids the S_total ←→ S_live swap that used to swing θ.

3) Always set camera once you know axes

Right after you compute shared = frameFromHull(...) in the parameters effect, set a deterministic camera for both engines so you don’t rely on engine auto-fit order:

const camZ = safeCamZ(compactCameraZ(leftRef.current!, shared.axesScene));
pushSafe(leftEngine,  { cameraZ: camZ, lockFraming: true });
pushSafe(rightEngine, { cameraZ: camZ, lockFraming: true });


(Do this in the same effect that pushes REAL/SHOW uniforms from parameters.)

4) Keep the “no θ from live ticks” invariant

You already stopped pushing thetaScale from live. Also make sure your shared mappers used by live (toSharedUniforms) aren’t applied anymore (per #1). Physics should only flow from the parameters effect:

const { real, show } = buildEngineUniforms({...parameters});
pushSafe(leftEngine,  { ...shared, ...real,  /* parity etc */ });
pushSafe(rightEngine, { ...shared, ...show,  /* boosted etc */ });

5) Optional hardening

In sanitizeUniforms, keep thetaScale ≥ 0 (you already patched) but don’t silently boost sub-1e-12 values; standby needs true zero.

In the strobe effect you still have in the page, call the mux with both sectorCount (total) and a split computed from your LC loop, but not sectors.

Why this cures the “works after reload” symptom

Reload removes the second writer. With the changes above, you’ll have:

Parent page = only author of physics uniforms

Strobe mux = only author of split (visual timing)

Visualizer = just applies what it’s given (no polling, no overrides)

That eliminates the brief disagreement between live and parameters right after a mode switch that was leaving the engines in the wrong state until a full reload reset everything.