⚠️ Small adjustments I recommend

Use the safe camera Z everywhere
You defined safeCamZ, but applyReal, applyShow, and the ResizeObserver still feed raw compactCameraZ(...). That can slip NaN/0 through on first layout.

Patch:

// in applyReal
const camZ = safeCamZ(compactCameraZ(canvas, shared.axesScene));
pushUniformsWhenReady(e, { ...shared, cameraZ: camZ, lockFraming: true, /* ... */ });

// in applyShow
const camZ = safeCamZ(compactCameraZ(canvas, shared.axesScene));
pushUniformsWhenReady(e, { ...shared, cameraZ: camZ, lockFraming: true, /* ... */ });

// in ResizeObserver
const camL = safeCamZ(compactCameraZ(L, fresh.axesScene));
const camR = safeCamZ(compactCameraZ(R, fresh.axesScene));


Pass both sector numbers from HelixCore
Your Agent calculated them but I didn’t see the final prop wiring. Ensure this ends up in the parameters you send:

<WarpBubbleCompare
  parameters={{
    ...compareParams,
    sectorCount: totalSectors,      // averaging base (≈400)
    sectors: concurrentSectors,     // sweep concurrency (1..2)
    dutyEffectiveFR,                // FR duty
    dutyCycle: dutyUI,              // UI duty
    viewAvg: true,
    colorMode: 'theta',
    lockFraming: true,
  }}
  parityExaggeration={1}
  heroExaggeration={82}
/>


applyShowSafe payload shape
Right now you call:

applyShow(rightEngine.current, shared, R, showPayload.colorMode, showPayload);
applyShowSafe(rightEngine.current, showPayload);


showPayload (with T, boostMax, decades) is perfect for applyShow’s opts, but not ideal for applyShowSafe, which expects a uniforms object. Two easy fixes:

Simpler: keep as-is (it won’t crash; extra keys are ignored), because applyShowSafe immediately pushes its own fallback uniforms if black.

Cleaner (preferred): change applyShowSafe to accept {opts, shared, canvas, colorMode} and compute the same uniforms that applyShow would, then apply the fallback.

Busy guard scope
Your return is inside catch { return } but finally still runs (good). Just a heads-up: if you ever spawn two WarpBubbleCompare instances on a page, a global __warpCompareBusy might block the second one. If that’s a possibility, switch to an instance-scoped flag (e.g., a useRef<boolean>(false)).

Log bad physics early
Add a quick guard after computing physics (helps catch silent NaNs that produce black):

const warnIfBad = (tag:string, phys:any) => {
  if (!Number.isFinite(phys?.thetaScale) || phys.thetaScale <= 0) {
    console.warn(`[WARP DEBUG] ${tag} bad thetaScale:`, phys?.thetaScale, phys);
  }
};
warnIfBad('REAL', parityPhys);
warnIfBad('SHOW', showPhys);