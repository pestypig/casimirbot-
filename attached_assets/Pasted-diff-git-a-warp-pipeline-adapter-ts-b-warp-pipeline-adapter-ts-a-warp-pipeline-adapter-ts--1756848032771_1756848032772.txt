diff --git a/warp-pipeline-adapter.ts b/warp-pipeline-adapter.ts
--- a/warp-pipeline-adapter.ts
+++ b/warp-pipeline-adapter.ts
@@ -1,8 +1,14 @@
 // Pipeline → WarpEngine Adapter
 // Drives renderer uniforms from pipeline state (single source of truth, strict; no fallbacks)
 
-import type { GreensPayload, HelixMetrics, EnergyPipelineState } from "@/hooks/use-energy-pipeline";
+import type { GreensPayload, HelixMetrics, EnergyPipelineState } from "@/hooks/use-energy-pipeline";
 
+// Optional Natário-esque tensor inputs (pass-through; no defaults here)
+export type NatarioTensorOpts = {
+  lapseN?: number;                           // N
+  shiftBeta?: [number,number,number];        // β^i
+  gSpatialSym?: [number,number,number,number,number,number]; // gxx,gyy,gzz,gxy,gyz,gzx
+};
+
 function aHarmonic(ax: number, ay: number, az: number) {
   const a = +ax || 0, b = +ay || 0, c = +az || 0;
   const d = (a>0?1/a:0) + (b>0?1/b:0) + (c>0?1/c:0);
@@ -11,10 +17,11 @@ function req(cond: any, msg: string) {
   if (!cond) throw new Error(`adapter: ${msg}`);
 }
 
-export type DriveMetricOpts = {
+export type DriveMetricOpts = {
   // Optional conformal metric inputs (Commit B)
   greens?: GreensPayload;   // φ samples; when present with kappa → metricMode
   metricKappa?: number;     // required to enable metric
+  natario?: NatarioTensorOpts; // optional 3+1 tensors (pass-through)
   // Hooks-fed helpers (no defaults in adapter)
   metrics?: HelixMetrics;   // from use-metrics (for hull)
   wallWidth_m?: number;     // from useLightCrossingLoop or explicit UI
@@ -76,6 +83,15 @@ export function driveWarpFromPipeline(
   if (opts?.greens && Number.isFinite(opts?.metricKappa)) {
     const φ = opts.greens.phi; if (φ && φ.length>0) {
       let sum = 0; for (let i=0;i<φ.length;i++) sum += φ[i];
       const φ̄ = sum / φ.length; const κ = Number(opts.metricKappa);
       const c = 1 + κ*φ̄; gSpatialDiag = [c,c,c]; metricMode = true;
     }
   }
+  // Optional: full symmetric spatial metric, lapse, shift (wins over diag if provided)
+  let gSpatialSym: [number,number,number,number,number,number] | undefined;
+  let lapseN: number | undefined;
+  let shiftBeta: [number,number,number] | undefined;
+  if (opts?.natario) {
+    if (Array.isArray(opts.natario.gSpatialSym) && opts.natario.gSpatialSym.length>=6) gSpatialSym = opts.natario.gSpatialSym.map(Number) as any;
+    if (Number.isFinite(opts.natario.lapseN)) lapseN = Number(opts.natario.lapseN);
+    if (Array.isArray(opts.natario.shiftBeta) && opts.natario.shiftBeta.length>=3) shiftBeta = opts.natario.shiftBeta.map(Number) as any;
+  }
 
   gatedUpdateUniforms(engine, {
     strictPhysics: true,
@@ -84,6 +100,10 @@ export function driveWarpFromPipeline(
     ...(gSpatialDiag ? { gSpatialDiag } : {}),
+    ...(gSpatialSym ?  { gSpatialSym }  : {}),
+    ...(Number.isFinite(lapseN) ? { lapseN } : {}),
+    ...(shiftBeta ? { shiftBeta } : {}),
     axesHull,
     // keep axesScene derived in engine
     wallWidth: w_rho,
     wallWidth_rho: w_rho,
     wallWidth_m: w_m,