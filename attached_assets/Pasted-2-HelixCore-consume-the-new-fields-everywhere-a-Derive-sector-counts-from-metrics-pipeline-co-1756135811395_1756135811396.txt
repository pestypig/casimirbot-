2) HelixCore: consume the new fields everywhere
a) Derive sector counts from metrics → pipeline → config
// pick from metrics when present; otherwise pipeline; otherwise config
const modeCfg = MODE_CONFIGS[pipeline?.currentMode || effectiveMode] || MODE_CONFIGS.hover;

const totalSectors = useMemo(() => {
  const fromMetrics = Number(systemMetrics?.totalSectors);
  if (Number.isFinite(fromMetrics) && fromMetrics! > 0) return Math.floor(fromMetrics!);
  const fromPipeline = Number((pipeline as any)?.sectorsTotal);
  if (Number.isFinite(fromPipeline) && fromPipeline! > 0) return Math.floor(fromPipeline!);
  return modeCfg.sectorsTotal; // ← new
}, [systemMetrics?.totalSectors, (pipeline as any)?.sectorsTotal, modeCfg.sectorsTotal]);

const concurrentSectors = useMemo(() => {
  const fromMetrics = Number(systemMetrics?.sectorStrobing);
  if (Number.isFinite(fromMetrics) && fromMetrics! > 0) return Math.floor(fromMetrics!);
  const fromPipeline = Number((pipeline as any)?.sectorsConcurrent ?? pipeline?.sectorStrobing);
  if (Number.isFinite(fromPipeline) && fromPipeline! > 0) return Math.floor(fromPipeline!);
  return modeCfg.sectorsConcurrent; // ← new
}, [systemMetrics?.sectorStrobing, (pipeline as any)?.sectorsConcurrent, pipeline?.sectorStrobing, modeCfg.sectorsConcurrent]);

// keep for legacy display text if needed
const sectorsUI = concurrentSectors;

b) Pass the total sector count and mode burst into the loop
const lc = useLightCrossingLoop({
-  sectorStrobing: concurrentSectors,   // ❌ this was the bug
+  sectorStrobing: totalSectors,        // ✅ total grid size
  currentSector: systemMetrics?.currentSector ?? 0,
  sectorPeriod_ms: systemMetrics?.sectorPeriod_ms ?? 1.0,
  duty: dutyUI,
  freqGHz: pipeline?.modulationFreq_GHz ?? 15,
  hull: { a: hull.a, b: hull.b, c: hull.c },
  wallWidth_m: 6.0,
+ localBurstFrac: MODE_CONFIGS[effectiveMode].localBurstFrac, // ✅ new
});

c) FR duty (unchanged code now yields mode-aware values)

You already compute:

const dutyEffectiveFR = useMemo(() => {
  const burst = Number(lc?.burst_ms);
  const dwell = Number(lc?.dwell_ms);
  const burstLocal = (Number.isFinite(burst) && Number.isFinite(dwell) && dwell > 0)
    ? burst / dwell
    : 0.01;

  const S_live  = Math.max(0, Math.floor(concurrentSectors ?? 1));
  const S_total = Math.max(1, Math.floor(totalSectors ?? 400));

  return clamp01(burstLocal * (S_live / S_total));
}, [lc?.burst_ms, lc?.dwell_ms, concurrentSectors, totalSectors]);


With localBurstFrac + correct totalSectors, this will now vary strongly across modes (and be 0 in Standby).

d) Feed the same knobs into visualizers & tiles

You’re already passing totalSectors, concurrentSectors, and dutyEffectiveFR_safe into:

WarpRenderInspector (baseShared)

WarpBubbleCompare (when enabled)

SliceViewer

ResonanceSchedulerTile

HelixCasimirAmplifier

useActiveTiles (good)

Just add a key on the inspector so it rebinds on mode change: