You’ve got two sneaky conflicts that keep resurrecting the mismatch:

1. The **gate is renaming uniforms to the wrong shader names** (`uPhysicsParity`, `uRidgeMode`, …) while the shader expects underscored names (`u_physicsParityMode`, `u_ridgeMode`, …). That’s why REAL keeps reading `parity=false`.&#x20;

2. The **pipeline adapter is baking θ with the wrong duty math** (puts `qSpoilingFactor` inside duty and then divides by sectors *again*), and it also **overrides the engine** by pushing that θ directly. &#x20;

3. The **UI normalizer derives θ linearly in duty** instead of √(d\_FR), which poisons “expected” paths and comparisons. &#x20;

Below are tight diffs that fix all three at the source.

---

### 1) Fix the gate → shader mapping and default duty exponent (√ when view-averaged)

```diff
*** a/src/lib/warp-uniforms-gate.ts
--- b/src/lib/warp-uniforms-gate.ts
@@
-const CANON = {
-  physicsParityMode: 'uPhysicsParity',
-  ridgeMode:         'uRidgeMode',
-  epsilonTilt:       'uEpsilonTilt',
-  betaTiltVec:       'uBetaTiltVec'
-} as const;
+// Match shader uniform names exactly (underscored)
+const CANON = {
+  physicsParityMode: 'u_physicsParityMode',
+  ridgeMode:         'u_ridgeMode',
+  epsilonTilt:       'u_epsilonTilt',
+  betaTiltVec:       'u_betaTiltVec'
+} as const;
@@
-  // Duty exponent (physics default = 1.0). Viz can request sqrt(·) via thetaDutyExponent or __vizDutySqrt
-  const dutyExp = Number.isFinite(+u.thetaDutyExponent)
-    ? +u.thetaDutyExponent
-    : (u.__vizDutySqrt ? 0.5 : 1.0);
+  // Duty exponent: when view-averaged, default to √(d_FR)
+  const dutyExp = Number.isFinite(+u.thetaDutyExponent)
+    ? +u.thetaDutyExponent
+    : ((u.__vizDutySqrt || (u.viewAvg ?? true)) ? 0.5 : 1.0);
```

Why this matters: the gate was writing the *wrong* uniform keys, so the engine never saw your parity lock; and θ was being built with **linear** duty by default instead of √ when averaging is on. The mapping fix aligns with the shader’s `u_physicsParityMode`/`u_ridgeMode` names, and the exponent fix aligns math with your checkpoints. &#x20;

---

### 2) Fix pipeline duty/θ and stop overriding θ in the renderer

```diff
*** a/src/lib/warp-pipeline-adapter.ts
--- b/src/lib/warp-pipeline-adapter.ts
@@
-  let d_ship =
+  let d_ship =
     num(s.dutyEffective_FR) ??
     num(s.dutyShip) ??
     (() => {
       const d_ui = clamp(s.dutyCycle ?? 0.14, 0, 1);
-      const strobe = Math.max(1, num(s.sectorStrobing) ?? sectorsTotal);
-      const qSpoil = Math.max(1e-12, num(s.qSpoilingFactor) ?? 1);
-      // HELIX effective duty ≈ UI duty × qSpoiling × (1 / sectors)
-      return clamp((d_ui * qSpoil) / strobe, 0, 1);
+      const strobe = Math.max(1, num(s.sectorStrobing) ?? sectorsTotal);
+      // FR duty is ship-wide time-average per total sectors (do NOT include q here)
+      return clamp(d_ui / strobe, 0, 1);
     })();
@@
-  const thetaScale =
-    Math.pow(gammaGeo, 3) *
-    qSpoil *
-    gammaVdB *
-    Math.max(1e-12, d_ship / sectorsTotal);
+  // Let the gate/engine compute authoritative θ. Provide only an audit value.
+  const thetaScaleExpected =
+    Math.pow(gammaGeo, 3) *
+    qSpoil *
+    gammaVdB *
+    Math.sqrt(Math.max(1e-12, d_ship));
@@
-      // Unified amplitude with qSpoiling included
-      thetaScale,
+      // Audit-only; do not override engine θ
+      thetaScaleExpected,
```

This removes the “q inside duty” double-count, stops the *second* divide by sectors, switches to √(d\_FR), and **stops pushing θ** as an authoritative uniform (the gate prefers a provided θ and will override the chain otherwise).  &#x20;

---

### 3) Make UI normalization consistent with √(d\_FR)

```diff
*** a/src/lib/warp-uniforms.ts
--- b/src/lib/warp-uniforms.ts
@@
-      thetaScale: dutyEffectiveFR * Math.pow(gammaGeo,3) * q * gammaVdB,
+      thetaScale: Math.sqrt(dutyEffectiveFR) * Math.pow(gammaGeo,3) * q * gammaVdB,
@@
-  const thetaScale = Number.isFinite(+raw.thetaScale)
-    ? +raw.thetaScale
-    : (dutyEffectiveFR * Math.pow(gammaGeo,3) * q_canonical * gammaVdB);
+  const thetaScale = Number.isFinite(+raw.thetaScale)
+    ? +raw.thetaScale
+    : (Math.sqrt(dutyEffectiveFR) * Math.pow(gammaGeo,3) * q_canonical * gammaVdB);
```

This aligns the UI’s derived θ with the checker’s “√ duty” expectation so your “expected vs uniforms” rows stop screaming. &#x20;

---

## What you should see after applying

* **Parity rows go green** (REAL shows `parity=true`, SHOW `false`) because the gate now writes the *actual* shader keys. You can also see the gate’s echo (`theta_dutyExp`) flip to `0.5` when `viewAvg=true`.&#x20;
* **θ (uniform) matches expected within a few %**, since no pipeline override is stomping the engine and all paths use √(d\_FR).

If anything still looks off, grab a quick console dump of `window.__warpEcho` (it already prints the exact θ inputs from the gate) and we’ll cross-check the specific term that’s drifting.&#x20;
