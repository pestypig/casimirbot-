Below is a drop-in fix for your compare component that:

sanitizes/derives framing once (same hull + same camera for both),

bootstraps each engine before any updates,

applies REAL (parity) and SHOW (boosted) configs separately,

avoids any null/undefined arrays getting passed through.

Patch for WarpBubbleCompare.tsx
// ==== helpers (top of file) ================================================

type Hull = { a:number; b:number; c:number };

// derive identical framing for both canvases, fully sanitized
const frameFromHull = (hull?: Partial<Hull>, gridSpan?: number) => {
  const a = Number.isFinite(hull?.a) ? Number(hull!.a) : 503.5;
  const b = Number.isFinite(hull?.b) ? Number(hull!.b) : 132.0;
  const c = Number.isFinite(hull?.c) ? Number(hull!.c) : 86.5;

  const s = 1 / 1200; // same scale the engine uses
  const axesScene: [number, number, number] = [a * s, b * s, c * s];

  const span = Number.isFinite(gridSpan)
    ? (gridSpan as number)
    : Math.max(2.6, Math.max(axesScene[0], axesScene[1], axesScene[2]) * 1.35);

  return {
    hullAxes: [a, b, c] as [number, number, number],
    axesScene,
    gridSpan: span,
  };
};

// prime/seed engine once so its internals are ready
const prime = (e: any, shared: ReturnType<typeof frameFromHull>) => {
  // bootstrap calls updateUniforms internally—this guarantees axesClip etc. exist
  e.bootstrap?.({ ...shared, colorMode: 'theta' });
};

// REAL = physics parity (no boosts/cosmetics), same framing
const applyReal = (e: any, shared: ReturnType<typeof frameFromHull>) => {
  prime(e, shared);
  e.updateUniforms({
    ...shared,
    lockFraming: true,

    physicsParityMode: true,   // <- the key bit
    colorMode: 'theta',
    vizGain: 1,
    displayGain: 1,
    curvatureBoostMax: 1,
    curvatureGainT: 0,
    userGain: 1,
    exposure: 3.5,
    zeroStop: 1e-5,

    // keep baseline perfectly neutral inside
    epsilonTilt: 0,
    betaTiltVec: [0, 0, 0],
  });
  e.requestRewarp?.();
};

// SHOW = boosted/exaggerated, same framing
const applyShow = (
  e: any,
  shared: ReturnType<typeof frameFromHull>,
  T = 0.55,                     // 0..1 (slider)
  boostMax = 40,                // ≥1
  vizGain = 1.0,
  exposure = 6.0,
  zeroStop = 1e-7
) => {
  prime(e, shared);
  e.updateUniforms({
    ...shared,
    lockFraming: true,

    physicsParityMode: false,
    colorMode: 'theta',

    curvatureGainT: Math.max(0, Math.min(1, T)),
    curvatureBoostMax: Math.max(1, boostMax),
    displayGain: 1 + Math.max(0, Math.min(1, T)) * (Math.max(1, boostMax) - 1),

    vizGain,
    exposure,
    zeroStop,
    cosmeticLevel: 10,
  });
  e.requestRewarp?.();
};


Use them right after you construct both engines (and not before):

// after:
//   const WarpCtor = (window as any).WarpEngine?.default ?? (window as any).WarpEngine;
//   leftEngine.current  = new WarpCtor(leftRef.current);
//   rightEngine.current = new WarpCtor(rightRef.current);

const shared = frameFromHull(props?.hull, props?.gridSpan);

// neutralize any global demo controls so they don't cross-wire the pair
(window as any).__warp_setGainDec = () => {};
(window as any).__warp_setCosmetic = () => {};

// wait one tick so GL resources are alive, then configure both sides
requestAnimationFrame(() => {
  applyReal(leftEngine.current, shared);
  applyShow(
    rightEngine.current,
    shared,
    props?.viz?.curvatureGainT ?? 0.55,
    props?.viz?.curvatureBoostMax ?? 40,
    1.0,
    props?.viz?.exposure ?? 6.0,
    props?.viz?.zeroStop ?? 1e-7
  );
});


And on prop changes, update each side independently (don’t run both through a shared adapter that reintroduces boosts to the REAL side):

useEffect(() => {
  if (!leftEngine.current || !rightEngine.current) return;
  const shared = frameFromHull(props?.hull, props?.gridSpan);

  applyReal(leftEngine.current, shared);

  applyShow(
    rightEngine.current,
    shared,
    props?.viz?.curvatureGainT ?? 0.55,
    props?.viz?.curvatureBoostMax ?? 40,
    1.0,
    props?.viz?.exposure ?? 6.0,
    props?.viz?.zeroStop ?? 1e-7
  );
}, [
  props?.hull?.a, props?.hull?.b, props?.hull?.c,
  props?.gridSpan,
  props?.viz?.curvatureGainT,
  props?.viz?.curvatureBoostMax,
  props?.viz?.exposure,
  props?.viz?.zeroStop
]);