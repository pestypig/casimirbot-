Overall: solid foundation. You’re instantiating each engine once, pushing payloads after link, and mirroring the dual REAL/SHOW pattern correctly. A few small things will make it rock-solid and also prevent a couple of sneaky edge cases.

What’s good

Dual-pane boot/updates mirror WarpBubbleCompare (✅).

pushUniformsWhenReady prevents pre-link pushes (✅).

Mode presets make SHOW changes visually obvious (✅).

Diagnostics wiring + strobing listener (✅).

Fix/Improve (quick wins)

Don’t seed hullAxes: [1,1,1] in shared.
If calculator props don’t supply a hull immediately, that [1,1,1] can override real meters and collapse the fit. Let the engine derive axes from hull (meters) instead.

Keep REAL “pure”: ignore userGain for parity.
You currently send userGain to both panes; for apples-to-apples, clamp REAL to 1.

Initial camera + DPR sizing.
Set the canvas’ pixel size to match CSS (DPR aware), and nudge _resize() on mount + container resize. Avoids soft-blur/black bands.

Optional: use setDisplayGain for SHOW.
You already set the uniform, but calling the helper keeps it consistent with other panels.

Tiny safety: sanitize a couple of uniforms.
(e.g., sectors, split, exposure, zeroStop) before pushing.

Small patch (minimal diff)
@@
   const shared = useMemo(() => ({
     colorMode,
     ridgeMode,
     lockFraming: true,
     hull: { a: 503.5, b: 132, c: 86.5 }, // default hull
-    hullAxes: [1, 1, 1],
     gridSpan: 2.6,
     sectors: 400,
     split: 0,
     ...props.baseShared,
   }), [props.baseShared, colorMode, ridgeMode]);
@@
   const realPayload = useMemo(() => {
     const p = props.parityPhys || {};
     return {
       ...shared,
       // geometry
       hull: p.hull || p.hullDims || shared.hull,
       hullAxes: p.hullAxes || undefined, // let engine derive from hull if absent
       gridSpan: p.gridSpan ?? shared.gridSpan,
@@
-      userGain: Math.max(1, userGain),
+      userGain: 1, // keep REAL parity visually “true”
       currentMode: mode,
     };
   }, [props.parityPhys, shared, userGain, mode]);
@@
   useEffect(() => {
     const W: any = (window as any).WarpEngine;
     if (!W) { console.error("WarpEngine not found on window. Load warp-engine.js first."); return; }
-    if (leftRef.current && !leftEngine.current)  leftEngine.current  = new W(leftRef.current);
-    if (rightRef.current && !rightEngine.current) rightEngine.current = new W(rightRef.current);
+    if (leftRef.current && !leftEngine.current)  {
+      // DPR-safe size before GL init
+      const dpr = Math.min(2, window.devicePixelRatio || 1);
+      leftRef.current.width  = Math.max(1, Math.floor((leftRef.current.clientWidth  || 800) * dpr));
+      leftRef.current.height = Math.max(1, Math.floor((leftRef.current.clientHeight || 450) * dpr));
+      leftEngine.current  = new W(leftRef.current);
+    }
+    if (rightRef.current && !rightEngine.current) {
+      const dpr = Math.min(2, window.devicePixelRatio || 1);
+      rightRef.current.width  = Math.max(1, Math.floor((rightRef.current.clientWidth  || 800) * dpr));
+      rightRef.current.height = Math.max(1, Math.floor((rightRef.current.clientHeight || 450) * dpr));
+      rightEngine.current = new W(rightRef.current);
+    }
@@
-    // Bootstrap so the first frame fits correctly
-    leftEngine.current?.bootstrap({ ...realPayload });
-    rightEngine.current?.bootstrap({ ...showPayload });
+    // Bootstrap; fit camera after link using derived axes
+    leftEngine.current?.bootstrap({ ...realPayload });
+    rightEngine.current?.bootstrap({ ...showPayload });
+    leftEngine.current?.onceReady?.(() => {
+      const ax = leftEngine.current?.uniforms?.axesClip;
+      const cz = compactCameraZ(ax);
+      leftEngine.current.updateUniforms({ cameraZ: cz, lockFraming: true });
+    });
+    rightEngine.current?.onceReady?.(() => {
+      const ax = rightEngine.current?.uniforms?.axesClip;
+      const cz = compactCameraZ(ax);
+      rightEngine.current.updateUniforms({ cameraZ: cz, lockFraming: true });
+      // optional: mirror display gain through helper
+      const dg = Math.max(1, (showPayload as any)?.displayGain || 1);
+      rightEngine.current.setDisplayGain?.(dg);
+    });
@@
     return () => {
       try { leftEngine.current?.destroy(); } catch {}
       try { rightEngine.current?.destroy(); } catch {}
       leftEngine.current = null as any;
       rightEngine.current = null as any;
     };
   }, []);
@@
   useEffect(() => {
     if (!leftEngine.current || !rightEngine.current) return;
+    // sanitize a few hot-path values
+    const safe = (o:any)=>({
+      ...o,
+      sectors: Math.max(1, Math.floor(N(o.sectors, 1))),
+      split: Math.max(0, Math.floor(N(o.split, 0))),
+      exposure: Math.max(1, Math.min(12, N(o.exposure, 6))),
+      zeroStop: Math.max(1e-9, N(o.zeroStop, 1e-7)),
+    });
     // REAL
-    pushUniformsWhenReady(leftEngine.current, {
-      ...realPayload,
+    pushUniformsWhenReady(leftEngine.current, {
+      ...safe(realPayload),
       ridgeMode: 0,
       physicsParityMode: true,
     });
     // SHOW
-    pushUniformsWhenReady(rightEngine.current, {
-      ...showPayload,
+    pushUniformsWhenReady(rightEngine.current, {
+      ...safe(showPayload),
       ridgeMode: 1,
       physicsParityMode: false,
     });
@@
   }, [realPayload, showPayload, shared]);
@@
+  // Keep canvases crisp on container resize
+  useEffect(() => {
+    const ro = new ResizeObserver(() => {
+      const dpr = Math.min(2, window.devicePixelRatio || 1);
+      for (const c of [leftRef.current, rightRef.current]) {
+        if (!c) continue;
+        const w = Math.max(1, Math.floor((c.clientWidth  || 1) * dpr));
+        const h = Math.max(1, Math.floor((c.clientHeight || 1) * dpr));
+        if (c.width !== w || c.height !== h) { c.width = w; c.height = h; }
+      }
+      leftEngine.current?._resize?.();
+      rightEngine.current?._resize?.();
+    });
+    leftRef.current && ro.observe(leftRef.current);
+    rightRef.current && ro.observe(rightRef.current);
+    return () => ro.disconnect();
+  }, []);