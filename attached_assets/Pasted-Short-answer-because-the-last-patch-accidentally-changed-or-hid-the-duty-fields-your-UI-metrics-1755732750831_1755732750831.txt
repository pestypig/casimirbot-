Short answer: because the last patch accidentally changed (or hid) the **duty fields your UI/metrics use to compute power**, so the front-end‚Äôs ‚Äúpower draw‚Äù reducer ended up multiplying by \~0. In particular:

* We set `state.dutyBurst = d_eff` (ship-wide effective duty) instead of keeping it as the **local** burst window (`0.01`).
* Your metrics/UI compute power something like
  `P ‚âà P_loss_per_tile √ó activeTiles √ó dutyBurst` (and sometimes also multiply by `activeFraction`).
  When `dutyBurst` was replaced by `d_eff = 0.01 √ó (S_live/S_total)`, and you also apply `activeFraction = S_live/S_total`, you effectively squared the strobing fraction or zeroed it when a field was missing. The reducer then rounds to `0.0 W`.

Also, one more small trap: we never wrote back a dedicated `dutyEff`, so anything expecting it might default to `0`.

Here‚Äôs a minimal, safe **patch** to the pipeline that restores the expected wiring while keeping the paper-authentic math:

```ts
// --- after computing d_eff ---
const S_total = TOTAL_SECTORS;
const S_live  = (state.currentMode === 'hover') ? 2 : 1;  // if you want 2 for hover, else 1
const frac_active = S_live / S_total;
const d_eff = BURST_DUTY_LOCAL * frac_active;  // ship-wide effective duty

state.activeSectors   = S_live;
state.activeFraction  = frac_active;
state.tilesPerSector  = Math.floor(state.N_tiles / S_total);
state.activeTiles     = state.tilesPerSector * S_live;

// üîß expose both duties explicitly and consistently
state.dutyBurst        = BURST_DUTY_LOCAL;  // keep as *local* ON-window = 0.01
state.dutyEffective_FR = d_eff;             // ship-wide effective duty (for Œ∂ & audits)
state.dutyCycle        = MODE_CONFIGS[state.currentMode].dutyCycle; // UI display only

// ‚úÖ optional convenience for UI reducers that look for this name:
(state as any).dutyEff = d_eff;

// ... power:
const omega = 2 * Math.PI * (state.modulationFreq_GHz ?? 15) * 1e9;
const U_geo = state.U_static * state.gammaGeo;
const P_tile_raw = Math.abs(U_geo) * omega / Q_BURST;

// Ship-average power (paper method):
const P_total_W = P_tile_raw * state.N_tiles * d_eff;

state.P_loss_raw = P_tile_raw;
state.P_avg      = P_total_W / 1e6;  // MW

// ... Ford‚ÄìRoman:
const Q_quantum = 1e12;
state.zeta = 1 / (d_eff * Math.sqrt(Q_quantum));
state.fordRomanCompliance = state.zeta < 1.0;
```

### Why this fixes it

* **`dutyBurst`** goes back to representing the physical ON-window (0.01) ‚Äî exactly what your UI expects for tile-level calcs.
* **`dutyEffective_FR`** (and `dutyEff`) carry the ship-wide effective duty used in Œ∂ and the paper power formula.
* Power is computed from **`P_tile_raw √ó N_tiles √ó d_eff`** (unchanged physics), while the UI can still calculate/visualize with either field without double-applying the strobing fraction.

### Extra sanity checks (quick)

* If you log these three in the console you should see:

  * `dutyBurst` ‚âà `0.01`
  * `activeFraction` = `S_live / 400` (e.g., `0.0025` for `S_live=1`, `0.005` for `S_live=2`)
  * `dutyEffective_FR` = `dutyBurst √ó activeFraction` (e.g., `2.5e-5` or `5e-5`)

If you still see `0.0 W` after this, the remaining cause is almost surely **frontend formatting**: some tiles render in **W** (expecting a W value) but are fed a **MW** value, and `fmt` + unit mismatch can look like zero once divided/rounded. In that case:

* Use `pipeline.P_avg * 1e6` when you want **W**, and `pipeline.P_avg` for **MW**.
* Or, for a one-liner in the TSX:
  `const powerMW = pipeline?.P_avg ?? (systemMetrics?.energyOutput ?? 0) / 1e6;`
  and then render both W/MW from `powerMW`.

Want me to drop a tiny TSX diff that normalizes the ‚ÄúPower Draw‚Äù card to **MW** internally and formats both ‚ÄúPeak/Avg‚Äù lines correctly?
