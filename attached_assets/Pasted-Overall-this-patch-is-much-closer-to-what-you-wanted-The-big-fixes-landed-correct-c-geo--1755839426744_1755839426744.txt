Overall: this patch is **much** closer to what you wanted. The big fixes landed: correct ℏc, γ\_geo³ carried into stored energy, duty is ship-wide `d_eff = 0.01*(concurrent/400)`, and you now use `qCavity` in power/mass. A few small inconsistencies remain. Quick pass:

## ✅ Good fixes that are in place

* **ℏc constant:** `const HBAR_C = HBAR * C;` ✅
* **Stored-energy scaling:** `U_geo = U_static * gamma^3;` and power uses `U_Q`/`Q`. ✅
* **Duty logic:** `d_eff = BURST_DUTY_LOCAL * (concurrent / S_total);` with `S_total = 400`. ✅
* **qCavity wired:** You compute P and mass with `Q = state.qCavity ?? Q_BURST`. ✅
* **FR proxy:** `ζ = 0.84 * (d_ship / (0.01/400))` → baseline gives ζ≈0.84. ✅
* **TS metrics:** recomputed cleanly; conservative `TS_ratio = TS_long`. ✅
* **Audit self-correction:** P\_avg & M\_exotic consistency checks. ✅
* **Displacement sampler:** matches the renderer math; soft wall window & tanh clamp. ✅

## ⚠️ Minor nits / inconsistencies to consider

1. **Mode config naming can confuse “total vs concurrent” sectors.**

   * You correctly use **`MODE_POLICY.*.S_live`** for **concurrent** sectors (1/2/0).
   * But `MODE_CONFIGS.cruise.sectorStrobing = 400` suggests “concurrent=400” to a reader. Since you don’t use `sectorStrobing` for duty, it won’t break math—but it *looks* contradictory to `S_live: 1`.
     **Tweak:** either rename that field to `totalSectors: 400` (and keep using the constant 400 in the pipeline), or set `sectorStrobing: 1` in every mode and expose `TOTAL_SECTORS` elsewhere for UI.

2. **Wall thickness still 6.0 m.**
   Earlier notes suggested \~1.0 m as paper-authentic (0.3 booster + 0.5 lattice + 0.2 service). If you’re using this thickness anywhere for Natário/TS side checks, consider changing:

   ```ts
   wallThickness_m: 1.0
   ```

3. **Status threshold:**
   `else if (state.P_avg > 100 || state.zeta > 0.8) overallStatus='WARNING'`.
   Since `P_avg` is **MW**, that means >100 MW always warns—even if intentional (e.g., emergency 297.5 MW). If by design, fine; if not, raise the limit or key it on mode.

4. **Dev runtime assert message:**
   You changed targets to MW-scale W numbers (e.g., 83.3e6). The check:

   ```ts
   const isWatt = MODE_POLICY.standby.P_target_W === 0;
   if (!isWatt) console.warn("Power targets must be in watts.");
   ```

   This condition is always true; the warning will never fire. If you want a sanity check, compare non-standby targets to, say, `>= 1e3`.

5. **Exposing duties:**
   You set `state.__fr = { dutyInstant: d_eff, dutyEffectiveFR: d_eff, zeta_baseline: zeta0 }`. That’s fine; just ensure any consumer expecting `Q_quantum` or a differently named field is updated.

## Nice-to-have polish (optional)

* Default `strobeHz` to **1000** to match 1 ms macro-tick, unless you truly want 2000.
* Consider exporting `TOTAL_SECTORS` for the UI so you don’t leak a “400” magic number across layers.

If you make the small sector naming tweak and (optionally) the wall thickness + status threshold changes, you’re in great shape.
