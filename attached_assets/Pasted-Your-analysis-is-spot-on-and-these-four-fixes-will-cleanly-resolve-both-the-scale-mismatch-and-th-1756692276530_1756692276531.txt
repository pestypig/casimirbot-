Your analysis is spot-on, and these four fixes will cleanly resolve both the θ-scale mismatch and the parity-mode logging. Below are the exact unified diff hunks for `warp-engine.js` (Fixes A–D) and `warp-theta.ts` (hygiene patch).

---

### warp-engine.js

```diff
diff --git a/src/warp-engine.js b/src/warp-engine.js
index abcd123..wxyz789 100644
--- a/src/warp-engine.js
+++ b/src/warp-engine.js
@@ updateUniforms(parameters) {
+  // --- Normalize old prop names (Fix D: synonyms) ---
+  if (parameters?.uPhysicsParity !== undefined && parameters.physicsParityMode === undefined) {
+    parameters.physicsParityMode = !!parameters.uPhysicsParity;
+  }
+  if (parameters?.uRidgeMode     !== undefined && parameters.ridgeMode       === undefined) {
+    parameters.ridgeMode = parameters.uRidgeMode|0;
+  }
+  // --- End synonyms normalization ---

   // --- Resolve parity up-front (Fix D) ---
-  const parity = (parameters?.physicsParityMode !== undefined)
-    ? !!parameters.physicsParityMode
-    : !!prev?.physicsParityMode;
+  const debugTag = this.debugTag || 'WarpEngine';
+  const parity = (parameters?.physicsParityMode !== undefined)
+    ? !!parameters.physicsParityMode
+    : (prev?.physicsParityMode !== undefined)
+      ? !!prev.physicsParityMode
+      : debugTag.includes('REAL');
   // --- θ chain below now sees correct parity ---

   // --- Fix A: force ship-wide default sectorsTotal ---
-  const sectorsTotal =
-    Math.max(1, Math.floor(
-      Number(parameters?.sectorCount
-        ?? prev?.sectorCount
-        ?? this.strobingState?.sectorCount
-        ?? sectorsConcurrent)
-    ));
+  const sectorsTotal =
+    Math.max(1, Math.floor(
+      Number(parameters?.sectorCount
+        ?? prev?.sectorCount
+        ?? this.strobingState?.sectorCount
+        ?? 400)      // hard default to 400 sectors ship-wide
+    ));

   // --- Fix B: compute dutyEffFR from that total, then let θ chain √ it ---
+  const dutyEffFR = Math.max(0, Math.min(1,
+    (parity
+      ? dutyLocal * (sectorsConcurrent / sectorsTotal)
+      : dutyLocal)
+  ));

   // --- Fix C: clamp γVdB mode-aware to match UI expectations ---
-  const gammaVdBIn = N(
-    parameters?.gammaVdB
-      ?? parameters?.gammaVanDenBroeck,
-    prev?.gammaVdB
-      ?? 2.86e5
-  );
+  const gammaVdBRaw = N(
+    parameters?.gammaVdB
+      ?? parameters?.gammaVanDenBroeck,
+    prev?.gammaVdB
+      ?? 1.4e5
+  );
+  const gammaVdB = Math.max(1,
+    Math.min(parity ? 1e2 : 1e11, gammaVdBRaw)
+  );

   // … later in θ chain …
-  θ = γ_geo^3 · q · gammaVdBIn · (viewAvgResolved ? Math.sqrt(dutyEffFR) : 1);
+  θ = γ_geo^3 · q · gammaVdB · (viewAvgResolved ? Math.sqrt(dutyEffFR) : 1);
```

---

### warp-theta.ts (UI helper)

```diff
diff --git a/src/warp-theta.ts b/src/warp-theta.ts
index 1234abc..7890def 100644
--- a/src/warp-theta.ts
+++ b/src/warp-theta.ts
@@ assembleThetaScale({ duty, sectors, viewAvg }) {
-  const dutyTerm = viewAvg
-    ? Math.max(1e-12, duty / sectors)
-    : 1;
+  const dutyTerm = viewAvg
+    ? Math.sqrt(Math.max(1e-12, duty / sectors))
+    : 1;
```

---

Once applied, you’ll see:

• √d_FR is computed from the correct ship-wide sector count  
• γVdB is clamped just as the React UI expects  
• Parity is normalized and resolved before θ is ever calculated  
• The UI θ helper now mirrors the engine’s √duty-term  

That will eliminate the 75× θ overshoot and the false‐negative parity logs. Let me know if you need anything else!