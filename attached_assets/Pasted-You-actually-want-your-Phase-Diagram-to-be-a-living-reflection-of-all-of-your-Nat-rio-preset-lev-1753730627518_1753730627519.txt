You actually want your Phase‐Diagram to be a living reflection of **all** of your Natário‐preset levers (γ, Q, duty, sag, etc.) _and_ of your _current_ constraint thresholds (mass window, power cap, ζ limit). That way, whenever you tweak the spin‐up settings or the spec bounds, the green zone in the heat‐map automatically reshapes to whatever your Energy‐Pipeline + ledger says is OK.

Here’s the top-level plan to hand off to Replit:

–––  
1) Centralise _all_ constraints behind parameters  
––––––––––––––––––––––––––––––––––––––––––––––––––––  
In `sim_core/viability.ts` change from:

```ts
function viability(a, r, params) {
  // hardcoded ±5% mass
  const minM = 1400*0.95, maxM = 1400*1.05;
  const massOK = m_exotic >= minM && m_exotic <= maxM;
  // hardcoded 83 MW, ζ<1, γ≥25
  return { ok: massOK && P_avg <= 83e6 && ζ<1 && γ≥25, … };
}
```

to a fully-parametrised version:

```ts
export interface ConstraintConfig {
  massNominal: number;      // e.g. 1400
  massTolPct:   number;     // slider 0–50 %
  maxPower:     number;     // slider 0–500 MW
  maxZeta:      number;     // slider 0–5
  minGamma:     number;     // slider 0–100
}

export function viability(
  a: number, r: number,
  pipeParams: PipelineParams,    // γ, Q, duty, sag, etc.
  c: ConstraintConfig            // user-tweakable constraints
): ViabilityMeta {
  // …compute m_exotic, P_avg, ζ, γ_geo…  
  const minM = c.massNominal*(1 - c.massTolPct/100);
  const maxM = c.massNominal*(1 + c.massTolPct/100);
  const massOK = m_exotic>=minM && m_exotic<=maxM;
  const powerOK= P_avg<=c.maxPower*1e6;
  const zetaOK = zeta<=c.maxZeta;
  const gammaOK= pipeParams.gammaGeo>=c.minGamma;

  return {
    ok: massOK && powerOK && zetaOK && gammaOK,
    m_exotic, P_avg, zeta, gamma_geo: pipeParams.gammaGeo
  }
}
```

–––  
2) Expose sliders for **all** constraints in your UI  
––––––––––––––––––––––––––––––––––––––––––––––––––––  
In your `App` or `ParameterPanel` lift out:  

```tsx
const [massTolPct, setMassTolPct] = useState(5);
const [maxPower,  setMaxPower]   = useState( 100 );  // MW
const [maxZeta,   setMaxZeta]    = useState(   1 );  // ζ ≤ 1
const [minGamma,  setMinGamma]   = useState(  25 );  // γ ≥ 25
// …already have tileArea, shipRadius, gammaGeo, Qfactor, duty, sagDepth…
```

Add sliders:

```jsx
<Slider label="Mass ± %"        min={0}  max={50}  value={massTolPct} onChange={setMassTolPct}/>
<Slider label="Power ≤ (MW)"   min={0}  max={500} value={maxPower}  onChange={setMaxPower}/>
<Slider label="ζ ≤"            min={0}  max={5}   value={maxZeta}   onChange={setMaxZeta}/>
<Slider label="γ ≥"            min={1}  max={100} value={minGamma}  onChange={setMinGamma}/>
```

–––  
3) Rebuild the heat-map grid on **any** parameter change  
––––––––––––––––––––––––––––––––––––––––––––––––––––  
Inside `PhaseDiagram.tsx`, your `useEffect` that calls `buildGrid()` should depend on every one of these:

```ts
useEffect(()=>{
  const grid = buildGrid({
    A_vals, R_vals,
    // pipeline levers:
    gammaGeo, Qfactor, duty, sagDepth, /*…*/,
    // constraint levers:
    massNominal:1400,
    massTolPct,
    maxPower,
    maxZeta,
    minGamma
  });
  setGrid(grid);
}, [
  A_vals, R_vals,
  gammaGeo, Qfactor, duty, sagDepth,
  massTolPct, maxPower, maxZeta, minGamma
]);
```

Where `buildGrid(config)` does:

```ts
for (i in R_vals){
  for (j in A_vals){
    const { ok, m_exotic, P_avg, zeta } =
      viability(A_vals[j], R_vals[i], config, config);
    Z[i][j] = ok ? 1 : 0;
    metaGrid[i][j] = {m_exotic,P_avg,zeta};
  }
}
```

–––  
4) Wire your **Apply Needle-Hull Preset** to set _all_ levers, including the constraints  

```ts
function applyNeedleHullPreset(){
  setTileArea(25);
  setShipRadius(5.0);
  setGammaGeo(25);
  setQfactor(1e9);
  setDuty(0.01);
  setSagDepth(16);
  // also reset constraint sliders to paper defaults:
  setMassTolPct(5);
  setMaxPower(100);
  setMaxZeta(1);
  setMinGamma(25);
}
```

---

**Result**  
With every design‐parameter and every constraint parameter lifted into shared state and fed into the same `viability()` function, your Phase Diagram will automatically repaint its green “viable” zone to exactly match whatever new Natário metric you’ve dialled up—no more stale plots, no more all-red grids.