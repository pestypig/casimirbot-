Yep—I can see why it’s spilling outside the frame from just this file.

There are three layout culprits in how you’re calling CavitySideView:

Vertical blow-up is too large
You force verticalExaggeration={5000} with a fairly small height={360}. If the component scales layer thickness as
px = physical_height * verticalExaggeration, a 1.5 µm mirror becomes 7 500 px tall (!) and will blast past the canvas. That orange/gray slab dominating the view is exactly that.

The inset is guaranteed to collide
You set gapInsetMagnification={12000} with a fixed canvas width. If the inset layout reserves a fixed pixel width (or doesn’t shrink on small canvases), it will either clip or push the main drawing out of bounds. In your screenshot the inset is jammed against the right border.

You’ve disabled X scaling but kept a fixed pixel width
pxPerUmX={undefined} tells CavitySideView to “auto-fit horizontally”, but you also fix width={1000}. On narrower viewports the card may be smaller than 1000 px, so the SVG/canvas will overflow the card and the legend/inset will sit outside the visible area.

Quick, safe fixes (no changes to CavitySideView code required)

Auto-fit Y instead of forcing a constant exaggeration. Compute a cap so the full stack fits in 360 px (with some padding), then pass that:

// physical stack in nanometers
const top_nm  = (1.5 /* µm */) * 1000;
const gap_nm  = (state.gap_nm ?? 1);
const bot_nm  = (1.5 /* µm */) * 1000;
const stack_nm = top_nm + gap_nm + bot_nm;

// leave ~15% vertical padding for labels/axes
const usablePx = 360 * 0.85;
const verticalExaggeration =
  Math.max(1, usablePx / Math.max(1, stack_nm)); // px per nm

// Optional: cap to avoid silly values on extremely tiny gaps
const verticalExaggerationCapped = Math.min(verticalExaggeration, 1500);


Make the inset scale with width (or lower it a lot). If you can’t change CavitySideView, reduce your magnification to something that will always fit:

// pick a conservative magnification that won't eclipse the right margin
const gapInsetMagnification = 3000; // from 12000 → 3000


Let the component be responsive. Don’t hard-fix the drawing to 1000 px if the parent is smaller. Use full width and a max width:

<div className="w-full overflow-x-auto"> {/* guards narrow screens */}
  <CavitySideView
    width={Math.min(1000, /* fallback */ 1000)}  // consider a responsive width from a hook/ResizeObserver
    height={360}
    /* ... */
    verticalExaggeration={verticalExaggerationCapped}
    gapInsetMagnification={gapInsetMagnification}
    pxPerUmX={undefined} // keep auto-fit X
  />
</div>


If you can tweak CavitySideView, even better:

Use SVG viewBox + preserveAspectRatio="xMidYMid meet", not fixed canvas pixels.

Reserve layout margins that include legend + inset width before computing the drawing area.

Compute verticalExaggeration from the available height, not as a raw constant:

exagY = (innerHeightPx - topPad - bottomPad) / (stackPhysicalMeters)


Make the inset percentage-based (insetWidth = min(0.22 * innerWidth, 260px)), and hide or shrink it under a minimum width.

Minimal change you can drop into your file right now

Replace the hardcoded props with the computed ones:

// before the return:
const topMirror_um = 1.5;
const botMirror_um = 1.5;

const top_nm  = topMirror_um * 1000;
const gap_nm  = state.gap_nm ?? 1;
const bot_nm  = botMirror_um * 1000;
const stack_nm = top_nm + gap_nm + bot_nm;

const usablePx = 360 * 0.85;
const verticalExaggeration = Math.min(Math.max(1, usablePx / Math.max(1, stack_nm)), 1500);
const gapInsetMagnification = 3000; // safer default

// ...

<CavitySideView
  pocketDiameter_um={40}
  sag_nm={state.sag_nm ?? 16}
  gap_nm={gap_nm}
  topMirror_thick_um={topMirror_um}
  botMirror_thick_um={botMirror_um}
  alnRim_width_um={20}
  tileWidth_mm={50}
  physicsParity={false}
  onWindow={lightCrossing?.onWindow ?? false}

  width={1000}   // consider making this responsive via a ResizeObserver
  height={360}

  pxPerUmX={undefined}
  verticalExaggeration={verticalExaggeration}
  gapInsetMagnification={gapInsetMagnification}
  fontScale={1.15}
/>


That will keep everything inside the frame on typical screens while still making the nm-scale visible. If you want me to, I can also make CavitySideView fully responsive (viewBox, dynamic margins, inset layout) so you never have to juggle these numbers again.