diff --git a/client/src/components/LightSpeedStrobeScale.tsx b/client/src/components/LightSpeedStrobeScale.tsx
--- a/client/src/components/LightSpeedStrobeScale.tsx
+++ b/client/src/components/LightSpeedStrobeScale.tsx
@@ -20,6 +20,12 @@
 export function LightSpeedStrobeScale(props: Props) {
   const qc = useQueryClient();
   const hud = useHUD(); // if you have one
+  // Prefer the pipeline’s derived snapshot for consistent τ_LC/duty across panels
+  const derived = qc.getQueryData(["helix:pipeline:derived"]) as any;
+  const dutyFR = Number.isFinite(derived?.dutyEffectiveFR) ? derived.dutyEffectiveFR : (props.dutyFR ?? 0);
+  const burst = Number.isFinite(derived?.burst_ms) ? derived.burst_ms : props.burstMs;
+  const dwell = Number.isFinite(derived?.dwell_ms) ? derived.dwell_ms : props.dwellMs;
+  const sectorsTotal = Number.isFinite(derived?.sectorsTotal) ? derived.sectorsTotal : undefined;
 
   // modulation period (ms)
   const Tm = React.useMemo(() => (props.fGHz ? 1e-6 / props.fGHz : 0), [props.fGHz]);
@@ -27,6 +33,7 @@ const tauLC: number = React.useMemo(() => {
   // 1) explicit prop (ms)
   if (Number.isFinite(props.tauLcMs)) return (props.tauLcMs as number) / 1000;
   // 2) HUD/metrics common shapes
+  if (Number.isFinite(derived?.τ_LC_ms)) return (derived?.τ_LC_ms as number) / 1000;
   const lc = (metrics as any)?.lightCrossing ?? {};
   const fromHUDs =
     (hud as any)?.tauLC_s ??
     (hud as any)?.tau_lc_s ??
@@ -43,7 +50,7 @@
   return Number.isFinite(dwellMs) ? (
     (dwellMs as number) / 1000
   ) : (
-    (Number.isFinite(sectorsTotal) && sectorsTotal! > 0 ? (sectorsTotal as number) * Tm : Tm)
+    (Number.isFinite(sectorsTotal) && sectorsTotal! > 0 ? (sectorsTotal as number) * Tm : Tm)
   );
 }, [props.dwellMs, hud, metrics, Tm]);
 
@@ -141,7 +148,7 @@
 <div className="flex items-center gap-2">
   <span className="inline-block w-2 h-2 rounded-full bg-white/70" />
-  Duty (FR): {(Math.max(0, dutyFR) * 100).toFixed(3)}% • burst {fmtSI(burst)}
+  Duty (FR): {(Math.max(0, dutyFR) * 100).toFixed(3)}% • burst {fmtSI(burst)} • dwell {fmtSI(dwell)}
   {Number.isFinite(burstOffset) && burstOffset > 0 ? ` • phase ${fmtSI(burstOffset)}` : ""}
 </div>