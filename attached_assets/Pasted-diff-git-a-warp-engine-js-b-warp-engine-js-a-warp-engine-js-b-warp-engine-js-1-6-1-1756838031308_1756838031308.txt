diff --git a/warp-engine.js b/warp-engine.js
--- a/warp-engine.js
+++ b/warp-engine.js
@@ -1,6 +1,30 @@
 // WarpEngine (WebGL runtime)
 // ------------------------------------------------------------
 
+// ---- helpers for meters ↔ rho thickness ------------------------------------
+function _aHarmonic(ax, ay, az) {
+  const a = +ax || 0, b = +ay || 0, c = +az || 0;
+  const d = (a>0?1/a:0) + (b>0?1/b:0) + (c>0?1/c:0);
+  return d > 0 ? 3 / d : NaN;
+}
+function _guessAH(U, p) {
+  const H = (p && p.axesHull) || U.axesHull;
+  const S = (p && p.axesScene) || U.axesScene;
+  if (Array.isArray(H) && H.length >= 3) return _aHarmonic(H[0], H[1], H[2]);
+  if (Array.isArray(S) && S.length >= 3) return _aHarmonic(S[0], S[1], S[2]);
+  return NaN;
+}
+
 class WarpEngine {
   // ...
   updateUniforms(parameters) {
-    const U = this.uniforms || (this.uniforms = {});
+    const U = this.uniforms || (this.uniforms = {});
+
+    // ---- wall width ingestion (unify aliases) --------------------------------
+    // Accept: wallWidth (rho), wallWidth_rho (rho), hullDimensions.wallWidth_m (meters)
+    // Keep shader-facing alias "wallWidth" in rho units.
+    const aH = _guessAH(U, parameters);
+    let w_rho = Number.isFinite(parameters.wallWidth) ? +parameters.wallWidth : undefined;
+    if (Number.isFinite(parameters.wallWidth_rho)) w_rho = +parameters.wallWidth_rho;
+    const w_m_in = Number.isFinite(parameters?.hullDimensions?.wallWidth_m)
+      ? +parameters.hullDimensions.wallWidth_m : undefined;
+    if (!Number.isFinite(w_rho) && Number.isFinite(w_m_in) && Number.isFinite(aH)) {
+      w_rho = w_m_in / aH;
+    }
+    if (Number.isFinite(w_rho)) U.wallWidth = w_rho;
+    if (!Number.isFinite(U.wallWidth)) U.wallWidth = U.wallWidth ?? 0.06; // preserve existing default
+    // Echo helpful aliases for UIs
+    U.wallWidth_rho = U.wallWidth;
+    if (Number.isFinite(aH)) U.wallWidth_m = U.wallWidth * aH;
 
     // ... rest of your uniform ingestion (q, gamma, duty, etc.) ...
   }
@@ -60,12 +84,12 @@ class WarpEngine {
   _render() {
     const U = this.uniforms || {};
     // ...
-    // CPU interior window width (previously used U.wallWidth with mixed defaults)
-    const w_int = Number.isFinite(this.uniforms?.intWidth)
-      ? Math.max(0.002, +this.uniforms.intWidth)
-      : Math.max(3.0 * (this.uniforms?.wallWidth || 0.016), 0.02);
+    // CPU interior window width: derive from the unified rho width
+    const w_int = Number.isFinite(this.uniforms?.intWidth)
+      ? Math.max(0.002, +this.uniforms.intWidth)
+      : Math.max(3.0 * (this.uniforms?.wallWidth ?? 0.06), 0.02);
     // ...
   }
 }

2) warp-engine.js

Mirror the q alias internally and expose a raw γVdB for diagnostics (clamp stays).

diff --git a/warp-engine.js b/warp-engine.js
@@
-  // Ingest parameters → uniforms
+  // Ingest parameters → uniforms
   const U = this.uniforms || (this.uniforms = {});
-  U.deltaAOverA = Number.isFinite(parameters.qSpoilingFactor) ? parameters.qSpoilingFactor : (U.deltaAOverA ?? 1);
+  // Accept either alias for q; keep both set for UI parity
+  const qIn = Number.isFinite(parameters.qSpoilingFactor) ? parameters.qSpoilingFactor
+            : Number.isFinite(parameters.deltaAOverA)    ? parameters.deltaAOverA
+            : (U.deltaAOverA ?? 1);
+  U.deltaAOverA    = qIn;
+  U.qSpoilingFactor = qIn;
@@
-  // γ_VdB with parity clamp
-  U.gammaVanDenBroeck = clampByParity(parameters.gammaVanDenBroeck, this.physicsParityMode);
+  // γ_VdB with parity clamp; also expose raw for inspector diagnostics
+  const gammaVdB_raw = Number.isFinite(parameters.gammaVanDenBroeck) ? parameters.gammaVanDenBroeck : (U.gammaVanDenBroeck ?? 1);
+  U.gammaVdBRaw = gammaVdB_raw;
+  U.gammaVanDenBroeck = clampByParity(gammaVdB_raw, this.physicsParityMode);
@@
-  // Duty: prefer FR if provided, else derive from local × S_live/S_total
+  // Duty: prefer FR if provided, else derive from local × S_live/S_total
   const FR = Number.isFinite(parameters.dutyEffectiveFR) ? parameters.dutyEffectiveFR : null;
   const local = clamp(parameters.dutyCycle, 0, 1);
   const S_total = Math.max(1, parameters.sectorCount|0);
   const S_live  = Math.max(1, (parameters.sectorStrobing|0) || 1);
   U.dutyEffectiveFR = FR ?? (local * (S_live / S_total));
@@
-  // θ chain (if host didn't specify thetaScale)
+  // θ chain (if host didn't specify thetaScale)
   if (Number.isFinite(parameters.thetaScale)) {
     U.thetaScale = parameters.thetaScale;
   } else {
     const dutyForTheta = U.dutyEffectiveFR;
     U.thetaScale = Math.pow(U.gammaGeo ?? 1, 3) * (U.deltaAOverA ?? 1) * (U.gammaVanDenBroeck ?? 1) * Math.sqrt(Math.max(1e-12, dutyForTheta));
   }


Why: Inspector/audits can now read either deltaAOverA or qSpoilingFactor; and if a mismatch appears, you can compare gammaVdBRaw vs clamped to understand why.