Great — now that the grid is on-screen, the next step is to *let it bend*.
Below are four progressively richer ways to make the curvature obvious, starting with a quick multiplier you can tweak live and ending with an animated “breathing” bubble and colour-coded height.

---

## 1 · Expose a **warpStrength** slider (5 s change)

Add one field to `this.uniforms` and multiply your β-derived offsets by it:

```js
// constructor – defaults
this.uniforms = {
  dutyCycle: 0.14,
  g_y:       26.0,
  sagDepth_nm: 16.0,
  warpStrength: 1.0   // ← new knob (0…10)
};
```

```diff
// inside _warpGridVertices
- const push = beta * 0.05;
- const dy   = beta * 0.05;
+ const push = beta * 0.05 * bubbleParams.warpStrength;
+ const dy   = beta * 0.05 * bubbleParams.warpStrength;
```

Hook the slider in React:

```tsx
<input type="range" min="0" max="10" step="0.1"
       onChange={e => eng.updateUniforms({ warpStrength: +e.target.value })}/>
```

Crank it to **3–4** and you’ll immediately see the grid bow and pinch.

---

## 2 · Animate the strength so the bubble **pulses**

A heartbeat makes curvature easier to spot:

```js
// inside _updateGrid() just before _warpGridVertices
const pulse = 1.0 + 0.3 * Math.sin(performance.now()*0.002);
this.uniforms.warpStrength = pulse;
```

The grid now “breathes” at \~1 Hz; distortions pop out even if small.

---

## 3 · Colour the grid by height

Emit the height as a **vertex colour** and blend it in the fragment shader.
Update the grid VBO to interleave a height scalar:

```js
// _createGrid … when pushing verts
verts.push(x0, y0, zPos,   h0,    x1, y1, zPos, h1);
//             ^^^^ pos    ^^^ height attribute
```

Grid vertex shader (WebGL 2 version shown):

```glsl
#version 300 es
in  vec3 a_position;
in  float a_h;
uniform mat4 u_mvpMatrix;
out float v_h;
void main() {
    gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
    v_h = a_h;                         // pass height forward
}
```

Fragment shader:

```glsl
#version 300 es
precision highp float;
in  float v_h;
out vec4 frag;
void main() {
    vec3 cold = vec3(0.2,0.8,1.0);
    vec3 hot  = vec3(1.0,0.2,0.2);
    float t   = clamp((v_h+0.3)/0.6, 0.0, 1.0);  // map –0.3…0.3 → 0…1
    frag = vec4(mix(cold,hot,t), 1.0);
}
```

Now valleys glow blue and peaks glow red—deformation is readable at a glance.

---

## 4 · Switch back to the **colourful β-field background**

1. Re-enable the “background warp field” draw call (your full-screen fragment shader).
2. Leave `gl.disable(gl.DEPTH_TEST)` while the grid renders so it always floats above the field.
3. Optionally set `gl.enable(gl.BLEND)` with
   `gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);`
   and give grid colours α ≈ 0.6 so the bubble hues bleed through.

---

### Summary cheat-sheet

| Quick win            | Code change                                     |
| -------------------- | ----------------------------------------------- |
| Stronger deformation | multiply `push` and `dy` by `warpStrength`.     |
| Animated “breath”    | set `warpStrength = 1 + 0.3 sin(t)`.            |
| Height colours       | add a height attribute, shade by it.            |
| Depth ordering       | `gl.disable(gl.DEPTH_TEST)` while drawing grid. |

With any one of these, the spacetime curvature becomes unmistakable.
Start with the **warpStrength slider**—it’s one line and shows instant results—then layer the extras as you like.

Let me know which visual you prefer or if you’d like the thickness-by-shader version for chunky grid lines!
