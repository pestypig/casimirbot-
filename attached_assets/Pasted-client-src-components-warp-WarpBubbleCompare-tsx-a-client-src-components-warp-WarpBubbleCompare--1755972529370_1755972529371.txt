client/src/components/warp/WarpBubbleCompare.tsx
*** a/client/src/components/warp/WarpBubbleCompare.tsx
--- b/client/src/components/warp/WarpBubbleCompare.tsx
@@
-import React, { useEffect, useRef } from "react";
-// at top-level, set a build token (replace with your commit/ts)
-const APP_WARP_BUILD = (window as any).__APP_WARP_BUILD || "dev-" + Date.now();
+import React, { useEffect, useRef } from "react";
+// at top-level, set a stable build token in dev
+const APP_WARP_BUILD =
+  (window as any).__APP_WARP_BUILD ||
+  (window as any).__WarpEngineBuild ||
+  "dev";
@@
 async function ensureWarpEngineCtor(opts: { requiredBuild?: string; forceReload?: boolean } = {}): Promise<any> {
   const { requiredBuild = APP_WARP_BUILD, forceReload = false } = opts;
   const w = window as any;
 
   // If an engine is already present, verify its build token
   let Ctor = w.WarpEngine?.default || w.WarpEngine;
   const currentBuild = w.WarpEngine?.BUILD || w.__WarpEngineBuild;
-  if (Ctor && !forceReload) {
-    if (!requiredBuild || currentBuild === requiredBuild) {
-      console.log('[WARP LOADER] Reusing WarpEngine', { build: currentBuild });
-      return Ctor;
-    }
-    console.warn('[WARP LOADER] Build mismatch; reloading engine', { currentBuild, requiredBuild });
-  }
+  if (Ctor && !forceReload) {
+    const dev = requiredBuild === 'dev';
+    if (dev || !requiredBuild || currentBuild === requiredBuild) {
+      console.log('[WARP LOADER] Reusing WarpEngine', { build: currentBuild });
+      return Ctor;
+    }
+    console.warn('[WARP LOADER] Build mismatch; reloading engine', { currentBuild, requiredBuild });
+  }
 
   // Nuke caching that can pin the old engine
-  if (forceReload || (Ctor && currentBuild !== requiredBuild)) {
+  if (forceReload) {
     console.log('[WARP LOADER] Nuking Service Worker cache');
     try {
       // Service Worker / PWA: unregister & prepare for hard-reload
       const registrations = await navigator.serviceWorker?.getRegistrations?.();
       if (registrations?.length) {
         await Promise.all(registrations.map(r => r.unregister()));
         console.log('[WARP LOADER] Unregistered', registrations.length, 'service workers');
       }
     } catch (e) {
       console.warn('[WARP LOADER] Service worker cleanup failed (normal if none active):', e);
     }
   }
 
-  // Remove any old <script> tags and load a fresh one with cache-bust
-  removeOldWarpScripts();
-  const url = `/warp-engine.js?v=${encodeURIComponent(requiredBuild)}&t=${Date.now()}`;
-  await loadScript(url);
+  // Reuse existing <script> if present; otherwise inject once with cache-bust
+  const existing = Array.from(document.scripts).find(s => /\/warp-engine\.js(\?|$)/.test(s.src));
+  if (!existing) {
+    const url = `/warp-engine.js?v=${encodeURIComponent(requiredBuild)}&t=${Date.now()}`;
+    await loadScript(url);
+  } else {
+    await new Promise<void>((resolve, reject) => {
+      const ok = () => (w.WarpEngine ? resolve() : setTimeout(ok, 30));
+      existing.addEventListener('error', () => reject(new Error('warp-engine.js failed to load')));
+      ok();
+    });
+  }
 
   // Re-check
   Ctor = w.WarpEngine?.default || w.WarpEngine;
   if (Ctor) {
     // Stamp a build token so we can verify later even if the engine lacks BUILD
     w.__WarpEngineBuild = w.WarpEngine?.BUILD || requiredBuild;
     console.log('[WARP LOADER] Loaded WarpEngine', { src: url, build: w.__WarpEngineBuild });
     return Ctor;
   }
   throw new Error('WarpEngine constructor not found after reload');
 }
@@
 function compatifyUniforms(raw: any) {
   const p = { ...(raw || {}) };
 
   // Enhanced color mode compatibility - normalize to numeric
-  const map: any = { theta: 0, shear: 1, solid: 2 };
+  const map: any = { solid: 0, theta: 1, shear: 2 };
   if (typeof p.colorMode === 'string') p.colorMode = map[p.colorMode] ?? 0;
   if (!Number.isFinite(p.colorMode) && Number.isFinite(p.colorModeIndex)) p.colorMode = p.colorModeIndex;
   if (p.colorModeName == null && typeof raw?.colorMode === 'string') p.colorModeName = raw.colorMode;
   if (p.colorModeIndex == null && Number.isFinite(p.colorMode)) p.colorModeIndex = p.colorMode;
@@
 const applyReal = (
   e: any,
   sharedIn: ReturnType<typeof frameFromHull>,
   canvas: HTMLCanvasElement,
   colorMode: 'theta'|'shear'|'solid'
 ) => {
@@
-  const camZ = safeCamZ(compactCameraZ(canvas, shared.axesScene));
-  const colorModeIndex = ({ theta:0, shear:1, solid:2 } as const)[colorMode] ?? 0;
+  const camZ = safeCamZ(compactCameraZ(canvas, shared.axesScene));
+  const colorModeIndex = ({ solid:0, theta:1, shear:2 } as const)[colorMode] ?? 1;
@@
   pushUniformsWhenReady(e, {
     ...shared,
     cameraZ: camZ,
     lockFraming: true,
     physicsParityMode: true,
     colorMode: colorModeIndex,
     colorModeIndex,
     colorModeName: colorMode,
@@
 const applyShow = (
   e: any,
   sharedIn: ReturnType<typeof frameFromHull>,
   canvas: HTMLCanvasElement,
   colorMode: 'theta'|'shear'|'solid',
   opts: { T?: number; boostMax?: number; decades?: number; vizGain?: number; exposure?: number; zeroStop?: number; }
 ) => {
@@
-  // Use numeric color mode for engine compatibility
-  const colorModeIndex = ({ theta:0, shear:1, solid:2 } as const)[colorMode] ?? 0;
+  // Use numeric color mode for engine compatibility (engine: 0=solid,1=theta,2=shear)
+  const colorModeIndex = ({ solid:0, theta:1, shear:2 } as const)[colorMode] ?? 1;
@@
   pushUniformsWhenReady(e, {
     ...shared,
     cameraZ: camZ,
     lockFraming: true,
     physicsParityMode: false,   // enable amplification
     // Force numeric (engine canonical) + provide synonyms
     colorMode: colorModeIndex,
     colorModeIndex,
     colorModeName: colorMode,
@@
-          const initCamZ = safeCamZ(2.0);  // fallback to safe default
-          const initColor = 0; // theta
-          leftEngine.current?.setParams?.({ thetaScale: 1.0, sectors: 400, cameraZ: initCamZ, colorMode: initColor, colorModeIndex: initColor, colorModeName: 'theta' });
-          rightEngine.current?.setParams?.({ thetaScale: 1.0, sectors: 400, cameraZ: initCamZ, colorMode: initColor, colorModeIndex: initColor, colorModeName: 'theta' });
+          const initCamZ = safeCamZ(2.0);  // fallback to safe default
+          const initColor = 1; // theta (engine expects 0=solid,1=theta,2=shear)
+          leftEngine.current?.setParams?.({ thetaScale: 1.0, sectors: 400, cameraZ: initCamZ, colorMode: initColor, colorModeIndex: initColor, colorModeName: 'theta' });
+          rightEngine.current?.setParams?.({ thetaScale: 1.0, sectors: 400, cameraZ: initCamZ, colorMode: initColor, colorModeIndex: initColor, colorModeName: 'theta' });
