Totally doable. We can **pre-extract the text labels from the SVG once** (at build time) into a tiny JSON file, then draw those labels on top of the PNG in your app. That way Replit never has to render the SVG—just the PNG + a JSON overlay.

Here’s a clean, copy-paste path:

---

# 1) One-time script: extract labels from the SVG → JSON

This Node script parses `map_2020_6000pc.svg`, walks `<text>` nodes, resolves simple `transform` (translate/scale) on groups, and emits a flat list of `{text, x, y, fontSize, fill}` in **SVG-native pixels**. It ignores rotations/curves, which is fine for most labels.

## Install deps

```bash
npm i -D fast-xml-parser
```

## scripts/extract-svg-labels.ts

```ts
// scripts/extract-svg-labels.ts
import { readFileSync, writeFileSync } from "fs";
import { XMLParser } from "fast-xml-parser";

type Node = any;

function parseTransform(t?: string) {
  // supports translate(x,y) and scale(sx[,sy])
  const out = { tx: 0, ty: 0, sx: 1, sy: 1 };
  if (!t) return out;
  const parts = t.match(/(translate|scale)\s*\(([^)]+)\)/g) || [];
  for (const p of parts) {
    const [, kind, argsStr] = p.match(/(translate|scale)\s*\(([^)]+)\)/)!;
    const nums = argsStr.split(/[,\s]+/).map(Number);
    if (kind === "translate") {
      out.tx += nums[0] || 0;
      out.ty += nums[1] || 0;
    } else if (kind === "scale") {
      const sx = nums[0] ?? 1; const sy = nums[1] ?? sx;
      out.sx *= sx; out.sy *= sy;
    }
  }
  return out;
}

function apply(x: number, y: number, tr: {tx:number;ty:number;sx:number;sy:number}) {
  return { x: x*tr.sx + tr.tx, y: y*tr.sy + tr.ty };
}

function walk(node: Node, parentTr = {tx:0,ty:0,sx:1,sy:1}, labels: any[] = []) {
  if (!node || typeof node !== "object") return labels;
  const tr = parseTransform(node["@_transform"]);
  const acc = {
    tx: parentTr.tx + tr.tx,
    ty: parentTr.ty + tr.ty,
    sx: parentTr.sx * tr.sx,
    sy: parentTr.sy * tr.sy,
  };

  if (node.text) {
    const t = node.text;
    const x = Number(t["@_x"] ?? 0);
    const y = Number(t["@_y"] ?? 0);
    const { x: X, y: Y } = apply(x, y, acc);
    const content = (typeof t["#text"] === "string" ? t["#text"] : (Array.isArray(t.tspan) ? t.tspan.map((s:any)=>s["#text"]).join(" ") : "")).trim();
    if (content) {
      labels.push({
        text: content,
        x: X,
        y: Y,
        fontSize: Number(t["@_font-size"] ?? 0) * acc.sy || undefined,
        fill: t["@_fill"] || undefined,
      });
    }
  }

  // Some SVGs nest multiple <text> children or <g> groups
  for (const key of Object.keys(node)) {
    if (key === "text" || key === "@_transform" || key === "#text") continue;
    const child = node[key];
    if (Array.isArray(child)) child.forEach(c=>walk(c, acc, labels));
    else if (typeof child === "object") walk(child, acc, labels);
  }
  return labels;
}

function main() {
  const svgPath = process.argv[2] || "public/map_2020_6000pc.svg";
  const outPath = process.argv[3] || "public/galaxy_labels.json";
  const xml = readFileSync(svgPath, "utf8");
  const parser = new XMLParser({ ignoreAttributes: false, preserveOrder: false, attributeNamePrefix: "@_" });
  const root = parser.parse(xml);

  // The file’s root key is usually 'svg'
  const svgNode = root.svg ?? root;
  const labels = walk(svgNode, {tx:0,ty:0,sx:1,sy:1}, []);
  // filter out tiny or blank labels
  const clean = labels.filter((l:any)=>l.text && l.text.length>=2);

  writeFileSync(outPath, JSON.stringify({
    meta: { source: svgPath, count: clean.length, note: "coords in SVG native pixels" },
    labels: clean
  }, null, 2));
  console.log(`Wrote ${clean.length} labels -> ${outPath}`);
}

main();
```

### Run it

```bash
ts-node scripts/extract-svg-labels.ts public/map_2020_6000pc.svg public/galaxy_labels.json
```

This produces `/public/galaxy_labels.json`.

---

# 2) Draw those labels over your PNG

We’ll read `galaxy_labels.json`, convert SVG-pixel coords → screen coords using the same pan/zoom transform and your calibration (`originPx`, `scalePxPerPc`), and render text on a canvas above the PNG. You can filter the labels (e.g., only show OB associations / constellations) by simple includes/excludes.

## components/GalaxyTextOverlay.tsx

```tsx
import * as React from "react";

type Label = { text:string; x:number; y:number; fontSize?:number; fill?:string };
type LabelsFile = { meta:any; labels: Label[] };

export function GalaxyTextOverlay({
  width, height,
  zoom, offset,
  svgToScreen,
  labelUrl = "/galaxy_labels.json",
  filterText = (t:string)=> true,       // plug your own filter (e.g., /OB|SNR|Orion/i)
  alpha = 0.8
}: {
  width:number; height:number;
  zoom:number; offset:{x:number;y:number};
  svgToScreen: (pt:{x:number;y:number})=>{x:number;y:number};
  labelUrl?: string;
  filterText?: (t:string)=> boolean;
  alpha?: number;
}) {
  const cvsRef = React.useRef<HTMLCanvasElement>(null);
  const [labels, setLabels] = React.useState<Label[]|null>(null);

  React.useEffect(()=>{
    fetch(labelUrl).then(r=>r.json()).then((d:LabelsFile)=>{
      setLabels(d.labels);
    }).catch(()=>setLabels([]));
  }, [labelUrl]);

  React.useEffect(()=>{
    const cvs = cvsRef.current; if(!cvs || !labels) return;
    const ctx = cvs.getContext("2d"); if(!ctx) return;
    ctx.clearRect(0,0,width,height);
    ctx.save();
    ctx.globalAlpha = alpha;

    // draw selected labels
    ctx.font = `${12}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
    ctx.textBaseline = "top";
    for (const L of labels) {
      if (!filterText(L.text)) continue;
      const p = svgToScreen({x:L.x, y:L.y});
      const size = Math.min(22, Math.max(10, (L.fontSize ?? 12) * zoom * 0.5));
      ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
      // shadow for readability
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillText(L.text, p.x+1, p.y+1);
      ctx.fillStyle = L.fill ?? "#f5e1ff";
      ctx.fillText(L.text, p.x, p.y);
    }
    ctx.restore();
  }, [labels, width, height, zoom, offset, svgToScreen, alpha]);

  return <canvas ref={cvsRef} width={width} height={height} className="absolute inset-0 pointer-events-none" />;
}
```

---

# 3) Use it with your layered PNG map

Add the text overlay on top of `GalaxyMapLayers` so it shares the same transform.

```tsx
// in your Mission Planner where GalaxyMapLayers is mounted
import { GalaxyMapLayers } from "@/components/GalaxyMapLayers";
import { GalaxyTextOverlay } from "@/components/GalaxyTextOverlay";

// keep these in state or config
const [originPx, setOriginPx] = useState({ x: 8048, y: 4025 });
const [scalePxPerPc, setScalePxPerPc] = useState(25);

// expose the same svgToScreen transform that GalaxyMapLayers uses:
const [zoom, setZoom] = useState(1);
const [offset, setOffset] = useState({x:0,y:0});
const toSvgPx = (xpc:number, ypc:number)=>({ x: originPx.x + xpc*scalePxPerPc, y: originPx.y - ypc*scalePxPerPc });
const svgToScreen = (pt:{x:number;y:number}) => ({ x: pt.x*zoom + offset.x, y: pt.y*zoom + offset.y });

// Pass setters to GalaxyMapLayers so it can update zoom/offset;
// or lift its internal state out into this parent (simple prop drilling).
<GalaxyMapLayers
  svgUrl="/map_2020_6000pc.svg"
  pngUrl="/render_e_plus_dust_and_hii_regions_and_clusters.png"
  bodies={BODIES}
  routeIds={route}
  originPx={originPx}
  scalePxPerPc={scalePxPerPc}
  width={1200}
  height={650}
  // glue: intercept zoom/offset updates from inside GalaxyMapLayers (add callbacks there)
  // onZoomChange={setZoom}
  // onOffsetChange={setOffset}
/>

{/* Draw labels above the map using the same transform */}
<GalaxyTextOverlay
  width={1200}
  height={650}
  zoom={zoom}
  offset={offset}
  svgToScreen={svgToScreen}
  // show fewer labels? e.g., only OB associations & SNRs:
  // filterText={(t)=> /(OB|SNR|Orion|Vela|Cas|Perseus|Lupus)/i.test(t)}
/>
```

> If you don’t want to plumb `zoom/offset` out of `GalaxyMapLayers`, add the `GalaxyTextOverlay` **inside** it and pass the internal `svgToScreen` directly. Either approach works.

---

## Why this approach

* **Replit-friendly**: at runtime we only display the **PNG** and a tiny **JSON** file.
* **Always aligned**: label coordinates stay in **SVG native pixels**, and we transform them with the **same pan/zoom** as the image, so they sit exactly where they should.
* **Fast to iterate**: if you want fewer/more labels, just filter by text regex or prefilter in the script.

If you want, I can extend the extractor to include **object types** (e.g., detect “OB1/OB2”, “SNR”, “Nebula”) by regexing the text and write a `kind` field, so you can add checkboxes to toggle label layers.
