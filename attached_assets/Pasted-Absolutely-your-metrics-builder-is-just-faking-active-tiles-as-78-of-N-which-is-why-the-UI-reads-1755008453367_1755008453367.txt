Absolutely—your metrics builder is just faking “active tiles” as 78% of N, which is why the UI reads strobing wrong. Here’s a drop-in replacement that:

* reports **concurrent active tiles = sectorStrobing (S)**,
* adds **activeFraction = S/N**, **effective duty** (for ζ intuition), and **strobe timing**,
* keeps your existing fields/names, and uses safe fallbacks.

Paste this over your current function in `server/helix-core.ts`:

```ts
// System metrics endpoint (physics-first, strobe-aware)
export function getSystemMetrics(req: Request, res: Response) {
  const state = getGlobalPipelineState();

  const N = Math.max(1, Math.round(state.N_tiles ?? 0));          // total tiles
  const S = Math.max(1, Math.round(state.sectorStrobing ?? 1));   // concurrent sectors
  const activeFraction = Math.min(1, S / N);

  const dutyGlobal = Math.max(0, Math.min(1, state.dutyCycle ?? 0.14));
  const qSpoil     = state.qSpoilingFactor ?? 1;

  // Effective duty relevant to Ford–Roman sampling (time-sliced exposure)
  const dutyEffectiveFR = dutyGlobal * qSpoil * activeFraction;

  // Optional timing hints (client can animate the grid with these)
  const strobeHz        = Number(state.strobeHz ?? process.env.STROBE_HZ ?? 2000);
  const sectorPeriod_ms = 1000 / Math.max(1, strobeHz);

  res.json({
    // Strobe-aware tile counts
    activeTiles: S,                   // concurrent tiles (sectors) energized
    totalTiles: N,
    activeFraction,                   // S / N (should be << 1)

    // Power / mass (already computed on server)
    energyOutput: state.P_avg,        // MW
    exoticMass: Number.isFinite(state.M_exotic) ? Math.round(state.M_exotic) : null,       // kg
    exoticMassRaw: Number.isFinite((state as any).M_exotic_raw) ? Math.round((state as any).M_exotic_raw) : undefined,
    massCalibration: (state as any).massCalibration ?? 1,

    // Duty visibility (helps explain ζ)
    dutyGlobal,
    dutyEffectiveFR,
    strobeHz,
    sectorPeriod_ms,

    // Constraints
    fordRoman: {
      value: state.zeta,
      limit: 1.0,
      status: state.zeta < 1 ? "PASS" : "FAIL",
    },
    natario: {
      value: 0,
      status: state.natarioConstraint ? "VALID" : "CHECK",
    },
    curvatureMax: Math.abs(state.U_cycle ?? 0) / (3e8 * 3e8),

    timeScaleRatio: state.TS_ratio,
    overallStatus: (state.zeta < 1 && (state.curvatureLimit ?? true)) ? "NOMINAL" : "CHECK",
  });
}
```

What changes for you right away:

* `activeTiles` now equals **`sectorStrobing`** (e.g., 4 or 400), not \~78% of N.
* You get `activeFraction` and `dutyEffectiveFR`, so ζ should make sense and trend correctly with strobing and duty changes.
* Clients can animate the **Interactive map of all tile sectors** using `strobeHz`/`sectorPeriod_ms` without guessing.

If you want, I can also hand you a tiny `<TileGrid>` React snippet wired to these new fields so that grid finally shows the strobe moving across sectors.
