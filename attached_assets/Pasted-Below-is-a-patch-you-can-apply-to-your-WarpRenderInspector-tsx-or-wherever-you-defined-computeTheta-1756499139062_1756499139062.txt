Below is a patch you can apply to your WarpRenderInspector.tsx (or wherever you defined computeThetaScale and build realPayload/showPayload) to force both REAL and SHOW to use the mass pocket-factor and the Ford–Roman duty, so that your shader’s θ exactly matches the physics pipeline:
--- a/src/components/WarpRenderInspector.tsx
+++ b/src/components/WarpRenderInspector.tsx
@@ -215,31 +215,22 @@ function pushUniformsWhenReady(engine: any, patch: Record<string, any>, source: s
 // Push only after shaders are ready - now with enhanced gating and diagnostics
 function computeThetaScale(phys: any, source: 'fr' | 'ui') {
-  const g = +phys.gammaGeo || 26;
-  const q = +phys.qSpoilingFactor || 1;
-  // force use of explicit mass vs. visual pocket factors
-  const vMass = +phys.gammaVanDenBroeck_mass || 1;
-  const vVis  = +phys.gammaVanDenBroeck_vis  || 1;
-  const v     = source === 'fr' ? vMass : vVis;
-  // pick duty depending on mode:
-  let duty: number;
-  if (source === 'fr') {
-    duty = Number(phys.dutyEffectiveFR ?? live?.dutyEffectiveFR ?? 0);
-  } else {
-    // UI‐average = dutyCycle ÷ concurrent sectors
-    duty = Number(phys.dutyCycle ?? 0) / Math.max(1, Number(phys.sectors ?? 1));
-  }
-  duty = Math.max(1e-12, Math.min(1, duty));
-
-  // published: θ = γ_geo³ · q · γ_VdB · √duty
-  return Math.pow(g, 3) * q * v * Math.sqrt(duty);
-}
+/**  
+ * Compute θ using exactly the physics pipeline formula  
+ * θ = γ_geo³ · q · γ_VdB_mass · √(dutyEffectiveFR)  
+ * (always uses the mass pocket-factor and Ford–Roman duty)  
+ */  
+function computeThetaScale(phys: any) {
+  const g    = +phys.gammaGeo || 26;
+  const q    = +phys.qSpoilingFactor || 1;
+  const v    = +phys.gammaVanDenBroeck_mass || +phys.gammaVanDenBroeck || 1;
+  const duty = Math.max(
+    1e-12,
+    Math.min(1, Number(phys.dutyEffectiveFR ?? live?.dutyEffectiveFR ?? 0))
+  );
+  return Math.pow(g, 3) * q * v * Math.sqrt(duty);
+}
 
 // … later in the file: building the two uniform payloads …
@@ -345,15 +336,16 @@ function WarpRenderInspector(props: { parityPhys?: Record<string, any>; sho
   // Build REAL payload (Ford–Roman parity)
-  const realThetaScale = computeThetaWithDebug(realPhys, 'fr', 'REAL');
+  const realThetaScale = computeThetaScale(realPhys);
   const realPayload = {
     ...baseShared,
     physicsParityMode: true,
     ridgeMode: 0,
     ...realPhys,
-    thetaScale: realThetaScale,
+    thetaScale: realThetaScale,
     exposure: 5.0,
     zeroStop: 1e-7,
     colorMode: 2,
     lockFraming: true
   };
 
   // Build SHOW payload (use physics θ for pipeline accuracy)
-  const showThetaScale = computeThetaWithDebug(showPhys, 'ui', 'SHOW');
+  const showThetaScale = computeThetaScale(showPhys);
   const showPayload = {
     ...baseShared,
     physicsParityMode: false,
@@ -363,8 +355,8 @@ function WarpRenderInspector(props: { parityPhys?: Record<string, any>; sho
     ...showPhys,
-    // now truly θ=γ³·q·γ_VdB_vis·√(dutyCycle/sectors)
-    thetaScale: showThetaScale,
+    // now θ matches exactly the physics pipeline
+    thetaScale: showThetaScale,
     exposure: 7.5,
     zeroStop: 1e-7,
     curvatureGainT: 0.70,