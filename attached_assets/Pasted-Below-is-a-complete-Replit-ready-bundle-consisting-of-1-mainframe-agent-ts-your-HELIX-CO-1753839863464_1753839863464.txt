Below is a complete, Replit-ready bundle consisting of:

  1. `mainframe.agent.ts` – your HELIX-CORE agent scaffold  
  2. A `run_mode.ts` helper with `run_mode(modeName)` + callback wiring  
  3. A React hook system (`useModule.tsx`) for registering new panels  

Feel free to drop these three files into your Replit project.

— — — — — —

**1) mainframe.agent.ts**  
```ts
import { createAgent, AgentContext } from '@helix/core';
import { calculateCasimirEnergy } from './pipeline';
import { run_modeHandler } from './run_mode';

export default createAgent({
  name: "HELIX-CORE",
  
  // Boot and initial state
  onInit: async ({ setState }) => {
    await setState({
      currentMode: "auto-duty",
      activeModules: [],
      modulationFrequencyGHz: 15,
      energyPipeline: {
        exoticMass_kg:  0,
        energyOutput_MW: 0,
        totalCurvature:  0,
        tileStatus:      {}
      },
      presets: {
        "auto-duty": {
          sectors:         400,
          pulseDuration_us: 10,
          cycleDuration_ms:  1,
          modulationFrequencyGHz: 15,
          equations:       "CasimirEnergy = -π²ħcA / (240·a³)",
          engine:          "staticCasimirEnergy"
        },
        "manual-pulse": {
          sectors:        "custom",
          equations:      "CasimirEnergy = -π²ħcA / (240·a³)",
          engine:         "staticCasimirEnergy"
        },
        "diagnostics": {
          equations:      "∇·Tμν = 0, Ford–Roman QI, Δβ=0",
          engine:         "metricViolationScan"
        },
        "theory-playback": {
          documents:     [],
          highlightSync: true
        }
      }
    });
  },

  // Handle incoming commands
  onMessage: async ({ message, getState, setState, send }) => {
    const state = await getState();

    // Mode switching
    if (message.type === "run_mode") {
      const modeName: string = message.mode;
      await run_modeHandler({ modeName, state, setState, send });
    }

    // Module registration
    if (message.type === "register_module") {
      const mods = [...state.activeModules, message.module];
      await setState({ activeModules: mods });
      send({ type: "module_registered", module: message.module.name });
    }
  }
});
```

---

**2) run_mode.ts**  
```ts
import { AgentContext, SendFn } from '@helix/core';
import { calculateCasimirEnergy } from './pipeline';

export async function run_modeHandler(
  { modeName, state, setState, send }:
  { modeName: string; state: any; setState: any; send: SendFn }
) {
  const preset = state.presets[modeName];
  if (!preset) {
    send({ type: 'error', message: `Unknown mode: ${modeName}` });
    return;
  }

  // Load preset into state
  await setState({ currentMode: modeName });

  // Example: auto-duty sequence
  if (modeName === "auto-duty") {
    const { sectors, pulseDuration_us, cycleDuration_ms, modulationFrequencyGHz } = preset;
    // Simulate one cycle
    const gap_nm    = 16;     // example
    const radius_mm = 0.5;    // example
    const E_perTile = calculateCasimirEnergy({ gap_nm, radius_mm });
    const totalE    = E_perTile * sectors;
    const M_exotic  = totalE / (299792458**2);

    // Accumulate into energyPipeline
    const newPipeline = {
      ...state.energyPipeline,
      exoticMass_kg:  M_exotic,
      energyOutput_MW: totalE / 1e6,
    };
    await setState({ energyPipeline: newPipeline });

    send({
      type: 'mode_ran',
      mode: modeName,
      results: { M_exotic, energyMW: totalE / 1e6 }
    });
  }

  // ...handle other modes similarly...
}
```

---

**3) pipeline.ts**  
```ts
// Physical helper functions
export function calculateCasimirEnergy({
  gap_nm,
  radius_mm
}: {
  gap_nm: number;
  radius_mm: number;
}): number {
  const hbar = 1.0545718e-34;      // J·s
  const c    = 299792458;          // m/s
  const hbar_c = hbar * c;         // J·m
  const area   = Math.PI * (radius_mm * 1e-3)**2; // m²
  const gap_m  = gap_nm * 1e-9;    // m

  // E = -π² ħ c·A / (240·a³)
  return -(Math.PI**2 * hbar_c * area) / (240 * gap_m**3);
}
```

---

**4) useModule.tsx**  
```tsx
import { useEffect } from 'react';
import { useAgent } from '@helix/react';

export interface ModuleDescriptor {
  name: string;
  role: string;
  updatesFrom: string[];
}

export function useModuleRegistration(module: ModuleDescriptor) {
  const agent = useAgent();

  useEffect(() => {
    agent.send({
      type: 'register_module',
      module
    });
  }, [agent, module]);
}
```

**Example React Panel**  
```tsx
import React from 'react';
import { useModuleRegistration } from './useModule';

export function MetricHUD() {
  useModuleRegistration({
    name: 'MetricHUD',
    role: 'diagnostic',
    updatesFrom: ['mode_ran', 'energy_update']
  });

  // You’d pull in state via useAgent().select(...) etc.
  return (
    <div className="metric-hud">
      {/* render metrics from agent state */}
    </div>
  );
}
```

— — — — — —

With these three pieces you have:

  • A **HELIX-CORE** agent that boots with your presets  
  • A clean **`run_mode("auto-duty")`** handler wiring pipeline logic → state → events  
  • A **React hook** so any new panel just calls `useModuleRegistration(...)`  

Drop them into Replit, `npm install @helix/core @helix/react chart.js` (etc.), and you’re off to the races. Let me know if you need more detail or extra panels!