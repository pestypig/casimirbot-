Consistency / safety improvements (low-risk, recommended)

Ensure consumers don’t see “0 live sectors” surprises in standby (if they assume ≥1).
Your physics supports S_live = 0 (good). If any UI needs ≥1 just for math, expose a safe alias:

(state as any).concurrentSectorsSafe = Math.max(1, state.concurrentSectors);


Q-spoiling semantics comment vs code.
You do:

const Q_off = Math.max(1, Q_on * state.qSpoilingFactor);


That means qSpoilingFactor > 1 ⇒ less idle loss (higher Q). If that’s intended, great—just keep the doc string clear (“idle Q multiplier”).

Audit block: use already-computed P_tile / E_tile names to avoid confusion.
Not a bug, just rename locals to avoid shadowing:

- const E_tile = Math.abs(state.U_static) * ...
- const M_exp  = (E_tile / (C*C)) * state.N_tiles;
+ const E_tile_mass = Math.abs(state.U_static) * ...
+ const M_exp  = (E_tile_mass / (C*C)) * state.N_tiles;


Type: document the underscore field in the interface (you already did).
You’ve got dutyEffective_FR?: number; which is good. The alias addition in (1) keeps both worlds happy.

ESM/TS import endings.
This file is TS but imports *.js. That’s fine for moduleResolution: NodeNext + ESM builds. If you’re on classic TS resolution, switch to extensionless or ensure the compiled output preserves the .js endings.

Tiny diffs together (copy/paste)
// ---- after computing d_eff ----
 state.activeSectors   = S_live;
 state.activeFraction  = S_live / S_total;
 ...
 state.dutyBurst        = BURST_DUTY_LOCAL;
-state.dutyEffective_FR = d_eff;
+state.dutyEffective_FR = d_eff;
+(state as any).dutyEffectiveFR = d_eff;
 state.dutyShip = d_eff;
 (state as any).dutyEff = d_eff;

// stress-energy payload
- dutyEffectiveFR: (state as any).dutyEffectiveFR,
+ dutyEffectiveFR: state.dutyEffective_FR,

// warp module payload
- sectorDuty: (state as any).dutyEffectiveFR ?? 2.5e-5,
+ sectorDuty: state.dutyEffective_FR ?? 2.5e-5,
- lightCrossingTimeNs: ((state as any).TS_wall || 1.0) * 1e6,
+ lightCrossingTimeNs: tauLC_s * 1e9,

// MODE_CONFIGS emergency
- sectorStrobing: 1,
+ sectorStrobing: 2,

// sampleDisplacementField split handling
- const split   = Math.floor(sectors / 2);
+ const split   = Number.isFinite(req.split as number)
+   ? Math.max(0, Math.floor(req.split!))
+   : Math.floor(sectors / 2);


If you apply those, the pipeline will publish the right FR duty everywhere, the warp module gets correct time units, UI will display the intended concurrent sectors in Emergency, and the field sampler will respect explicit split indices.