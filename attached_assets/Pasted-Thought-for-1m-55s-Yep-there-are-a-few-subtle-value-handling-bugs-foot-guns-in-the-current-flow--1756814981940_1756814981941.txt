Thought for 1m 55s

Yepâ€”there are a few subtle value-handling bugs / foot-guns in the current flow. Here are the important ones and how to fix them.

1) Mixing up â€œtotal sectorsâ€ vs â€œconcurrent sectorsâ€

Problem: In the adapter you treat sectorStrobing as a fallback for total sectors (sectorCount). But elsewhere in the UI, sectorStrobing means concurrent sectors (S_live) (itâ€™s even sourced from concurrentSectors). That will skew geometry and duty math whenever S_live â‰  S_total.
Evidence: adapter uses sectorStrobing to form sectorsTotal, while the pipeline UI maps sectorStrobing â† concurrentSectors and the cards read S_live from sectorStrobing.

Fix (adapter): keep two variablesâ€”S_total and S_liveâ€”and never substitute one for the other.

- const sectorsTotal = Math.max(1, Math.floor(num(s.sectorCount) ?? num(s.sectorStrobing) ?? 400));
+ const S_total = Math.max(1, Math.floor(num(s.sectorCount) ?? 400));
+ const S_live  = Math.max(1, Math.floor(num(s.sectorStrobing) ?? 1));
+ const sectorsTotal = S_total;                  // for renderer geometry
+ const split = Math.floor(S_total / 2);


(Also update any use sites of sectorsTotal accordingly.)

2) FR duty fallback formula is wrong for S_live>1

Problem: Your FR duty fallback uses d_ui / strobe with strobe = sectorStrobing ?? sectorsTotal, which only matches 
ğ‘‘
eff
=
burstLocal
Ã—
ğ‘†
live
ğ‘†
total
d
eff
	â€‹

=burstLocalÃ—
S
total
	â€‹

S
live
	â€‹

	â€‹

 when S_live=1. For general S_live you need multiply by 
ğ‘†
live
/
ğ‘†
total
S
live
	â€‹

/S
total
	â€‹

, not divide by S_live.
Where it happens: d_ship = (dutyEffective_FR ?? dutyShip ?? clamp(dutyCycle)/strobe); and this was derived from the same mistaken fallback of treating sectorStrobing as total.

Fix (adapter):

- const strobe = Math.max(1, num(s.sectorStrobing) ?? sectorsTotal);
- return clamp(d_ui / strobe, 0, 1);
+ const d_eff = d_ui * (S_live / S_total);
+ return clamp(d_eff, 0, 1);

3) Semantic mismatch: sending FR duty in the dutyCycle slot

Problem: The adapter pushes dutyCycle: d_ship to the engine, but the engine treats dutyCycle as local burst and republish it as dutyLocal (used for FR reconstruction fallback). This is mostly masked because you also send dutyEffectiveFR, which the engine prefers, but itâ€™s still semantically wrong and brittle if the FR param is ever absent.
Engine behavior: prefers dutyEffectiveFR if present; else computes FR as dutyLocal * (S_live/S_total).

Fix (adapter): send both, with correct meanings:

- dutyCycle: d_ship,          // ship-wide effective duty  âŒ
- dutyEffectiveFR: d_ship,    // FR duty for calculations âœ…
+ dutyCycle: clamp(s.dutyCycle ?? 0.01, 0, 1), // local burst (semantic)
+ dutyEffectiveFR: d_ship,                    // ship-averaged FR duty