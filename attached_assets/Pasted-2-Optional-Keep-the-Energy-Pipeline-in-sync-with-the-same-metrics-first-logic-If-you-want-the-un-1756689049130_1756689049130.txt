2) (Optional) Keep the Energy Pipeline in sync with the same metrics-first logic

If you want the underlying derived duty to match the panel calc (so other widgets see the same value even without doing their own calc), mirror the same dwell fallback in the pipeline component (we already added sectorPeriod_ms once, but this tightens priority to metrics-first explicitly):

diff --git a/client/src/components/energy-pipeline.tsx b/client/src/components/energy-pipeline.tsx
--- a/client/src/components/energy-pipeline.tsx
+++ b/client/src/components/energy-pipeline.tsx
@@ -92,18 +92,24 @@ const dutyEffectiveFR: number = useMemo(() => {
   if (isFiniteNum(frFromPipeline)) return clamp01(frFromPipeline);
 
   // 1) timing (metrics-first, then live)
-  const burst_ms = Number(
-    (live as any)?.burst_ms ??
-    (systemMetrics as any)?.lightCrossing?.burst_ms
-  );
-  const dwell_ms = Number(
-    (live as any)?.dwell_ms ??
-    (systemMetrics as any)?.lightCrossing?.dwell_ms ??
-    (systemMetrics as any)?.lightCrossing?.sectorPeriod_ms // <-- accept sector dwell
-  );
+  const burst_ms = Number(
+    (systemMetrics as any)?.lightCrossing?.burst_ms ??
+    (live as any)?.burst_ms
+  );
+  const dwell_ms = Number(
+    (systemMetrics as any)?.lightCrossing?.dwell_ms ??
+    (systemMetrics as any)?.lightCrossing?.sectorPeriod_ms ??
+    (live as any)?.dwell_ms ??
+    (live as any)?.sectorPeriod_ms
+  );
   let dutyLocal: number | undefined =
     (Number.isFinite(burst_ms) && Number.isFinite(dwell_ms) && dwell_ms > 0)
       ? burst_ms / dwell_ms
       : undefined;
 
   // 2) mode-local burst fraction as physics default
   const localBurstFrac = Number((live as any)?.localBurstFrac ?? (live as any)?.dutyCycle);
   if (!isFiniteNum(dutyLocal) && isFiniteNum(localBurstFrac)) dutyLocal = clamp01(localBurstFrac);
   if (!isFiniteNum(dutyLocal)) dutyLocal = 0.01; // ultra-conservative fallback
 
   // 3) sectorization (metrics-first)
   const S_total =
     Math.max(1, Math.floor(
-      Number((systemMetrics as any)?.totalSectors) ??
+      Number((systemMetrics as any)?.lightCrossing?.sectorsTotal) ??
+      Number((systemMetrics as any)?.totalSectors) ??
       Number((live as any)?.sectorsTotal) ??
       Number((live as any)?.sectorCount) ?? 400
     ));
   const S_live =
     Math.max(1, Math.min(S_total, Math.floor(
-      Number((live as any)?.sectorsConcurrent) ??
+      Number((systemMetrics as any)?.lightCrossing?.activeSectors) ??
+      Number((systemMetrics as any)?.activeSectors) ??
+      Number((live as any)?.sectorsConcurrent) ??
       Number((live as any)?.concurrentSectors) ?? 1
     )));
 
   return clamp01((dutyLocal as number) * (S_live / S_total));
 }, [live, systemMetrics]);


That’s it. After (1) you should see Duty (FR) ≈ 0.035% on the panel. After (2) the derived cache will match it, so any downstream cards that read ["helix:pipeline:derived"] will also show the same number.