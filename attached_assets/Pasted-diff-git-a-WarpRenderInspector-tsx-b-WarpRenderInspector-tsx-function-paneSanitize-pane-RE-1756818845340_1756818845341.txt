diff --git a/WarpRenderInspector.tsx b/WarpRenderInspector.tsx
@@
-function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
-  return {
-    ...patch,
-    physicsParityMode: pane === 'REAL',
-    parityMode: pane === 'REAL',
-    ridgeMode: pane === 'REAL' ? 0 : 1
-  };
-}
+// Enforcement disabled: passthrough (no parity/ridge forcing)
+function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
+  return { ...patch };
+}
 
@@
-  const verifyEngineStates = () => {
+  const verifyEngineStates = () => {
     const leftState  = (leftEngine.current || {}) as any;
     const rightState = (rightEngine.current || {}) as any;
-    // (kept) visibility logs
+    // (kept) visibility logs
     console.log('REAL ridge:', leftState?.uniforms?.ridgeMode, ' SHOW ridge:',
       rightState?.uniforms?.ridgeMode, '(should be 1)');
     const thL = leftState?.uniforms?.thetaScale;
     const thR = rightState?.uniforms?.thetaScale;
     const thLact = leftState?.uniforms?.thetaScale_actual;
     const thRact = rightState?.uniforms?.thetaScale_actual;
     console.log(
       'Theta scales - REAL:', thL?.toExponential?.(2),
       'SHOW:', thR?.toExponential?.(2),
       ' [engine actual]', thLact?.toExponential?.(2), thRact?.toExponential?.(2)
     );
-
-    // Check for parity violations and attempt gentle correction
-    if (leftState?.uniforms && leftState.uniforms.physicsParityMode !== true) {
-      console.warn('ðŸ”§ REAL parity drift detected in verification - applying correction');
-      leftState.uniforms.physicsParityMode = true;
-      leftState.uniforms.parityMode = true;
-      leftState.uniforms.ridgeMode = 0;
-      gatedUpdateUniforms(leftEngine.current, {
-        physicsParityMode: true,
-        parityMode: true,
-        ridgeMode: 0
-      }, 'client');
-    }
-
-    if (rightState?.uniforms && rightState.uniforms.physicsParityMode !== false) {
-      console.error('SHOW parity violation detected - attempting correction');
-      rightState.uniforms.physicsParityMode = false;
-      rightState.uniforms.parityMode = false;
-      rightState.uniforms.ridgeMode = 1;
-      gatedUpdateUniforms(rightEngine.current, {
-        physicsParityMode: false,
-        parityMode: false,
-        ridgeMode: 1
-      }, 'client');
-    }
+    // Enforcement disabled: no corrections here
   };
 
@@
-          // Initialize with ENFORCED parity mode for REAL
-          const realInitUniforms = {
+          // Initialize (no enforced parity/ridge)
+          const realInitUniforms = {
             exposure: 5.0,
             zeroStop: 1e-7,
-            physicsParityMode: true,
-            parityMode: true, // Explicit fallback
-            ridgeMode: 0,
             colorMode: 2, // Shear proxy for truth view
             lockFraming: true,
             epsilonTilt: epsilonTilt,
             betaTiltVec: betaTiltVecN,
           };
@@
-          // CRITICAL: Force parity directly on uniforms object as backup
-          if (leftEngine.current.uniforms) {
-            leftEngine.current.uniforms.physicsParityMode = true;
-            leftEngine.current.uniforms.parityMode = true;
-            leftEngine.current.uniforms.ridgeMode = 0;
-          }
+          // No direct parity enforcement
 
@@
-          // Add gentle parity correction with debouncing
-          let lastParityCheck = 0;
-          const enforceParityREAL = () => {
-            const now = Date.now();
-            if (now - lastParityCheck < 1000) return;
-            lastParityCheck = now;
-            const U = leftEngine.current?.uniforms;
-            if (U && U.physicsParityMode !== true) {
-              console.warn("ðŸ”§ REAL parity drift detected - applying gentle correction");
-              U.physicsParityMode = true;
-              U.parityMode = true;
-              U.ridgeMode = 0;
-            }
-          };
-          if (leftEngine.current._render) {
-            const originalRender = leftEngine.current._render.bind(leftEngine.current);
-            leftEngine.current._render = function(...args: any[]) {
-              enforceParityREAL();
-              return originalRender(...args);
-            };
-          }
+          // No parity enforcement in render loop
 
@@
-  // Minimal parity lock function to prevent duplicate shader rebuilds
-  function lockPane(engine: any, pane: 'REAL' | 'SHOW') {
-    if (!engine || engine.__locked) return;
-    engine.__locked = true;
-    // enforce at uniform *values* only â€“ no source rebuilds:
-    const forcedParity = (pane === 'REAL');
-    const forcedRidge  = (pane === 'REAL') ? 0 : 1;
-    const enforce = (patch: any = {}) => ({
-      ...patch,
-      physicsParityMode: forcedParity,
-      uPhysicsParity: forcedParity,
-      uRidgeMode: forcedRidge,
-      ridgeMode: forcedRidge
-    });
-    const origUpdate = engine.updateUniforms?.bind(engine);
-    engine.updateUniforms = (p: any) => origUpdate?.(enforce(p));
-    // also set once immediately
-    origUpdate?.(enforce());
-    console.log(`[${pane}] Parity locked: parity=${forcedParity}, ridge=${forcedRidge}`);
-  }
+  // Parity lock disabled (no-op)
+  function lockPane(engine: any, pane: 'REAL' | 'SHOW') { /* no-op */ }
 
@@
-    // Build REAL payload (Fordâ€“Roman parity) - DO NOT include thetaScale here
-    const realPayload = {
+    // Build REAL payload (no parity enforcement) + Î¸ passthrough
+    const pipelineTheta = Number.isFinite(Number(live?.thetaScaleUsed))
+      ? Number(live?.thetaScaleUsed)
+      : (Number.isFinite(Number(live?.thetaScale)) ? Number(live?.thetaScale) : undefined);
+    const realPayload = {
       ...baseShared,
-      physicsParityMode: true,
-      ridgeMode: 0,
       ...realPhys,
       exposure: 5.0,
       zeroStop: 1e-7,
       colorMode: 2, // Shear proxy for truth view
-      lockFraming: true
+      lockFraming: true,
+      thetaScale: (pipelineTheta ?? realPhys.thetaScale ??
+        computeThetaScale(realPhys))
     };
@@
-    // Build SHOW payload (UI boosted) - DO NOT include thetaScale here
-    const showPayload = {
+    // Build SHOW payload (no parity enforcement) + Î¸ passthrough
+    const showPayload = {
       ...baseShared,
-      physicsParityMode: false,
-      ridgeMode: 1,
       ...showPhys,
       exposure: 7.5,
       zeroStop: 1e-7,
       curvatureGainT: 0.70,
       curvatureBoostMax: 40,
       userGain: 1.25,
       colorMode: 1, // Theta mode for visual enhancement
-      lockFraming: true
+      lockFraming: true,
+      thetaScale: (pipelineTheta ?? showPhys.thetaScale ??
+        computeThetaScale({ ...showPhys, gammaVanDenBroeck: showPhys.gammaVanDenBroeck_vis ?? showPhys.gammaVanDenBroeck }))
     };
 
@@
-  // Run verification less frequently and expose to window for debugging
-  useEffect(() => {
-    const interval = setInterval(verifyEngineStates, 5000); // Reduce from 2s to 5s
-    (window as any).__verifyWarpParity = verifyEngineStates;
-    return () => {
-      clearInterval(interval);
-      delete (window as any).__verifyWarpParity;
-    };
-  }, []);
+  // Keep only optional manual verifier hook; no background enforcement
+  useEffect(() => {
+    (window as any).__verifyWarpParity = verifyEngineStates;
+    return () => { delete (window as any).__verifyWarpParity; };
+  }, []);