Here’s a tight patch you can drop into your WarpBubbleCompare.tsx so the two canvases diverge correctly and keep identical framing:

// helpers (put near top of file)
const sameFraming = (hull?: {a:number;b:number;c:number}, gridSpan?: number) => {
  const a = hull?.a ?? 503.5, b = hull?.b ?? 132, c = hull?.c ?? 86.5;
  const s = 1/1200; // same scale used in engine
  return {
    hullAxes: [a,b,c] as [number,number,number],
    axesScene: [a*s, b*s, c*s] as [number,number,number],
    gridSpan: gridSpan ?? Math.max(2.6, Math.max(a*s, b*s, c*s) * 1.35), // match GRID_DEFAULTS
  };
};

function configureReal(e: any, shared: ReturnType<typeof sameFraming>) {
  e.updateUniforms({
    // identical geometry/framing to the SHOW side
    ...shared,
    lockFraming: true,

    // hard “true physics” baseline
    physicsParityMode: true,
    colorMode: 'theta',
    vizGain: 1,
    displayGain: 1,
    curvatureBoostMax: 1,
    curvatureGainT: 0,
    userGain: 1,
    exposure: 3.5,
    zeroStop: 1e-5,

    // no interior tilt in baseline
    epsilonTilt: 0,
    betaTiltVec: [0,0,0],
  });
  e.requestRewarp?.();
}

function configureShow(e: any, shared: ReturnType<typeof sameFraming>, opts?: {
  gainT?: number;         // 0..1
  boostMax?: number;      // ≥1
  vizGain?: number;
  exposure?: number;
  zeroStop?: number;
}) {
  const T        = Math.max(0, Math.min(1, opts?.gainT ?? 0.55));
  const boostMax = Math.max(1, opts?.boostMax ?? 40);
  const dispGain = 1 + T * (boostMax - 1);

  e.updateUniforms({
    ...shared,
    lockFraming: true,           // keep identical camera/frustum

    physicsParityMode: false,
    colorMode: 'theta',
    curvatureGainT: T,
    curvatureBoostMax: boostMax,
    displayGain: dispGain,
    vizGain: opts?.vizGain ?? 1.0,
    exposure: opts?.exposure ?? 6.0,
    zeroStop: opts?.zeroStop ?? 1e-7,
    cosmeticLevel: 10,           // current visual feel
    // (optional) keep whatever tilt you like on the demo side
  });
  e.requestRewarp?.();
}


Then, right after you construct both engines:

// after:
leftEngine.current  = new WarpCtor(leftRef.current);
rightEngine.current = new WarpCtor(rightRef.current);

// ensure no globals can cross-talk in compare view
(window as any).__warp_setGainDec = () => {};      // neutralize global slider
(window as any).__warp_setCosmetic = () => {};

// lock both to the same hull/framing
const shared = sameFraming(props?.hull, props?.gridSpan);

// configure the two views
configureReal(leftEngine.current, shared);
configureShow(rightEngine.current, shared, {
  gainT: 0.55,        // feel free to bind to a UI slider
  boostMax: 40,
  vizGain: 1.0,
  exposure: 6.0,
  zeroStop: 1e-7
});


And when your compare props change (mode, hull, slider, etc.), update them separately instead of piping both through the same adapter:

useEffect(() => {
  if (!leftEngine.current || !rightEngine.current) return;
  const shared = sameFraming(props?.hull, props?.gridSpan);
  configureReal(leftEngine.current, shared);
  configureShow(rightEngine.current, shared, {
    gainT: props.viz?.curvatureGainT ?? 0.55,
    boostMax: props.viz?.curvatureBoostMax ?? 40,
    vizGain: 1.0,
    exposure: props.viz?.exposure ?? 6.0,
    zeroStop: props.viz?.zeroStop ?? 1e-7
  });
}, [props.hull, props.gridSpan, props.viz?.curvatureGainT, props.viz?.curvatureBoostMax, props.viz?.exposure, props.viz?.zeroStop]);


Quick sanity checks: