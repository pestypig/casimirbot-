You’re right to suspect it’s not just “more gain.” Two things are very likely swallowing your tilt effect:
	1.	the Reset button is pushing a bare parameters object back into the engine (which doesn’t include your resolved epsilonTilt / tiltGain), wiping out the uniforms you just sent; and
	2.	inside the WebGL engine the interior-only envelope is probably too narrow or multiplied by the exterior “ring” bell, so the tilt term goes to ~0 through most of the cabin.

Here’s a small, safe patch set that fixes both, keeps mode-based defaults, and makes the effect visible but gentle.

⸻

A) Don’t wipe your tilt uniforms on Reset (React)

File: client/src/components/WarpVisualizer.tsx
Patch: change the reset handler to re-push the resolved uniforms instead of the raw parameters object.

-  const resetView = () => {
-    if (engineRef.current) {
-      // Reset any view parameters if needed
-      engineRef.current.updateUniforms(parameters);
-    }
-  };
+  const resetView = () => {
+    if (!engineRef.current) return;
+    // Reapply the exact uniforms we computed in the last update, not the bare props.
+    const u = engineRef.current.uniforms || {};
+    engineRef.current.updateUniforms({ ...u });
+    if (engineRef.current.requestRewarp) engineRef.current.requestRewarp();
+  };

Why: parameters usually doesn’t carry epsilonTilt, betaTiltVec, tiltGain, vizGain, etc. Resetting with it zeroes the tilt. Copying current uniforms preserves your resolved values.

⸻

B) Make the tilt actually act on the interior (WebGL)

File: client/public/warp-engine-fixed.js
Find where you compute the displacement in _warpGridVertices (the loop over vertices). Add/adjust an interior envelope independent of the exterior “ring” bell, and scale the tilt gently.

// existing values you already compute:
const rho = rhoEllipsoidal(p);           // normalized ellipsoidal radius
const sd  = rho - 1.0;                   // signed distance from shell
const ring = Math.exp(-(sd / w_rho) ** 2);  // exterior bell for the wall

// NEW: interior-only smooth window (C¹), wider and independent of 'ring'
+const w_int = Math.max(3.0 * (this.uniforms?.wallWidth || 0.016), 0.02); // ~few cm in normalized space
+const interior = (() => {
+  // 1 inside the cabin (rho <= 1 - w_int), 0 outside; smooth edge within w_int
+  const t = (1.0 - rho) / Math.max(w_int, 1e-6);
+  // smoothstep(0→1): 3t² − 2t³, clamped
+  const s = Math.max(0, Math.min(1, t));
+  return s * s * (3 - 2 * s);
+})();

// ... your normal vector 'n' and strobing 'sgn' are already computed above

// existing curvature displacement (kept as-is)
let disp = gridK * betaVis * modeAmp * modeViz * ring * sgn * front;

// NEW: interior tilt displacement — do NOT multiply by 'ring'
+const epsTilt   = this.uniforms?.epsilonTilt ?? 0.0;
+const tiltGain  = this.uniforms?.tiltGain ?? 0.25;     // gentle default
+const betaTilt  = this.uniforms?.betaTiltVec || [0, -1, 0];
+// project normal onto "down" and keep sign stable
+const downDot   = (n[0]*betaTilt[0] + n[1]*betaTilt[1] + n[2]*betaTilt[2]);
+// scale small, interior-only, soft-clamped
+let dispTilt = epsTilt * tiltGain * interior * downDot;
+const maxTilt = 0.05;          // <= 5% of nominal radius; tune to taste
+dispTilt = Math.max(-maxTilt, Math.min(maxTilt, dispTilt));

// apply both
vtx[i+0] = p[0] - n[0] * (disp + dispTilt);
vtx[i+1] = p[1] - n[1] * (disp + dispTilt);
vtx[i+2] = p[2] - n[2] * (disp + dispTilt);

Why:
	•	Previously the tilt often rode on the exterior bell (ring), which is ~0 at the cabin, so you never saw it.
	•	The new interior window makes the tilt strong in the cabin and smoothly vanish through the wall.
	•	A gentle tiltGain + maxTilt keeps it visible but not cartoonish.

⸻

C) Make it easy to see & tune (tiny HUD + keyboard)

Still in warp-engine-fixed.js, after you update uniforms, log the key ones:

if (this._diagEnabled) {
  console.log('Tilt uniforms:', {
    epsilonTilt: this.uniforms?.epsilonTilt,
    tiltGain: this.uniforms?.tiltGain,
    betaTiltVec: this.uniforms?.betaTiltVec,
  });
}

And in WarpVisualizer.tsx, keep the on-screen HUD (you already have it) and add quick keys to tweak tiltGain live if you want:

useEffect(() => {
+  const onKey = (e: KeyboardEvent) => {
+    if (!engineRef.current) return;
+    if (e.key === ']') {
+      engineRef.current.uniforms.tiltGain = (engineRef.current.uniforms.tiltGain ?? 0.25) * 1.25;
+      engineRef.current.requestRewarp?.();
+    } else if (e.key === '[') {
+      engineRef.current.uniforms.tiltGain = (engineRef.current.uniforms.tiltGain ?? 0.25) / 1.25;
+      engineRef.current.requestRewarp?.();
+    }
+  };
+  window.addEventListener('keydown', onKey);
+  return () => window.removeEventListener('keydown', onKey);
}, [isLoaded]);


⸻

About Play/Pause vs. accuracy
	•	Play/Pause only starts/stops requestAnimationFrame; it doesn’t change physics or uniforms.
	•	Reset previously re-applied raw parameters, which cleared tilt. The reset patch above preserves your last uniforms.
	•	Accuracy check: if you toggle modes and call requestRewarp (you already do), the deformation should update immediately, regardless of animation state.

⸻

Quick test checklist
	1.	Switch to Standby ⇒ the bubble interior should look flat (tilt fades to 0).
	2.	Switch to Hover ⇒ a subtle interior slope appears (look across the central slice).
	3.	Tap ] a couple times ⇒ the slope becomes more obvious; [ reduces it.
	4.	Click Reset ⇒ the current slope remains (no wipe).
	5.	Toggle Pause ⇒ geometry stays as is (only animation stops).

If any of these don’t happen, tell me which step fails and I’ll adjust the envelope widths or clamp further.