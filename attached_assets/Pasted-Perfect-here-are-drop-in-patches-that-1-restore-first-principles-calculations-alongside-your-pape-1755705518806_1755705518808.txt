Perfect—here are drop-in patches that (1) restore first-principles calculations alongside your “paper-calibrated” display values, and (2) surface a transparent power chain + dual mass values in /api/helix/metrics. I kept everything defensive (no crashes if a field is undefined) and non-breaking (your calibrated UI can stay on by default).

⸻

1) server/energy-pipeline.ts

Goals:
	•	Compute raw power from the physics chain (no targets).
	•	Keep your legacy/calibrated values, but don’t overwrite raw.
	•	Compute raw exotic mass from energy (no hard pin), expose both.
	•	Remove the ad-hoc “0.159” Casimir calibration factor (keep a comment so it’s easy to put back if you truly need finite-conductivity/edge corrections).

*** a/server/energy-pipeline.ts
--- b/server/energy-pipeline.ts
@@
 // ──────────────────────────────────────────────────────────────────────────────
 // Energy pipeline main calculation
 export function calculateEnergyPipeline(state: EnergyPipelineState): EnergyPipelineState {
@@
-  // Step 1: Static Casimir energy
-  state.U_static = calculateStaticCasimir(state.gap_nm, tileArea_m2, state.sag_nm);
+  // Step 1: Static Casimir energy (per tile)
+  // NOTE: Keep this strictly first-principles. If you previously matched a
+  // paper demo with an empirical factor (e.g. 0.159), remove it here and
+  // document finite-conductivity/edge corrections separately.
+  state.U_static = calculateStaticCasimir(state.gap_nm, tileArea_m2, state.sag_nm);
@@
-  // Step 7: Power calculations (calibrated to research targets)
-  // Research targets from Needle Hull Mk 1 papers:
-  // - Hover mode: 83.3 MW for full hull
-  // - Cruise mode: ~7.4 MW for full hull
-  const powerTargets = {
-    hover: 83.3,      // MW
-    cruise: 7.4,      // MW
-    emergency: 297.5, // MW (scaled appropriately)
-    standby: 0        // MW
-  };
-  state.P_avg = powerTargets[state.currentMode] || 83.3; // Default to hover mode target
-  // Calculate raw power loss per tile
-  // The research papers specify ~595 MW peak power for hover mode
-  // This requires calibration to match the expected values
-  const omega = 2 * PI * state.modulationFreq_GHz * 1e9;
-  // Calculate uncalibrated power
-  const P_loss_uncalibrated = Math.abs(state.U_Q * omega / state.qCavity);
-  // Calibration factor to match research target of 595 MW total (0.531 W per tile)
-  // Current calculation gives 0.1084 W/tile, we need 0.531 W/tile
-  // Calibration factor = 0.531 / 0.1084 ≈ 4.9
-  const powerCalibrationFactor = 2.0e-5; // Calibrated to produce 0.531 W per tile
-  state.P_loss_raw = P_loss_uncalibrated * powerCalibrationFactor; // W per tile
+  // Step 7: Power calculations (dual-path: RAW physics vs CALIBRATED display)
+  // RAW chain (first principles):
+  const omega = 2 * PI * (state.modulationFreq_GHz ?? 15) * 1e9;  // rad/s
+  const gammaGeo = state.gammaGeo ?? 26;
+  const geoAmp   = Math.pow(gammaGeo, 3);                         // γ_geo^3
+  const Qmech    = state.qMechanical ?? 1;                         // optional mechanical gain
+  const Qcav     = state.qCavity ?? 1e9;                           // EM cavity Q
+
+  // Per-tile stored energy in the driven mode:
+  const U_mode_tile = Math.abs(state.U_static) * geoAmp * Qmech;   // J / tile
+  // Per-tile instantaneous dissipated power via cavity Q:
+  const P_tile_inst = (omega * U_mode_tile) / Math.max(1, Qcav);   // W / tile
+
+  // Sector aggregation
+  const sectors = Math.max(1, state.sectorStrobing ?? 1);
+  const tilesPerSector = Math.max(1, Math.floor(Math.max(1, state.N_tiles ?? 0) / sectors));
+  const P_sector_inst  = P_tile_inst * tilesPerSector;             // W per active sector
+
+  // Time averaging (burst duty, sector fraction, Q-spoiling)
+  const duty_burst     = state.dutyCycle ?? 0.14;                  // instantaneous duty in sector
+  const activeSectors  = Math.max(1, state.activeSectors ?? 1);    // usually 1
+  const sectorFraction = activeSectors / sectors;                  // e.g., 1/400 in cruise
+  const qSpoil         = state.qSpoilingFactor ?? 1;
+
+  const P_avg_raw_W = P_sector_inst * duty_burst * sectorFraction * qSpoil; // W
+  const P_avg_raw_MW = P_avg_raw_W / 1e6;
+  state.P_avg_raw = P_avg_raw_MW;                                  // expose RAW
+
+  // CALIBRATED (paper-matched) — keep legacy value if requested
+  if (state.modelMode === 'calibrated') {
+    // Preserve whatever you previously put in state.P_avg (e.g., 83.3 MW) if present,
+    // otherwise fall back to RAW so UI never goes empty.
+    state.P_avg = typeof state.P_avg === 'number' ? state.P_avg : P_avg_raw_MW;
+  } else {
+    state.P_avg = P_avg_raw_MW;
+  }
@@
-  // Step 8: Exotic mass calculation (paper-specified exact values)
-  // According to attached file: exoticMassTotal: 1.405e+3 kg (≃1,405 kg)
-  // Use exact paper specification rather than calculated values
-  state.M_exotic = 1405; // kg - exact paper specification
+  // Step 8: Exotic mass calculation (dual-path: RAW vs CALIBRATED)
+  // RAW: convert energy per cycle to mass via E/c^2
+  // Use U_cycle if you already compute it; otherwise derive from U_mode_tile with duty.
+  const c2 = C * C;
+  // Cycle energy per tile (use already-computed U_cycle if available; otherwise proxy)
+  const U_cycle_tile = (typeof state.U_cycle === 'number' && isFinite(state.U_cycle))
+    ? Math.abs(state.U_cycle)
+    : Math.abs(U_mode_tile) * duty_burst; // conservative proxy if U_cycle absent
+
+  const Ntiles = Math.max(1, state.N_tiles ?? 1);
+  const E_cycle_hull = U_cycle_tile * Ntiles;           // J (per cycle)
+  const M_raw = E_cycle_hull / c2;                      // kg
+  state.M_exotic_raw = M_raw;
+
+  if (state.modelMode === 'calibrated') {
+    const baseline = 1405; // kg – paper target
+    state.M_exotic = baseline;
+    state.massCalibration = baseline / Math.max(1e-12, M_raw);
+  } else {
+    state.M_exotic = M_raw;
+    state.massCalibration = 1.0;
+  }
@@
-  // Quantum inequality parameter (Ford-Roman bound)
-  // ζ = 1 / (d × √Q_cavity) where Q_cavity = 1e10
-  // For hover mode: ζ = 1 / (0.14 × √1e10) ≈ 7.1e-5
-  const effectiveDuty = state.dutyCycle * state.qSpoilingFactor * (1 / state.sectorStrobing);
-  const Q_cavity_quantum = 1e10; // Fixed cavity Q for quantum calculations
-  state.zeta = 1 / (effectiveDuty * Math.sqrt(Q_cavity_quantum));
+  // Quantum inequality parameter (Ford–Roman)
+  // Use instantaneous burst duty within the active sector; do NOT divide by sectors here.
+  const Q_quantum = 1e10; // adopted quantum Q for ζ proxy
+  const duty_FR   = Math.max(1e-12, duty_burst); // instantaneous
+  state.zeta = 1 / (duty_FR * Math.sqrt(Q_quantum));
@@
   return state;
 }
 
@@
-function calculateStaticCasimir(gap_nm: number, area_m2: number, sag_nm: number = 16): number {
+function calculateStaticCasimir(gap_nm: number, area_m2: number, sag_nm: number = 16): number {
   // For 5 cm² tile with 1 nm gap, the correct energy is -2.168e-4 J
   const gap_m = gap_nm * NM_TO_M;
   // Volume of the cavity between parallel plates
   const V_cavity = area_m2 * gap_m;
   // Energy density for Casimir effect
   const u_casimir = -(PI * PI * HBAR_C) / (720 * Math.pow(gap_m, 4));
-  // Total static Casimir energy with calibration factor
-  // The raw calculation gives -1.361e-03 J but we need -2.168e-4 J
-  // Calibration factor = -2.168e-4 / -1.361e-03 ≈ 0.159
-  const calibrationFactor = 0.159;
-  const energy = u_casimir * V_cavity * calibrationFactor;
+  // Total static Casimir energy — keep first-principles; if you require
+  // finite-conductivity/edge corrections, document and apply explicitly.
+  const calibrationFactor = 1.0;
+  const energy = u_casimir * V_cavity * calibrationFactor;
   return energy;
 }

What changes for you in the UI right now?
Nothing breaks. If state.modelMode === 'calibrated', your legacy display (e.g., 83.3 MW / 1405 kg) stays. You also get P_avg_raw + M_exotic_raw available for a “Raw physics” toggle.

⸻

2) server/helix-core.ts

Goal: expose the raw vs calibrated values + a transparent power chain in /api/helix/metrics for easy debugging and user education.

*** a/server/helix-core.ts
--- b/server/helix-core.ts
@@
 export function getSystemMetrics(req: Request, res: Response) {
   const state = getGlobalPipelineState();
   res.json({
-    activeTiles: Math.floor(state.N_tiles * 0.78),
-    totalTiles: Math.floor(state.N_tiles),
-    energyOutput: state.P_avg, // MW
-    exoticMass: Math.round(state.M_exotic), // kg
+    // tiles / sectors
+    activeTiles: Math.max(0, Math.floor((state.N_tiles ?? 0) / Math.max(1, state.sectorStrobing ?? 1))),
+    totalTiles: Math.floor(state.N_tiles ?? 0),
+    sectorStrobing: state.sectorStrobing ?? 1,
+    activeSectors: state.activeSectors ?? 1,
+
+    // dual-path energy/mass
+    modelMode: state.modelMode ?? 'calibrated',
+    energyOutput: state.P_avg,               // MW (calibrated or raw depending on mode)
+    energyOutputRaw: state.P_avg_raw ?? null,// MW
+    exoticMass: Math.round(state.M_exotic ?? 0),       // kg (calibrated or raw)
+    exoticMassRaw: Math.round(state.M_exotic_raw ?? 0),// kg
+    massCalibration: state.massCalibration ?? 1,
+
+    // physics cores
+    gammaVanDenBroeck: state.gammaVanDenBroeck ?? null,
+    gammaGeo: state.gammaGeo ?? null,
+    qCavity: state.qCavity ?? null,
+    dutyGlobal: state.dutyCycle ?? null,
@@
     fordRoman: {
       value: state.zeta,
       limit: 1.0,
       status: state.fordRomanCompliance ? "PASS" : "FAIL"
     },
@@
-    curvatureMax: Math.abs(state.U_cycle) / (3e8 * 3e8),
+    curvatureMax: Math.abs(state.U_cycle ?? 0) / (3e8 * 3e8),
     timeScaleRatio: state.TS_ratio,
     overallStatus: state.overallStatus,
+
+    // transparent power chain (for diagnostics/education)
+    P_chain: {
+      omega: 2 * Math.PI * ((state.modulationFreq_GHz ?? 15) * 1e9),
+      U_tile_static: Math.abs(state.U_static ?? 0),
+      gamma_geo3: (state.gammaGeo ?? 26) ** 3,
+      Q_mech: state.qMechanical ?? 1,
+      Q_cavity: state.qCavity ?? 1e9,
+      tilesPerSector: Math.max(1, Math.floor(Math.max(1, state.N_tiles ?? 0) / Math.max(1, state.sectorStrobing ?? 1))),
+      duty_burst: state.dutyCycle ?? 0.14,
+      sectorFraction: (Math.max(1, state.activeSectors ?? 1) / Math.max(1, state.sectorStrobing ?? 1)),
+      qSpoiling: state.qSpoilingFactor ?? 1,
+      P_avg_raw_MW: state.P_avg_raw ?? null
+    }
   });
 }


⸻

Optional (but useful) UI notes
	•	In your client, show a tiny toggle or tooltip:
	•	Raw physics: uses the first-principles chain.
	•	Calibrated to paper: pins to the demo numbers (83.3 MW / 1405 kg) while still showing raw side-by-side.
	•	The new P_chain object lets you print a compact “how this MW number is composed” explainer.

⸻

If anything here collides with a type interface, tell me the exact EnergyPipelineState fields and I’ll adapt the patch verbatim.