1) CPU geometry never re-warps on mode/gain changes

_applyUniformsNow only calls _updateGrid() when it thinks geometry changed, but it checks â€œdid geo change?â€ after youâ€™ve already overwritten this.uniforms, so it almost always evaluates to false. Also, Î¸-scale/gain/boost changes (SHOW vs REAL) donâ€™t trigger any re-warp at all.

Patch

Compute the â€œnew uniformsâ€ first, compare with the previous uniforms, then assign and rebuild:

@@ _applyUniformsNow(parameters) {
-    // Update internal parameters
-    this.currentParams = { ...this.currentParams, ...parameters };
-
-    this.uniforms = {
-      ...this.uniforms,
+    const prev = { ...(this.uniforms || {}) };
+    this.currentParams = { ...this.currentParams, ...parameters };
+
+    // --- build next uniforms without mutating prev ---
+    const nextUniforms = {
+      ...prev,
       // geometry (authoritative)
       hullAxes: [a, b, c],
       axesClip: axesScene,
       gridSpan,
       // camera/framing
       lockFraming,
       cameraZ,
       // visualization / parity
       physicsParityMode: parity,
       ridgeMode,
       colorMode, exposure, zeroStop,
       vizGain,
       curvatureGainT: curvT,
       curvatureBoostMax: curvMax,
       cosmeticLevel: cosmetic,
       // existing fields
       vShip: parameters.vShip || prev.vShip || 1,
       wallWidth: parameters.wallWidth || prev.wallWidth || 0.06,
       driveDir: parameters.driveDir || prev.driveDir || [1,0,0],
       // tilt
       epsilonTilt: parity ? 0 : N(parameters.epsilonTilt || prev.epsilonTilt || 0),
       betaTiltVec: (Array.isArray(parameters.betaTiltVec) && parameters.betaTiltVec.length===3)
                    ? parameters.betaTiltVec
                    : (prev.betaTiltVec || [0,-1,0]),
       tiltGain: prev.tiltGain ?? 0.55,
+      // ðŸ”— physics chain fields used by CPU warp & shader
+      thetaScale: N(parameters.thetaScale, prev.thetaScale ?? 1.0),
+      dutyCycle: N(parameters.dutyCycle, prev.dutyCycle ?? 0.14),
+      sectors: Math.max(1, Math.floor(N(parameters.sectors ?? parameters.sectorCount, prev.sectors ?? 1))),
+      split: Math.max(0, Math.min((prev.sectors ?? 1)-1, N(parameters.split, prev.split ?? 0))),
+      viewAvg: parameters.viewAvg != null ? !!parameters.viewAvg : (prev.viewAvg ?? true),
+      gammaGeo: N(parameters.gammaGeo ?? parameters.g_y, prev.gammaGeo ?? 26),
+      deltaAOverA: N(parameters.deltaAOverA ?? parameters.qSpoilingFactor, prev.deltaAOverA ?? 1),
+      gammaVdB: N(parameters.gammaVdB, prev.gammaVdB ?? 2.86e5),
+      currentMode: parameters.currentMode ?? prev.currentMode ?? 'hover',
     };
-
-    // Only rebuild mesh if geometry actually changed (not for mode switches)
-    const geoChanged = (
-        parameters.hullAxes && (
-            parameters.hullAxes[0] !== this.uniforms.hullAxes[0] ||
-            parameters.hullAxes[1] !== this.uniforms.hullAxes[1] ||
-            parameters.hullAxes[2] !== this.uniforms.hullAxes[2]
-        )
-    ) || (
-        parameters.gridSpan && parameters.gridSpan !== this.uniforms.gridSpan
-    );
-        
-    if (geoChanged) {
-        console.log('[WarpEngine] Geometry changed, rebuilding grid');
-        this._updateGrid();
-    } else if (parameters.currentMode) {
-        console.log('[WarpEngine] Mode change without geometry change - skipping grid rebuild');
-    }
+    // decide if the CPU warp needs recompute
+    const geoChanged =
+      (prev.hullAxes?.[0] !== nextUniforms.hullAxes[0]) ||
+      (prev.hullAxes?.[1] !== nextUniforms.hullAxes[1]) ||
+      (prev.hullAxes?.[2] !== nextUniforms.hullAxes[2]) ||
+      (prev.gridSpan !== nextUniforms.gridSpan);
+
+    const warpKeys = [
+      'thetaScale','userGain','curvatureGainT','curvatureBoostMax',
+      'exposure','zeroStop','physicsParityMode','ridgeMode',
+      'driveDir','wallWidth','epsilonTilt','betaTiltVec','tiltGain',
+      'dutyCycle','sectors','split','gammaGeo','deltaAOverA','gammaVdB',
+      'viewAvg','currentMode'
+    ];
+    const ampChanged = warpKeys.some(k => JSON.stringify(prev[k]) !== JSON.stringify(nextUniforms[k]));
+
+    this.uniforms = nextUniforms;
+    if (geoChanged || ampChanged) {
+      this._updateGrid();
+    } else if (parameters.currentMode) {
+      console.log('[WarpEngine] Mode change applied (no warp needed)');
+    }


Why this fixes it: switching REAL/SHOW or adjusting gain now recomputes the CPU-side displacement buffer, so the grid actually bends.