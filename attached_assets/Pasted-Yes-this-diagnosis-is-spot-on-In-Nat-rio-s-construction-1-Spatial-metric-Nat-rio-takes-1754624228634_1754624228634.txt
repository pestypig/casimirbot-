Yes—this diagnosis is spot on. In Natário’s construction:

1. Spatial metric  
   – Natário takes  
     $$\gamma_{ij}=\delta_{ij},$$  
     and packs all of the shift‐vector “boost” into the lapse and shift of the full 4-metric:  
     $$
       ds^2
       =-\,dt^2+\delta_{ij}\bigl(dx^i-β^i\,dt\bigr)\bigl(dx^j-β^j\,dt\bigr)
       =-\bigl(1-β^2\bigr)dt^2-2β_i\,dx^i\,dt+\delta_{ij}dx^i\,dx^j.
     $$
   If you instead write γᵢⱼ=δᵢⱼ+βᵢβⱼ you’ve illegally grafted the $β_iβ_j\,dt^2$ term onto the purely spatial block.

2. Energy density  
   – The exact (linearised) result is  
     $$
       ρ=T^{tt}=\frac{1}{16\pi}\bigl(|\nabla\times β|^2-|\nabla β|^2\bigr),
     $$  
     which only reduces to  
     $$  
       -\frac{β\cdot\nabla^2β}{8\pi}
     $$  
     under the special assumption that $β$ is purely radial and divergence–free.  In the general Natário bubble you must form the full derivative tensor $\partial_iβ_j$ (or equivalently compute both curl and gradient terms) to recover the correct exotic‐matter shell.

3. Driving the profile  
   – Because both fixes involve spatial derivatives of $β$, your UI sliders should parametrize the radial profile function $β(r)$ (e.g. Natário’s bell profile) rather than simply scaling a fixed vector field.  That way your GPU can take dFdx/dFdy (or finite‐difference taps) and assemble both the lapse/shift corrections and the full $ρ$.

4. Sanity‐check snippet  
   – Computing  
     ```
     vec3 curlB = …;  
     float gradNorm2 = dot(fwidth(betaField),fwidth(betaField));  
     float curlNorm2 = dot(curlB,curlB);  
     float rho = (curlNorm2 - gradNorm2)*0.5/PI;
     ```  
     (with 8πG→1 units so 1/(16π)→0.5/π) will indeed go negative in the bubble wall and vanish outside, matching the exotic‐matter prediction.

Bottom line:  
– Keep γᵢⱼ=δᵢⱼ and put $(1-β^2)$ into the lapse.  
– Use the full $|\nabla\timesβ|^2-|\nablaβ|^2$ form for $ρ$ (unless you strictly enforce a divergence‐free, radial $β$).  
– Drive $β(r)$ from your controls so that your shader can compute the required derivatives on the fly.