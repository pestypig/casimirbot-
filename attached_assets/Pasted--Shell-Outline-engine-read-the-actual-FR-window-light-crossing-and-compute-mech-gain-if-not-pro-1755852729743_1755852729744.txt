) Shell Outline engine: read the actual FR window + light-crossing, and compute mech gain if not provided
What this does

Accept dutyEffectiveFR (burst/dwell) and lightCrossing (so the legend shows τLC, Tsec and a PASS/WARN).

If mechGain isn’t passed, compute it from qMechanical, fMod_Hz, f0_Hz.

Use dutyEffectiveFR instead of (duty/sectors) in gainVis.

Optional: tint/alpha flip to WARN when ζ≥1 (Ford-Roman breach), if you pass zeta.

Patch (minimal diff)
   function OutlineEngine(canvas) {
     this.canvas = canvas;
     this.ctx = canvas.getContext('2d', { alpha: false });
     this.pixelRatio = Math.max(1, window.devicePixelRatio || 1);
     this.params = {
       hullAxes: [0.42, 0.11, 0.09],
       wallWidth: 0.06,
       epsilonTilt: 0.0,
       betaTiltVec: [0, -1, 0],
       // Mode coupling
       mode: 'hover',
       dutyCycle: 0.14,
       sectors: 1,
+      dutyEffectiveFR: undefined,   // ← FR window (burst/dwell)
+      lightCrossing: undefined,     // ← { tauLC_ms, dwell_ms, burst_ms } (shape-agnostic bag)
+      zeta: undefined,              // ← Ford–Roman ζ for HUD tint (optional)
       gammaGeo: 26,
       qSpoil: 1.0,
       qCavity: 1e9,
       // NEW: Mechanical response parameters
       qMechanical: 1,
       fMod_Hz: 15e9,
       f0_Hz: 15e9,
       mechZeta: 0.005,
-      mechGain: 0.0
+      mechGain: undefined          // compute if not provided
     };

   OutlineEngine.prototype.updateUniforms = function (params) {
     const p = Object.assign({}, this.params, params || {});
     ...
     this.params = p;
     this._requestDraw();
   };

   OutlineEngine.prototype._draw = function () {
     const ctx = this.ctx;
     const p   = this.params;
+    const clamp01 = (x) => Math.max(0, Math.min(1, x));

     // Clear
     ...
     const cam = this._camera();

-    const gamma3   = Math.pow(p.gammaGeo ?? 26, 3);
-    const dutyEff  = Math.max(1e-6, (p.dutyCycle ?? 0.14) / Math.max(1, p.sectors ?? 1));
-    const qspoil   = Math.max(1e-3, p.qSpoil ?? 1.0);
-    const gainVis  = Math.pow(gamma3 * qspoil * dutyEff, 0.25);
+    const gamma3  = Math.pow(p.gammaGeo ?? 26, 3);
+    // Prefer authoritative FR window if present; fall back to duty/sectors
+    const dutyEff = Number.isFinite(p.dutyEffectiveFR)
+      ? clamp01(p.dutyEffectiveFR)
+      : Math.max(1e-6, (p.dutyCycle ?? 0.14) / Math.max(1, p.sectors ?? 1));
+    const qspoil  = Math.max(1e-3, p.qSpoil ?? 1.0);
+    const gainVis = Math.pow(gamma3 * qspoil * dutyEff, 0.25);

-    const mechGain = Math.max(0, Math.min(1, p.mechGain ?? 0));
+    // Mechanical response: compute from Q if mechGain not provided
+    let mechGain = p.mechGain;
+    if (!Number.isFinite(mechGain)) {
+      const qMech = Math.max(1e-6, p.qMechanical ?? 1);
+      const zeta  = 1 / (2 * qMech);
+      const f0    = Math.max(1e-12, p.f0_Hz ?? p.fMod_Hz ?? 15e9);
+      const fmod  = Math.max(1e-12, p.fMod_Hz ?? 15e9);
+      const omega = fmod / f0;
+      const denom = Math.sqrt((1 - omega*omega)**2 + (2 * zeta * omega)**2);
+      const Arel  = 1 / denom;         // amplitude ratio at drive
+      mechGain    = clamp01(Arel - 1); // 0..~ (soft normalized)
+    } else {
+      mechGain = clamp01(mechGain);
+    }
     const mechMod  = 1 + 2.5 * mechGain;

-    const modeAlpha =
+    // Mode tint/alpha (flip to warning tint if ζ≥1)
+    const frBreach = Number.isFinite(p.zeta) && p.zeta! >= 1.0;
+    const modeAlpha =
       p.mode === 'standby'   ? 0.40 :
       p.mode === 'cruise'    ? 0.55 :
       p.mode === 'hover'     ? 0.70 :
       p.mode === 'emergency' ? 0.85 : 0.65;

-    const baseColors = {
+    const baseColors = {
-      inner:  [255, 176, 176],
-      center: [200, 208, 220],
-      outer:  [176, 208, 255]
+      // shift palette slightly if FR breach
+      inner:  frBreach ? [255,120,120] : [255,176,176],
+      center:             [200,208,220],
+      outer:  frBreach ? [255,196,120] : [176,208,255]
     };

     // Mini legend with mode indicator
     ctx.globalAlpha = 0.9;
-    ctx.fillStyle = 'rgba(0,0,0,0.6)';
-    ctx.fillRect(12, 12, 240, 76);
+    ctx.fillStyle = 'rgba(0,0,0,0.6)';
+    const legendW = 280, legendH = 96;
+    ctx.fillRect(12, 12, legendW, legendH);
     ctx.fillStyle = '#fff';
     ctx.font = '12px ui-sans-serif, system-ui, -apple-system';
     ctx.fillText(`Shell Outline • ${p.mode?.toUpperCase() || 'HOVER'} mode`, 18, 28);
     ...
     ctx.fillStyle = '#888';
     ctx.font = '10px ui-sans-serif, system-ui, -apple-system';
-    const mechStatus = mechGain > 0.1 ? `IN-BAND` : `off-resonance`;
-    ctx.fillText(`γ³=${gamma3.toExponential(1)} • duty=${(dutyEff*100).toFixed(2)}% • mechanical: ${mechStatus}`, 18, 74);
+    const mechStatus = mechGain > 0.1 ? `IN-BAND` : `off-resonance`;
+    const lc = p.lightCrossing || {};
+    const tauLCs  = Number.isFinite(lc.tauLC_ms) ? `${(lc.tauLC_ms/1000).toFixed(3)}s` : '—';
+    const dwellMs = Number.isFinite(lc.dwell_ms) ? `${lc.dwell_ms.toFixed(2)}ms` : '—';
+    const frTxt   = Number.isFinite(p.zeta) ? `ζ=${p.zeta!.toFixed(3)} ${p.zeta!>=1?'(WARN)':'(PASS)'}` : 'ζ=—';
+    ctx.fillText(`γ³=${gamma3.toExponential(1)} • duty_FR=${(dutyEff*100).toFixed(2)}% • mech:${mechStatus}`, 18, 74);
+    ctx.fillText(`τLC=${tauLCs} • Tsec=${dwellMs} • ${frTxt}`, 18, 88);


Tie-in (you’re already most of the way there): when you instantiate ShellOutlineVisualizer, pass the two extras you already compute in HelixCore: