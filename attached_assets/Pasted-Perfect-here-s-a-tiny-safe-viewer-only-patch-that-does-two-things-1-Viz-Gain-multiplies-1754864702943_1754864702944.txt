Perfect—here’s a tiny, safe “viewer-only” patch that does two things:

1. **Viz Gain:** multiplies the rendered deformation by a user-tunable factor (no physics changed).
2. **York-sign colors:** blue for contraction (−θ) in front, red/orange for expansion (+θ) behind.

You only touch your **grid code**; the orange torus shader can stay as is.

---

# 1) Add two uniforms to your engine state

Somewhere near your other defaults:

```js
// display-only controls (do NOT feed these back into your pipeline math)
this.uniforms.vizGain = this.uniforms.vizGain ?? 4.0;   // how exaggerated the bend looks
this.uniforms.colorByTheta = this.uniforms.colorByTheta ?? 1.0; // 1=York colors, 0=solid sheet color

// if not present already (used for θ)
this.uniforms.vShip = this.uniforms.vShip ?? 1.0;       // ship-frame speed scale for θ
this.uniforms.wallWidth = this.uniforms.wallWidth ?? 0.06;
this.uniforms.axesClip = this.uniforms.axesClip ?? [0.40,0.22,0.22];
this.uniforms.driveDir = this.uniforms.driveDir ?? [1,0,0];
```

---

# 2) Multiply your rendered displacement by vizGain

In `_warpGridVertices(...)`, right before you apply the normal push:

```js
let disp = (U.gridK||0.12) * betaVis * ring * sgn * front;

// NEW: exaggerate for display only (clamped later)
disp *= (U.vizGain ?? 4.0);

// existing clamp (keep!)
const maxPush = 0.10;             // 10% of shell radius
if (disp >  maxPush) disp =  maxPush;
if (disp < -maxPush) disp = -maxPush;

// apply
vtx[i  ] = p[0] - n[0]*disp;
vtx[i+1] = p[1] - n[1]*disp;
vtx[i+2] = p[2] - n[2]*disp;
```

This makes Hover/ Cruise differences pop without touching any pipeline numbers.

---

# 3) Color the grid by York-time sign (shader-only change)

### Replace your **grid vertex shader** with this (only change is passing the model-space position to the fragment):

```glsl
// grid.vert
#ifdef GL_ES
precision highp float;
#endif
attribute vec3 a_position;
uniform mat4 u_mvpMatrix;
varying vec3 v_pos;         // NEW: unprojected position in scene space
void main() {
  v_pos = a_position;
  gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
}
```

### Replace your **grid fragment shader** with this York-aware version:

```glsl
// grid.frag
#ifdef GL_ES
precision highp float;
#endif
uniform float u_colorByTheta;     // 1 = York color; 0 = solid sheet color
uniform vec3  u_sheetColor;       // fallback color
uniform vec3  u_axes;             // ellipsoid radii in clip space
uniform vec3  u_driveDir;         // drive direction (e.g., +x)
uniform float u_wallWidth;        // shell thickness (visual σ ~ 1/w)
uniform float u_vShip;            // scales θ
varying vec3  v_pos;

vec3 diverge(float t) {
  // t in [-1,1]; map to blue-white-red
  float x = clamp((t+1.0)*0.5, 0.0, 1.0);
  // simple 3-point blend: blue -> white -> red
  vec3 c1 = vec3(0.15, 0.45, 1.0);  // blue
  vec3 c2 = vec3(1.0);              // white
  vec3 c3 = vec3(1.0, 0.45, 0.0);   // orange-red
  return mix( x < 0.5 ? mix(c1,c2, x/0.5) : mix(c2,c3,(x-0.5)/0.5), vec3(0.0), 0.0);
}

void main(){
  if (u_colorByTheta < 0.5) {
    gl_FragColor = vec4(u_sheetColor, 0.85);
    return;
  }

  // Ellipsoid-normalized coords
  vec3 pN = v_pos / u_axes;
  float rs = length(pN) + 1e-6;

  // Project onto normalized drive axis (normalize with axes weighting)
  vec3 dN = normalize(u_driveDir / u_axes);
  float xs = dot(pN, dN);

  // Gaussian shell around rs=1
  float w = max(1e-4, u_wallWidth);
  float f = exp(-pow(rs - 1.0, 2.0) / (w*w));
  float dfdrs = (-2.0*(rs - 1.0) / (w*w)) * f;

  // York-time proxy: θ ∝ v_s * (x_s/r_s) * df/dr_s
  float theta = u_vShip * (xs/rs) * dfdrs;

  // clamp for display; keep sign
  float tVis = clamp(theta * 1.0, -1.0, 1.0);

  vec3 col = diverge(tVis);
  gl_FragColor = vec4(col, 0.9);
}
```

### Feed the new uniforms when drawing the grid

In your grid draw routine (where you already set `u_mvpMatrix` and `u_sheetColor`), add:

```js
gl.uniform1f(this.gridUniforms.colorByTheta, this.uniforms.colorByTheta ? 1.0 : 0.0);
gl.uniform3f(this.gridUniforms.axes,  this.uniforms.axesClip[0], this.uniforms.axesClip[1], this.uniforms.axesClip[2]);
gl.uniform3f(this.gridUniforms.driveDir, this.uniforms.driveDir[0], this.uniforms.driveDir[1], this.uniforms.driveDir[2]);
gl.uniform1f(this.gridUniforms.wallWidth, this.uniforms.wallWidth);
gl.uniform1f(this.gridUniforms.vShip, this.uniforms.vShip);
```

…and make sure you cached those locations when compiling the grid program:

```js
this.gridUniforms.colorByTheta = gl.getUniformLocation(this.gridProgram, "u_colorByTheta");
this.gridUniforms.axes         = gl.getUniformLocation(this.gridProgram, "u_axes");
this.gridUniforms.driveDir     = gl.getUniformLocation(this.gridProgram, "u_driveDir");
this.gridUniforms.wallWidth    = gl.getUniformLocation(this.gridProgram, "u_wallWidth");
this.gridUniforms.vShip        = gl.getUniformLocation(this.gridProgram, "u_vShip");
```

---

## How to use it

* Start with `vizGain = 4.0`, `colorByTheta = 1`, `vShip = 1.0`, `wallWidth = 0.06`.
* **Hover**: `phaseSplit = 0.50` → colors nearly symmetric.
* **Cruise**: `phaseSplit ≈ 0.65` → clear **blue front / red rear**; bump `vizGain` if it’s still too subtle.

This keeps your physics math intact, but makes the front-compression / rear-expansion **obvious** at a glance. If you want, I can generate a patched `warp-engine-fixed.js` with these edits baked in so you can drop one file and go.
