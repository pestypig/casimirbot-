Yep—this is almost certainly the engine not honoring (or even seeing) some of the uniforms you’re pushing. Two tiny-but-critical fixes usually clear it up:

make sure we push to both engine APIs (updateUniforms and setParams) and

ship a compat shim so whatever key names the engine expects (old/new) will get set.

Below is a drop-in patch you can apply directly in WarpBubbleCompare.tsx. It does three things:

replaces pushUniformsWhenReady so it always pushes (no “ready” gate), uses both APIs, and retries a few frames,

adds a compatifyUniforms() mapper that sets common synonyms (e.g., curvatureGainT ↔ gainT, sectors ↔ sectorCount, exposure ↔ exposureEV, string color mode → index), and

uses that mapper everywhere you push.

1) Replace pushUniformsWhenReady with this
// --- drop-in replacement ---
function compatifyUniforms(raw: any) {
  const p = { ...(raw || {}) };

  // Color mode: accept string or numeric; provide both keys
  const colorMap: any = { theta: 0, shear: 1, solid: 2 };
  if (typeof p.colorMode === 'string') {
    p.colorModeIndex = colorMap[p.colorMode] ?? 0;
  } else if (Number.isFinite(p.colorMode)) {
    p.colorModeIndex = p.colorMode;
  }

  // Sector/strobe synonyms
  if (Number.isFinite(p.sectors)) {
    p.sectorCount = p.sectorCount ?? p.sectors;
  }
  if (Number.isFinite(p.sectorIdx)) {
    p.currentSector = p.currentSector ?? p.sectorIdx;
    p.sectorIndex   = p.sectorIndex   ?? p.sectorIdx;
  }
  if (Number.isFinite(p.split)) {
    p.sectorSplit = p.sectorSplit ?? p.split;
  }

  // Gain/boost synonyms
  if (p.curvatureGainT != null) {
    p.gainT      = p.gainT      ?? p.curvatureGainT;
    p.thetaGainT = p.thetaGainT ?? p.curvatureGainT;
  }
  if (p.curvatureBoostMax != null) {
    p.boostMax = p.boostMax ?? p.curvatureBoostMax;
  }
  if (p.curvatureGainDec != null) {
    p.gainDec   = p.gainDec   ?? p.curvatureGainDec;
    p.gainDecs  = p.gainDecs  ?? p.curvatureGainDec;
    p.gainDecades = p.gainDecades ?? p.curvatureGainDec;
  }

  // Exposure synonyms
  if (p.exposure != null) {
    p.exposureEV = p.exposureEV ?? p.exposure;
  }

  // Camera synonyms
  if (p.cameraZ != null) {
    p.camZ = p.camZ ?? p.cameraZ;
  }

  // Parity synonyms
  if (p.physicsParityMode != null) {
    p.parityMode = p.parityMode ?? p.physicsParityMode;
    p.isParity   = p.isParity   ?? p.physicsParityMode;
  }

  return p;
}

function pushUniformsWhenReady(engine: any, payload: any, retries = 24) {
  if (!engine) return;
  const bundle = compatifyUniforms(payload);

  const tryPush = () => {
    try { engine.updateUniforms?.(bundle); } catch {}
    try { engine.setParams?.(bundle); }      catch {}
  };

  // push immediately
  tryPush();

  // push again on a few frames (late init, async resize, etc.)
  if (retries > 0) {
    requestAnimationFrame(() => pushUniformsWhenReady(engine, payload, retries - 1));
  }
}