B) Replace the “paper” energy path with pipeline-true math

In calculateDynamicCasimir(params), right after destructuring params, resolve the pipeline values from the second arg you get in calculateDynamicCasimirWithNatario (so we’ll move the actual calculation there—see C). If you must keep this function standalone, add a pipe arg. The simplest: convert calculateDynamicCasimirWithNatario to be the single entry point and inline compute there.

Replace the guts of calculateDynamicCasimirWithNatario(...) with:

export function calculateDynamicCasimirWithNatario(
  params: DynamicCasimirParams,
  simulationParams: SimulationParameters
): DynamicCasimirResult & Partial<NatarioMetricResult> {
  // --- Resolve pipeline values
  const pipe = resolveFromPipeline(simulationParams);
  const { A_total_inst } = computeAmplificationChain(pipe);

  // --- Time domain
  const strokePeriodPs = 1000 / pipe.modulationFreq_GHz;
  const dutyFactor_local = Math.max(0, Math.min(1, params.burstLengthUs / params.cycleLengthUs)); // local burst duty
  // Prefer FR duty (burst/dwell or explicit) for average physics:
  const d_eff = Math.max(0, Math.min(1, pipe.dutyEffectiveFR));

  // --- Static baseline (from static module call above)
  const staticEnergy = Math.abs(params.staticEnergy); // magnitude

  // Instantaneous amplified energy (per cavity/tile-scale quantity as appropriate to your staticEnergy)
  const boostedEnergy = staticEnergy * A_total_inst;

  // Cycle-averaged energy uses FR duty
  const cycleAverageEnergy = boostedEnergy * d_eff;

  // Geometry for densities
  const gap_m = Math.max(1e-12, pipe.gap_nm * PHYSICS_CONSTANTS.NM_TO_M);
  const tileVolume = Math.max(1e-18, pipe.tileArea_m2 * gap_m);
  const exoticEnergyDensity = cycleAverageEnergy / tileVolume;

  // Power (do not use “2 PW/83 MW” targets)
  const f_m = pipe.modulationFreq_GHz * 1e9;
  const T_m = 1 / f_m;
  const instantaneousPower = boostedEnergy / Math.max(1e-12, params.burstLengthUs * 1e-6); // during local burst
  const averagePower = cycleAverageEnergy * f_m; // ⟨E⟩ per cycle times cycles/s

  // Lattice totals (use pipeline N_tiles)
  const E_tile = cycleAverageEnergy;              // per tile/cavity (matches staticEnergy basis)
  const E_total = E_tile * pipe.N_tiles;
  const c2 = PHYSICS_CONSTANTS.C * PHYSICS_CONSTANTS.C;
  const massPerTileComputed = Math.abs(E_tile) / c2;
  const massTotalLatticeReadout = Math.abs(E_total) / c2;

  // Cavity losses (pipeline Q)
  const ω = 2 * Math.PI * f_m;
  const U_geo_like = boostedEnergy; // energy sitting in the effective “amplified” state
  const P_loss = Math.abs(U_geo_like * ω / Math.max(1, pipe.cavityQ)); // simplistic cavity loss model

  // Light-crossing & TS ratio (pipeline hull → τ_LC already supplied)
  const T_LC = Math.max(1e-12, pipe.tauLC_ms * 1e-3);
  const TS_ratio = T_m / T_LC;

  // Compose base dynamic result
  const baseResults: DynamicCasimirResult = {
    strokePeriodPs,
    dutyFactor: dutyFactor_local,   // keep local % for UI
    boostedEnergy,
    cycleAverageEnergy,
    totalExoticMass: massTotalLatticeReadout,
    exoticEnergyDensity,
    quantumInequalityMargin: 0,     // leave 0 or compute with your proper QI bound; remove the HBAR_C/δ^4 toy
    quantumSafetyStatus: 'safe',    // let server/services/target-validation.ts own this
    instantaneousPower,
    averagePower,
    isaacsonLimit: d_eff < 0.1,     // rough check; refine if needed
    greenWaldCompliance: true,      // defer to natario-metric’s GR checks
    averagePowerPerTile: averagePower / pipe.N_tiles,
    averagePowerTotalLattice: averagePower,
    exoticMassPerTile: massPerTileComputed,
    exoticMassTotalLattice: massTotalLatticeReadout,
    energyPipeline: {
      U_static: params.staticEnergy,     // sign-preserving if your static returns signed
      U_Q: params.cavityQ * params.staticEnergy,
      U_geo: boostedEnergy,              // using total amp chain is fine as “effective geometric”
      U_cycle: cycleAverageEnergy,
      P_loss,
      TS_ratio,
      E_tile,
      E_total,
      m_exotic: massTotalLatticeReadout,
      γ_geo: pipe.gammaGeo,
      ω,
      d: d_eff,
      N_tiles: pipe.N_tiles,
      τ_pulse: T_m,
      T_LC,
      powerPerTileComputed: P_loss,
      powerTotalComputed: P_loss * pipe.N_tiles,
      massPerTileComputed
    }
  };

  // Natário metric on **time-averaged** energy (pipeline-true)
  let natarioResults: Partial<NatarioMetricResult> = {};
  try {
    const nat = calculateNatarioMetric(
      {
        ...simulationParams,
        // hand the same knobs the viewers read:
        dynamicConfig: {
          ...(simulationParams.dynamicConfig||{}),
          cavityQ: pipe.cavityQ,
          sectorCount: pipe.sectorStrobing,
          sectorDuty: pipe.dutyCycle,
          pulseFrequencyGHz: pipe.modulationFreq_GHz,
          lightCrossingTimeNs: pipe.tauLC_ms * 1e6
        }
      } as any,
      E_total // total average negative energy (preferred over static)
    );
    const gr = validateGRConsistency(nat);
    natarioResults = {
      stressEnergyT00: nat.stressEnergyT00,
      stressEnergyT11: nat.stressEnergyT11,
      natarioShiftAmplitude: nat.natarioShiftAmplitude,
      sectorStrobingEfficiency: nat.sectorStrobingEfficiency,
      grValidityCheck: nat.grValidityCheck && gr.strategyA,
      homogenizationRatio: nat.homogenizationRatio,
      timeAveragedCurvature: nat.timeAveragedCurvature
    };
  } catch (e) {
    console.warn('Natário metric calculation failed:', e);
  }

  return { ...baseResults, ...natarioResults };
}


That single block removes the paper constants, re-uses the pipeline’s amplification chain, uses FR duty, and feeds the metric the time-averaged lattice energy E_total.

C) Small cleanups elsewhere

Remove “paper target” comments/fields (paperTargetPower, paperTargetMass, etc.). They won’t be referenced anymore.

If anything else in the code expects paperTileCount or “83 MW”, delete those lines or replace with pipeline-computed averagePower.