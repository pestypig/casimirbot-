Short answer: the physics side of the app now “knows” your **needle hull = 1007 × 264 × 173 m**, but the **Natário visual bell** is probably still using a **spherical, fixed-radius** profile in the front-end renderer. That’s why you’re not yet *seeing* the canonical bell wrapped to the ellipsoidal needle—even though the server is already computing with the needle geometry.

Here’s how to tell (and how to fix it so the bell you see is the one you fly).

---

## What “Natário 2002 canonical bell” means in our UI

In our implementation the bell is a scalar envelope $B(\rho)$ that controls the **shift vector** $\boldsymbol{\xi}$ for a **divergence-free** (Natário) flow:

* We evaluate an **ellipsoidal radius**

  $$
  \rho(x,y,z)=\sqrt{\left(\frac{x}{a}\right)^2+\left(\frac{y}{b}\right)^2+\left(\frac{z}{c}\right)^2},
  \quad a=\frac{L_x}{2},\; b=\frac{L_y}{2},\; c=\frac{L_z}{2}
  $$
* The **canonical bell** we use is a $C^\infty$ “bump” that rises inside the bubble and falls through the wall, e.g.

  $$
  B(\rho)=\exp\!\left(-\frac{(\rho-1)^2}{w^2}\right)\;\; \text{(with wall width \(w\ll 1\))}
  $$
* We then build a divergence-free $\boldsymbol{\xi}$ via a vector potential (one simple choice):

  $$
  \boldsymbol{\xi}=\nabla\times\!\big(B(\rho)\,\hat{\boldsymbol{z}}\big)
  $$

  which guarantees $\nabla\cdot\boldsymbol{\xi}=0$ (your “Natário: VALID” badge).

If the renderer is still using **$\rho=\sqrt{x^2+y^2+z^2}/R$** with a hard-coded $R$, you’ll see a *spherical* bell no matter what hull you set.

---

## Quick checklist to see what you have now

1. **Server shows needle geometry?**
   You already have `state.hull = { Lx_m:1007, Ly_m:264, Lz_m:173 }` and TS is computed from `L_long`. ✅

2. **Metrics expose hull → client?**
   The `/api/helix/metrics` payload should include either `hull` or derived semi-axes `a,b,c`. If you don’t see them, we need to add them. (Right now you likely only see TS, power, etc.)

3. **Renderer uses ellipsoidal radius?**
   In `public/warp-engine-fixed.js` (or `warp-simple.js`) look for radius code. If you see:

   ```js
   const r = Math.sqrt(x*x + y*y + z*z);
   const rho = r / R0;
   ```

   that’s spherical. You want:

   ```js
   const rho = Math.sqrt((x/a)**2 + (y/b)**2 + (z/c)**2);
   ```

---

## Minimal wiring to make the bell match the needle

### 1) Add hull to metrics (server)

Expose semi-axes so the client can draw the right bubble.

```ts
// server/helix-core.ts  (inside getSystemMetrics)
const { Lx_m, Ly_m, Lz_m } = state.hull!;
const a = Lx_m / 2, b = Ly_m / 2, c = Lz_m / 2;

res.json({
  // ...existing fields...
  hull: { Lx_m, Ly_m, Lz_m, a, b, c },
  wall: { w_norm: 0.06 } // normalized wall thickness (tune as you like)
});
```

### 2) Use ellipsoidal bell in the renderer

In `public/warp-engine-fixed.js` (or your active viewer), change the bell calculation:

```js
// read once from a config or fetch('/api/helix/metrics')
let a = 503.5, b = 132, c = 86.5; // default; overwrite from metrics.hull
let w = 0.06; // normalized wall width

function bell(rho) {
  // Canonical bell (C∞) centered at rho=1 with width w
  const t = (rho - 1.0) / w;
  return Math.exp(-t*t);
}

function rhoEllipsoidal(x, y, z) {
  return Math.sqrt((x/a)*(x/a) + (y/b)*(y/b) + (z/c)*(z/c));
}

// wherever you compute deformation:
const rho = rhoEllipsoidal(x, y, z);
const B = bell(rho);
// then use B in your Natário shift-vector construction / grid warp
```

### 3) (Optional) Show a quick diagnostic

On the Natário card, display:

* `semi-axes a,b,c` (m)
* `max |∇·ξ|` sampled on the grid (should be ≪ 1 in normalized units)
* wall width $w$ you’re using

That makes it obvious the visual profile matches the 1007×264×173 m needle.

---

## How you’ll know it’s correct

* The bubble outline becomes **elliptical** with the right aspect, not spherical.
* The **divergence badge** remains “VALID” after switching to ellipsoidal $\rho$.
* The **TS card** and the **visual wall thickness** agree: when you narrow $w$, the visual wall narrows, and the power/curvature panels respond accordingly (through your pipeline).

---

## Why it matters

Matching the **display bell** to the **physics hull** keeps the site’s “cockpit” honest: the Natário compliance you see is the Natário flow you fly. It also sets you up to attach engineering tolerances (wall width $w$, pocket gain $\gamma_{\rm VdB}$, strobe duty) to something users can literally *see*.

If you want, I can also add a small **/api/helix/warp-params** endpoint (a clean contract just for the renderer) and a micro “cross-section preview” plot on the Bridge page to show $B(\rho)$ along the long axis—handy for screenshots in a paper or demo.
