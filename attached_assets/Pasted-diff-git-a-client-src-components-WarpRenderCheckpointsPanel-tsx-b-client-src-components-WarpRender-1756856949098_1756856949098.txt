diff --git a/client/src/components/WarpRenderCheckpointsPanel.tsx b/client/src/components/WarpRenderCheckpointsPanel.tsx
--- a/client/src/components/WarpRenderCheckpointsPanel.tsx
+++ b/client/src/components/WarpRenderCheckpointsPanel.tsx
@@ -1,8 +1,7 @@
 "use client";
 import React, {useEffect, useMemo, useRef, useState} from "react";
-import { checkpoint, Check, Side, Stage, within, onCheck } from "@/lib/checkpoints";
-import { thetaScaleExpected } from "@/lib/expectations";
+import { checkpoint, Check, Side, Stage, within, onCheck } from "@/lib/checkpoints";
 import CheckpointViewer from "./CheckpointViewer";
@@
 // tiny helpers
 const N = (x: any, d = 0) => (Number.isFinite(+x) ? +x : d);
 const clamp01 = (x: number) => Math.max(0, Math.min(1, x));
+const aHarmonic = (ax?:number, ay?:number, az?:number) => { const a=+ax||0,b=+ay||0,c=+az||0; const d=(a>0?1/a:0)+(b>0?1/b:0)+(c>0?1/c:0); return d>0?3/d:NaN; };
@@
-// âœ… Pane-specific expected Î¸ using one duty law (âˆšd_FR) and engine authority
+// âœ… Pane-specific expected Î¸ using one duty law (âˆšd_FR), with ENGINE authority
 function expectedThetaForPane(live: any, engine: any) {
   const N = (x:any,d=0)=>Number.isFinite(+x)?+x:d;
 
   // Mode gate
   const mode = String((engine?.uniforms?.currentMode ?? live?.currentMode) || '').toLowerCase();
   if (mode === 'standby') return 0;
 
-  // Prefer values bound to the engine (authoritative for the pane)
-  const gammaGeo = Math.max(1, N(engine?.uniforms?.gammaGeo ?? live?.gammaGeo ?? live?.g_y, 26));
-  const q        = Math.max(1e-12, N(engine?.uniforms?.qSpoilingFactor ?? engine?.uniforms?.deltaAOverA ?? live?.deltaAOverA ?? live?.qSpoilingFactor, 1));
-  const gVdB     = Math.max(1, N(engine?.uniforms?.gammaVdB ?? engine?.uniforms?.gammaVanDenBroeck ?? live?.gammaVanDenBroeck ?? live?.gammaVdB, 1.4e5));
+  // Values bound to the engine (authoritative for the pane)
+  const U = engine?.uniforms || {};
+  const gammaGeo = Math.max(1, N(U.gammaGeo ?? live?.gammaGeo ?? live?.g_y, 26));
+  const q        = Math.max(1e-12, N(U.qSpoilingFactor ?? U.deltaAOverA ?? live?.deltaAOverA ?? live?.qSpoilingFactor, 1));
+  const gVdB     = Math.max(1, N(U.gammaVdB ?? U.gammaVanDenBroeck ?? live?.gammaVanDenBroeck ?? live?.gammaVdB, 1.4e5));
 
   // Duty: prefer the pane's actual d_FR from uniforms/echo; else compute
   const echo = (window as any).__warpEcho;
   const dFR_echo = Number.isFinite(echo?.terms?.d_FR) ? Math.max(1e-12, +echo.terms.d_FR) : NaN;
-  const dFR_u    = Number.isFinite(engine?.uniforms?.dutyEffectiveFR) ? Math.max(1e-12, +engine.uniforms.dutyEffectiveFR) : NaN;
+  const dFR_used = Number.isFinite(U.dutyUsed) ? Math.max(1e-12, +U.dutyUsed) : NaN;
+  const dFR_u    = Number.isFinite(U.dutyEffectiveFR) ? Math.max(1e-12, +U.dutyEffectiveFR) : NaN;
 
   // Fallback from UI knobs only if needed (dutyCycle/sectorCount)
-  const sectorsTotal = Math.max(1, N(live?.sectorCount ?? engine?.uniforms?.sectorCount, 400));
-  const sectorsLive  = Math.max(1, N(engine?.uniforms?.sectors ?? 1, 1));
+  const sectorsTotal = Math.max(1, N(live?.sectorCount ?? U.sectorCount, 400));
+  const sectorsLive  = Math.max(1, N(U.sectors ?? 1, 1));
   const dutyLocal    = 0.01; // from light-crossing loop
   const dFR_fallback = dutyLocal * (sectorsLive / sectorsTotal);
 
-  const dFR = Number.isFinite(dFR_u) ? dFR_u : (Number.isFinite(dFR_echo) ? dFR_echo : dFR_fallback);
+  const dFR = Number.isFinite(dFR_used) ? dFR_used
+            : Number.isFinite(dFR_u)    ? dFR_u
+            : Number.isFinite(dFR_echo) ? dFR_echo
+            : dFR_fallback;
 
   const base = Math.pow(gammaGeo, 3) * q * gVdB;
-  const viewAvg = (engine?.uniforms?.viewAvg ?? live?.viewAvg ?? true) ? 1 : 0;
+  const viewAvg = (U.viewAvg ?? live?.viewAvg ?? true) ? 1 : 0;
   return viewAvg ? base * Math.sqrt(dFR) : base; // (no âˆš term when not averaging)
 }
@@
   return useMemo(() => {
     const { engine: e, canvas: cv } = getCanvasEngine(engineRef, canvasRef); // Use the utility function
     const rows: { label: string; detail?: string; state: "ok" | "warn" | "fail" }[] = [];
     const side: Side = label === "REAL" ? "REAL" : "SHOW";
 
     // ðŸ‘‚ Publish the engine's current physics authority for other UI bits
     publishWarpEcho(e, side, liveSnap);
 
-    // === DAG Stage 1: INPUT CHECKPOINTS ===
-    // Pipeline inputs validation
-    const gammaGeo = N(liveSnap?.gammaGeo ?? liveSnap?.g_y, 26);
-    const deltaAOverA = N(liveSnap?.deltaAOverA ?? liveSnap?.qSpoilingFactor, 1);
-    const gammaVdB = N(liveSnap?.gammaVdB ?? liveSnap?.gammaVanDenBroeck, 1.4e5);
-    const sectors = Math.max(1, Math.floor(N(liveSnap?.sectorCount ?? liveSnap?.sectors, 1)));
-    const duty = N(liveSnap?.dutyCycle, 0);
+    // === DAG Stage 1: INPUT CHECKPOINTS (ENGINE-FIRST) ===
+    // Prefer bound uniforms; fall back to live snapshot for context only.
+    const Ue = (e?.uniforms || {});
+    const gammaGeo = N(Ue.gammaGeo ?? liveSnap?.gammaGeo ?? liveSnap?.g_y, 26);
+    const deltaAOverA = N(Ue.deltaAOverA ?? Ue.qSpoilingFactor ?? liveSnap?.deltaAOverA ?? liveSnap?.qSpoilingFactor, 1);
+    const gammaVdB = N(Ue.gammaVdB ?? Ue.gammaVanDenBroeck ?? liveSnap?.gammaVdB ?? liveSnap?.gammaVanDenBroeck, 1.4e5);
+    const sectors = Math.max(1, Math.floor(N(Ue.sectorCount ?? liveSnap?.sectorCount ?? liveSnap?.sectors, 400)));
+    const duty    = N(Ue.dutyCycle ?? liveSnap?.dutyCycle, 0);
@@
-    // === DAG Stage 2: EXPECTATIONS (Single Source of Truth) ===
-    // Calculate the expected Î¸-scale using canonical formula (RAW, no tone-mapping)
-    const dutyFR = Math.max(1e-12, duty / sectors);
-    const thetaExpected = thetaScaleExpected({
-      gammaGeo: Math.max(1, gammaGeo),
-      q: Math.max(1e-12, deltaAOverA), 
-      gammaVdB: Math.max(1, gammaVdB),
-      dFR: dutyFR
-    });
+    // === DAG Stage 2: EXPECTATIONS (ENGINE AUTHORITY) ===
+    // Calculate expected Î¸-scale using the SAME chain the engine uses (RAW)
+    // Prefer dutyUsedâ†’dutyEffectiveFRâ†’(dutyLocal*sectorsLive/total) as in expectedThetaForPane.
+    const thetaExpected = expectedThetaForPane(liveSnap, e);
+    const dutyFR = (() => {
+      const used = N(Ue.dutyUsed, NaN);
+      if (Number.isFinite(used)) return Math.max(1e-12, used);
+      const de   = N(Ue.dutyEffectiveFR, NaN);
+      if (Number.isFinite(de)) return Math.max(1e-12, de);
+      const sTot = Math.max(1, N(Ue.sectorCount ?? liveSnap?.sectorCount, 400));
+      const sCon = Math.max(1, N(Ue.sectors ?? 1, 1));
+      const dutyLocal = 0.01;
+      return Math.max(1e-12, dutyLocal * (sCon / sTot));
+    })();
 
     checkpoint({
       id: 'expect.theta_scale', side, stage: 'expect',
       pass: Number.isFinite(thetaExpected) && thetaExpected > 0,
       msg: `Î¸_expected=${thetaExpected.toExponential(2)}`,
       expect: '>0', actual: thetaExpected,
       sev: !Number.isFinite(thetaExpected) || thetaExpected <= 0 ? 'error' : 'info',
-      meta: { gammaGeo, q: deltaAOverA, gammaVdB, dFR: dutyFR }
+      meta: { gammaGeo, q: deltaAOverA, gammaVdB, dFR: dutyFR }
     });
@@
-    // NEW: CameraZ presence checkpoint (warn-only so it wonâ€™t halt render)
+    // NEW: CameraZ presence checkpoint (warn-only so it wonâ€™t halt render)
     const camZOk = Number.isFinite(u?.cameraZ);
@@
     // NEW: Informational display-space Î¸ (tone-mapped) â€” for context only
     {
       const exposure   = Math.max(1.0, N(u?.exposure, 6.0));
@@
     rows.push({ label: "Î¸-scale", detail: tsDetail, state: tsState });
 
+    // Metric/tensors actually in use by the shader
+    {
+      const metricActive = (u?.useMetric === true) || (+u?.metricOn > 0.5) || (!!u?.metricMode);
+      const gDiag = Array.isArray(u?.gSpatialDiag) ? u.gSpatialDiag : null;
+      const gSym  = Array.isArray(u?.gSpatialSym)  && u.gSpatialSym.length>=6 ? u.gSpatialSym : null;
+      rows.push({
+        label: "Metric",
+        detail: `${metricActive ? 'ON' : 'off'} Â· g_diag=${gDiag ? `[${gDiag.map((x:number)=>N(x).toFixed(3)).join(', ')}]` : 'â€”'} Â· g_sym=${gSym ? '[â€¦6]' : 'â€”'}`,
+        state: metricActive ? "ok" : "warn"
+      });
+    }
+
+    // Wall width as the renderer uses it (Ï and meters)
+    {
+      const aH = aHarmonic(u?.axesHull?.[0], u?.axesHull?.[1], u?.axesHull?.[2]);
+      const w_rho = Number.isFinite(u?.wallWidth_rho) ? +u.wallWidth_rho : (Number.isFinite(u?.wallWidth) ? +u.wallWidth : NaN);
+      const w_m   = Number.isFinite(u?.wallWidth_m)   ? +u.wallWidth_m   : (Number.isFinite(aH) && Number.isFinite(w_rho) ? w_rho * aH : NaN);
+      rows.push({
+        label: "Wall width",
+        detail: `${Number.isFinite(w_m)? w_m.toFixed(3) : 'â€”'} m â€¢ ${Number.isFinite(w_rho)? w_rho.toExponential(3) : 'â€”'} Ï`,
+        state: (Number.isFinite(w_m) && Number.isFinite(w_rho)) ? "ok" : "warn"
+      });
+    }
+
+    // View forward & lowered shift g0i presence (tensors used by shader)
+    {
+      const vf = Array.isArray(u?.viewForward) ? u.viewForward : null;
+      const g0 = Array.isArray(u?.g0i) ? u.g0i : null;
+      rows.push({
+        label: "Tensors (view/gâ‚€áµ¢)",
+        detail: `${vf ? `[${vf.map((x:number)=>N(x).toFixed(2)).join(', ')}]` : 'â€”'} â€¢ ${g0 ? `[${g0.map((x:number)=>N(x).toFixed(2)).join(', ')}]` : 'â€”'}`,
+        state: (vf && g0) ? "ok" : "warn"
+      });
+    }
+
     // Show detailed breakdown from bound uniforms if available
     if (echo && echo.terms) {
       const terms = echo.terms;
       const breakdown = `src=${echo.src || 'unknown'} v=${echo.v || '?'} Â· Î³_geo=${terms.Î³_geo || '?'}^3 Â· q=${terms.q || '?'} Â· Î³_VdB=${(terms.Î³_VdB || 0).toExponential(2)} Â· d_FR=${((terms.d_FR || 0) * 100).toExponential(2)}%`;
       rows.push({ label: "Î¸ breakdown", detail: breakdown, state: "ok" });
     }
@@
   const dutyLocal = (lightCrossing?.burst_ms && lightCrossing?.dwell_ms)
     ? (lightCrossing.burst_ms / lightCrossing.dwell_ms)    // ~0.01
     : 0.01;                                                 // fallback
 
   const sTotal       = snap?.sectorCount ?? 400;
-  const sConcLeft    = leftEngineRef.current?.uniforms?.sectors  ?? 1;
-  const sConcRight   = rightEngineRef.current?.uniforms?.sectors ?? sConcLeft;
+  const sConcLeft    = leftEngineRef.current?.uniforms?.sectors  ?? 1;
+  const sConcRight   = rightEngineRef.current?.uniforms?.sectors ?? sConcLeft;
   const dutyFR_left  = dutyLocal * (sConcLeft  / sTotal);
   const dutyFR_right = dutyLocal * (sConcRight / sTotal);
@@
       <div className="space-y-1 text-xs">
         <div className="flex justify-between">
           <span className="text-white/70">Î¸-scale expected:</span>
           <span className="font-mono">{
             (() => {
-              const exp = expectedThetaForPane(snap, leftEngineRef.current);
+              const exp = expectedThetaForPane(snap, leftEngineRef.current);
               return Number.isFinite(exp) ? exp.toExponential(2) : 'â€”';
             })()
           }</span>
         </div>
         <div className="flex justify-between">