Yep—let’s make HelixCore, the visualizers, and the new inspector speak the same dialect. Here’s a tiny, surgical patch that:

pushes the same strobing tuple (sectorCount/currentSector/split) to both engines

feeds FR duty into both REAL & SHOW inspector payloads

uses a real current sector for split (instead of concurrentSectors - 1)

adds sectorCount to the inspector’s baseShared so all panels agree

Drop these edits into your HelixCore file:

// 1) Broaden the global to allow 'split' (some engines listen for it)
declare global {
  interface Window {
    setStrobingState?: (args: { sectorCount: number; currentSector: number; split?: number }) => void; // ← CHANGED
  }
}

// 2) When mirroring strobing to the engine mux, include 'split' and use a real index
useEffect(() => {
  const total = Number.isFinite(totalSectors) ? Math.max(1, Math.floor(totalSectors)) : undefined;
  const cs = Number.isFinite(systemMetrics?.currentSector)
    ? Number(systemMetrics!.currentSector)
    : Number(lc?.sectorIdx ?? NaN);
  const fn = (window as any).setStrobingState;

  if (!total || !Number.isFinite(cs) || typeof fn !== "function") return;

  try {
    const cur = Math.max(0, Math.floor(cs)) % total;
    fn({ sectorCount: total, currentSector: cur, split: cur }); // ← CHANGED
  } catch (err) {
    console.warn("setStrobingState threw; skipped this tick:", err);
  }
}, [totalSectors, systemMetrics?.currentSector, lc?.sectorIdx]);

// 3) Warp Render Inspector • pass FR duty to BOTH panes and use a real split
<Suspense fallback={<div className="h-64 grid place-items-center text-slate-400">Loading inspector…</div>}>
  <WarpRenderInspector
    parityPhys={{
      hull: { a: 503.5, b: 132, c: 86.5 },
      gammaGeo: pipeline?.gammaGeo ?? 26,
      qSpoilingFactor: qSpoilUI,
      gammaVanDenBroeck: pipeline?.gammaVanDenBroeck ?? 2.86e5,
      dutyCycle: dutyUI,
      dutyEffectiveFR,                             // ← CHANGED
      sectors: totalSectors,
      split: Math.max(0, Math.min(totalSectors - 1, (systemMetrics?.currentSector ?? lc.sectorIdx ?? 0) % totalSectors)), // ← CHANGED
      sectorCount: totalSectors,
    }}
    showPhys={{
      hull: { a: 503.5, b: 132, c: 86.5 },
      gammaGeo: pipeline?.gammaGeo ?? 26,
      qSpoilingFactor: qSpoilUI,
      gammaVanDenBroeck: pipeline?.gammaVanDenBroeck ?? 2.86e5,
      dutyCycle: dutyUI,
      dutyEffectiveFR,                             // ← CHANGED
      sectors: totalSectors,
      split: Math.max(0, Math.min(totalSectors - 1, (systemMetrics?.currentSector ?? lc.sectorIdx ?? 0) % totalSectors)), // ← CHANGED
      sectorCount: totalSectors,
    }}
    baseShared={{
      hull: { a: 503.5, b: 132, c: 86.5 },
      sectors: totalSectors,
      sectorCount: totalSectors,                   // ← CHANGED (explicit for clarity)
      split: Math.max(0, Math.min(totalSectors - 1, (systemMetrics?.currentSector ?? lc.sectorIdx ?? 0) % totalSectors)), // ← CHANGED
      colorMode: 'theta',
      ridgeMode: 1,
    }}
  />
</Suspense>


That’s it. With this, the engines, inspector, and slice viewer all resolve strobing and duty the same way, and the inspector has the exact FR duty the renderer uses—so if modes don’t bend curvature or a pane goes black, the checkpoints now finger the right stage, every time.