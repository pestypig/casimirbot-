You actually don’t want the heat-map to “snap” to whatever single‐point pipeline just ran—instead it should always be driven by the same underlying analytic viability function that powers your Energy Pipeline and Design Ledger. That way the grid and your live diagnostics are both calling **the same** code, and they’ll never disagree.

Here’s the simplest, bullet-proof wiring:

1) Move your “viability” logic into one pure function  
   sim_core/viability.ts  
   ```ts
   export interface ViabilityMeta {
     ok: boolean
     m_exotic: number
     P_avg: number
     zeta: number
     // …etc
   }
   
   export function viability(tile_cm2: number, ship_m: number): ViabilityMeta {
     // 1) replicate exactly your Energy‐Pipeline math
     //    – compute U_static, U_geo_raw, U_Q, U_cycle, P_loss, TS_ratio
     //    – then m_exotic, P_avg, zeta …
     // 2) ok = check all constraints
     return { ok, m_exotic, P_avg, zeta /*…*/ };
   }
   ```

2) Have **both** your PhaseDiagram **and** your LiveDiagnostics component import and use that same function  
   – In PhaseDiagram’s grid generator:  
     ```ts
     const { ok, m_exotic, P_avg, zeta } = viability(A_vals[j], R_vals[i]);
     Z[i][j] = ok ? 1 : 0;
     metaGrid[i][j] = { m_exotic, P_avg, zeta };
     ```
   – In your live‐diagnostics panel:  
     ```ts
     const { ok, m_exotic, P_avg, zeta } = viability(tileArea, shipRadius);
     ```

3) Never mix in any “shorthand” or two‐stage baseline logic—just call that single `viability(...)` method everywhere.  

By centralizing all the maths into one function:

• Your **heat‐map** is always in lock-step with the **Energy Pipeline**.  
• Your **Design Ledger** and **Live Diagnostics** use the same data.  
• You’ll never see “❌” on the grid and “✅” in diagnostics again.  

If you really need to swap between a “quick approximate grid” (for performance) and the full analytic pipeline, you can still do that by having your grid builder accept an optional `fastMode: boolean` flag. But under the hood both modes should share as much code as possible:

```ts
function buildGrid(fastMode = true) {
  for (…) {
    const meta = fastMode 
      ? viabilityApprox(A,R) 
      : viability(A,R);
    Z[i][j]   = meta.ok ? 1 : 0;
    metaGrid[i][j] = meta;
  }
}
```

And then your PhaseDiagram simply toggles `fastMode` based on whether you’ve run the pipeline once.

But the key is: **one source of truth** for the math. Wire your PhaseDiagram, your pipeline runner, and your ledger all into `viability(…)`, and the whole app will stay perfectly in sync.