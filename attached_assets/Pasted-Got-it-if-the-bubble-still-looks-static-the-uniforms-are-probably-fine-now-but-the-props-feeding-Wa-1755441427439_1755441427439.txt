Got itâ€”if the bubble still looks static, the uniforms are probably fine now but the props feeding WarpVisualizer arenâ€™t changing, or React isnâ€™t telling the engine to refresh. Hereâ€™s a zero-drama â€œrefresh parametersâ€ patch that makes the visual respond every time the operational mode changes.

â¸»

1) Wire a â€œmode change versionâ€ + pass live parameters

File: client/src/pages/helix-core.tsx

Add a tiny version counter that bumps whenever the mode changes (or when fresh pipeline metrics arrive). Then pass a rich parameters object to WarpVisualizer that includes everything the engine uses, plus a visualKey that forces a re-init when key knobs change.

// at top of file
import React from "react";
import { useEnergyPipeline } from "@/hooks/use-energy-pipeline";
import { useQuery } from "@tanstack/react-query";
// ... other imports

export default function HelixCore() {
  // existing hooks
  const { data: pipelineState } = useEnergyPipeline();

  // pull /api/helix/metrics if you have it (optional but helpful)
  const { data: metrics } = useQuery({
    queryKey: ['/api/helix/metrics'],
    refetchInterval: 2000
  });

  // ðŸ”‘ version bump forces remount & uniform push
  const [modeVersion, setModeVersion] = React.useState(0);

  // wherever you switch modes, after the API call completes, bump version:
  // e.g. in your â€œswitch modeâ€ handler success:
  // setModeVersion(v => v + 1);

  // make a stable parameters object from live state
  const vizParams = React.useMemo(() => {
    const ps = pipelineState || ({} as any);
    const m  = metrics || ({} as any);

    const mode      = ps.currentMode || 'hover';
    const duty      = Number(ps.dutyCycle ?? 0.14);
    const sectors   = Number(ps.sectorStrobing ?? 1);
    const qSpoil    = Number(ps.qSpoilingFactor ?? 1);
    const gGeo      = Number(ps.gammaGeo ?? 26);
    const qCav      = Number(ps.qCavity ?? 1e9);
    const gVdB      = Number(ps.gammaVanDenBroeck ?? 2.86e5);

    // hull + wall (meters). If server provides metrics.hull, use it; else defaults.
    const hull = (m && m.hull) ? {
      Lx_m: Number(m.hull.Lx_m ?? 1007),
      Ly_m: Number(m.hull.Ly_m ?? 264),
      Lz_m: Number(m.hull.Lz_m ?? 173),
      a:    Number(m.hull.a    ?? (m.hull.Lx_m ?? 1007)/2),
      b:    Number(m.hull.b    ?? (m.hull.Ly_m ??  264)/2),
      c:    Number(m.hull.c    ?? (m.hull.Lz_m ??  173)/2),
    } : { Lx_m:1007, Ly_m:264, Lz_m:173, a:503.5, b:132, c:86.5 };

    // normalized shell thickness for the engine (fallback to a sane visual)
    const wallWidth_m = Number(m?.wallWidth_m ?? 6.0); // meters (example)
    const wallNorm    = wallWidth_m / Math.max(hull.a, hull.b, hull.c);

    // build the exact knobs WarpEngine reads
    return {
      currentMode: mode,
      dutyCycle: duty,
      sectorStrobing: sectors,   // WarpVisualizer maps this to "sectors"
      qSpoilingFactor: qSpoil,   // â†’ deltaAOverA
      g_y: gGeo,                 // â†’ gammaGeo
      cavityQ: qCav,             // â†’ Qburst
      gammaVanDenBroeck: gVdB,

      hull,                      // hullAxes derived inside WarpVisualizer
      wall: { w_norm: wallNorm },

      // purely visual helpers
      vizGain: 1.0,
      gridScale: 1.0,

      // ðŸ”‘ Any change here should trigger a remount via key:
      visualKey: `${mode}|${duty}|${sectors}|${qSpoil}|${gGeo}|${qCav}|${gVdB}|${wallNorm}|v${modeVersion}`,
    };
  }, [pipelineState, metrics, modeVersion]);

  return (
    // ... your existing layout ...
    <WarpVisualizer
      // ðŸ‘‡ force remount on mode/knob changes
      key={vizParams.visualKey}
      parameters={vizParams}
    />
    // ... rest of page
  );
}

What this does
	â€¢	vizParams is rebuilt whenever pipeline/metrics change or you bump modeVersion.
	â€¢	The key={vizParams.visualKey} forces React to re-mount the canvas/engine when meaningful knobs change (great for stubborn WebGL singletons).
	â€¢	parameters contains exactly the fields the engine uses; your WarpVisualizer patch maps them to the uniform names the engine actually reads (sectors, viewAvg, gammaGeo, Qburst, etc.).

Wherever you call the server to change mode, add setModeVersion(v=>v+1) after success. If your switch function returns onSuccess, put it there.

â¸»

2) Make WarpVisualizer push a full uniform set on every prop change

File: client/src/components/WarpVisualizer.tsx

Ensure you have a useEffect that depends on all the parameters used, and calls engine.updateUniforms(...) (you already have this from earlier), plus a gentle re-warp trigger after pushing uniforms:

React.useEffect(() => {
  if (!engineRef.current || !parameters) return;

  // push uniforms â€“ (this block from the previous fix)
  engineRef.current.updateUniforms({
    currentMode: parameters.currentMode ?? 'hover',
    dutyCycle: parameters.dutyCycle ?? 0.14,
    sectors: parameters.sectorStrobing ?? 1,
    split: Math.floor(((parameters.sectorStrobing ?? 1) / 2)), // mid split
    viewAvg: true,

    gammaGeo: parameters.g_y ?? 26,
    Qburst: parameters.cavityQ ?? 1e9,
    deltaAOverA: parameters.qSpoilingFactor ?? 1,
    gammaVdB: parameters.gammaVanDenBroeck ?? 2.86e5,

    hullAxes: [
      parameters.hull?.a ?? 503.5,
      parameters.hull?.b ?? 132.0,
      parameters.hull?.c ?? 86.5,
    ],
    wallWidth: parameters.wall?.w_norm ?? 0.016,

    vizGain: parameters.vizGain ?? 1.0,
    gridScale: parameters.gridScale ?? 1.0,
  });

  // force a warp with the latest uniforms
  engineRef.current.requestRewarp?.();
}, [parameters, engineRef]);


â¸»

3) Tiny safety in the engine (no-op if uniforms missing)

File: client/public/warp-engine-fixed.js

Right before using uniforms in _warpGridVertices, add:

const U = this.uniforms || {};
const gammaGeo = Number(U.gammaGeo ?? 26);
const qBurst   = Number(U.Qburst   ?? 1e9);
const qSpoil   = Number(U.deltaAOverA ?? 1);
const gammaVdB = Number(U.gammaVdB ?? 1);
const sectors  = Math.max(1, Number(U.sectors ?? 1));
const split    = Math.min(sectors-1, Math.max(0, Number(U.split ?? Math.floor(sectors/2))));
const viewAvg  = !!U.viewAvg;

const hullAxes = Array.isArray(U.hullAxes) && U.hullAxes.length === 3
  ? U.hullAxes.map(Number)
  : [503.5, 132.0, 86.5];

const wallWidth = Number(U.wallWidth);
const w_rho     = Number.isFinite(wallWidth) && wallWidth > 0 ? wallWidth : 0.016;

This prevents the engine from silently falling back to stale internal defaults and guarantees whatever React sent is what gets used for the next warp.

â¸»

How to test quickly
	1.	Open the console and flip modes (hover â†’ cruise â†’ emergency).
	2.	You should see the <WarpVisualizer> remount (new key) and logs like:

ðŸ›° uniforms {
  currentMode:"cruise",
  sectors:400,
  split:200,
  dutyCycle:0.005,
  deltaAOverA:0.625,
  gammaGeo:26,
  Qburst:1e9,
  gammaVdB:286000,
  hullAxes:[503.5,132,86.5],
  wallWidth:0.016,
}

	3.	The bubble should now clearly change magnitude/strobing when you switch modes. If it doesnâ€™t, confirm your mode buttons actually update the pipeline state. If they do, bump modeVersion right after the server confirms the change.

â¸»

If you want, I can also give you a 1-line helper useModeVersion(switchMode) that automatically bumps on onSuccess of your mode API call, so you donâ€™t miss any path.