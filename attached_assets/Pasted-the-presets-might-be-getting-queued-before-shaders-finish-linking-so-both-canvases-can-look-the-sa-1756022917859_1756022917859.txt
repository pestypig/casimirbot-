the presets might be getting queued before shaders finish linking, so both canvases can “look the same” until the first flush. Here’s a small, safe patch that:

adds a per-engine onceReady(fn) hook (fires when shaders are linked),

adds forceRedraw() to rebuild geometry immediately, and

updates __warpInitTruthCosmetic to apply presets after ready so the two viewers visibly diverge.

Drop-in diff:

*** a/warp-engine.js
--- b/warp-engine.js
@@
 class WarpEngine {
     constructor(canvas) {
@@
-        // Loading state management
+        // Loading state management
         this.isLoaded = false;
         this.onLoadingStateChange = null; // callback for loading progress
+        this._readyQueue = [];            // callbacks to run once shaders are linked
@@
     _setLoaded(loaded) {
         this.isLoaded = loaded;
         if (this.onLoadingStateChange) {
             this.onLoadingStateChange({ 
                 type: loaded ? 'ready' : 'loading',
                 message: loaded ? 'Warp engine ready' : 'Initializing...'
             });
         }
+        // Flush once-ready callbacks on first successful link
+        if (loaded && this._readyQueue && this._readyQueue.length) {
+            const q = this._readyQueue.splice(0);
+            for (const fn of q) { try { fn(this); } catch(e){ console.warn(e); } }
+            try { this._render(); } catch {}
+        }
     }
@@
     }
 
+    // Run a callback when the engine is fully ready (shaders linked)
+    onceReady(fn) {
+        if (this.isLoaded && this.gridProgram) {
+            try { fn(this); } catch(e){ console.warn(e); }
+        } else {
+            this._readyQueue.push(fn);
+        }
+    }
+
+    // Public: force a geometry rebuild + immediate draw
+    forceRedraw() {
+        try { this._updateGrid(); this._render(); } catch(e){ console.warn('forceRedraw:', e); }
+    }
+
@@
 globalThis.__warpInitTruthCosmetic = function initPair(opts = {}) {
   const q = (x) => (typeof x === 'string' ? document.querySelector(x) : x);
   const truthEl    = q(opts.truth)    || document.getElementById('viewer-truth');
   const cosmeticEl = q(opts.cosmetic) || document.getElementById('viewer-cosmetic');
   if (!truthEl && !cosmeticEl) {
     console.warn('[warp-engine] no truth/cosmetic canvases found');
     return {};
   }
 
   const engines = {};
   // Truth-only viewer (physics-faithful)
   if (truthEl) {
     const e = new WarpEngine(truthEl);
     const id = truthEl.id || 'viewer-truth';
     e.__id = id;
     (globalThis.__warp || (globalThis.__warp = {}))[id] = e;
     e.bootstrap(opts.paramsTruth || {});
-    e.setPresetParity();      // <- TRUTH MODE
+    e.onceReady(() => {
+      e.setPresetParity();                                  // TRUTH MODE
+      // Make the difference obvious at a glance (optional, can remove):
+      e.updateUniforms({ colorMode: 2, ridgeMode: 0 });     // shear palette + physics double-lobe
+      e.forceRedraw();
+      console.log('[warp] truth ready');
+    });
     engines.truth = e;
   }
 
   // Cosmetic/showcase viewer (visually exaggerated)
   if (cosmeticEl) {
     const e = new WarpEngine(cosmeticEl);
     const id = cosmeticEl.id || 'viewer-cosmetic';
     e.__id = id;
     (globalThis.__warp || (globalThis.__warp = {}))[id] = e;
     e.bootstrap(opts.paramsCosmetic || {});
-    e.setPresetShowcase();    // <- COSMETIC MODE
+    e.onceReady(() => {
+      e.setPresetShowcase();                               // COSMETIC MODE
+      e.updateUniforms({ colorMode: 1, ridgeMode: 1 });    // theta diverging + single crest
+      e.forceRedraw();
+      console.log('[warp] cosmetic ready');
+    });
     engines.cosmetic = e;
   }
@@
   cosmeticEl && ro.observe(cosmeticEl.parentElement || cosmeticEl);
   return engines;
 };