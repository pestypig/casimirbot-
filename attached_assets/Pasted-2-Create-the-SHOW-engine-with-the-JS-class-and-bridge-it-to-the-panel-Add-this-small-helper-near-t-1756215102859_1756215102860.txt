2) Create the SHOW engine with the JS class and bridge it to the panel

Add this small helper near the top (with your other helpers):

// -- SHOW checkpoints binder: exports a full snapshot every frame
function bindShowCheckpoints(engine: any, canvas: HTMLCanvasElement) {
  const publish = () => {
    const u = engine?.uniforms || {};
    const floats = (engine?.gridVertices?.length || 0);
    const snap = {
      // canvas / GL
      canvasW: canvas?.width || 0,
      canvasH: canvas?.height || 0,
      hasGL: !!engine?.gl,

      // readiness
      programReady: !!engine?.gridProgram,
      isLoaded: !!engine?.isLoaded,

      // critical fields the panel cares about
      cameraZSet: Number.isFinite(u?.cameraZ || null),
      axesClipSet: Array.isArray(u?.axesClip) && u.axesClip.length === 3,
      thetaValid: Number.isFinite(u?.thetaScale) && (u.thetaScale as number) > 0,

      // runtime viz
      parity: !!u?.physicsParityMode,
      ridgeMode: (u?.ridgeMode ?? undefined),
      toneExp: u?.exposure ?? 0,
      toneZero: u?.zeroStop ?? 0,

      // grid + sectoring
      gridFloats: floats,                       // total vertex floats
      sectors: Math.max(1, (u?.sectors|0) || 1),
      sectorTotal: Math.max(1, (u?.sectorCount|0) || (u?.sectors|0) || 1),
      split: Math.max(0, (u?.split|0) || 0),

      // loop
      running: !!engine?._raf,
      ts: Date.now(),
    };

    // Expose to devtools and a UI listener (if the panel listens)
    (window as any).__chkSHOW = snap;
    try {
      window.dispatchEvent(new CustomEvent('helix:show-checkpoints', { detail: snap }));
    } catch {}
    // Also ship full diagnostics if available
    try {
      (window as any).__diagSHOW = engine?.computeDiagnostics?.() || null;
    } catch {}
  };

  // fire on every diagnostics beat & on loading state changes
  engine.onDiagnostics = () => publish();
  engine.onLoadingStateChange = () => publish();
  publish(); // kick once now
}


Then, in your main mount effect, always create SHOW from the JS class and bind:

useEffect(() => {
  const W: any = (window as any).WarpEngine;
  if (!W) { console.error("WarpEngine not found on window. Load warp-engine.js first."); return; }

  // REAL (unchanged)
  if (leftRef.current && !leftEngine.current) {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    leftRef.current.width  = Math.max(1, Math.floor((leftRef.current.clientWidth  || 800) * dpr));
    leftRef.current.height = Math.max(1, Math.floor((leftRef.current.clientHeight || 450) * dpr));
    leftEngine.current = W.getOrCreate?.(leftRef.current) || new W(leftRef.current);
    leftOwnedRef.current = true;
    gatedUpdateUniforms(leftEngine.current, { exposure: 5.0, zeroStop: 1e-7 }, 'mute');
    leftEngine.current?.setVisible?.(false);
    lockPane(leftEngine.current, 'REAL');
  }

  // SHOW â€” use plain WarpEngine (fast path), not the TSX wrapper
  if (rightRef.current && !rightEngine.current) {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    rightRef.current.width  = Math.max(1, Math.floor((rightRef.current.clientWidth  || 800) * dpr));
    rightRef.current.height = Math.max(1, Math.floor((rightRef.current.clientHeight || 450) * dpr));
    rightEngine.current = W.getOrCreate?.(rightRef.current) || new W(rightRef.current);
    rightOwnedRef.current = true;
    gatedUpdateUniforms(rightEngine.current, { exposure: 5.0, zeroStop: 1e-7 }, 'mute');
    rightEngine.current?.setVisible?.(false);
    lockPane(rightEngine.current, 'SHOW');

    // attach SHOW checkpoints so the panel/devtools get live data
    bindShowCheckpoints(rightEngine.current, rightRef.current);
  }

  // parity hard-locks (keep)
  if (leftEngine.current)  hardLockUniforms(leftEngine.current,  { forceParity: true,  tag: 'REAL' });
  if (rightEngine.current) hardLockUniforms(rightEngine.current, { forceParity: false, tag: 'SHOW' });

  // bootstrap both
  leftEngine.current?.bootstrap({ ...realPayload });
  rightEngine.current?.bootstrap({ ...showPayload });

  leftEngine.current?.onceReady?.(() => {
    const ax = leftEngine.current?.uniforms?.axesClip;
    const cz = compactCameraZ(ax);
    gatedUpdateUniforms(leftEngine.current, { cameraZ: cz, lockFraming: true }, 'inspector-left-init');
  });

  rightEngine.current?.onceReady?.(() => {
    // seed axes/camera immediately so buffers build and checkpoints flip to "set"
    const hull = props.baseShared?.hull ?? { a:503.5, b:132, c:86.5 };
    const ax = deriveAxesClip(hull, 1);
    const cz = compactCameraZ(ax);
    gatedUpdateUniforms(rightEngine.current, { axesClip: ax, cameraZ: cz, lockFraming: true }, 'inspector-right-init');
  });

  // (listeners/cleanup unchanged) ...
}, []); // keep your deps suppression
