2) Harden ensureWarpEngineCtor (donâ€™t inject if a tag already exists)

Use a single-flight promise, wait on an existing tag, and only inject if nothing is present.

let __warpCtorPromise: Promise<any> | null = null;

async function ensureWarpEngineCtor(forceReload=false) {
  // If already available, return immediately
  if (!forceReload && (window as any).WarpEngine) return (window as any).WarpEngine;
  if (!forceReload && __warpCtorPromise) return __warpCtorPromise;

  __warpCtorPromise = (async () => {
    // 1) If an engine tag already exists, wait for it instead of injecting
    const existing = [...document.getElementsByTagName('script')]
      .find(s => /\/warp-engine\.js(\?|$)/.test(s.src));

    if (existing && !(window as any).WarpEngine) {
      await new Promise<void>((resolve, reject) => {
        const poll = setInterval(() => {
          if ((window as any).WarpEngine) { clearInterval(poll); resolve(); }
        }, 50);
        existing.addEventListener('error', () => { clearInterval(poll); reject(new Error('warp-engine.js failed to load')); });
        // If it was already loaded, resolve quickly
        if ((window as any).WarpEngine) { clearInterval(poll); resolve(); }
      });
      return (window as any).WarpEngine;
    }

    // 2) No tag? Then (and only then) inject
    if (!existing) {
      const src = `/warp-engine.js?v=${encodeURIComponent((window as any).__APP_WARP_BUILD || 'dev')}`;
      await new Promise<void>((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous';
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(s);
      });
    }

    if (!(window as any).WarpEngine) throw new Error('WarpEngine did not attach to window');
    return (window as any).WarpEngine;
  })();

  try {
    return await __warpCtorPromise;
  } finally {
    if (forceReload) __warpCtorPromise = null;
  }
}