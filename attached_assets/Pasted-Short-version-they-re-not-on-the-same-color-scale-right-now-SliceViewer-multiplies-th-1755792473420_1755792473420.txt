Short version: they’re **not on the same color scale right now**.

* **SliceViewer** multiplies the York-time proxy θ by the full “viewer amplitude chain”
  `A = γ_geo^3 · (ΔA/A) · γ_VdB · (viewAvg ? √(duty/sectors) : 1)`
  and then maps it with a **symmetric log**:
  `x = sign(θA) · log10(1 + |θA|/zeroStop) / log10(1 + exposure)` → fed to the blue↔white↔orange diverging palette.

* **3D Visualizer shader** colors by **raw θ only** (no amplitude chain, no symmetric log):
  `theta = u_vShip * (xs/rs) * dfdrs;` → `tVis = clamp(theta, -1, 1)` → diverging palette.
  (You already declare `u_exposure`/`u_zeroStop`, but the fragment shader doesn’t use them.)

So the slice “bands” are denser and mode-separated because of the log + amplitude chain, while the 3D visualizer shows a gentler single-band profile and clamps early.

---

## Make both match (minimal patch)

Unify the color scalar in the shader to the SliceViewer formulation. Do the amplitude math on CPU and pass a single uniform `u_thetaScale`.

**1) Add a uniform to the fragment shader and actually use exposure/log:**

```glsl
// + in both WebGL2 and WebGL1 shader variants
uniform float u_thetaScale;   // = γ^3 · (ΔA/A) · γ_VdB · (avg? √(duty/sectors):1)
uniform float u_exposure;     // already declared
uniform float u_zeroStop;     // already declared

// ... after computing float theta = u_vShip * (xs/rs) * dfdrs;

float val = theta * u_thetaScale;

// symmetric log to [-1,1], same as SliceViewer
float denom = log2(10.0) * log(1.0 + max(1.0, u_exposure));  // == log(10)*(...)
float mag   = log(1.0 + abs(val) / max(u_zeroStop, 1e-18));
float signed = (val < 0.0 ? -1.0 : 1.0) * (mag / denom);

// replace the old line:
float tVis = clamp(signed, -1.0, 1.0);
```

**2) Pass `u_thetaScale` from JS exactly like SliceViewer builds `amp`:**

```js
// when setting uniforms before draw:
const gammaGeo = this.uniforms?.gammaGeo ?? 26;
const qSpoil   = this.uniforms?.deltaAOverA ?? this.uniforms?.qSpoilingFactor ?? 1.0;
const gammaVdB = Math.max(1.0, this.uniforms?.gammaVdB ?? 3.83e1);
const duty     = Math.max(0, Math.min(1, this.uniforms?.dutyCycle ?? 0.14));
const sectors  = Math.max(1, this.uniforms?.sectors ?? 1);
const viewAvg  = (this.uniforms?.viewAvg ?? true) ? Math.sqrt(duty / sectors) : 1.0;

const thetaScale = Math.pow(gammaGeo, 3) * Math.max(1e-12, qSpoil) * gammaVdB * viewAvg;

gl.uniform1f(this.gridUniforms.thetaScale, thetaScale);
gl.uniform1f(this.gridUniforms.exposure, this.uniforms?.exposure ?? 6.0);
gl.uniform1f(this.gridUniforms.zeroStop, this.uniforms?.zeroStop ?? 1e-9);
```

(You’ll also need to cache the new uniform location:)

```js
this.gridUniforms.thetaScale = gl.getUniformLocation(this.gridProgram, 'u_thetaScale');
```

**3) Keep the wall width consistent.**
Both views should use the same **ρ-space wall width**: set the shader’s `u_wallWidth` to the same `w_rho` you compute on the CPU (you already do this at the end of `_warpGridVertices`).

---

## Result

* Contraction (blue) and expansion (orange) now follow the **same symmetric-log scale** and react to **mode changes** the same way in both the slice and the 3D view.
* The visible “band” thickness across the wall matches because both use the same `w_ρ`.
* If you enable `diffMode` in the slice, the 3D view will still show absolute θ unless you also add a baseline scale `u_thetaScaleRef` and color by `theta*(scale - scaleRef)`; that’s optional and easy to add later.

If you want, I can hand you a tiny inline patch that applies these exact diffs to your current file.
