Great‚Äîsince you‚Äôve got Physics Parity Debug Mode working, here‚Äôs a clean way to make the Curvature Gain slider fade the same visual boost in the 3D engine (and guarantee true-physics = 1√ó when boosts are disabled).

What we want

Parity ON: everything is physics-only ‚Üí exactly 1√ó regardless of slider.

Parity OFF: slider (0‚Äì8) maps smoothly to a visual multiplier in the one place where boosts live.

Same boost path is used by both SliceViewer and 3D engine; no secret extra multipliers.

1) One visual boost, applied once (post-physics)

In warp-engine-fixed.js (where uniforms are computed), add a single visual boost uniform that multiplies the already physical chain:

// ---- existing physics chain (do not change) ----
const A_geoUniform    = gammaGeoUniform * gammaGeoUniform * gammaGeoUniform; // Œ≥_geo^3
const effDutyUniform  = viewAvgUniform ? Math.max(1e-12, dutyCycleUniform / Math.max(1, sectorsUniform)) : 1.0;
const betaInstUniform = A_geoUniform * QburstUniform * gammaVdBUniform * qSpoilUniform;
const betaAvgUniform  = betaInstUniform * Math.sqrt(effDutyUniform);
const betaUsedUniform = viewAvgUniform ? betaAvgUniform : betaInstUniform;

// ---- new: *single* visual-only multiplier injected AFTER physics ----
function mapDecadesToBoost(dec, maxBoost) {
  // dec ‚àà [0,8] ‚Üí 1..maxBoost, geometric interpolation (smooth, scale-free)
  const t = Math.max(0, Math.min(1, dec / 8));
  return Math.exp(Math.log(Math.max(1, maxBoost)) * t);
}

// These two come in as uniforms or props from React:
const physicsParityOn   = !!physicsParityUniform;     // true/false
const gainDec           = Number.isFinite(curvatureGainDecUniform) ? curvatureGainDecUniform : 0;
const boostMax          = Math.max(1, curvatureBoostMaxUniform || 1);

// When parity is on ‚Üí force 1√ó; otherwise map 0..8 to 1..boostMax
const visualBoostUniform = physicsParityOn ? 1 : mapDecadesToBoost(gainDec, boostMax);

// Final viz field used by vertex/color shaders (visual-only; physics chain intact)
const betaVizUniform = betaUsedUniform * visualBoostUniform;

// (Optionally expose for HUD / debug throttled log)
console.debug("[Œ≤ chain]",
  { betaUsedUniform, visualBoostUniform, betaVizUniform, gainDec, boostMax, physicsParityOn }
);


Why here? This guarantees any ‚Äúextra curvature‚Äù is only from this single knob. With parity ON, visualBoostUniform = 1, so you render authentic 1√ó physics.

2) Drive both SliceViewer & 3D from the same slider

In your React props to WarpVisualizer, pass only the decade value and max; don‚Äôt call the global __warp_setGainDec anymore.

<WarpVisualizer
  parameters={{
    // physics‚Ä¶
    gammaGeo: pipeline?.gammaGeo ?? 1,
    gammaVanDenBroeck: pipeline?.gammaVanDenBroeck ?? 1,
    qSpoilingFactor: qSpoilUI,
    dutyCycle: dutyUI,
    sectorStrobing: sectorsUI,
    // visual boost (shared with SliceViewer semantics)
    curvatureGainDec: curvatureGain,                     // 0..8 from your slider
    curvatureBoostMax: physicsParity ? 1 : 40,           // 1√ó in parity; 40√ó otherwise
    physicsParity: physicsParity,                        // new flag down to engine
    // remove any legacy visual gain hooks:
    // DO NOT call (window as any).__warp_setGainDec
  }}
/>


And keep the SliceViewer using the same curvatureGainDec/curvatureBoostMax mapping (or reuse mapDecadesToBoost on the CPU side if it needs the numeric factor). This way the slider‚Äôs meaning is consistent across both.

3) Fix your current slider root (remove hidden defaults)

Your current snippet:

curvatureGain: (() => {
  const gain = Number.isFinite(parameters.curvatureGainDec) ? +parameters.curvatureGainDec! : 3;
  console.log(`üéõÔ∏è CURVATURE GAIN DEBUG: parameters.curvatureGainDec=${parameters.curvatureGainDec}, resolved gain=${gain}`);
  return gain;
})(),
curvatureBoostMax: Math.max(1, Number(parameters.curvatureBoostMax) || 40),


Change to:

Default decades to 0 (true physics) instead of 3.

When parity is ON, force curvatureBoostMax = 1.

curvatureGainDec: (() => {
  const gain = Number.isFinite(parameters.curvatureGainDec) ? +parameters.curvatureGainDec! : 0; // 0 = 1√ó
  console.log(`üéõÔ∏è CURVATURE GAIN DEBUG: curvatureGainDec=${parameters.curvatureGainDec}, resolved=${gain}`);
  return Math.max(0, Math.min(8, gain));
})(),
curvatureBoostMax: physicsParity ? 1 : Math.max(1, Number(parameters.curvatureBoostMax) || 40),
physicsParity, // pass the flag down


This ensures ‚Äúvisual boosts disabled = authentic physics‚Äù with no hidden 3√ó default.

4) Sanity assertions (dev-only)

Add these in the engine update loop:

if (physicsParityOn) {
  console.assert(visualBoostUniform === 1, "Parity ON but visualBoost ‚â† 1");
}
if (curvatureBoostMaxUniform < 1) {
  console.warn("curvatureBoostMax < 1; clamping to 1");
}

5) Recap: what happens at 1√ó?

With parity ON ‚Üí visualBoostUniform = 1, and the 3D visualizer shows the same Œ≤ used for physics:
Œ≤_viz = Œ≤_used = Œ≥_geo^3 ¬∑ Œ≥_VdB ¬∑ Q_burst ¬∑ q_spoil ¬∑ (‚àöd_eff if avg).

With parity OFF, slider 0..8 smoothly fades from 1√ó up to your chosen curvatureBoostMax (default 40√ó), only in the visual layer.

This keeps the physics chain pristine, gives you an intuitive fade, and guarantees the ‚Äúauthentic 1√ó‚Äù display any time boosts are disabled.