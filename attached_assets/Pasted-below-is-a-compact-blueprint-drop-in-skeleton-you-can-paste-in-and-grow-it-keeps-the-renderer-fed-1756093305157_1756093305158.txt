below is a compact blueprint + drop-in skeleton you can paste in and grow. it keeps the renderer fed (REAL vs SHOW parity) while making the backend strictly equation-first.

the minimal “baseline pack”
1) single-source constants & units

use SI everywhere; convert at the edges.

one place for ℏ, c, π, and unit scalars.

// core/phys/const.ts
export const PI = Math.PI;
export const C = 299_792_458;             // m/s
export const HBAR = 1.054_571_817e-34;    // J·s
export const HBAR_C = HBAR * C;           // J·m
export const NM = 1e-9, CM2 = 1e-4;

2) geometry: ellipsoid helpers (renderer parity)
// core/geom/ellipsoid.ts
export type Axes = { a:number; b:number; c:number }; // semi-axes in meters

export const areaKnudThomsen = (a:number,b:number,c:number) => {
  const p = 1.6075;
  const t = (x:number,y:number)=>Math.pow(x*y,p);
  return 4*PI*Math.pow((t(a,b)+t(a,c)+t(b,c))/3,1/p);
};

export const rho = (p:[number,number,number], ax:Axes) =>
  Math.hypot(p[0]/ax.a, p[1]/ax.b, p[2]/ax.c);

export const nHat = (p:[number,number,number], ax:Axes):[number,number,number] => {
  const nx=p[0]/(ax.a*ax.a), ny=p[1]/(ax.b*ax.b), nz=p[2]/(ax.c*ax.c);
  const L=Math.hypot(p[0]/ax.a,p[1]/ax.b,p[2]/ax.c)||1;
  const n0=nx/L,n1=ny/L,n2=nz/L, m=Math.hypot(n0,n1,n2)||1;
  return [n0/m,n1/m,n2/m];
};

export const aEffHarmonic = (ax:Axes) => 3/(1/ax.a + 1/ax.b + 1/ax.c);

3) baseline equations (no calibration/knobs yet)
// core/phys/baseline.ts
import { PI, HBAR_C, C } from "../phys/const";

export const casimir_E_over_A = (gap_m:number) =>
  -(PI*PI*HBAR_C) / (720 * Math.pow(gap_m,3)); // J/m^2

export const casimir_E_tile = (gap_m:number, area_m2:number) =>
  casimir_E_over_A(gap_m)*area_m2; // J

// geometric amplification: viewer + pipeline agreed convention
export const geo_amp3 = (gammaGeo:number)=> Math.pow(Math.max(1, gammaGeo), 3);

// dynamic power during ON: P_on_tile = |U| * ω / Q
export const power_tile_ON = (U_J:number, omega:number, Q:number) =>
  Math.abs(U_J) * omega / Math.max(1, Q);

// ship-wide Ford–Roman effective duty (FR average across sectors)
export const duty_FR = (burstLocal:number, concurrent:number, total:number) =>
  (burstLocal * Math.max(0,concurrent)) / Math.max(1,total);

// light-crossing + modulation
export const lightCrossing_ms = (wall_m:number)=> (wall_m/C)*1e3;
export const modulation = (fGHz:number)=>({ fHz:fGHz*1e9, T_ms: 1e3/(fGHz*1e9) });

// simple ζ proxy (baseline fit against FR duty)
export const zeta_from_duty = (d_ship:number, z0=0.84, d0=0.01/400) =>
  z0 * (d_ship / d0);

4) kernel I/O (strict schema)
// core/kernel/types.ts
export type Mode = 'standby'|'hover'|'cruise'|'emergency';

export interface KernelInput {
  // geometry
  hull: { Lx_m:number; Ly_m:number; Lz_m:number; wallThickness_m:number };
  tileArea_cm2: number;
  radialLayers: number;
  packing: number;        // 0..1

  // casimir
  gap_nm: number;

  // amps/physics
  gammaGeo: number;
  Q_cavity: number;
  qMechanical: number;    // power knob only

  // timing/strobing
  f_GHz: number;
  sectorsTotal: number;
  sectorsLive: number;
  burstLocal: number;     // e.g. 0.01

  // calibration toggles
  modelMode: 'raw'|'calibrated';
  powerTarget_W?: number;     // optional targets for auto-cal
  massTarget_kg?: number;

  // presentation
  mode: Mode;
}

export interface KernelOutput {
  // counting
  hullArea_m2: number;
  tilesTotal: number;
  tilesPerSector: number;
  activeTiles: number;

  // timing/duty
  omega: number;
  dutyFR: number;
  strobeHz: number;
  sectorPeriod_ms: number;
  tauLC_ms: number;

  // energy/power
  U_static_tile_J: number;
  U_geo_tile_J: number;
  U_on_tile_J: number;
  P_on_tile_W: number;
  P_avg_MW: number;

  // mass proxy
  M_exotic_kg: number;

  // constraints
  zeta: number;
  fordRomanOk: boolean;

  // mirrors for renderer parity
  parityPhys: any; // packed params (REAL)
  parityShow: any; // packed params (SHOW)
}

5) reference kernel (baseline first, knobs second)
// core/kernel/baseline-kernel.ts
import { NM, CM2 } from "../phys/const";
import { areaKnudThomsen } from "../geom/ellipsoid";
import { casimir_E_tile, geo_amp3, power_tile_ON, duty_FR, modulation, lightCrossing_ms, zeta_from_duty } from "../phys/baseline";
import type { KernelInput, KernelOutput } from "./types";

export function computeBaseline(input: KernelInput): KernelOutput {
  const { hull, tileArea_cm2, radialLayers, packing,
          gap_nm, gammaGeo, Q_cavity, qMechanical,
          f_GHz, sectorsTotal, sectorsLive, burstLocal } = input;

  const a=hull.Lx_m/2, b=hull.Ly_m/2, c=hull.Lz_m/2;
  const hullArea_m2 = areaKnudThomsen(a,b,c);
  const tileArea_m2 = tileArea_cm2 * CM2;
  const surfaceTiles = Math.floor(hullArea_m2 / tileArea_m2);
  const tilesTotal = Math.max(1, Math.round(surfaceTiles * radialLayers * packing));
  const tilesPerSector = Math.floor(tilesTotal / Math.max(1, sectorsTotal));
  const activeTiles = tilesPerSector * Math.max(0, sectorsLive);

  const { fHz, T_ms } = modulation(f_GHz);
  const omega = 2*Math.PI*fHz;
  const tauLC_ms = lightCrossing_ms(hull.wallThickness_m);

  const dFR = duty_FR(burstLocal, sectorsLive, Math.max(1, sectorsTotal));

  // energies per tile
  const U_static = casimir_E_tile(gap_nm*NM, tileArea_m2);          // J
  const U_geo    = U_static * geo_amp3(gammaGeo);                    // J
  const U_on     = U_geo * Math.max(qMechanical, 0);                 // J
  const P_on     = power_tile_ON(U_on, omega, Q_cavity);             // W/tile

  const P_avg_W  = P_on * tilesTotal * dFR;
  const P_avg_MW = P_avg_W / 1e6;

  // minimal mass proxy (use same “paper” idea without γVdB until you wire it)
  const M_exotic_kg = Math.abs(U_geo) * dFR * tilesTotal / (299_792_458**2);

  const zeta = zeta_from_duty(dFR);
  const fordRomanOk = zeta < 1;

  // renderer parity packets (everything the viz needs)
  const baseShared = {
    hull: { a, b, c }, sectors: sectorsTotal, sectorCount: sectorsTotal,
    dutyCycle: input.mode==='standby'?0:input.burstLocal, dutyEffectiveFR: dFR,
    colorMode:'theta' as const, ridgeMode:1
  };
  const parityPhys = { ...baseShared, gammaGeo, qSpoilingFactor: 1, gammaVanDenBroeck: 1, split: 0 };
  const parityShow = { ...baseShared, gammaGeo, qSpoilingFactor: 1, gammaVanDenBroeck: 1, split: 0 };

  return {
    hullArea_m2, tilesTotal, tilesPerSector, activeTiles,
    omega, dutyFR: dFR, strobeHz: 1000, sectorPeriod_ms: 1, tauLC_ms,
    U_static_tile_J: U_static, U_geo_tile_J: U_geo, U_on_tile_J: U_on,
    P_on_tile_W: P_on, P_avg_MW,
    M_exotic_kg, zeta, fordRomanOk,
    parityPhys, parityShow,
  };
}