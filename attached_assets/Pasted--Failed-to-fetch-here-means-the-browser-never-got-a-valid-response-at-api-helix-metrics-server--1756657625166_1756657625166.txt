“Failed to fetch” here means the browser never got a valid response at `/api/helix/metrics` (server down, wrong port/path, no dev proxy, or CORS). Here’s a tight set of fixes you can drop in so the hook works in both dev and prod, plus better error reporting.

# 1) Make the client hit the right URL (with timeout + useful errors)

```diff
--- a/client/src/hooks/use-metrics.ts
+++ b/client/src/hooks/use-metrics.ts
@@
-export function useMetrics(pollMs = 2000) {
+export function useMetrics(pollMs = 2000) {
+  // Configure API base once. In dev, point to your backend port.
+  // Example: VITE_API_BASE=http://localhost:3001
+  const API_BASE = (typeof import.meta !== 'undefined' ? import.meta.env?.VITE_API_BASE : '') || '';
   const [data, setData] = React.useState<HelixMetrics | null>(null);
   const [err, setErr] = React.useState<string | null>(null);
 
   React.useEffect(() => {
     let alive = true;
+    const makeUrl = (path: string) => (API_BASE ? `${API_BASE}${path}` : path);
     const tick = async () => {
       try {
-        const r = await fetch("/api/helix/metrics", {
+        // Add a 7s timeout so "Failed to fetch" surfaces quickly + cleanly
+        const ctrl = new AbortController();
+        const to = setTimeout(() => ctrl.abort(), 7000);
+        const r = await fetch(makeUrl("/api/helix/metrics"), {
           method: 'GET',
           headers: {
             'Accept': 'application/json',
             'Content-Type': 'application/json'
-          }
+          },
+          signal: ctrl.signal
         });
+        clearTimeout(to);
+        if (!r.ok) {
+          // Try to extract any text error for easier debugging
+          let body = '';
+          try { body = await r.text(); } catch {}
+          throw new Error(`HTTP ${r.status} ${r.statusText}${body ? ` — ${body.slice(0,200)}` : ''}`);
+        }
-        if (!r.ok) throw new Error(`HTTP ${r.status}: ${r.statusText}`);
-        const j = await r.json();
+        // Some runtimes return empty; guard JSON parse
+        const text = await r.text();
+        const j = text ? JSON.parse(text) : null;
         if (alive) {
           setData(j);
           setErr(null); // Clear any previous errors
         }
       } catch (e: any) {
         if (alive) {
-          console.error('[useMetrics] Fetch error:', e);
-          setErr(e.message ?? "network error");
+          const msg = e?.name === 'AbortError'
+            ? 'request timeout (7s)'
+            : (e?.message || 'network error');
+          console.error('[useMetrics] Fetch error:', msg);
+          setErr(msg);
         }
       }
     };
@@
   }, [pollMs]);
 
   return { data, err };
 }
```

> Dev tip: set `VITE_API_BASE=http://localhost:3001` (or whatever your backend port is) in your `.env.local`.

---

# 2) Dev proxy (if you want to keep relative `/api/...` in dev)

If you’re using **Vite**, add a proxy so the client dev server forwards `/api` to the backend:

```diff
--- a/vite.config.ts
+++ b/vite.config.ts
@@
 export default defineConfig({
   plugins: [react()],
   server: {
-    port: 5173
+    port: 5173,
+    proxy: {
+      '/api': {
+        target: 'http://localhost:3001', // ← your Express port
+        changeOrigin: true
+      }
+    }
   }
 })
```

(Then you can skip `VITE_API_BASE` in dev; the proxy will handle it.)

---

# 3) Ensure the backend route exists and returns JSON

In your **Express** app (the one started by `server/index.ts`), confirm the route and CORS:

```diff
--- a/server/index.ts
+++ b/server/index.ts
@@
+import cors from 'cors';
 import express from 'express';
 const app = express();
 app.use(express.json());
+app.use(cors()); // dev convenience; tighten in prod as needed
 
 // ... other middleware & routes
 
 // Example metrics route
-app.get('/api/helix/metrics', async (req, res) => {
-  try {
-    const metrics = await getHelixMetrics(); // your existing function
-    res.json(metrics);
-  } catch (err:any) {
-    res.status(500).json({ error: 'metrics_unavailable', detail: String(err?.message || err) });
-  }
-});
+app.get('/api/helix/metrics', async (req, res) => {
+  try {
+    const metrics = await getHelixMetrics(); // must return HelixMetrics shape
+    res.setHeader('Cache-Control', 'no-store');
+    res.status(200).json(metrics);
+  } catch (err: any) {
+    console.error('[metrics] error:', err);
+    res.status(500).json({ error: 'metrics_unavailable', detail: String(err?.message || err) });
+  }
+});
 
 const port = process.env.PORT || 3001;
 app.listen(port, () => console.log(`API listening on ${port}`));
```

> If your server crashed earlier (e.g., from the `natario-metric` import error), the client will get “Failed to fetch.” Make sure the backend compiles and is **running**.

---

# 4) Quick sanity checklist

* ✅ **Server running** and listening where the client expects (`localhost:3001` in these examples).
* ✅ `/api/helix/metrics` **exists** and returns valid JSON (open it in the browser to confirm).
* ✅ Either `VITE_API_BASE` is set **or** Vite proxy maps `/api` → your backend.
* ✅ No **CORS** complaint in console (we allowed all in dev via `cors()`).
* ✅ The route returns the **shape** your UI expects (`HelixMetrics`). If you’re still wiring kg vs “arb”, ensure `exoticMass` is a number **in kilograms** in the server response.

---

# 5) (Optional) Provide a safe mock when the API is down

You can keep the UI usable when offline:

```diff
@@
       } catch (e: any) {
         if (alive) {
           const msg = e?.name === 'AbortError'
             ? 'request timeout (7s)'
             : (e?.message || 'network error');
           console.error('[useMetrics] Fetch error:', msg);
           setErr(msg);
+          // Fallback mock so the Bridge stays interactive in dev
+          setData(d => d ?? {
+            energyOutput: 0,
+            exoticMass: 0,
+            timeScaleRatio: 0,
+            curvatureMax: 0,
+            fordRoman: { value: 0, limit: 1, status: 'PASS' },
+            modelMode: 'calibrated',
+            tiles: { tileArea_cm2: 25, hullArea_m2: null, N_tiles: 0 }
+          });
         }
       }
```

---

If you apply the diffs above, you’ll either get real metrics in dev (via proxy or `VITE_API_BASE`) or a clear, actionable error (status code, body, or timeout), instead of the opaque “Failed to fetch.”
