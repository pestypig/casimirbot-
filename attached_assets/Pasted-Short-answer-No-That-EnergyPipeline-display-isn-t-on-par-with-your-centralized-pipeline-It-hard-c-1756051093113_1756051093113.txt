Short answer: No. That EnergyPipeline display isn’t on-par with your centralized pipeline. It hard-codes physics (γ, Q, duty, tile count, radii, power targets) and even forces values like P_loss and P_avg, which disagrees with the HELIX-CORE pipeline that already computes all of this (including UI duty vs FR duty and per-mode calibration).

Biggest mismatches (why your UI won’t track modes)

Duty: UI forces d = 0.01 (1%) instead of using the pipeline’s ship-wide FR duty dutyEffectiveFR (≈2.5e-5 in nominal modes; doubles in emergency).

Gamma/Q: UI pins γ_geo = 25 and Q = 1e9; pipeline provides gammaGeo and qCavity (and re-calibrates power/mass via qMechanical and gammaVanDenBroeck).

Power: UI sets P_loss and P_total to “targets”; pipeline gives P_avg (MW) and the ingredients to compute per-tile power correctly.

Time-scale: UI uses T_m/T_LC and expects “≪1”; pipeline defines TS_long = T_long/T_m (≫1e3 means homogenized).

Geometry: UI uses R_hull = 0.05 m and N_tiles = 1.96e9; pipeline computes both from real hull dims.

Validation: UI compares to fixed spec numbers, not to the pipeline’s calibrated outputs.

Drop-in fix (replace the hard-coded “else if (…)” block)

Replace your entire else if (results.stressEnergyTensor || results.powerDraw) { … } with this pipeline-true version. It derives the same fields your cards display, but from the pipeline snapshot you already have:

} else if (results.stressEnergyTensor || results.powerDraw || true) {
  // Build a pipeline-shaped view from the unified snapshot (computeEnergySnapshot)
  const fGHz = Number(results.modulationFreq_GHz ?? results.modulationFreq_GHz ?? 15);
  const f_m = fGHz * 1e9;                 // Hz
  const ω = 2 * Math.PI * f_m;            // rad/s

  // First-class pipeline fields (authoritative)
  const dutyFR = Number(
    results.dutyEffectiveFR ?? results.dutyShip ?? results.dutyEff ?? 2.5e-5
  );                                       // Ford–Roman ship-wide duty
  const dutyUI = Number(results.dutyCycle ?? 0.14);   // UI duty (for display only)
  const γ_geo  = Number(results.gammaGeo ?? 26);
  const Q      = Number(results.qCavity ?? 1e9);
  const N      = Math.max(1, Number(results.N_tiles ?? results.N_tilesTotal ?? 1));

  // Per-tile static energy comes directly from the pipeline
  const U_static = Number(results.U_static ?? 0);      // J per tile

  // Follow the same order as the pipeline: geometry → Q → duty(FR)
  const γ3        = Math.pow(γ_geo, 3);
  const U_geo_raw = U_static * γ3;                     // J per tile (on-window stored)
  const U_Q       = U_geo_raw * Q;                     // J per tile (on-window)
  const U_cycle   = U_Q * dutyFR;                      // J per tile, ship-averaged (FR)

  // Per-tile dissipation during ON-window (pipeline’s P_tile_on)
  const P_tile_on = Math.abs(U_Q) * ω / Math.max(1, Q); // W per tile (ON)
  // Average total electrical power (matches pipeline’s P_avg when inputs match)
  const P_total   = P_tile_on * N * dutyFR;             // W ship-averaged

  // Prefer pipeline’s own calibrated totals if present (authoritative)
  const P_avg_W   = Number.isFinite(results.P_avg) ? Number(results.P_avg) * 1e6 : P_total;
  const m_exotic  = Number.isFinite(results.M_exotic) ? Number(results.M_exotic) : (Number(results.M_exotic_raw) || 0);

  // Time-scale separation: use pipeline’s TS_long / TS_geom if available
  const TS_long = results.TS_long ?? results.TS_ratio ?? undefined;  // pipeline’s conservative metric
  const TS_geom = results.TS_geom ?? undefined;

  pipeline = {
    U_static,
    U_geo_raw,
    U_Q,
    U_cycle,
    P_loss: P_tile_on,        // per-cavity ON-window loss (W)
    powerTotalComputed: P_avg_W, // ship-avg W (prefer pipeline P_avg)
    E_tile: U_cycle,          // what your UI shows as per-tile energy
    N_tiles: N,
    γ_geo,
    ω,
    d: dutyFR,                // show FR duty as the physics duty
    dutyUI,                   // also show UI duty for comparison
    TS_ratio: TS_long,        // keep existing prop name but fill with TS_long
    TS_long,
    TS_geom,
    m_exotic,
  };