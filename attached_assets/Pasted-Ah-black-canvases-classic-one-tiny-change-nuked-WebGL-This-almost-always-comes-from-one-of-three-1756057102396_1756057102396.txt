Ah, black canvases—classic “one tiny change nuked WebGL.” This almost always comes from one of three things your Live Titles patch likely triggered:

the engines are getting non-finite uniforms (e.g. "83.3 MW" → NaN),

the canvases briefly collapse to 0×0 from layout changes (titles reflow), or

uniforms are being pushed before shaders are ready.

Here’s a safe hot-fix you can drop into WarpBubbleCompare.tsx right now. It hardens value flow, defers updates until engines are ready, and prevents 0×0 canvas.

Patch A — Safe uniform push (sanitize + onceReady)

Add this near the top of WarpBubbleCompare.tsx:

// --- resilient uniform push helpers ---
const CM = { solid: 0, theta: 1, shear: 2 };
const finite = (x: any, d: number) => (Number.isFinite(+x) ? +x : d);

function sanitizeUniforms(u: any = {}) {
  const s = { ...u };

  // numeric coercions + clamps
  s.thetaScale        = Math.max(1e-12,  finite(s.thetaScale,        1));
  s.exposure          = Math.min(12, Math.max(1, finite(s.exposure,  6)));
  s.zeroStop          = Math.max(1e-9,    finite(s.zeroStop,   1e-7));
  s.wallWidth         = Math.max(1e-4,    finite(s.wallWidth,  0.016));
  s.curvatureBoostMax = Math.max(1,       finite(s.curvatureBoostMax, 40));
  s.curvatureGainT    = Math.max(0, Math.min(1, finite(s.curvatureGainT, 0)));
  s.userGain          = Math.max(1,       finite(s.userGain,  1));
  s.displayGain       = Math.max(1,       finite(s.displayGain, 1));
  s.sectors           = Math.max(1, Math.floor(finite(s.sectors, 1)));
  s.split             = Math.max(0, Math.min(s.sectors - 1, Math.floor(finite(s.split, 0))));

  // map strings → ints
  if (typeof s.colorMode === 'string') s.colorMode = CM[s.colorMode] ?? 1;
  s.ridgeMode = Math.max(0, Math.min(1, Math.floor(finite(s.ridgeMode, 0))));

  // hull normalization (drop invalid)
  if (s.hull) {
    const a = finite(s.hull.a, NaN), b = finite(s.hull.b, NaN), c = finite(s.hull.c, NaN);
    if (Number.isFinite(a) && Number.isFinite(b) && Number.isFinite(c)) s.hull = { a, b, c };
    else delete s.hull;
  }

  return s;
}

function pushSafe(engineRef: React.MutableRefObject<any>, patch: any) {
  const e = engineRef?.current;
  if (!e) return;
  const clean = sanitizeUniforms(patch);
  if (!e.isLoaded || !e.gridProgram) {
    e.onceReady(() => { e.updateUniforms(clean); e.forceRedraw?.(); });
  } else {
    e.updateUniforms(clean);
    e.forceRedraw?.();
  }
}


Then replace every pushUniformsWhenReady(leftEngine.current, {...}) / pushUniformsWhenReady(rightEngine.current, {...}) with:

pushSafe(leftEngine,  {/* ... */});
pushSafe(rightEngine, {/* ... */});


This shields the shaders from NaN/undefined caused by stringy values coming from the live titles/pipeline.