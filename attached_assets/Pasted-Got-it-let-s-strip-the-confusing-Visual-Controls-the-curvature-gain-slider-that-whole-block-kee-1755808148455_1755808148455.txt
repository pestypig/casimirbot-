Got it—let’s strip the confusing Visual Controls (the curvature gain slider + that whole block), keep your Physics Parity Debug Mode, keep the SliceViewer controls (they work!), and make sure the Galaxy map controls aren’t accidentally nested there.

Here’s a clean, minimal set of changes you can drop in:

1) Remove the Visual Controls panel (and slider) entirely

Delete the whole block that contains the curvature gain UI (and its wrapper panel). That’s the <div className="mb-4 p-2 ..."> with the “Curvature Gain” label + range input + helper text. Also remove any surrounding “Visual Controls” card/panel markup if it only existed to host this slider.

What to keep inside the Slice column: your Physics Parity toggle (already good) and the SliceViewer itself.

2) Pass Physics Parity to the engine and force 1× visuals when ON

Make your WarpVisualizer props tell the engine when parity is on, so the engine clamps visual boost to 1× internally. (No slider needed.)

// Compute parity from localStorage once per render
const physicsParity = localStorage.getItem('physics-parity-mode') === 'true';

<WarpVisualizer
  key={`mode-${effectiveMode}-v${modeVersion}`} // you already bump version on toggle; perfect
  parameters={{
    // --- physics inputs (unchanged) ---
    dutyCycle: dutyUI,
    g_y: pipeline?.gammaGeo || 26,
    cavityQ: pipeline?.qCavity || 1e9,
    sagDepth_nm: pipeline?.sag_nm || 16,
    tsRatio: isFiniteNumber(pipeline?.TS_ratio) ? pipeline!.TS_ratio! : 5.03e4,
    powerAvg_MW: /* your existing logic */,
    exoticMass_kg: /* your existing logic */,
    currentMode: effectiveMode,
    sectorStrobing: sectorsUI,
    qSpoilingFactor: qSpoilUI,
    gammaVanDenBroeck: isFiniteNumber(pipeline?.gammaVanDenBroeck) ? pipeline!.gammaVanDenBroeck! : 3.83e1,

    // --- visual policy (new) ---
    physicsParity,            // tells engine to render true-physics 1×
    curvatureGainDec: 0,      // no slider; keep at 0 decades (1×)
    curvatureBoostMax: 1,     // force visualBoost = 1× in parity mode anyway
  }}
/>


In your WebGL engine (where uniforms are derived), keep the single visual multiplier and clamp it when physicsParity is true:

// … existing physics chain …
const betaUsedUniform = viewAvgUniform ? betaAvgUniform : betaInstUniform;

// Single visual-only multiplier
function mapDecadesToBoost(dec, maxBoost) {
  const t = Math.max(0, Math.min(1, dec / 8));
  return Math.exp(Math.log(Math.max(1, maxBoost)) * t);
}

const visualBoostUniform = physicsParityUniform
  ? 1
  : mapDecadesToBoost(curvatureGainDecUniform || 0, Math.max(1, curvatureBoostMaxUniform || 1));

const betaVizUniform = betaUsedUniform * visualBoostUniform;


This guarantees that with parity ON you see authentic physics (1×), and there’s no slider anywhere.