You’ve got two issues overlapping:

a hard error (buildREAL is not defined) caused by leftover imports/usage, and

the flicker, caused by a second (legacy) code path that still builds & pushes uniforms (including viewAvg/sector logic) at the same time as the new packet builders.

Here’s a tight, surgical fix list you can apply right now.

1) Export both the new builders and legacy aliases

In client/src/lib/warp-uniforms.ts, make sure the module exports your new builders and also legacy shims so old call-sites don’t explode:

// … your normalizeWU + new builder implementations …

export function buildRealPacket(parameters: any, base: any = {}) {
  // existing implementation
}

export function buildShowPacket(parameters: any, base: any = {}) {
  // existing implementation
}

// ---- Legacy shims (keep until every call-site is migrated) ----
export const buildREAL = (p: any, base: any = {}) => buildRealPacket(p, base);
export const buildSHOW = (p: any, base: any = {}) => buildShowPacket(p, base);


That satisfies imports like import { buildREAL, buildSHOW } from "@/lib/warp-uniforms" while you finish migrating.

2) Stop importing the legacy API in WarpRenderInspector

Open client/src/components/WarpRenderInspector.tsx and change the imports so you only bring in what you actually use. Replace:

import { normalizeWU, buildREAL, buildSHOW } from "@/lib/warp-uniforms";


with:

import { buildRealPacket, buildShowPacket } from "@/lib/warp-uniforms";


(You no longer use normalizeWU in this file after the packet switch.)

3) Remove the leftover legacy build calls (they’re causing the flicker)

You still have old lines that compute realUniforms/showUniforms via buildREAL/buildSHOW. They create a second set of uniforms that can race your new packet push.

Delete these lines everywhere they appear:

const realUniforms = useMemo(() => buildREAL(live || {}), [live]);
const showUniforms = useMemo(() => buildSHOW(live || {}), [live]);


They show up multiple times from a merge (search the file for buildREAL( / buildSHOW( and remove). You can see one such block near the “Missing variables for new layout” section and duplicates nearby.

Your new path already builds the payloads:

const realPayload = buildRealPacket(parameters, { ...shared, colorMode: 2 });
const showPayload = buildShowPacket(parameters, { ...shared, … });


Those are the only payloads that should exist now.

4) Make view-fraction deterministic (eliminate REAL vs SHOW bounce)

Keep viewAvg locked per pane and compute the UI “view fraction” from sectorCount only, never from transient engine props. You already lock this in paneSanitize:

function paneSanitize(pane: 'REAL'|'SHOW', patch: any) {
  const isREAL = pane === 'REAL';
  return {
    ...patch,
    physicsParityMode: isREAL,
    ridgeMode: isREAL ? 0 : 1,
    viewAvg: isREAL,      // lock
  };
}


(Confirmed in the file.)

Now, replace any usage of a “smart” detector with a stable helper so REAL is always 1/sectorCount, SHOW is always 1.0:

function viewMassFractionLocked(u: any, flavor: 'REAL'|'SHOW'){
  const total = Math.max(1, Number(u?.sectorCount ?? 400));
  return flavor === 'REAL' ? 1 / total : 1.0;
}


And call it explicitly with flavor:

const uLeft  = leftEngine.current?.uniforms  ?? {};
const uRight = rightEngine.current?.uniforms ?? {};

const viewMassFracREAL = viewMassFractionLocked(uLeft, 'REAL');
const viewMassFracSHOW = viewMassFractionLocked(uRight, 'SHOW');


(There are current references to computeViewMassFraction/computeViewMassFractionStable without a flavor argument; update those calls so they don’t infer from drifting uniforms.)

5) Ensure the strobing stream does not mutate concurrent sectors

Your strobing hook is correct: it only rebroadcasts sectorCount and split, not sectors (concurrent). Keep it that way—concurrent sectors per pane must remain fixed (REAL/SHOW) so FR averaging is stable:

// Only broadcast TOTAL & split. Leave "sectors" (concurrent) alone.
const payload = { sectorCount: s, split: Math.max(0, sp) };


(As written in your file, this is already correct.)

6) Single authority for θ

You’ve already shifted to engine-authoritative θ; keep rejecting any incoming thetaScale in client packets. The builder returns thetaScale: undefined, and the engine recomputes θ and exposes it as thetaScale_actual. Keep reading that for display/verification. You’re doing that in the inspector snapshot table (good).

7) Sanity sweep (duplicates & re-defs)

This file had previous merge collisions (e.g., duplicate paneSanitize, sanitizeUniforms, etc.). Do a quick search-and-remove of any second definitions—keep the top one only. That’s how earlier “already been declared” errors happened