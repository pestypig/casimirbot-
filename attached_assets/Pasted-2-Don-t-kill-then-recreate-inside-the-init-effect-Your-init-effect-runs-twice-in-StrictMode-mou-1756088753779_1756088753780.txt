2) Don’t “kill-then-recreate” inside the init effect

Your init effect runs twice in StrictMode (mount → cleanup → mount). The early kill(leftEngine)/kill(rightEngine) can race with the engine’s internal book-keeping. Just reuse the instance if one is already there.

Change the init effect like this:

Remove these two lines at the top of the effect:

// idempotent (React StrictMode)
// kill(leftEngine); kill(rightEngine);


Inside initOne, reuse if present:

const initOne = async (cv: HTMLCanvasElement, uniforms: any) => {
  const w = (window as any).WarpEngine;
  const eng = getOrCreateEngine(w, cv);   // ← reuse or create
  const { w: W, h: H } = sizeCanvas(cv);
  eng.gl.viewport(0, 0, W, H);

  // Make sure program + VBO exist (handles async shader path)
  if (!eng.gridProgram || !eng.gridVbo || !eng._vboBytes) {
    try { eng._initializeGrid?.(); } catch {}
    try { eng._compileGridShaders?.(); } catch {}
    await new Promise<void>((resolve) => {
      const tick = () => {
        if (eng.gridProgram && eng.gridVbo && eng._vboBytes > 0) return resolve();
        requestAnimationFrame(tick);
      };
      tick();
    });
  }

  eng.updateUniforms?.(uniforms);
  eng.isLoaded = true;
  if (!eng._raf && typeof eng._renderLoop === 'function') eng._renderLoop();
  eng.start?.();

  const ro = new ResizeObserver(() => {
    const { w, h } = sizeCanvas(cv);
    eng.gl.viewport(0, 0, w, h);
    eng.resize?.(w, h);
  });
  ro.observe(cv);
  eng.__ro = ro;
  return eng;
};


Keep the cleanup as you already have (the one that calls destroy?.() and deletes the canvas key) so unmounts are clean:

return () => {
  cancelled = true;
  const left = leftRef.current as any;
  const right = rightRef.current as any;

  const nuke = (cv?: HTMLCanvasElement, ref?: any) => {
    try {
      const e = ref?.current;
      e?.__ro?.disconnect?.();
      e?._offStrobe?.();
      e?.stop?.();
      e?.dispose?.();
      e?.destroy?.();
    } catch {}
    if (cv) {
      delete (cv as any)[ENGINE_KEY];
      delete (cv as any).__warpEngineAttached; // in case the engine uses its own flag
      delete (cv as any).__warpAttached;
    }
    if (ref) ref.current = null;
  };

  nuke(left, leftEngine);
  nuke(right, rightEngine);
};


(Optional but recommended) Do not put leftRef.current / rightRef.current in the deps array; it causes extra re-runs. Use [] and guard inside:

}, []); // ← run once


Inside, if the canvases aren’t there yet, poll with requestAnimationFrame until they are.