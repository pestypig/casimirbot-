Great catch—yes, the **VisualProofCharts** is the right place to wire the proof panels to **live pipeline values** (with clean fallbacks), so the radar, energy pipeline, and duty vs power charts all reflect *what the server is actually producing*.

Here’s a drop-in patch that:

* Reads the **HELIX-CORE pipeline** via `useEnergyPipeline()`
* Builds `results` and `targets` from **live backend fields** (with sensible fallbacks)
* Normalizes **power** correctly (server sends `P_avg` in MW; this component expects W)
* Uses **server duty** fields (`dutyBurst`, `dutyEffective_FR`) when present
* Uses **server targets** when available; otherwise falls back to per-mode client targets

You can keep the props as optional overrides; the pipeline will drive everything by default.

---

### Patched `VisualProofCharts.tsx`

```tsx
/**
 * Visual Proof Charts Component
 * Implements the three proof visualizations: Radar plot, Energy Pipeline, and Duty vs Power
 */

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer,
  RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar,
  LineChart, Line, ComposedChart
} from 'recharts';
import { TrendingUp, Activity, Target } from "lucide-react";
import { useEnergyPipeline, MODE_CONFIGS } from "@/hooks/use-energy-pipeline";

interface VisualProofChartsProps {
  // Optional overrides; if omitted, live pipeline values are used
  results?: {
    totalEnergy?: number;               // J (we’ll use pipeline.U_cycle if missing)
    geometricBlueshiftFactor?: number;  // γ_geo
    qEnhancementFactor?: number;        // Q factor
    totalExoticMass?: number;           // kg
    powerDraw?: number;                 // W (NOTE: pipeline.P_avg is MW → convert)
    quantumInequalityMargin?: number;   // ζ
    dutyFactor?: number;                // d_burst (local ON window, e.g. 0.01)
    effectiveDuty?: number;             // d_eff (shipwide, e.g. S_live/400 * d_burst)
    baselineEnergyDensity?: number;
    amplifiedEnergyDensity?: number;
  };
  targets?: {
    gammaGeo?: number;         // nominal target
    cavityQ?: number;          // Q target
    dutyFactor?: number;       // burst duty target (e.g. 0.01)
    effectiveDuty?: number;    // effective duty target (e.g. 2.5e-5)
    exoticMassTarget?: number; // kg
    powerTarget?: number;      // W  (NOTE: this component expects W)
    zetaSafeLimit?: number;    // ≤ 1.0 typically
  };
}

export function VisualProofCharts({ results = {}, targets = {} }: VisualProofChartsProps) {
  const { data: pipeline } = useEnergyPipeline();

  // --- Live values from pipeline with safe fallbacks ---
  const mode = (pipeline as any)?.currentMode as keyof typeof MODE_CONFIGS | undefined;

  // Power: server sends P_avg in MW for the HUD — convert to W for this component
  const powerDrawW =
    Number.isFinite((pipeline as any)?.P_avg) ? ((pipeline as any).P_avg as number) * 1e6 :
    Number.isFinite(results.powerDraw) ? (results.powerDraw as number) :
    0;

  // Mass
  const massKg =
    Number.isFinite((pipeline as any)?.M_exotic) ? (pipeline as any).M_exotic as number :
    Number.isFinite(results.totalExoticMass) ? (results.totalExoticMass as number) :
    0;

  // Gamma_geo, Q, ζ
  const gammaGeo =
    Number.isFinite((pipeline as any)?.gammaGeo) ? (pipeline as any).gammaGeo as number :
    (results.geometricBlueshiftFactor ?? 26);

  const qCavity =
    Number.isFinite((pipeline as any)?.qCavity) ? (pipeline as any).qCavity as number :
    (results.qEnhancementFactor ?? 1e9);

  const zeta =
    Number.isFinite((pipeline as any)?.zeta) ? (pipeline as any).zeta as number :
    (results.quantumInequalityMargin ?? 0.5);

  // Energy (J): prefer pipeline.U_cycle (duty-cycled energy per tile *? server semantics*).
  // If not available, fall back to given results or a paper-ish seed.
  const totalEnergyJ =
    Number.isFinite((pipeline as any)?.U_cycle) ? (pipeline as any).U_cycle as number :
    Number.isFinite(results.totalEnergy) ? (results.totalEnergy as number) :
    -2.55e-3;

  // Duty (two notions): server exposes both
  const dutyBurst =
    Number.isFinite((pipeline as any)?.dutyBurst) ? (pipeline as any).dutyBurst as number :
    (results.dutyFactor ?? 0.01);

  const dutyEff =
    Number.isFinite((pipeline as any)?.dutyEffective_FR) ? (pipeline as any).dutyEffective_FR as number :
    (results.effectiveDuty ?? 2.5e-5);

  // --- Targets (server-first if you expose them; else sane fallbacks) ---
  // Prefer server’s exoticMassTarget_kg if present
  const exoticMassTarget =
    Number.isFinite((pipeline as any)?.exoticMassTarget_kg) ? (pipeline as any).exoticMassTarget_kg as number :
    (targets.exoticMassTarget ?? 1405);

  // Prefer server constraints if you add them as `pipeline.constraints`
  const serverCons = (pipeline as any)?.constraints ?? {};

  const zetaSafeLimit =
    Number.isFinite(serverCons.zeta_max) ? serverCons.zeta_max as number :
    (targets.zetaSafeLimit ?? 1.0);

  const targetGammaGeo =
    Number.isFinite((pipeline as any)?.gammaGeo) ? (pipeline as any).gammaGeo as number :
    (targets.gammaGeo ?? 26);

  const targetQ =
    Number.isFinite((pipeline as any)?.qCavity) ? (pipeline as any).qCavity as number :
    (targets.cavityQ ?? 1e9);

  const targetDutyBurst =
    Number.isFinite((pipeline as any)?.dutyBurst) ? (pipeline as any).dutyBurst as number :
    (targets.dutyFactor ?? 0.01);

  const targetDutyEff =
    Number.isFinite((pipeline as any)?.dutyEffective_FR) ? (pipeline as any).dutyEffective_FR as number :
    (targets.effectiveDuty ?? 2.5e-5);

  // Power target by mode — this component expects W.
  // If the backend later exposes a per-mode power target (e.g. pipeline.policy.P_target_W),
  // use that instead. Until then, map from known mode policy.
  const powerTargetW =
    Number.isFinite(serverCons.P_target_W) ? serverCons.P_target_W as number :
    (mode === 'hover'    ? 83.3e6 :
     mode === 'cruise'   ? 7.437 :
     mode === 'emergency'? 297.5e6 :
     mode === 'standby'  ? 0 :
     (targets.powerTarget ?? 83e6));

  // A. Radar Plot Data - "Spec vs Achieved"
  const radarData = [
    {
      subject: 'γ_geo',
      target: targetGammaGeo,
      achieved: gammaGeo,
      fullMark: targetGammaGeo * 1.2
    },
    {
      subject: 'Q (10⁹)',
      target: targetQ / 1e9,
      achieved: qCavity / 1e9,
      fullMark: (targetQ / 1e9) * 1.2
    },
    {
      subject: 'duty d (%)',
      target: targetDutyBurst * 100,
      achieved: dutyBurst * 100,
      fullMark: (targetDutyBurst * 100) * 1.2
    },
    {
      subject: '1/ζ',
      target: 1 / zetaSafeLimit,
      achieved: zeta > 0 ? (1 / zeta) : 0,
      fullMark: (1 / zetaSafeLimit) * 1.2
    },
    {
      subject: 'Power (MW)',
      target: powerTargetW / 1e6,
      achieved: powerDrawW / 1e6,
      fullMark: (powerTargetW / 1e6) * 1.2
    },
    {
      subject: 'Mass (10³kg)',
      target: exoticMassTarget / 1e3,
      achieved: massKg / 1e3,
      fullMark: (exoticMassTarget / 1e3) * 1.2
    }
  ];

  // B. Energy Boost Pipeline Data (units: mJ for display)
  const E_flat = -2.55e-3;                            // J (paper-ish seed)
  const E_bowl = Number.isFinite(totalEnergyJ) ? totalEnergyJ : E_flat; // J
  const Q_enhancement = Number.isFinite(qCavity) ? qCavity : 1;         // dimensionless

  const energyPipelineData = [
    { stage: 'E_flat',  energy: Math.abs(E_flat) * 1e3,                 label: 'Flat Plates' },        // mJ
    { stage: 'E_bowl',  energy: Math.abs(E_bowl) * 1e3,                 label: 'Bowl Geometry' },      // mJ
    { stage: 'E_Q',     energy: Math.abs(E_bowl) * Q_enhancement * 1e3, label: '+Q Enhancement' },     // mJ
    { stage: 'E_duty',  energy: Math.abs(E_bowl) * Q_enhancement * dutyBurst * 1e3,  label: '+Duty Factor' },     // mJ
    { stage: 'E_deff',  energy: Math.abs(E_bowl) * Q_enhancement * dutyEff * 1e3,    label: '+Sector Strobing' }, // mJ
  ];

  // C. Duty vs Power Analysis Data (scale around live baseline)
  // Use the current live dutyBurst as the baseline and scale power/ζ proportionally.
  const dutyRange = [0.001, 0.005, 0.01, 0.02, 0.05, 0.1]; // candidate d values
  const baseDuty = dutyBurst || 0.01;
  const basePowerW = powerDrawW || powerTargetW; // avoid zero dividing; use target if no reading
  const baseZeta = zeta || 0.5;

  const dutyAnalysisData = dutyRange.map(d => {
    const scale = baseDuty > 0 ? (d / baseDuty) : 1;
    const power = basePowerW * scale; // proportional scaling assumption
    const zetaScaled = baseZeta * scale;
    return {
      duty: d * 100,          // %
      power: power / 1e6,     // MW
      zeta: zetaScaled,
      isOptimal: power < 83e6 && zetaScaled < 1.0 // legacy sweet-spot rule; adjust if you expose per-mode caps
    };
  });

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp className="h-5 w-5" />
        <h3 className="text-lg font-semibold">Visual Proof Analysis</h3>
        <Badge variant="outline">Real-time Validation</Badge>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
        
        {/* A. Radar Plot - Spec vs Achieved */}
        <Card className="col-span-1">
          <CardHeader>
            <CardTitle className="text-sm flex items-center gap-2">
              <Target className="h-4 w-4" />
              Spec vs Achieved
            </CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={250}>
              <RadarChart data={radarData}>
                <PolarGrid />
                <PolarAngleAxis dataKey="subject" className="text-xs" />
                <PolarRadiusAxis angle={90} domain={[0, 'dataMax']} className="text-xs" />
                <Radar name="Target"   dataKey="target"   stroke="#10b981" fill="#10b981" fillOpacity={0.2} strokeWidth={2} />
                <Radar name="Achieved" dataKey="achieved" stroke="#3b82f6" fill="#3b82f6" fillOpacity={0.4} strokeWidth={2} />
                <Tooltip formatter={(v: number, n: string) => [typeof v === 'number' ? v.toFixed(2) : v, n]} />
              </RadarChart>
            </ResponsiveContainer>
            <div className="text-xs text-muted-foreground mt-2">
              Green: Target spec | Blue: Achieved values
            </div>
          </CardContent>
        </Card>

        {/* B. Energy Boost Pipeline */}
        <Card className="col-span-1">
          <CardHeader>
            <CardTitle className="text-sm flex items-center gap-2">
              <Activity className="h-4 w-4" />
              Energy Boost Pipeline
            </CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={250}>
              <BarChart data={energyPipelineData} layout="horizontal">
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis type="number" scale="log" domain={['dataMin', 'dataMax']} className="text-xs" />
                <YAxis type="category" dataKey="stage" className="text-xs" width={60} />
                <Tooltip
                  formatter={(value: number) => [`${value.toExponential(2)} mJ`, 'Energy']}
                  labelFormatter={(label: string) => {
                    const item = energyPipelineData.find(d => d.stage === label);
                    return item?.label || label;
                  }}
                />
                <Bar dataKey="energy" fill="#8884d8" name="Energy (mJ)" />
              </BarChart>
            </ResponsiveContainer>
            <div className="text-xs text-muted-foreground mt-2">
              Energy amplification: Flat → Bowl → Q → Duty
            </div>
          </CardContent>
        </Card>

        {/* C. Duty vs Power Sweet Spot */}
        <Card className="col-span-1">
          <CardHeader>
            <CardTitle className="text-sm flex items-center gap-2">
              <TrendingUp className="h-4 w-4" />
              Duty vs Power/Safety
            </CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={250}>
              <ComposedChart data={dutyAnalysisData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="duty" className="text-xs" label={{ value: 'Duty (%)', position: 'insideBottom', offset: -5 }} />
                <YAxis yAxisId="left" className="text-xs" label={{ value: 'Power (MW)', angle: -90, position: 'insideLeft' }} />
                <YAxis yAxisId="right" orientation="right" className="text-xs" label={{ value: 'ζ margin', angle: 90, position: 'insideRight' }} />
                <Tooltip formatter={(v: number, n: string) => [typeof v === 'number' ? v.toFixed(2) : v, n === 'power' ? 'Power (MW)' : 'ζ margin']} />
                <Bar  yAxisId="left"  dataKey="power" fill="#ef4444" name="power" opacity={0.7} />
                <Line yAxisId="right" type="monotone" dataKey="zeta" stroke="#10b981" strokeWidth={2}
                      dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }} name="zeta" />
              </ComposedChart>
            </ResponsiveContainer>
            <div className="text-xs text-muted-foreground mt-2">
              Sweet spot: Power &lt; 83&nbsp;MW (red) & ζ &lt; 1.0 (green)
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Summary Status */}
      <Card>
        <CardContent className="pt-4">
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium">Proof Validation Status:</span>
            <div className="flex gap-2">
              <Badge variant={
                radarData.every(d => d.target > 0 && Math.abs((d.achieved - d.target) / d.target) <= 0.1)
                  ? "default" : "secondary"
              }>
                Spec Compliance
              </Badge>
              <Badge variant={(powerDrawW || 0) < powerTargetW * 1.1 ? "default" : "destructive"}>
                Power Target
              </Badge>
              <Badge variant={zeta < zetaSafeLimit ? "default" : "destructive"}>
                Quantum Safety
              </Badge>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

---

### Why this fixes your issues

* **Live power & units:** `P_avg` is MW on the server; the chart expects **W**, so we convert (`* 1e6`). Radar shows **Power (MW)** using `/ 1e6` for display.
* **Live duty:** Uses `pipeline.dutyBurst` and `pipeline.dutyEffective_FR` when present, matching the physics pipeline.
* **Live targets:** Pulls `exoticMassTarget_kg` directly, honors `constraints` if you start sending them, and maps per-mode **powerTarget** to W (83.3 MW hover / 7.437 W cruise / 297.5 MW emergency).
* **Backward-compatible:** You can still pass `results`/`targets` as props to override or to mock in Storybook.

If you later expose `pipeline.constraints` with `P_target_W`, `P_avg_max`, `TS_min`, `zeta_max`, etc., this component will automatically prefer those.
