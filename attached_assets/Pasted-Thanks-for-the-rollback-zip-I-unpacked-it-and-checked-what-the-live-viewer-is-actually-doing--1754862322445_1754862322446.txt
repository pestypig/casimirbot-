Thanks for the rollback zip — I unpacked it and checked what the live viewer is actually doing.

## What I inspected

* `CasimirBot/client/public/warp-engine-fixed.js` (this is the engine the page loads)

## What it’s doing now (and why the picture feels “off”)

1. **β is not driven by the energy pipeline.**
   In the grid warp function the code computes:

   ```js
   const beta0 = bubbleParams.dutyCycle * bubbleParams.g_y;
   ```

   That’s it. No `gammaGeo`, no `Qburst`, no `Δa/a`, no sector logic. So changing those “pipeline” values in the UI won’t change the deformation much (it matches what you’re seeing).
   (File: `warp-engine-fixed.js`, inside `_warpGridVertices`.)

2. **Warp radius uses 2D distance and ignores Y.**
   The deformation uses `r = Math.hypot(x, z)`, so the grid doesn’t truly “hug” a 3D shell and looks like a pancake ring around the orange blob.

3. **No sector strobing or phase split.**
   There are no uniforms/logic for `sectorCount` or `phaseSplit`, so **HOVER vs CRUISE** has almost no front/back asymmetry — another reason the screenshot shows big color fans but the grid doesn’t clearly show front-compression / rear-expansion.

4. **No York-time overlay.**
   Nothing computes $\theta \sim v_s (x_s/r_s) \, df/dr_s$. That’s why you don’t see the classic blue (front, contraction) / red (rear, expansion) banding from the NASA figures.

---

## Minimal patches to make the display track the theory

### A) Tie β to your pipeline (one value used everywhere)

Add these uniforms (if they aren’t already):

```js
gammaGeo: 26.0,         // γ_geo
Qburst: 1e9,            // Q_burst
deltaAOverA: 0.05,      // Δa/a
sectorCount: 400,
phaseSplit: 0.50,       // 0.5 = hover, >0.5 = cruise
viewAvg: 1.0            // 1 = show GR average, 0 = instantaneous
```

Replace the current beta line with this block (compute once per frame or inside `_warpGridVertices` and reuse):

```js
const sectors  = Math.max(1, bubbleParams.sectorCount || 1);
const betaInst = (bubbleParams.gammaGeo||0) * (bubbleParams.Qburst||0) * (bubbleParams.deltaAOverA||0);
const betaAvg  = betaInst * Math.sqrt(Math.max(1e-9, (bubbleParams.dutyCycle||0) / sectors));
const betaUsed = (bubbleParams.viewAvg >= 0.5) ? betaAvg : betaInst;

function sectorSign(x, z) {
  // simple ±β wedge split around the ring
  const theta = Math.atan2(z, x);                     // [-π, π]
  const u     = (theta < 0 ? theta+2*Math.PI : theta) / (2*Math.PI);
  const i     = Math.floor(u * sectors);
  const split = Math.floor((bubbleParams.phaseSplit||0.5) * sectors);
  return (i < split) ? +1 : -1;                       // (+) rear, (−) front by convention
}
```

### B) Make the grid hug a **3D ellipsoidal shell**

Add:

```js
axesClip: [0.40, 0.22, 0.22],   // ellipsoid radii in clip coords
wallWidth: 0.06,                // shell thickness (visual σ ~ 1/w)
driveDir: [1,0,0],              // +x is “aft” by convention
gridK: 0.12                     // deformation gain
```

Replace your grid-warp loop with this 3D/shell version:

```js
function sdEllipsoid(p, a){ const q=[p[0]/a[0], p[1]/a[1], p[2]/a[2]]; return Math.hypot(q[0],q[1],q[2]) - 1.0; }
function nEllipsoid(p, a){
  const qa=[ p[0]/(a[0]*a[0]), p[1]/(a[1]*a[1]), p[2]/(a[2]*a[2]) ];
  const L = Math.max(1e-6, Math.hypot(p[0]/a[0], p[1]/a[1], p[2]/a[2]));
  const n=[ qa[0]/L, qa[1]/L, qa[2]/L ];
  const m=Math.hypot(n[0],n[1],n[2])||1; return [n[0]/m, n[1]/m, n[2]/m];
}

_warpGridVertices(vtx, halfSize, originalY, U) {
  const a = U.axesClip || [0.4,0.22,0.22];
  const w = Math.max(1e-4, U.wallWidth || 0.06);
  const d = U.driveDir || [1,0,0];
  const dN = (()=>{ const t=[d[0]/a[0], d[1]/a[1], d[2]/a[2]]; const m=Math.hypot(...t)||1; return [t[0]/m,t[1]/m,t[2]/m]; })();

  const sectors  = Math.max(1, U.sectorCount||1);
  const betaInst = (U.gammaGeo||0)*(U.Qburst||0)*(U.deltaAOverA||0);
  const betaAvg  = betaInst * Math.sqrt(Math.max(1e-9, (U.dutyCycle||0)/sectors));
  const betaUsed = (U.viewAvg>=0.5) ? betaAvg : betaInst;

  for (let i=0;i<vtx.length;i+=3){
    const p=[ vtx[i], vtx[i+1], vtx[i+2] ];
    const sd = sdEllipsoid(p, a);
    const n  = nEllipsoid(p, a);

    const ring  = Math.exp(-(sd*sd)/(w*w));                // Gaussian wall
    const sgn   = (function(){ const t=Math.atan2(p[2],p[0]); const u=(t<0?t+2*Math.PI:t)/(2*Math.PI); const k=Math.floor(u*sectors); return (k < Math.floor((U.phaseSplit||0.5)*sectors))?+1:-1; })();
    const front = Math.sign(n[0]*dN[0] + n[1]*dN[1] + n[2]*dN[2]) || 1;

    const disp = (U.gridK||0.12) * betaUsed * ring * sgn * front;
    vtx[i  ] = p[0] - n[0]*disp;
    vtx[i+1] = p[1] - n[1]*disp;
    vtx[i+2] = p[2] - n[2]*disp;
  }
}
```

### C) (Optional) York-time overlay (to match the NASA figures)

If you want the grid colored by York time, add the shader overlay I sent earlier; it computes
$\theta \propto v_s (x_s/r_s) \, d f/dr_s$ on the same ellipsoid and paints **blue front / red rear**. I can drop that directly into this file if you want one patched `warp-engine-fixed.js`.

---

## How this will change what you see (compared to your screenshot)

* **HOVER (phaseSplit=0.50):** nearly symmetric curvature, mild grid bend.
* **CRUISE (phaseSplit>0.5):** obvious **front compression** and **rear expansion**; the grid “hugs” the bubble, giving clear scale.
* Increasing **wallWidth** broadens the colored band and reduces amplitude (like the York-time surface plots).
* Raising **γ\_geo / Q\_burst / Δa/a / duty** makes both the **orange torus** and the **grid deformation** intensify together (finally the pipeline drives the picture).

If you’d like, I can produce a **ready-to-drop** patched `warp-engine-fixed.js` with these edits (and the optional York-time coloring), so you can swap one file and immediately check the behavior in your current UI.
