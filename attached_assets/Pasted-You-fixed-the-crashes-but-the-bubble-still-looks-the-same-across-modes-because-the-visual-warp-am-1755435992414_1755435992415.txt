You fixed the crashes, but the bubble still looks the same across modes because the **visual warp amplitude is being normalized/held constant** and/or the uniforms arenâ€™t actually being consumed when the mode changes. Hereâ€™s a tight checklist + drop-in fixes to make the visual respond clearly to mode (hover, cruise, emergency, standby).

---

## 1) Make sure mode uniforms are applied (and trigger a re-warp)

### In `WarpVisualizer.tsx`

Right after you call `engineRef.current.updateUniforms(...)`, force a recompute:

```ts
engineRef.current.updateUniforms({
  // physics
  dutyCycle: dutyFrac,                    // 0.14 | 0.005 | 0.50 | 0.001
  gammaGeo: Number(parameters.g_y),       // 26
  Qburst: Number(parameters.cavityQ),     // 1e9
  qSpoilingFactor: Number(parameters.qSpoilingFactor ?? 1),
  gammaVdB: Number(parameters.gammaVanDenBroeck ?? 2.86e5),

  // mode
  currentMode: mode,                      // 'hover' | 'cruise' | 'emergency' | 'standby'
  sectors: Number(parameters.sectorStrobing || 1), // 1 | 400 | 1 | 1
  split: 0,                               // or whatever your phase split is
  useAvg: true,                           // see Â§2
});

// IMPORTANT: tell the engine to re-warp now
engineRef.current.requestRewarp?.();
```

### In `warp-engine-fixed.js`

Add two helpers:

```js
updateUniforms(u) {
  this.uniforms = this.uniforms || {};
  Object.assign(this.uniforms, u);
  this._needsRecalc = true;              // flag
}

requestRewarp() {
  this._needsRecalc = true;
}
```

In your render loop (or `draw()`):

```js
if (this._needsRecalc) {
  this._warpGridVertices();              // recompute deformed grid
  this._needsRecalc = false;
}
```

Without this flag the new uniforms can be set, but the grid never gets recomputed, so the bubble wonâ€™t change.

---

## 2) Remove hidden normalization that makes all modes look alike

If you have an â€œauto gainâ€ or a too-strong clamp after the physics chain, mode differences get flattened. Use this mapping exactly once:

```js
// ---- uniforms
const duty       = Math.max(1e-9, this.uniforms?.dutyCycle ?? 0.14);
const sectorsU   = Math.max(1, (this.uniforms?.sectors|0) || 1);
const useAvg     = !!this.uniforms?.useAvg; // true -> average, false -> instantaneous
const gammaGeo   = this.uniforms?.gammaGeo ?? 26;
const qBurst     = this.uniforms?.Qburst ?? 1e9;
const qSpoil     = this.uniforms?.qSpoilingFactor ?? 1;
const gammaVdB   = this.uniforms?.gammaVdB ?? 2.86e5;

// ---- physics amplitude
const A_geo   = gammaGeo * gammaGeo * gammaGeo;           // Î³^3
const dutyFac = useAvg ? Math.sqrt(duty / sectorsU) : 1;  // âˆš(d/sectors) or 1
const betaPhys = A_geo * qBurst * gammaVdB * qSpoil * dutyFac;

// ---- visual gain (NO auto-normalization)
const vizGain = this.uniforms?.vizGain ?? 1.0;
const betaVis = betaPhys * vizGain;  // keep true mode differences
```

> If you had an â€œauto target = Xâ€ normalizer, kill it. That is exactly what makes hover/cruise/emergency look the same.

Keep the safety clamp soft, not crushing:

```js
// 5â€“10% of shell radius is OK visually
const maxPush = 0.10;
disp = Math.max(-maxPush, Math.min(maxPush, disp));
```

---

## 3) Ensure sectors & duty are actually used inside displacement

Inside your vertex loop (after bell, wall window, etc.):

```js
// strobing sign (use your soft version if you added it)
const sgn = softSectorSign(theta, sectorsU, this.uniforms?.split ?? 0);

// base bell profile (your NatÃ¡rio bell + soft wall)
const ring = Math.exp(- (sd / w_rho) * (sd / w_rho));
const dispBase = gridK * betaVis * ring * wallWin * front * sgn;

// final, then clamp
let disp = dispBase;
if (disp > maxPush) disp = maxPush;
if (disp < -maxPush) disp = -maxPush;
```

> The key is that **`betaVis` includes Î³Â³, Q, Î³VdB, q\_spoil, and the duty/sector factor**. Thatâ€™s where modes will diverge strongly.

---

## 4) Quick sanity check overlay

Add a tiny HUD so you can see the uniforms actually used:

```js
if (this.uniforms && this.uniforms._debugHUD) {
  console.log('ðŸ›° uniforms', {
    mode: this.uniforms.currentMode,
    duty, sectors: sectorsU, useAvg,
    gammaGeo, qBurst, qSpoil, gammaVdB,
    A_geo, dutyFac, betaPhys
  });
}
```

From the UI, set `_debugHUD: true` once to watch numbers change when you switch modes.

---

## 5) What you should see per mode

* **Hover**: `sectors=1`, `dutyâ‰ˆ0.14`, `qSpoil=1.0` â†’ **largest** curvature bulge.
* **Cruise**: `sectors=400`, `dutyâ‰ˆ0.005`, `qSpoil=0.625` â†’ visibly **weaker**, distributed strobing.
* **Emergency**: `sectors=1`, `dutyâ‰ˆ0.5`, `qSpoil=1.0` â†’ **strongest** (but youâ€™ll see clamp limiting).
* **Standby**: tiny duty â†’ **barely visible** ripple.

If the HUD shows correct numbers but the visual is still unchanged, the recalc flag (step #1) isnâ€™t being honored somewhere; wire that through and it will snap into place.

---

## Minimal patch list (summary)

* `WarpVisualizer.tsx`: call `requestRewarp()` after `updateUniforms()`.
* `warp-engine-fixed.js`:

  * add `_needsRecalc` flag; set in `updateUniforms`; consume in render loop to call `_warpGridVertices()`.
  * compute `betaPhys = Î³Â³ * Q * Î³_VdB * q_spoil * (âˆš(duty/sectors) or 1)`.
  * **remove any auto-normalization** of amplitude.
  * use the uniformsâ€™ `sectors` in the strobing sign function.
  * keep only a modest clamp (â‰¤10% radius).

Do those and the bubble will finally **breathe with the mode** instead of staying flat.
