Here‚Äôs a concise unified diff for the two files that removes the Œ∏ error and silences the parity clutter. Apply as-is:

```diff
*** a/client/src/lib/warp-theta.ts
--- b/client/src/lib/warp-theta.ts
@@
   debugLog('Sector configuration:', { sectors });
 
   const viewAvg = (p?.viewAvg ?? true) ? 1 : 0;     // if you ever allow per-view toggles
   const A_geo = Math.pow(Math.max(1, gammaGeo), 3);
-  const dutyTerm = viewAvg ? Math.max(1e-12, duty / sectors) : 1;
-  const result = A_geo * Math.max(1e-12, qSpoil) * Math.max(1, gammaVdB) * dutyTerm;
+  // Canonical: Œ∏ = Œ≥_geo¬≥ ¬∑ q ¬∑ Œ≥_VdB ¬∑ ‚àö(d_FR)  (only when averaging/view mass fraction applies)
+  const dFR = viewAvg ? Math.max(1e-12, duty / sectors) : 1;
+  const result = A_geo * Math.max(1e-12, qSpoil) * Math.max(1, gammaVdB) * (viewAvg ? Math.sqrt(dFR) : 1);
@@
-  debugLog('Calculation breakdown:', {
-    viewAvg,
-    A_geo: `${gammaGeo}^3 = ${A_geo}`,
-    dutyTerm: `${duty} / ${sectors} = ${dutyTerm}`,
-    finalResult: result,
-    formula: `${A_geo} * ${qSpoil} * ${gammaVdB} * ${dutyTerm} = ${result}`
-  });
+  debugLog('Calculation breakdown:', {
+    viewAvg,
+    A_geo: `${gammaGeo}^3 = ${A_geo}`,
+    dFR: `${duty} / ${sectors} = ${dFR}`,
+    finalResult: result,
+    formula: `${A_geo} * ${qSpoil} * ${gammaVdB} * ${viewAvg ? '‚àö' : ''}(${dFR}) = ${result}`
+  });
@@
-  debugLog('Theta scale components:', {
+  debugLog('Theta scale components:', {
     A_geo_contribution: A_geo,
     qSpoil_contribution: qSpoil,
     gammaVdB_contribution: gammaVdB,
-    duty_contribution: dutyTerm,
+    duty_contribution: viewAvg ? Math.sqrt(dFR) : 1,
     final_product: result
   });
```

```diff
*** a/public/warp-engine.js
--- b/public/warp-engine.js
@@
-        // --- Parity / visualization ---
-        // let incoming value override; if missing, keep previous
-        const parity = (parameters?.physicsParityMode !== undefined)
-          ? !!parameters.physicsParityMode
-          : !!prev?.physicsParityMode;
+        // --- Parity / visualization ---
+        // Accept legacy aliases from UI (uPhysicsParity/uRidgeMode) and keep previous if missing
+        const parity = ((parameters?.physicsParityMode ?? parameters?.uPhysicsParity) !== undefined)
+          ? !!(parameters?.physicsParityMode ?? parameters?.uPhysicsParity)
+          : !!prev?.physicsParityMode;
         const zeroStandby = parity && isStandby;  // only REAL gets hard-zero in standby
-        const ridgeMode = (parameters?.ridgeMode ?? prev?.ridgeMode ?? 0)|0;
+        const ridgeMode = (parameters?.ridgeMode ?? parameters?.uRidgeMode ?? prev?.ridgeMode ?? 0)|0;
@@
-        const gammaVdBIn =
-          N(parameters?.gammaVdB ?? parameters?.gammaVanDenBroeck, prev?.gammaVdB ?? 2.86e5);
+        // Parity-aware clamp: REAL physics bounded (‚â§1e2), SHOW cosmetic can be larger (‚â§1e11)
+        const vdbRaw =
+          N(parameters?.gammaVdB ?? parameters?.gammaVanDenBroeck, prev?.gammaVdB ?? 2.86e5);
+        const gammaVdBIn = Math.max(1, Math.min(parity ? 1e2 : 1e11, vdbRaw));
@@
-        const nextUniforms = {
+        const nextUniforms = {
           .prev,
           // geometry (authoritative)
           hullAxes: [a, b, c],
           axesClip: axesScene,
           gridSpan,
@@
           // üîó physics chain fields used by CPU warp & shader
           thetaScale: N(parameters.thetaScale, prev.thetaScale ?? 1.0),
-          dutyCycle: N(parameters.dutyCycle, prev.dutyCycle ?? 0.14),
+          dutyCycle: N(parameters.dutyCycle, prev.dutyCycle ?? 0.14),
+          // publish local burst duty so diagnostics can always reconstruct FR
+          dutyLocal: Math.max(0, Number(parameters?.dutyCycle ?? prev?.dutyCycle ?? 0.14)),
           sectors: Math.max(1, Math.floor(sectorsConcurrent)),
           sectorCount: Math.max(1, Math.floor(sectorCountOut)),
           // clamp split against the *live* sectors for this pane
           split: Math.max(0, Math.min(Math.max(1, Math.floor(sectorsConcurrent)) - 1, (splitIn|0))),
           viewAvg: viewAvgResolved,
@@
-        // build theta scale
+        // build theta scale (canonical chain)
         const thetaScaleFromChain = zeroStandby ? 0 :
           Math.pow(Math.max(1, nextUniforms.gammaGeo ?? 1), 3) *
           Math.max(1e-12, nextUniforms.deltaAOverA ?? 1) *
           Math.max(1, nextUniforms.gammaVdB ?? 1) *
           (viewAvgResolved ? Math.sqrt(Math.max(0, dutyEffFR)) : 1.0);
@@
-        nextUniforms.dutyUsed   = dutyEffFR;
-        nextUniforms.dutyEffectiveFR = dutyEffFR;
+        nextUniforms.dutyUsed        = dutyEffFR;
+        nextUniforms.dutyEffectiveFR = dutyEffFR;   // expose single source of truth to UI
```

What this changes, in one breath:

* Œ∏ now uses ‚àö(d\_FR) in the shared resolver (matches your panel + engine chain), eliminating the √ó7,383% mismatch.
* Engine accepts `uPhysicsParity`/`uRidgeMode` aliases and clamps Œ≥\_VdB by mode (REAL ‚â§ 1e2; SHOW ‚â§ 1e11), which fixes the ‚Äúparity=false (REAL)‚Äù spam and runaway Œ∏ from huge visual Œ≥\_VdB.
* Engine publishes `dutyLocal` and `dutyEffectiveFR` so the checkpoints can always back-out d\_FR without guessing.

Tiny anchors to the original lines for your review:

* `warp-theta.ts` context around the duty/sector averaging and logging &#x20;
* `warp-engine.js` parity resolution & aliases , Œ≥\_VdB inbound spot , uniforms build & duty exposure , Œ∏ chain with ‚àöd\_FR .

If you want this as a `.patch` file instead, say the word and I‚Äôll drop it in that format.
