Your pipeline is correctly driving power/mass and exposing mode → sectors, but there are three wiring bugs that keep it from being fully consistent with the strobing and the warp engine:

Total vs. concurrent sectors are mixed up inside dynamicConfig for Natário/DCE.

Light-crossing units are wrong (you pass a dimensionless ratio where ms/ns are expected).

computeEnergySnapshot recomputes dutyEffectiveFR instead of trusting the pipeline (can drift from the server truth).

Below are tight, drop-in patches. Apply all three and you’ll have a clean mode → pipeline → warp-engine.js linkage.

1) Fix sector counts & duties in Natário + DCE calls

Use sectorCount = state.sectorCount (total, e.g. 400) and carry concurrentSectors = state.concurrentSectors separately. Also pass FR duty, not UI duty.

@@
-  const natario = calculateNatarioMetric(
-    {
+  // --- Construct light-crossing packet (filled correctly below) ---
+  const f_m = (state.modulationFreq_GHz ?? 15) * 1e9;     // Hz
+  const T_m_s = 1 / f_m;                                  // s
+  const tauLC_s = (state.hull?.wallThickness_m ?? 1.0) / C;
+  const lightCrossing = {
+    tauLC_ms: tauLC_s * 1e3,
+    burst_ms: BURST_DUTY_LOCAL * T_m_s * 1e3,
+    dwell_ms: T_m_s * 1e3,
+  };
+  (state as any).lightCrossing = lightCrossing;
+
+  const natario = calculateNatarioMetric({
       gap: state.gap_nm,
       hull: state.hull ? { a: state.hull.Lx_m / 2, b: state.hull.Ly_m / 2, c: state.hull.Lz_m / 2 } : { a: 503.5, b: 132, c: 86.5 },
       N_tiles: state.N_tiles,
       tileArea_m2: state.tileArea_cm2 * CM2_TO_M2,
-      dutyEffectiveFR: d_eff,
-      lightCrossing: { tauLC_ms: (state as any).TS_wall || 1.0, burst_ms: 0.01, dwell_ms: 0.99 },
+      dutyEffectiveFR: d_eff,
+      lightCrossing,
       gammaGeo: state.gammaGeo,
       gammaVanDenBroeck: state.gammaVanDenBroeck,
       qSpoilingFactor: state.qSpoilingFactor,
       cavityQ: state.qCavity,
       modulationFreq_GHz: state.modulationFreq_GHz,
-      sectorStrobing: state.sectorStrobing,
-      dynamicConfig: {
-        sectorCount: state.sectorStrobing,
-        sectorDuty: state.dutyCycle,
+      sectorStrobing: state.concurrentSectors,   // concurrent live sectors
+      dynamicConfig: {
+        sectorCount: state.sectorCount,          // TOTAL sectors (e.g. 400)
+        concurrentSectors: state.concurrentSectors,
+        sectorDuty: d_eff,                       // FR duty, not UI duty
         cavityQ: state.qCavity,
         qSpoilingFactor: state.qSpoilingFactor,
         gammaGeo: state.gammaGeo,
         gammaVanDenBroeck: state.gammaVanDenBroeck,
         pulseFrequencyGHz: state.modulationFreq_GHz,
-        lightCrossingTimeNs: ((state as any).TS_wall || 1.0) * 1e6
+        lightCrossingTimeNs: tauLC_s * 1e9
       }
-    } as any,
-    state.U_static * state.N_tiles   // pipeline total Casimir energy this tick
-  );
+    } as any, state.U_static * state.N_tiles);
@@
-    const dyn = calculateDynamicCasimirWithNatario(
-      {
+    const dyn = calculateDynamicCasimirWithNatario({
         staticEnergy: staticResult.totalEnergy,
         modulationFreqGHz: state.modulationFreq_GHz,
         strokeAmplitudePm: (state as any).strokeAmplitude_pm ?? 50,
         burstLengthUs: (state as any).burst_us ?? 10,
         cycleLengthUs: (state as any).cycle_us ?? 1000,
         cavityQ: state.qCavity,
         tileCount: state.N_tiles
-      },
-      // pass the full snapshot so resolveFromPipeline can read it:
-      {
+      }, {
         ...state,
         dynamicConfig: {
           modulationFreqGHz: state.modulationFreq_GHz,
           cavityQ: state.qCavity,
           qSpoilingFactor: state.qSpoilingFactor,
-          sectorCount: state.sectorStrobing,
-          sectorDuty: state.dutyCycle,
-          lightCrossingTimeNs: ((state as any).TS_wall || 1.0) * 1e6,
+          sectorCount: state.sectorCount,
+          concurrentSectors: state.concurrentSectors,
+          sectorDuty: d_eff,                      // FR duty
+          lightCrossingTimeNs: tauLC_s * 1e9,
           gammaGeo: state.gammaGeo,
           gammaVanDenBroeck: state.gammaVanDenBroeck
         }
       } as any
     );