Good catch — that error usually happens when a public JS file includes HTML <script> tags or class-field syntax that the bundler isn’t expecting. In the outline engine I gave you, I wrapped the file in <script>…</script> so you could paste it anywhere, but since you’re serving it as a standalone JS file (/warp-engine-outline.js), those tags break parsing.

Here’s a clean patch (no <script> wrapper, no class fields), plus a tiny safety tweak so the React component waits for the script to load before bootstrapping.

⸻

✅ Patch 1 — client/public/warp-engine-outline.js (replace file contents)

/**
 * Warp Bubble • Shell Outline (ρ = 1 ± Δ)
 * Ellipsoidal wireframes for inner / center / outer shell (Natário),
 * with interior shift vector (violet).
 */
(function () {
  const TAU = Math.PI * 2;

  // Helpers
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const lerp  = (a, b, t) => a + (b - a) * t;

  function ellipsoidPoint(a, b, c, theta, phi) {
    const cosPhi = Math.cos(phi), sinPhi = Math.sin(phi);
    const cosTh  = Math.cos(theta), sinTh = Math.sin(theta);
    const x = a * cosPhi * cosTh;
    const y = b * sinPhi;
    const z = c * cosPhi * sinTh;
    return [x, y, z];
  }

  // Very simple look-at perspective aligned with +Y up, camera at +Z
  function project(p, cam) {
    const [x, y, z] = p;
    const pe = [x - cam.eye[0], y - cam.eye[1], z - cam.eye[2]];
    const Z = -pe[2];                       // looking toward -Z
    const X = pe[0];
    const Y = pe[1];
    const sx = cam.cx + cam.f * (X / Math.max(1e-6, Z));
    const sy = cam.cy - cam.f * (Y / Math.max(1e-6, Z));
    return [sx, sy, Z];
  }

  function OutlineEngine(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d', { alpha: false });
    this.pixelRatio = Math.max(1, window.devicePixelRatio || 1);
    this.params = {
      hullAxes: [0.42, 0.11, 0.09], // scene units
      wallWidth: 0.06,              // normalized Δρ thickness
      epsilonTilt: 0.0,
      betaTiltVec: [0, -1, 0]
    };
    this._needsFrame = false;
    this._resize = this._resize.bind(this);
    window.addEventListener('resize', this._resize);
    this._resize();
  }

  OutlineEngine.prototype.destroy = function () {
    window.removeEventListener('resize', this._resize);
  };

  OutlineEngine.prototype.bootstrap = function (params) {
    this.updateUniforms(params || {});
    this._draw(); // immediate paint
  };

  OutlineEngine.prototype.updateUniforms = function (params) {
    const p = Object.assign({}, this.params, params || {});

    if (!Array.isArray(p.hullAxes) || p.hullAxes.length !== 3) {
      p.hullAxes = this.params.hullAxes.slice();
    }
    p.wallWidth =
      Number.isFinite(p.wallWidth) && p.wallWidth > 0 ? p.wallWidth : this.params.wallWidth;

    const v = Array.isArray(p.betaTiltVec) ? p.betaTiltVec.slice(0, 3) : [0, -1, 0];
    const L = Math.hypot(v[0], v[1], v[2]) || 1;
    p.betaTiltVec = [v[0] / L, v[1] / L, v[2] / L];

    this.params = p;
    this._requestDraw();
  };

  OutlineEngine.prototype._resize = function () {
    const pr = this.pixelRatio;
    const w = this.canvas.clientWidth || (this.canvas.parentElement && this.canvas.parentElement.clientWidth) || 800;
    const h = this.canvas.clientHeight || (this.canvas.parentElement && this.canvas.parentElement.clientHeight) || 400;
    this.canvas.width  = Math.floor(w * pr);
    this.canvas.height = Math.floor(h * pr);
    this.canvas.style.width  = w + 'px';
    this.canvas.style.height = h + 'px';
    this.ctx.setTransform(pr, 0, 0, pr, 0, 0);
    this._requestDraw();
  };

  OutlineEngine.prototype._camera = function () {
    const a = this.params.hullAxes[0], b = this.params.hullAxes[1], c = this.params.hullAxes[2];
    const R = Math.max(a, b, c);

    const w = this.canvas.width  / this.pixelRatio;
    const h = this.canvas.height / this.pixelRatio;
    const aspect = w / Math.max(1, h);

    // Slightly overhead; camera on +Z looking toward origin
    const eye  = [0, 0.40 * R, 1.8 * R];
    const fov  = aspect > 1 ? Math.PI / 3.2 : Math.PI / 2.8;
    const f    = (0.5 * h) / Math.tan(0.5 * fov);

    return {
      eye,
      f,
      cx: w * 0.5,
      cy: h * 0.5
    };
  };

  OutlineEngine.prototype._requestDraw = function () {
    if (this._needsFrame) return;
    this._needsFrame = true;
    requestAnimationFrame(() => {
      this._needsFrame = false;
      this._draw();
    });
  };

  OutlineEngine.prototype._draw = function () {
    const ctx = this.ctx;
    const p   = this.params;

    // Clear
    const W = this.canvas.width / this.pixelRatio;
    const H = this.canvas.height / this.pixelRatio;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    const cam = this._camera();

    // Colors (match main viz semantics)
    const colOuter  = '#1e90ff'; // expansion (blue)
    const colInner  = '#ff9b3a'; // compression (orange)
    const colCenter = '#cccccc'; // mid
    const colShift  = '#9b5cff'; // shift vector violet

    const a0 = p.hullAxes[0], b0 = p.hullAxes[1], c0 = p.hullAxes[2];
    const dRho = clamp(p.wallWidth, 0.005, 0.40);

    const shells = [
      { scale: 1 - dRho, color: colInner,  line: 1.5 },
      { scale: 1.00,     color: colCenter, line: 1.0 },
      { scale: 1 + dRho, color: colOuter,  line: 1.5 },
    ];

    const Nθ = 96, Nφ = 40;

    shells.forEach(s => {
      const a = a0 * s.scale, b = b0 * s.scale, c = c0 * s.scale;
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = s.color;
      ctx.lineWidth   = s.line;

      // Latitudes
      for (let j = 1; j < Nφ; j++) {
        const phi = lerp(-Math.PI/2, Math.PI/2, j / Nφ);
        let first = true;
        ctx.beginPath();
        for (let i = 0; i <= Nθ; i++) {
          const th = (i / Nθ) * TAU;
          const [x, y] = project(ellipsoidPoint(a, b, c, th, phi), cam);
          if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
        }
        ctx.stroke();
      }

      // Meridians
      for (let i = 0; i < Nθ; i += 6) {
        const th = (i / Nθ) * TAU;
        let first = true;
        ctx.beginPath();
        for (let j = 0; j <= Nφ; j++) {
          const phi = lerp(-Math.PI/2, Math.PI/2, j / Nφ);
          const [x, y] = project(ellipsoidPoint(a, b, c, th, phi), cam);
          if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
        }
        ctx.stroke();
      }
    });

    // Shift vector arrow
    if (p.epsilonTilt > 0) {
      const R = Math.max(a0, b0, c0);
      const head = p.epsilonTilt * 1.2 * R;
      const base = [0, 0, 0];
      const tip  = [
        base[0] + p.betaTiltVec[0] * head,
        base[1] + p.betaTiltVec[1] * head,
        base[2] + p.betaTiltVec[2] * head,
      ];
      const [x0, y0] = project(base, cam);
      const [x1, y1] = project(tip,  cam);

      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = colShift;
      ctx.fillStyle   = colShift;
      ctx.lineWidth   = 2.0;

      ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke();

      const angle = Math.atan2(y1 - y0, x1 - x0);
      const ah = 10, aw = 6;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x1 - ah * Math.cos(angle - Math.PI/8), y1 - ah * Math.sin(angle - Math.PI/8));
      ctx.lineTo(x1 - aw * Math.cos(angle + Math.PI/2), y1 - aw * Math.sin(angle + Math.PI/2));
      ctx.closePath();
      ctx.fill();
    }

    // Mini legend
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(12, 12, 220, 56);
    ctx.fillStyle = '#fff';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system';
    ctx.fillText('Shell Outline • ρ-surfaces (inner/center/outer)', 18, 28);
    ctx.fillStyle = colInner;  ctx.fillRect(18, 36, 10, 10); ctx.fillStyle = '#b0b8c0'; ctx.fillText('Compression (inner)', 34, 45);
    ctx.fillStyle = colOuter;  ctx.fillRect(138, 36, 10, 10); ctx.fillStyle = '#b0b8c0'; ctx.fillText('Expansion (outer)',   154, 45);
    ctx.fillStyle = '#b0b8c0';
    ctx.fillText('Shift vector shown in violet', 18, 60);
  };

  // expose
  window.OutlineEngine = OutlineEngine;
})();


⸻

✅ Patch 2 — client/src/components/ShellOutlineVisualizer.tsx (minor tweak)

Make sure we wait for the script load before bootstrapping. If your current file already matches this, you’re fine; otherwise, replace it with this version:

import React, { useEffect, useRef, useState } from "react";

type Props = {
  parameters?: {
    hull?: { a:number; b:number; c:number };
    wallWidth?: number;
    epsilonTilt?: number;
    betaTiltVec?: [number,number,number];
  };
};

declare global { interface Window { OutlineEngine?: any; } }

export default function ShellOutlineVisualizer({ parameters }: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const engineRef = useRef<any>(null);
  const [ready, setReady] = useState(!!window.OutlineEngine);

  useEffect(() => {
    if (window.OutlineEngine) { setReady(true); return; }
    const s = document.createElement("script");
    s.src = "/warp-engine-outline.js?v=3";
    s.onload = () => setReady(true);
    document.body.appendChild(s);
  }, []);

  useEffect(() => {
    if (!ready || !canvasRef.current) return;
    if (!engineRef.current) {
      engineRef.current = new window.OutlineEngine(canvasRef.current);
    }
    const hull = parameters?.hull || { a:0.42, b:0.11, c:0.09 };
    engineRef.current.bootstrap({
      hullAxes: [hull.a, hull.b, hull.c],
      wallWidth: parameters?.wallWidth ?? 0.06,
      epsilonTilt: parameters?.epsilonTilt ?? 0.0,
      betaTiltVec: (parameters?.betaTiltVec || [0,-1,0]) as [number,number,number],
    });
  }, [ready]);

  useEffect(() => {
    if (!engineRef.current) return;
    const hull = parameters?.hull || { a:0.42, b:0.11, c:0.09 };
    engineRef.current.updateUniforms({
      hullAxes: [hull.a, hull.b, hull.c],
      wallWidth: parameters?.wallWidth ?? 0.06,
      epsilonTilt: parameters?.epsilonTilt ?? 0.0,
      betaTiltVec: (parameters?.betaTiltVec || [0,-1,0]) as [number,number,number],
    });
  }, [parameters?.hull, parameters?.wallWidth, parameters?.epsilonTilt, parameters?.betaTiltVec]);

  return (
    <div className="rounded-xl overflow-hidden bg-black">
      <canvas ref={canvasRef} style={{ width: "100%", height: "420px", display: "block" }} />
    </div>
  );
}


⸻

Why this fixes your error
	•	No <script> tags inside the .js file → Vite/ESBuild can parse it cleanly.
	•	No class field syntax; everything is on the prototype → zero surprises for your bundler.
	•	The React component now waits for the script to load before creating the engine, avoiding race conditions that render a black panel.

If you still see a blank canvas afterward, double-check that the panel container actually has a nonzero height (the inline height: "420px" ensures the first draw has pixels).