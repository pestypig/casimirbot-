Great work â€” this version is **much** closer: itâ€™s pipeline-first, the Casimir baseline now comes from the gap, and you removed the hard-coded â€œtargets.â€ ðŸ‘

Hereâ€™s a tight audit with the few remaining issues and a small patch to make everything non-magical and fully pipeline-driven.

# âœ… Looks correct / pipeline-driven

* `Î³_geo`, `Î³_VdB`, `Q`, `qSpoilingFactor`, sectoring & duties, tile area/count, Fordâ€“Roman limit, and `P_avg_W` are all accepted from params (with sane defaults).
* Casimir density now uses $u_0 = -\pi^2 \hbar c / (720 a^4)$ â€” good.
* No more â€œ83 MW / 1.4e3 kg / 1.96e9 tilesâ€ baked in.
* Unit bug on `effectivePathLength` is gone (kept in meters).

# âš ï¸ Remaining â€œmagic-ishâ€ spots

1. **Defaults that are still numbers** (OK to keep, but put them in `DEFAULTS` so theyâ€™re explicit & configurable):

   * `tileArea_m2 = 0.05Ã—0.05`, `Q0 = 1e9`, `fordRomanLimit_kg = 1e6`.
   * Numerical floors like `1e-12` are fine for safety, but also belong in `DEFAULTS` for visibility.

2. **Stress tensor anisotropy**

   * `T22 = -energyDensity * 0.5` is an arbitrary Â½ factor. Expose it as a parameter.

3. **Momentum shell thickness**

   * `calculateMomentumFlux(..., /*thickness*/ 1e-6)` is still a literal. Make it a param (with a DEFAULT).

4. **Power compliance flag**

   * `isPowerCompliant` currently means â€œpowerDraw is finite.â€ Better: compare to an optional `powerTarget_W` with a tolerance.

5. **Comment mismatch**

   * The result comment says â€œ`-Î³_geo^3/a^3` scaling,â€ but the code returns `Î³_geo^3 * Î³_VdB` (the `a` dependence is already in the Casimir term). Update the comment to avoid confusion.

6. **Shift vector components**

   * `axialComponent = 0` is fine, but if you already have a tilt vector in your pipeline, map it here instead (so the 3D and slice stay in lockstep).

# Minimal patch (drop-in)

```ts
// --- add to DEFAULTS ---
const DEFAULTS = {
  fordRomanLimit_kg: 1e6,
  Q0: 1e9,
  tileArea_m2: 0.05 * 0.05,
  minPos: 1e-12,                 // numeric floor for divisions
  shellThickness_m: 1e-6,        // default shell thickness for momentum flux
  stressTangentialFactor: 0.5,   // default anisotropy factor for T22
  powerTolerance: 0.10           // Â±10% unless overridden
};

// --- extend NatarioWarpParams ---
export interface NatarioWarpParams {
  // ...existing...
  shellThickness_m?: number;                // for momentum flux
  stressTangentialFactor?: number;          // replaces hard-coded 0.5
  powerTarget_W?: number;                   // optional compliance target
  powerTolerance?: number;                  // fractional tolerance
  betaTiltVec?: [number, number, number];   // optional pipeline tilt mapping
}

// --- stress-energy uses param instead of 0.5 ---
export function calculateStressEnergyTensor(
  energyDensity: number,
  shiftField: NatarioShiftField,
  spatialGradients: { dvdr: number; dvdt: number },
  tangentialFactor: number = DEFAULTS.stressTangentialFactor
): StressEnergyComponents {
  const { amplitude } = shiftField;
  const { dvdr, dvdt } = spatialGradients;

  const T00 = energyDensity;
  const T11 = -(energyDensity + dvdr * amplitude * PHYSICS_CONSTANTS.C * PHYSICS_CONSTANTS.C);
  const T22 = -energyDensity * tangentialFactor;
  const T33 = -(energyDensity + dvdt * amplitude * PHYSICS_CONSTANTS.C * PHYSICS_CONSTANTS.C);

  const necSum = T00 + T11 + T22 + T33;
  return { T00, T11, T22, T33, isNullEnergyConditionSatisfied: necSum >= 0 };
}

// --- shift field: map axial from pipeline tilt if provided ---
export function calculateNatarioShiftField(
  params: NatarioWarpParams,
  totalExoticMass: number
): NatarioShiftField {
  const { shiftAmplitude, bowlRadius, betaTiltVec } = params;
  const radialProfile = (r: number): number => {
    const Rm = Math.max(DEFAULTS.minPos, bowlRadius * 1e-6);
    const rho = r / Rm;
    return rho <= 1
      ? shiftAmplitude * (rho * rho) * (3 - 2 * rho)
      : shiftAmplitude / (rho * rho);
  };

  const positivePhaseAmplitude = shiftAmplitude * (1 + params.effectiveDuty);
  const negativePhaseAmplitude = shiftAmplitude * (1 - params.effectiveDuty);
  const netShiftAmplitude = positivePhaseAmplitude - negativePhaseAmplitude;

  const tangentialComponent = 0;
  const axialComponent = Array.isArray(betaTiltVec) ? shiftAmplitude * (betaTiltVec[2] ?? 0) : 0;

  return { amplitude: shiftAmplitude, radialProfile, tangentialComponent, axialComponent,
           positivePhaseAmplitude, negativePhaseAmplitude, netShiftAmplitude };
}

// --- momentum flux: use param/default for thickness; pass tangentialFactor through ---
export function calculateNatarioWarpBubble(params: NatarioWarpParams): NatarioWarpResult {
  // ...unchanged up to tensor...
  const spatialGradients = {
    dvdr: shiftVectorField.amplitude / Math.max(DEFAULTS.minPos, params.bowlRadius * 1e-6),
    dvdt: 0.0
  };
  const stressEnergyTensor = calculateStressEnergyTensor(
    amplifiedEnergyDensity,
    shiftVectorField,
    spatialGradients,
    params.stressTangentialFactor ?? DEFAULTS.stressTangentialFactor
  );

  const shellThickness = params.shellThickness_m ?? DEFAULTS.shellThickness_m;
  const { momentumFlux } = calculateMomentumFlux(
    stressEnergyTensor,
    Math.max(DEFAULTS.minPos, params.bowlRadius * 1e-6),
    shellThickness
  );

  // --- power compliance against optional target ---
  const powerDraw = Number.isFinite(params.P_avg_W) ? params.P_avg_W! : NaN;
  const powerTarget = params.powerTarget_W;
  const tol = params.powerTolerance ?? DEFAULTS.powerTolerance;
  const isPowerCompliant =
    Number.isFinite(powerDraw) && Number.isFinite(powerTarget)
      ? Math.abs(powerDraw - (powerTarget as number)) <= (powerTarget as number) * tol
      : Number.isFinite(powerDraw); // fallback: â€œhas dataâ€ â‡’ ok

  return {
    // ...existing fields...
    isPowerCompliant
  };
}
```

# Tiny doc fixes

* In `NatarioWarpResult`, update the comment for `geometricAmplification` to:
  â€œ`Î³_geo^3 Ã— Î³_VdB` (Casimir $a^{-4}$ already in baseline)â€ to match the code.

# Verdict

With the small patch above, youâ€™ve removed the last â€œquietâ€ constants, exposed the remaining modeling choices via params/defaults, and kept everything driven by the real pipeline (including optional tilt and power targets). The curvature slider should now purely scale visualization without fighting hidden constants.
