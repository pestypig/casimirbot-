That crash is the same pattern as before: the engine tries to read gridScale before it exists. Fix it in two placesâ€”set a sane default in the engine, and guard every read. (Optionally, send an explicit value from React.)

1) Add a default in the engine

File: client/public/warp-engine-fixed.js
In the constructor (or right after this.uniforms is created), add:

// Defaults (extend, don't replace, if uniforms already exists)
this.uniforms = Object.assign({
  // â€¦ your other defaults â€¦
  gridScale: 1.0,       // unitless visual scale for the grid spacing
  vizGain: 1.0          // purely visual displacement gain
}, this.uniforms || {});

2) Guard reads where gridScale is used

Anywhere you use it (typically in _initializeGrid, _createGrid, or _warpGridVertices), coerce and fallback:

const gridScale = Number(this.uniforms?.gridScale);
const GS = Number.isFinite(gridScale) && gridScale > 0 ? gridScale : 1.0;

// Example uses:
const unit = 1.0 * GS;                 // grid cell size / scene unit
const axesScene = hullAxes.map(a => a / (1200 * GS));  // if you scale the scene

If you do a single place where you derive scene-space units, centralize it:

function getSceneScale(uniforms) {
  const s = Number(uniforms?.gridScale);
  return Number.isFinite(s) && s > 0 ? s : 1.0;
}
// â€¦
const GS = getSceneScale(this.uniforms);

3) (Optional) Send it from React so designers can tweak it

File: client/src/components/WarpVisualizer.tsx
When you call engine.updateUniforms(...), include a guarded value:

engineRef.current.updateUniforms({
  // â€¦existing uniformsâ€¦
  gridScale: Number(parameters.gridScale ?? 1.0),   // safe default
  vizGain:  Number(parameters.vizGain  ?? 1.0),     // lets you exaggerate visuals if needed
});

You can also expose two tiny buttons near the visual for quick testing:

<button onClick={()=>engineRef.current?.updateUniforms({gridScale: 0.8})}>Grid âˆ’</button>
<button onClick={()=>engineRef.current?.updateUniforms({gridScale: 1.2})}>Grid +</button>

4) Quick sanity check

Open the dev console and confirm uniforms exist before a frame renders:

ðŸ›° uniforms snapshot {
  hullAxes: [503.5,132,86.5],
  wallWidth: 0.06,
  sectors: 1,
  gridScale: 1,
  vizGain: 1,
  â€¦ }

With these guards:
	â€¢	No more gridScale undefined crashes.
	â€¢	You can safely tune grid density/scene scaling without breaking the renderer.
	â€¢	The bubble will still react to mode changes; gridScale only affects layout, not physics.