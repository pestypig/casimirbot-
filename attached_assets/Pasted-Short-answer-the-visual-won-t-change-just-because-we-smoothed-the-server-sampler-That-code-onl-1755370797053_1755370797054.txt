Short answer: the visual won’t change just because we smoothed the **server sampler**. That code only powers `/api/helix/field` and CSV exports. The onscreen warp bubble is driven entirely by the **client** `public/warp-engine-fixed.js` + the uniforms you pass from `WarpVisualizer.tsx`. If that renderer file didn’t actually change (or the browser is serving a cached copy), you’ll still see the ridge.

Here’s a tight checklist to make the visual change, plus the most likely remaining culprits.

---

## 1) Make sure the renderer code is the one running (cache-bust)

In `client/src/components/WarpVisualizer.tsx`, change the injected script URL so the browser fetches the new file:

```tsx
// BEFORE
script.src = "/warp-engine-fixed.js";

// AFTER (cache-bust)
script.src = `/warp-engine-fixed.js?v=3`;   // bump the number when you edit the file
```

Then hard-reload (Disable cache in DevTools → Network).

---

## 2) Verify the renderer uses the smooth math (not the sampler)

Open `public/warp-engine-fixed.js` and confirm these **four** are in the displacement loop:

```js
// (A) Smooth sector phase (replaces hard ±1)
const phase = 2*Math.PI*sectors*u + phase0;     // phase0 can be time-based
const sgn = viewAvg ? 1/Math.sqrt(2) : Math.sin(phase);

// (B) Soft front/back polarity (replaces Math.sign)
const dot = n[0]*dN[0] + n[1]*dN[1] + n[2]*dN[2];
const front = Math.tanh(6*dot);                 // 6–8 is a good steepness

// (C) Soft wall window (replaces hard band gate)
const asd = Math.abs(sd), a = 2.5*w_rho, b = 3.5*w_rho;
const wallWin = (asd<=a) ? 1 : (asd>=b) ? 0
               : 0.5*(1 + Math.cos(Math.PI*(asd-a)/(b-a)));

// (D) Physics-consistent amplitude (γ_geo³, not γ_geo¹)
const A_geo = gammaGeo*gammaGeo*gammaGeo;
let disp = gridK * betaGain * A_geo * qBurst * gammaVdB * qSpoil
         * wallWin * front * sgn * ring;
```

If any of those are still using `Math.floor`, `Math.sign`, a hard band, or `gammaGeo` to the first power, update them.

---

## 3) If it still looks “steppy”, it’s probably resolution or pre-clamp

* **Mesh resolution**: increase divisions of the grid (look for constants like `DIVS`, `GRID_DIVS`, `N_DIVS`):

```js
// try doubling
const GRID_DIVS = 160;   // was e.g. 80
```

* **Clamp order**: only clamp **after** any (optional) smoothing:

```js
// optional tiny smoothing in grid space
// disp = (disp + neighbors) / 5; // simple 3–5 tap average

const maxPush = 0.10;
disp = Math.max(-maxPush, Math.min(maxPush, disp));
```

Clamping too early creates flat shelves.

---

## 4) Quick sanity toggles (help isolate the cause)

Add temporary uniforms (or local consts) and flip them to see the effect:

```js
const USE_SMOOTH = true;  // set false to compare

const sgn = USE_SMOOTH
  ? (viewAvg ? 1/Math.sqrt(2) : Math.sin(phase))
  : ((Math.floor(u*sectors) < split) ? +1 : -1);

const front = USE_SMOOTH ? Math.tanh(6*dot) : (Math.sign(dot) || 1);

const wallWin = USE_SMOOTH ? softWindow(asd, w_rho) : (Math.abs(sd)<=3*w_rho ? 1:0);
```

* If the ridge vanishes when `sgn = Math.sin(phase)`, the culprit was the old hard sector step.
* If it vanishes when `front = tanh(…)`, the culprit was the front/back `Math.sign`.
* If it vanishes when using the soft wall window, the culprit was the hard band gate.
* If none of these change the ridge, bump **grid resolution**; you’re looking at aliasing.

---

## 5) Confirm the amplitude chain matches the pipeline

The renderer should match your energy pipeline’s amplification:

* `γ_geo³` (not `γ_geo`)
* `qBurst` = `Q_cavity` (or whatever you feed)
* `qSpoil` = `Q_spoilingFactor`
* `γ_VdB` from the pipeline state
* duty averaging: use `dutyEffectiveFR` for averaged view, and `dutyCycle` for instantaneous; with the sine sector, averaged amplitude gets the extra RMS factor `1/√2`.

---

## 6) Optional: overlay debug heatmaps

For 1–2 frames, color the grid by a field to see where discontinuities remain:

```js
// example: color by sgn or wallWin
const color = 0.5 + 0.5*sgn;         // 0..1
gridColors[i] = color; // or feed to shader if you’re using one
```

If you see a sharp band in the heatmap, that’s the source of the ridge.

---

### Why your earlier edit didn’t change visuals

You improved the **server** sampler (good for CSV/API), but the **visual** uses only `warp-engine-fixed.js`. Make the four smooth changes **there**, bump the cache-bust query string, hard-reload, and (if needed) increase grid divisions. That combination will give you the smooth, C¹ handoff between contraction and expansion you’re expecting.
