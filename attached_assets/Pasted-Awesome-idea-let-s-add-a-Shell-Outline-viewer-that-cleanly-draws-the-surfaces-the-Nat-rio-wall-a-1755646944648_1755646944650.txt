Awesome idea—let’s add a Shell Outline viewer that cleanly draws the ρ-surfaces (the Natário wall) as a wireframe, separate from the deformed grid. This is lightweight, fast, and super clear for audiences.

Below are drop-in files plus a small insertion in /helix-core.tsx. They don’t touch your existing warp engine.

⸻

1) New WebGL renderer (wireframe ellipsoid outlines)

client/public/warp-engine-outline.js

// Minimal wireframe outline renderer for Natário ρ-surfaces
// Draws three coaxial ellipsoids: ρ=1 (center wall), ρ=1±Δ (inner/outer)
// Colors: center=cyan/white, inner=blue, outer=orange, optional shift-vector arrow (violet)

(function () {
  class OutlineEngine {
    constructor(canvas) {
      this.canvas = canvas;
      this.gl = canvas.getContext('webgl', { antialias: true, alpha: true, preserveDrawingBuffer: true });
      if (!this.gl) throw new Error('WebGL not supported');

      this.uniforms = {
        hullAxes: [0.42, 0.22, 0.22], // scene units (clip-ish), default placeholder
        wallWidth: 0.06,              // normalized thickness
        showInner: true,
        showCenter: true,
        showOuter: true,
        showShiftArrow: true,
        lineAlpha: 0.95
      };

      this._initGL();
      this._setupCamera();
      this._resize();
      window.addEventListener('resize', () => this._resize());
      this._draw();
    }

    updateUniforms(partial) {
      Object.assign(this.uniforms, partial || {});
      // if hullAxes provided in meters, normalize approximately to scene units
      if (partial && partial.hullAxesMeters) {
        const a = partial.hullAxesMeters[0], b = partial.hullAxesMeters[1], c = partial.hullAxesMeters[2];
        // Normalize to an ~unit sphere-ish so it fits in clip space (similar to your main engine)
        const maxAxis = Math.max(a, b, c) || 1;
        const scale = 0.9 / maxAxis; // leave some margin
        this.uniforms.hullAxes = [a * scale, b * scale, c * scale];
      }
      this._draw();
    }

    // Public for React overlay HUD if desired
    getDiagnostics() {
      return { hullAxes: this.uniforms.hullAxes, wallWidth: this.uniforms.wallWidth };
    }

    _initGL() {
      const gl = this.gl;
      // Simple line program
      const vs = `
        attribute vec3 aPos;
        uniform mat4 uMVP;
        void main() { gl_Position = uMVP * vec4(aPos, 1.0); }
      `;
      const fs = `
        precision mediump float;
        uniform vec4 uColor;
        void main() { gl_FragColor = uColor; }
      `;
      const prog = this._mkProgram(vs, fs);
      gl.useProgram(prog);
      this.prog = prog;
      this.uMVP = gl.getUniformLocation(prog, 'uMVP');
      this.uColor = gl.getUniformLocation(prog, 'uColor');
      this.aPos = gl.getAttribLocation(prog, 'aPos');

      this.view = this._identity(); this.proj = this._identity(); this.mvp = this._identity();

      // Create dynamic buffers for 3 ellipsoids + shift arrow
      this.vbo = gl.createBuffer();
      this.counts = { inner: 0, center: 0, outer: 0, arrow: 0 };

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.lineWidth(1.0);
    }

    _setupCamera() {
      const gl = this.gl;
      const aspect = this.canvas.width / Math.max(1, this.canvas.height);
      const fov = this._fitFov(aspect);
      this._perspective(this.proj, fov, aspect, 0.01, 100.0);

      // Overhead-ish view (higher than default)
      const axes = this.uniforms.hullAxes;
      const R = Math.max(axes[0], axes[1], axes[2]);
      const dist = 2.2; // scene units; stable default (auto-fit happens in _fitCamera)
      const eye = [0, 0.55 * R * 3.2, -dist];
      const center = [0, -0.08 * R * 3.2, 0];
      const up = [0, 1, 0];
      this.view = this._lookAt(this._identity(), eye, center, up);
      this._mul(this.mvp, this.proj, this.view);
      this._fitCamera();
    }

    _fitFov(aspect) {
      // 60° desktop → ~68° portrait
      const fovDesktop = Math.PI / 3, fovPortrait = Math.PI / 2.65;
      const t = Math.min(1, Math.max(0, (1.2 - aspect) / 0.6));
      return fovDesktop * (1 - t) + fovPortrait * t;
    }

    _fitCamera() {
      const axes = this.uniforms.hullAxes;
      const R = Math.max(axes[0], axes[1], axes[2]);
      const aspect = this.canvas.width / Math.max(1, this.canvas.height);
      const fov = this._fitFov(aspect);
      const margin = aspect < 1 ? 1.32 : 1.20;
      const dist = (margin * R) / Math.tan(fov * 0.5);
      const eye = [0, 0.38 * R * 3.2, -dist];
      const center = [0, -0.06 * R * 3.2, 0];
      const up = [0, 1, 0];
      this.view = this._lookAt(this._identity(), eye, center, up);
      this._mul(this.mvp, this.proj, this.view);
    }

    _resize() {
      const gl = this.gl;
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const w = Math.floor(this.canvas.clientWidth * dpr);
      const h = Math.floor(this.canvas.clientHeight * dpr);
      if (this.canvas.width !== w || this.canvas.height !== h) {
        this.canvas.width = w; this.canvas.height = h;
        gl.viewport(0, 0, w, h);
        this._setupCamera();
        this._draw();
      }
    }

    _buildWire() {
      // Build polyline vertices for lat-long wireframes on 3 ellipsoids
      const { hullAxes, wallWidth } = this.uniforms;
      const [ax, ay, az] = hullAxes;
      const delta = Math.max(1e-4, wallWidth) * 0.5; // half-thickness
      const scaleInner = 1.0 - delta;
      const scaleOuter = 1.0 + delta;

      const rings = 24, meridians = 36;

      const buildEllipsoid = (scale) => {
        const verts = [];
        // Meridians (longitudes)
        for (let m = 0; m < meridians; m++) {
          const theta = (m / meridians) * Math.PI * 2;
          let prev = null;
          for (let r = 0; r <= rings; r++) {
            const phi = (r / rings) * Math.PI - Math.PI / 2; // [-π/2, +π/2]
            const x = scale * ax * Math.cos(phi) * Math.cos(theta);
            const y = scale * ay * Math.sin(phi);
            const z = scale * az * Math.cos(phi) * Math.sin(theta);
            if (prev) { verts.push(prev[0], prev[1], prev[2], x, y, z); }
            prev = [x, y, z];
          }
        }
        // Parallels (latitudes)
        for (let r = 1; r < rings; r++) {
          const phi = (r / rings) * Math.PI - Math.PI / 2;
          let prev = null;
          for (let m = 0; m <= meridians; m++) {
            const theta = (m / meridians) * Math.PI * 2;
            const x = scale * ax * Math.cos(phi) * Math.cos(theta);
            const y = scale * ay * Math.sin(phi);
            const z = scale * az * Math.cos(phi) * Math.sin(theta);
            if (prev) { verts.push(prev[0], prev[1], prev[2], x, y, z); }
            prev = [x, y, z];
          }
        }
        return new Float32Array(verts);
      };

      const inner = buildEllipsoid(scaleInner);
      const center = buildEllipsoid(1.0);
      const outer = buildEllipsoid(scaleOuter);

      // Optional: shift-vector arrow (violet), from center toward -Y by 0.6*ay
      const arrowLen = ay * 0.6;
      const arrow = new Float32Array([
        0, 0, 0,   0, -arrowLen, 0,
        0, -arrowLen, 0,   0.05*ax, -0.92*arrowLen, 0,
        0, -arrowLen, 0,  -0.05*ax, -0.92*arrowLen, 0
      ]);

      return { inner, center, outer, arrow };
    }

    _draw() {
      const gl = this.gl;
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const { inner, center, outer, arrow } = this._buildWire();

      gl.useProgram(this.prog);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
      gl.enableVertexAttribArray(this.aPos);
      gl.vertexAttribPointer(this.aPos, 3, gl.FLOAT, false, 0, 0);
      gl.uniformMatrix4fv(this.uMVP, false, this.mvp);

      const drawSet = (buf, rgba) => {
        gl.bufferData(gl.ARRAY_BUFFER, buf, gl.DYNAMIC_DRAW);
        gl.uniform4fv(this.uColor, rgba);
        gl.drawArrays(gl.LINES, 0, buf.length / 3);
      };

      const a = this.uniforms.lineAlpha;

      if (this.uniforms.showOuter)  drawSet(outer,  [1.00, 0.62, 0.20, a]); // orange
      if (this.uniforms.showInner)  drawSet(inner,  [0.28, 0.63, 0.98, a]); // blue
      if (this.uniforms.showCenter) drawSet(center, [0.70, 0.95, 1.00, a]); // cyan/white

      if (this.uniforms.showShiftArrow) {
        drawSet(arrow, [0.75, 0.45, 1.0, 0.95]); // violet arrow
      }
    }

    // --- tiny math utils ---
    _identity() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
    _mul(out, A, B) {
      const a=A, b=B, o=out;
      const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
      const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
      const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];
      const b00=b[0],b01=b[1],b02=b[2],b03=b[3];
      const b10=b[4],b11=b[5],b12=b[6],b13=b[7];
      const b20=b[8],b21=b[9],b22=b[10],b23=b[11];
      const b30=b[12],b31=b[13],b32=b[14],b33=b[15];
      o[0]=a00*b00+a01*b10+a02*b20+a03*b30;
      o[1]=a00*b01+a01*b11+a02*b21+a03*b31;
      o[2]=a00*b02+a01*b12+a02*b22+a03*b32;
      o[3]=a00*b03+a01*b13+a02*b23+a03*b33;
      o[4]=a10*b00+a11*b10+a12*b20+a13*b30;
      o[5]=a10*b01+a11*b11+a12*b21+a13*b31;
      o[6]=a10*b02+a11*b12+a12*b22+a13*b32;
      o[7]=a10*b03+a11*b13+a12*b23+a13*b33;
      o[8]=a20*b00+a21*b10+a22*b20+a23*b30;
      o[9]=a20*b01+a21*b11+a22*b21+a23*b31;
      o[10]=a20*b02+a21*b12+a22*b22+a23*b32;
      o[11]=a20*b03+a21*b13+a22*b23+a23*b33;
      o[12]=a30*b00+a31*b10+a32*b20+a33*b30;
      o[13]=a30*b01+a31*b11+a32*b21+a33*b31;
      o[14]=a30*b02+a31*b12+a32*b22+a33*b32;
      o[15]=a30*b03+a31*b13+a32*b23+a33*b33;
      return out;
    }
    _perspective(out, fovy, aspect, near, far) {
      const f = 1.0/Math.tan(fovy/2), nf = 1/(near - far);
      out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
      out[4]=0; out[5]=f; out[6]=0; out[7]=0;
      out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
      out[12]=0; out[13]=0; out[14]=(2*far*near)*nf; out[15]=0;
      return out;
    }
    _lookAt(out, eye, center, up) {
      let x0,x1,x2,y0,y1,y2,z0,z1,z2,len;
      z0 = eye[0]-center[0]; z1 = eye[1]-center[1]; z2 = eye[2]-center[2];
      len = Math.hypot(z0,z1,z2); if (len===0){z2=1;} else { z0/=len; z1/=len; z2/=len; }
      x0 = up[1]*z2 - up[2]*z1; x1 = up[2]*z0 - up[0]*z2; x2 = up[0]*z1 - up[1]*z0;
      len = Math.hypot(x0,x1,x2); if (len===0){x0=0;x1=0;x2=0;} else { x0/=len; x1/=len; x2/=len; }
      y0 = z1*x2 - z2*x1; y1 = z2*x0 - z0*x2; y2 = z0*x1 - z1*x0;
      out[0]=x0; out[1]=y0; out[2]=z0; out[3]=0;
      out[4]=x1; out[5]=y1; out[6]=z1; out[7]=0;
      out[8]=x2; out[9]=y2; out[10]=z2; out[11]=0;
      out[12]=-(x0*eye[0]+x1*eye[1]+x2*eye[2]);
      out[13]=-(y0*eye[0]+y1*eye[1]+y2*eye[2]);
      out[14]=-(z0*eye[0]+z1*eye[1]+z2*eye[2]);
      out[15]=1; return out;
    }
    _mkShader(src, type) {
      const s = this.gl.createShader(type);
      this.gl.shaderSource(s, src); this.gl.compileShader(s);
      if (!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) {
        throw new Error(this.gl.getShaderInfoLog(s) || 'shader error');
      }
      return s;
    }
    _mkProgram(vsSrc, fsSrc) {
      const gl = this.gl;
      const p = gl.createProgram();
      gl.attachShader(p, this._mkShader(vsSrc, gl.VERTEX_SHADER));
      gl.attachShader(p, this._mkShader(fsSrc, gl.FRAGMENT_SHADER));
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(p) || 'program link error');
      }
      return p;
    }
  }

  window.OutlineEngine = OutlineEngine;
})();


⸻

2) New React component for the panel

client/src/components/ShellOutlineVisualizer.tsx

import * as React from "react";

type Hull = { a:number; b:number; c:number; Lx_m:number; Ly_m:number; Lz_m:number; };
type Params = {
  hull?: Hull;
  wallWidth_m?: number;
  showInner?: boolean;
  showCenter?: boolean;
  showOuter?: boolean;
  showShiftArrow?: boolean;
};

declare global {
  interface Window { OutlineEngine?: any; }
}

export function ShellOutlineVisualizer({ params }: { params: Params }) {
  const canvasRef = React.useRef<HTMLCanvasElement>(null);
  const engineRef = React.useRef<any>(null);

  React.useEffect(() => {
    // load engine script once if needed
    const ensure = async () => {
      if (!window.OutlineEngine) {
        await new Promise<void>((resolve) => {
          const s = document.createElement("script");
          s.src = "/warp-engine-outline.js?v=1";
          s.onload = () => resolve();
          document.body.appendChild(s);
        });
      }
      if (canvasRef.current && !engineRef.current) {
        engineRef.current = new window.OutlineEngine(canvasRef.current);
      }
    };
    ensure();
    return () => {};
  }, []);

  React.useEffect(() => {
    if (!engineRef.current) return;
    const hull = params.hull || { a:503.5, b:132, c:86.5, Lx_m:1007, Ly_m:264, Lz_m:173 };
    const wall_m = params.wallWidth_m ?? 6.0; // default ~6 m wall
    const maxAxis = Math.max(hull.a*2, hull.b*2, hull.c*2) || 1;
    const w_rho = Math.max(1e-4, wall_m / maxAxis); // quick normalization (scene scale)

    engineRef.current.updateUniforms({
      hullAxesMeters: [hull.a, hull.b, hull.c],
      wallWidth: w_rho,
      showInner: params.showInner ?? true,
      showCenter: params.showCenter ?? true,
      showOuter: params.showOuter ?? true,
      showShiftArrow: params.showShiftArrow ?? true,
      lineAlpha: 0.95
    });
  }, [params]);

  return (
    <div className="relative w-full h-[420px] bg-black rounded-lg overflow-hidden">
      <canvas ref={canvasRef} className="w-full h-full block" />
      <div className="absolute top-2 left-2 text-xs bg-black/50 text-slate-200 px-2 py-1 rounded">
        Shell Outline • ρ-surfaces (inner/center/outer) • shift vector (violet)
      </div>
    </div>
  );
}


⸻

3) Add the new panel to /helix-core

In client/src/pages/helix-core.tsx, import and insert the panel (for example just below the main Natário Warp Bubble):

import { ShellOutlineVisualizer } from "@/components/ShellOutlineVisualizer";

// ... inside your layout where you place panels ...
<Card>
  <CardHeader>
    <CardTitle className="text-sm font-semibold">
      Warp Bubble • Shell Outline (ρ=1±Δ)
    </CardTitle>
    <CardDescription>
      Wireframe of inner/center/outer Natário wall (ellipsoidal), with interior shift vector.
    </CardDescription>
  </CardHeader>
  <CardContent>
    <ShellOutlineVisualizer
      params={{
        hull: systemMetrics?.hull || { a:503.5, b:132, c:86.5, Lx_m:1007, Ly_m:264, Lz_m:173 },
        wallWidth_m: 6.0,
        showInner: true,
        showCenter: true,
        showOuter: true,
        showShiftArrow: true
      }}
    />
  </CardContent>
</Card>

If you prefer it as a toggle inside the existing visual card, you can pass the same hull from useMetrics() and reuse the styling.

⸻

What this gives you
	•	A crisp wireframe outline of the bubble’s inner/center/outer wall (ρ=1±Δ), independent of the deformed grid—great for talks and screenshots.
	•	The violet shift-vector arrow drawn from the cabin center toward “down,” matching your color legend.
	•	Automatic camera fitting + responsive FOV like your main engine, with an overhead bias.
	•	Zero coupling to the main warp engine—safe to ship alongside.

If you want, we can also add a “Slice Stack” toggle to this outline panel in a follow-up so people can switch between wireframe shell and the multi-slice deformed-grid view.