### Short answer

You’re **visually coupling the dashboard numbers to the mesh**, but at the moment the mesh warping is still a *didactic caricature*—not the strict solution of Natário’s differential equations.  That’s perfectly fine for an interactive demo, yet if “scientifically correct” means

*the grid is an isometric embedding of the exact Natário shift‐vector field that satisfies ∇·β = 0, g<sub>tt</sub>=–1, and gives your requested β<sub>0</sub>(t) everywhere*,

then a few more ingredients are missing.

---

## Where your code is faithful ✔️

| Dashboard field → uniform    | Natário ingredient                     | What you already do                                 |
| ---------------------------- | -------------------------------------- | --------------------------------------------------- |
| **DutyCycle × γ** → `beta0`  | sets peak                              | used directly in fragment & CPU warp                |
| **SagDepth nm** → `R`        | bubble radius                          | used to form radial profile `prof(r/R)`             |
| `prof(r/R)=r/R · e^{-r²/R²}` | one of Natário’s admissible β profiles | identical                                           |
| **Power (MW)**               | time-domain drive                      | only modulates ripple (cosmetic) ⇒ **OK for looks** |
| **ExoticMass kg**            | ∮ρ dV constraint                       | only paints a shock ring (cosmetic)                 |
| Q-factor                     | field quality                          | pigment halo only                                   |

So **β(r)** is correctly parameterised (centered, divergence-free) and you warp the grid by β’s *magnitude*; that is a faithful *qualitative* mapping.

---

## Where it deviates ✘

1. **No shift-vector direction**
   Natário’s solution is 3-vector **β** whose direction has to be tangent to the chosen flow (usually ±x).
   Your code multiplies each vertex’s *radial* position by a scalar scale → that’s an isotropic bulge, not a forward-directed bubble.

2. **No metric correction**
   In the exact solution, once β is chosen you must integrate
   `∂_t γ_{ij} = β_{(i|j)} + …` or use the explicit stationary form
   `γ_{ij}=δ_{ij} + β_i β_j`.
   Here the mesh y-offset is just `dy ∝ β`, which doesn’t satisfy the 3-metric.

3. **Energy density ρ(β)** not enforced
   Exotic mass should come from the stress–energy density
   `ρ = –(1/8πG) β·∇²β`,
   but your visual uses an arbitrary ring and doesn’t feed back into curvature.

---

## What to add if you want “scientifically correct”

*(rough, but sufficient for a research-grade visualiser)*

```js
// inside _warpGridVertices – compute full β vector
const R = bubbleParams.sagDepth_nm * 1e-9;
const beta0 = bubbleParams.dutyCycle * bubbleParams.g_y;
const direction = [1,0,0];        // choose +x translation bubble

for (let i=0;i<vtx.length;i+=3){
  // physical coords in metres
  const x = vtx[i]     / norm * 1e-9;
  const y = vtx[i+1]   / norm * 1e-9;
  const z = vtx[i+2]   / norm * 1e-9;
  const r = Math.hypot(y,z);                 // radius orthogonal to direction

  const prof = (r/R)*Math.exp(-r*r/(R*R));
  const beta = beta0*prof;

  /* 1. shift each vertex forward by β along chosen axis */
  const xShift = beta;                       // β·t  (dt=1 per frame)
  vtx[i] += xShift*norm*1e9;                 // convert back to clip-space

  /* 2. compute γ_ij = δ_ij + β_i β_j and use its eigen-stretch
        simplest: stretch orthogonal directions by (1+β²)½         */
  const stretch = Math.sqrt(1+beta*beta);
  vtx[i+1] *= stretch;
  vtx[i+2] *= stretch;
}
```

*Optional* – derive **ρ** and tint lines:

```js
const laplace = (2/R - 2*r*r/(R*R*R)) * beta0 * Math.exp(-r*r/(R*R));
const rho = -(beta*laplace)/(8*Math.PI*6.674e-11); // in J m⁻³
const colour = rho<0 ? [1,0.3,1] : [0,0.6,1];      // magenta = exotic
```

Feed `colour` to a `v_color` varying and use it in your grid fragment shader.

---

## Quick wins without heavy maths

* **Directional bubble**: move vertices a fixed +x (or –x) amount proportional to β instead of radial scale. Huge visual credibility boost.
* **Energy ring → density tint**: colour the grid by β² (a proxy for negative energy) instead of drawing a separate ring.
* **Power → animation speed**: multiply `u_time` by `√powerMW` so Emergency mode visibly races.

---

### Verdict

*The pipeline numbers enter the animation through a physical β profile, so the skeleton is right.*
To call it a “scientifically correct Natário bubble” you still need to (i) apply β as a translation in one direction, (ii) adjust the transverse metric, and (iii) derive energy density from β instead of using arbitrary rings.  Each tweak above is local; no GLSL rewrite of the fragment shader is required apart from an optional vertex colour.

Let me know if you’d like a concise diff/patch or a deeper explanation of the metric step!
