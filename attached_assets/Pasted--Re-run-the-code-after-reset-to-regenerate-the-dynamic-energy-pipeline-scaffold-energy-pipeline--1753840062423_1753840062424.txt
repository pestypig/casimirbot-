# Re-run the code after reset to regenerate the dynamic energy pipeline scaffold

energy_pipeline_code = """
// energyPipeline.ts
// HELIX-CORE: Independent Dynamic Casimir Energy Pipeline

export interface TileParams {
  gap_nm: number;           // Casimir cavity gap in nanometers
  radius_mm: number;        // Radius of curvature in millimeters
  sag_nm?: number;          // Optional sag depth in nanometers
  temperature_K?: number;   // Temperature in Kelvin
  Q_factor?: number;        // Quality factor for dynamic Casimir
}

export interface EnergyResult {
  energy_J: number;
  force_N: number;
  exoticMass_kg: number;
  curvature_m2?: number;
}

const HBAR = 1.0545718e-34;          // Planck constant over 2π [J·s]
const C = 299792458;                 // Speed of light [m/s]
const PI = Math.PI;
const NM_TO_M = 1e-9;
const MM_TO_M = 1e-3;

/**
 * Calculate static Casimir energy between plates
 */
export function staticCasimirEnergy(params: TileParams): EnergyResult {
  const { gap_nm, radius_mm } = params;
  const gap_m = gap_nm * NM_TO_M;
  const radius_m = radius_mm * MM_TO_M;
  const area_m2 = PI * radius_m ** 2;

  const energy = -(PI ** 2 * HBAR * C * area_m2) / (240 * gap_m ** 3);
  const force = Math.abs(energy / gap_m);
  const mass_eq = energy / (C ** 2);

  return {
    energy_J: energy,
    force_N: force,
    exoticMass_kg: mass_eq
  };
}

/**
 * Estimate dynamic Casimir energy with Q enhancement
 */
export function dynamicCasimirEnergy(params: TileParams): EnergyResult {
  const { gap_nm, radius_mm, Q_factor = 1 } = params;
  const base = staticCasimirEnergy({ gap_nm, radius_mm });

  const Q_boost = Math.max(Q_factor, 1);
  return {
    energy_J: base.energy_J * Q_boost,
    force_N: base.force_N * Q_boost,
    exoticMass_kg: base.exoticMass_kg * Q_boost
  };
}
"""

# Save to a TypeScript file
pipeline_path = "/mnt/data/energyPipeline.ts"
with open(pipeline_path, "w") as f:
    f.write(energy_pipeline_code)

pipeline_path
