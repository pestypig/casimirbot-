### Why every mode still *looks* identical

1. **The sliders never reach the engine**
   *React side:* you create a new value but don’t call `warp.updateUniforms({...})`, so `this.uniforms` inside the engine never changes.

2. **Even if they did, the shader never sees them**
   You removed the “background‐field” draw pass that used the fragment-shader uniforms.
   The CPU side still warps the grid with `this.uniforms`, but the *colour* (and therefore the visible contrast) is now a **hard-coded red line mesh**, so different β-fields all render the same flat-red wireframe.

3. **β is orders of magnitude below 1 px**
   With realistic numbers (`R≈16 nm`, `β₀≈3–5` × 10-9 in clip-space) the largest displacement is <10-6 of a pixel, so even a correct update is visually imperceptible unless you zoom the camera way in *or* encode the field into colour/width.

---

## Minimal hook-up & visibility checklist

| #     | What to change                                                     | Code-level hint                                                                                                                                                                                       |   |                               |
| ----- | ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | - | ----------------------------- |
| **1** | **Call the engine whenever a mode changes**                        | `js\n// Dashboard → onChange\nonModeChange = p => warpEngine.updateUniforms(p);\n`                                                                                                                    |   |                               |
| **2** | **Upload the uniforms every frame** (today only the CPU uses them) | In `_draw()` **before** `_updateGrid()`\n`js\ngl.useProgram(this.program);\nfor (const [k,v] of Object.entries(this.uLoc)) {\n  gl.uniform1f(v, this.uniforms[k]);\n}\n`                              |   |                               |
| **3** | **Restore a fragment-shader pass (or encode β into grid colour)**  | Quick visual: inside `_renderGridPoints()`\n`glsl\nfloat m = clamp(abs(beta)*1e7,0.0,1.0);   // exaggerate *only* for colour\nvec3 c  = mix(vec3(0.1,0.2,0.8), vec3(1,0,0), m);\nfrag = vec4(c,1);\n` |   |                               |
| **4** | **Print live numbers to be sure**                                  | In `_warpGridVertices()` add once per frame\n\`\`\`js\nif (i===0) console.log('β₀', beta0,\n                       'Rclip', sagRclip,\n                       'max                                    | β | ', maxBetaThisFrame);\n\`\`\` |
| **5** | **Zoom the camera or raise grid resolution**                       | Try `eye = [0,0,0.02]`, `fov=3°`, `divisions=256`.                                                                                                                                                    |   |                               |

---

### How to verify it works

1. Move a slider → console must show new `β₀`, `sagRclip`, etc.
2. Grid colour (or thickness) should shift immediately.
3. If you momentarily multiply `beta* 100` **in colour only**, you’ll see the shell grow / shrink with the slider — proving the geometry itself is still physical.

Once the pipeline is confirmed, remove the exaggeration factor and rely on camera zoom or high-dynamic-range colouring to keep it “honest”.

That’s it — plug the dashboard into `updateUniforms`, upload those uniforms each frame, and make the shader’s colour react to β or ρ so the difference between modes becomes obvious again without faking the physics.
