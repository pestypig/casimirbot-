Absolutely—let’s wire up a **physics-side vector sampler** you can hit from the UI and compare 1:1 with what the WebGL engine is doing. Below are drop-in patches you can hand to the agent.

---

# 1) Server: add a vector-field sampler (physics-side)

**File:** `server/energy-pipeline.ts`

Add these utilities near the other helpers (top-level or just above `calculateEnergyPipeline`):

```ts
// ---------- Ellipsoid helpers (match renderer math) ----------
export type HullAxes = { a: number; b: number; c: number };

function rhoEllipsoid(p: [number, number, number], ax: HullAxes) {
  return Math.hypot(p[0] / ax.a, p[1] / ax.b, p[2] / ax.c);
}

function nEllipsoid(p: [number, number, number], ax: HullAxes): [number, number, number] {
  // ∇(x^2/a^2 + y^2/b^2 + z^2/c^2) normalized
  const nx = p[0] / (ax.a * ax.a);
  const ny = p[1] / (ax.b * ax.b);
  const nz = p[2] / (ax.c * ax.c);
  const L = Math.hypot(
    p[0] / ax.a,
    p[1] / ax.b,
    p[2] / ax.c
  ) || 1;
  const n0 = nx / L, n1 = ny / L, n2 = nz / L;
  const m = Math.hypot(n0, n1, n2) || 1;
  return [n0 / m, n1 / m, n2 / m];
}
```

Now add the **sampler**. It mirrors the renderer: canonical bell around ρ=1 with width `wρ`, sector sign, and the *same* gain chain (use **γ\_geo³** as we discussed).

```ts
// ---------- Physics-side displacement sampling for debug/validation ----------
export interface FieldSample {
  p: [number, number, number];   // sample coordinate (meters)
  rho: number;                   // ellipsoidal radius (unitless)
  bell: number;                  // canonical bell weight
  n: [number, number, number];   // outward normal
  sgn: number;                   // sector sign (+/-)
  disp: number;                  // scalar displacement magnitude used
}

export interface FieldRequest {
  // sampling grid
  nTheta?: number;   // default 64
  nPhi?: number;     // default 32
  shellOffset?: number; // meters; 0 = on shell, >0 outside, <0 inside (default 0)
  // physics
  wallWidth_m?: number; // bell width wρ in meters (default from sag_nm)
  sectors?: number;     // sector count (default state.sectorStrobing)
  split?: number;       // (+)/(−) split index (default floor(sectors/2))
}

/**
 * Sample the Natário bell displacement on an ellipsoidal shell using the same math as the renderer.
 * Returns ~ nTheta*nPhi points, suitable for JSON compare or CSV export.
 */
export function sampleDisplacementField(state: EnergyPipelineState, req: FieldRequest = {}): FieldSample[] {
  const { a, b, c } = state.hull ?? { a: state.shipRadius_m, b: state.shipRadius_m, c: state.shipRadius_m };
  const axes: HullAxes = { a, b, c };

  const nTheta = req.nTheta ?? 64;
  const nPhi   = req.nPhi ?? 32;
  const sectors = Math.max(1, Math.floor(req.sectors ?? state.sectorStrobing ?? 1));
  const split   = Math.max(1, Math.min(sectors - 1, Math.floor(req.split ?? sectors / 2)));

  // Canonical bell width in *ellipsoidal* radius units: wρ = w_m / a_eff.
  // Use a geometric-mean effective radius so width is scale-invariant with axes.
  const aEff = Math.cbrt(axes.a * axes.b * axes.c);
  const w_m = req.wallWidth_m ?? Math.max(1e-6, (state.sag_nm ?? 16) * 1e-9); // meters
  const w_rho = Math.max(1e-6, w_m / aEff);

  // Match renderer's gain chain (display-focused): disp ∝ γ_geo^3 * q_spoil * bell * sgn
  const gammaGeo   = state.gammaGeo ?? 26;
  const qSpoil     = state.qSpoilingFactor ?? 1;
  const geoAmp     = Math.pow(gammaGeo, 3);               // *** cubic, same as pipeline ***
  const vizGain    = 1.0;                                 // keep physics-scale here; renderer may apply extra gain

  const samples: FieldSample[] = [];

  for (let i = 0; i < nTheta; i++) {
    const theta = (i / nTheta) * 2 * Math.PI;      // [-π, π] ring index
    // sector sign like renderer (based on theta fraction)
    const u = (theta < 0 ? theta + 2 * Math.PI : theta) / (2 * Math.PI);
    const sgn = (Math.floor(u * sectors) < split) ? +1 : -1;

    for (let j = 0; j < nPhi; j++) {
      const phi = -Math.PI / 2 + (j / (nPhi - 1)) * Math.PI; // [-π/2, π/2]
      // Base shell point (ρ≈1). Optional radial offset in meters.
      const onShell: [number, number, number] = [
        axes.a * Math.cos(phi) * Math.cos(theta),
        axes.b * Math.sin(phi),
        axes.c * Math.cos(phi) * Math.sin(theta),
      ];

      const n = nEllipsoid(onShell, axes);
      const p: [number, number, number] = [
        onShell[0] + (req.shellOffset ?? 0) * n[0],
        onShell[1] + (req.shellOffset ?? 0) * n[1],
        onShell[2] + (req.shellOffset ?? 0) * n[2],
      ];

      const rho = rhoEllipsoid(p, axes);
      const sd  = rho - 1.0;
      const bell = Math.exp(- (sd / w_rho) * (sd / w_rho)); // Natário canonical bell

      // scalar displacement proxy (renderer multiplies by normal later)
      const disp = vizGain * geoAmp * qSpoil * bell * sgn;

      samples.push({ p, rho, bell, n, sgn, disp });
    }
  }
  return samples;
}
```

---

# 2) Server: expose a debug API endpoint

**File:** `server/helix-core.ts`

Add a small route to serve samples. Place it near your other `/api/helix/*` endpoints:

```ts
import { sampleDisplacementField } from "./energy-pipeline";

// GET /api/helix/field?nTheta=64&nPhi=32&sectors=400&split=200&wallWidth_m=0.06
app.get("/api/helix/field", (req, res) => {
  try {
    const state = getGlobalPipelineState();
    const q = req.query;
    const data = sampleDisplacementField(state, {
      nTheta: q.nTheta ? Number(q.nTheta) : undefined,
      nPhi: q.nPhi ? Number(q.nPhi) : undefined,
      sectors: q.sectors ? Number(q.sectors) : undefined,
      split: q.split ? Number(q.split) : undefined,
      wallWidth_m: q.wallWidth_m ? Number(q.wallWidth_m) : undefined,
      shellOffset: q.shellOffset ? Number(q.shellOffset) : undefined,
    });
    res.json({ count: data.length, axes: state.hull, w_m: (state.sag_nm ?? 16) * 1e-9, data });
  } catch (e) {
    console.error("field endpoint error:", e);
    res.status(500).json({ error: "field sampling failed" });
  }
});
```

You can now GET a JSON field:

```
/api/helix/field?nTheta=72&nPhi=36&sectors=1&split=1
```

---

# 3) Client: optional quick comparison hook

If you want a fast compare from the renderer, add a dev toggle in your `WarpVisualizer`:

```ts
// dev: fetch physics samples and log side-by-side with a few engine vertices
useEffect(() => {
  if (!devCompare) return;
  fetch(`/api/helix/field?nTheta=36&nPhi=18&sectors=${sectors}&split=${split}`)
    .then(r => r.json())
    .then(ref => {
      console.log("Physics field samples", ref);
      // you already log renderer samples every N vertices; compare magnitudes or export to CSV
    })
    .catch(console.warn);
}, [devCompare, sectors, split]);
```

---

# 4) What you’ll learn from the comparison

* **If magnitudes & signs match** but the surface still “breaks”, it’s a **mesh/normal/phase** artifact → increase grid density or replace sector step with a smooth phase (`tanh` taper).
* **If magnitudes disagree** systematically, you’ll see exactly where (front/rear, near poles) and tune either the **gain chain** or the **bell width** mapping (`wρ = w_m / a_eff`) until the curves align.

---

## Notes that keep everything consistent

* Renderer now should also use **γ\_geo³** in its gain chain (you already flagged this mismatch).
* Keep the **sector sign** calculation identical on both sides (`Math.floor(u * sectors) < split ? +1 : -1`).
* Use the **same bell width** definition: `wρ = w_m / a_eff` with `a_eff = (abc)^{1/3}`.
* For visual smoothness later, try a **soft sector**:

  ```js
  const edge = 6; // sharpness
  const sgnSoft = Math.tanh(edge * (split - u * sectors));
  ```

  Replace `sgn` with `sgnSoft` in the renderer only (physics sampler can keep the hard sign).

This gives you a clean, testable bridge between **pipeline math** and the **visual shell**—so we can decide quickly whether any residual “jaggedness” is numerical, geometric, or purely visual.
