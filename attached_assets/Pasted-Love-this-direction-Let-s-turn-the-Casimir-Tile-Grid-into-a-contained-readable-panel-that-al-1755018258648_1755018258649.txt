Love this direction. Let’s turn the “Casimir Tile Grid” into a **contained, readable panel** that always fits its card, scales cleanly, and shows a **sector-sweep** animation driven by your strobing physics.

Below is a drop-in Canvas component plus one tiny API addition so the math is explicit.

---

# 1) Add two fields to `/api/helix/metrics`

These keep the UI honest about scale and avoid guessing.

**server/helix-core.ts → getSystemMetrics():**

```ts
res.json({
  // ...existing fields...
  totalTiles: state.N_tiles,
  sectorStrobing: state.sectorStrobing,     // active sectors at an instant (e.g., 1)
  totalSectors: state.totalSectors ?? 400,   // ← add (compute in pipeline or set here)
  tilesPerSector: Math.floor(state.N_tiles / (state.totalSectors ?? 400)), // ← add
  currentSector: state.currentSector ?? 0,
  strobeHz: state.modulationFreq_GHz * 1e3,  // (your value already)
  sectorPeriod_ms: 1000 / (state.modulationFreq_GHz * 1e3),
  // ...rest...
});
```

If you don’t already track `state.totalSectors`, you can hard-wire **400** for Cruise and **1** otherwise, or compute it once in the pipeline from your scheduler.

---

# 2) New compact panel: `CasimirTileGridPanel.tsx`

* **Always confined** (you choose width/height).
* **Canvas** for 60-fps and cheap draws.
* **Grid = totalSectors**, clamped to a sensible grid (e.g., up to 20×20).
* **Active sector** = bright stripe; **recent trail** = fading.
* **Per-sector fill** shows **tilesPerSector / totalTiles** and **sectorStrobing** (how many instantaneously on).
* Legend + live numbers embedded.

```tsx
// client/src/components/CasimirTileGridPanel.tsx
import * as React from "react";

type Metrics = {
  totalTiles: number;
  sectorStrobing: number;     // how many sectors are on at an instant (1 for hover/cruise in your model)
  totalSectors: number;       // e.g., 400 in cruise
  tilesPerSector: number;     // totalTiles / totalSectors
  currentSector: number;      // physics-timed index
  strobeHz: number;           // e.g., 2000
  sectorPeriod_ms: number;    // e.g., 0.5
  overallStatus?: "NOMINAL" | "WARNING" | "CRITICAL" | "CHECK";
};

export function CasimirTileGridPanel({
  metrics,
  width = 320,
  height = 170,
  dark = true,
}: {
  metrics: Metrics;
  width?: number;
  height?: number;
  dark?: boolean;
}) {
  const ref = React.useRef<HTMLCanvasElement>(null);

  // fade trail store
  const trail = React.useRef<number[]>([]);
  const lastStamp = React.useRef<number>(0);

  // compute a nice grid that fits totalSectors (<= 20x20)
  const { rows, cols } = React.useMemo(() => {
    const n = Math.max(1, Math.min(400, metrics.totalSectors));
    // prefer a near-square grid, favor more columns
    let best = { rows: 1, cols: n, score: Infinity };
    for (let r = 1; r <= Math.min(20, n); r++) {
      const c = Math.ceil(n / r);
      if (c > 20) continue;
      const score = Math.abs(c - r); // squareness
      if (score < best.score) best = { rows: r, cols: c, score };
    }
    return { rows: best.rows, cols: best.cols };
  }, [metrics.totalSectors]);

  // normalize current sector into [0, totalSectors)
  const sectorIndex = ((metrics.currentSector % metrics.totalSectors) + metrics.totalSectors) % metrics.totalSectors;

  // draw
  React.useEffect(() => {
    const cvs = ref.current; if (!cvs) return;
    const ctx = cvs.getContext("2d")!;

    const dpr = window.devicePixelRatio || 1;
    cvs.width = Math.floor(width * dpr);
    cvs.height = Math.floor(height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const pad = 10;
    const legendH = 30;
    const w = width - pad*2;
    const h = height - pad*2 - legendH;
    const x0 = pad, y0 = pad;

    // cell geometry
    const cellW = w / cols;
    const cellH = h / rows;
    const gap = Math.max(0, Math.min(2, Math.floor(Math.min(cellW, cellH) * 0.08)));
    const innerW = cellW - gap, innerH = cellH - gap;

    // clear
    ctx.fillStyle = dark ? "#0a0f1a" : "#0b1220";
    ctx.fillRect(0, 0, width, height);

    // frame
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.strokeRect(x0 - 2, y0 - 2, w + 4, h + 4);

    const N = metrics.totalSectors;

    // lazy-init trail
    if (!trail.current.length || trail.current.length !== N) {
      trail.current = new Array(N).fill(0);
    }

    // trail decay based on elapsed time
    const now = performance.now();
    const dt = lastStamp.current ? (now - lastStamp.current) / 1000 : 0;
    lastStamp.current = now;
    const decay = Math.exp(-dt * 6); // faster decay → shorter trail
    for (let i = 0; i < N; i++) trail.current[i] *= decay;
    // mark current active sectors (could be >1 if sectorStrobing>1)
    for (let k = 0; k < metrics.sectorStrobing; k++) {
      const idx = (sectorIndex + k) % N;
      trail.current[idx] = 1;
    }

    // compute per-sector instantaneous fill (how many tiles of that sector are energized *now*)
    // In your physics, at any instant only `sectorStrobing` sectors are on:
    // fractionOn = sectorStrobing / totalSectors
    const fracOn = Math.min(1, Math.max(0, metrics.sectorStrobing / metrics.totalSectors));

    for (let r = 0, s = 0; r < rows; r++) {
      for (let c = 0; c < cols && s < N; c++, s++) {
        const x = x0 + c * cellW + gap/2;
        const y = y0 + r * cellH + gap/2;

        // base tile background
        ctx.fillStyle = "rgba(255,255,255,0.04)";
        ctx.fillRect(x, y, innerW, innerH);

        // fill proportional to fracOn (vertical fill from bottom)
        const fillH = innerH * fracOn;
        ctx.fillStyle = "rgba(100, 220, 255, 0.18)";
        ctx.fillRect(x, y + (innerH - fillH), innerW, fillH);

        // active/trail overlay
        const t = trail.current[s]; // [0..1]
        if (t > 0.01) {
          // active
          const g = Math.floor(180 + 60 * t);
          ctx.fillStyle = `rgba(80, ${g}, 120, ${0.30 + 0.5 * t})`;
          ctx.fillRect(x, y, innerW, innerH);
          // rim
          ctx.strokeStyle = `rgba(120, 240, 255, ${0.4 + 0.5 * t})`;
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 0.5, y + 0.5, innerW - 1, innerH - 1);
        }
      }
    }

    // legend
    const Lx = x0, Ly = y0 + h + 10;
    ctx.font = "11px ui-sans-serif, system-ui, Segoe UI, Roboto";
    ctx.textBaseline = "top";

    const txt = [
      `Sectors: ${metrics.sectorStrobing}/${metrics.totalSectors}`,
      `Tiles/sector: ${metrics.tilesPerSector.toLocaleString()}`,
      `Active fraction: ${(fracOn*100).toFixed(5)}%`,
      `Sweep: ${(metrics.strobeHz).toLocaleString()} Hz`,
    ];

    let cx = Lx;
    const chips = (label: string, color: string) => {
      const w = ctx.measureText(label).width + 14;
      ctx.fillStyle = `rgba(255,255,255,0.06)`;
      ctx.fillRect(cx, Ly, w, 18);
      ctx.fillStyle = color;
      ctx.fillRect(cx + 6, Ly + 6, 6, 6);
      ctx.fillStyle = "rgba(240,240,255,0.9)";
      ctx.fillText(label, cx + 16, Ly + 3);
      cx += w + 6;
    };

    chips(txt[0], "rgba(120,220,255,1)");
    chips(txt[1], "rgba(220,180,255,1)");
    chips(txt[2], "rgba(180,255,200,1)");
    chips(txt[3], "rgba(255,220,160,1)");
  }, [metrics, width, height, rows, cols, dark]);

  // lightweight animation loop – we only redraw when sector changes.
  React.useEffect(() => {
    let raf = 0;
    let lastSector = -1;

    const tick = () => {
      // if backend increments currentSector at strobeHz, this will trigger effect above via prop change.
      // If not, uncomment below to synthesize client-side:
      // const t = performance.now() * 0.001;
      // const idx = Math.floor((t * metrics.strobeHz) % metrics.totalSectors);
      // if (idx !== lastSector) setLocalSector(idx);

      if (metrics.currentSector !== lastSector) {
        lastSector = metrics.currentSector;
        // force effect to run by nudging state? Not needed: parent should pass updated metrics.
      }
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [metrics.currentSector, metrics.strobeHz, metrics.totalSectors]);

  return (
    <div className="rounded-lg border border-white/10 bg-black/40 p-2">
      <div className="flex items-center justify-between px-1 pb-1">
        <div className="text-[12px] font-medium text-white/90">Casimir Tile Grid</div>
        <div className="text-[11px] text-white/60">
          {metrics.sectorStrobing}/{metrics.totalSectors} sectors • {metrics.strobeHz.toLocaleString()} Hz
        </div>
      </div>
      <canvas ref={ref} style={{ width, height, display: "block" }} />
    </div>
  );
}
```

**Why Canvas?** For 400 sectors + fading trail at kHz sweep, a `<div>` grid will stutter; Canvas stays smooth and lets us mirror the strobing physics visually.

---

# 3) Use it in the Helix-Core page

Replace your current tile grid block with:

```tsx
// client/src/pages/helix-core.tsx
import { CasimirTileGridPanel } from "@/components/CasimirTileGridPanel";
import { useQuery } from "@tanstack/react-query";

function useHelixMetrics() {
  return useQuery({
    queryKey: ["helix-metrics"],
    queryFn: async () => (await fetch("/api/helix/metrics")).json(),
    refetchInterval: 100, // strobing UI feels “live” without overloading
  });
}

// ...
const { data: m } = useHelixMetrics();

<div className="col-span-1">
  {m && (
    <CasimirTileGridPanel
      metrics={{
        totalTiles: m.totalTiles,
        sectorStrobing: m.sectorStrobing,
        totalSectors: m.totalSectors,          // new field
        tilesPerSector: m.tilesPerSector,      // new field
        currentSector: m.currentSector ?? 0,
        strobeHz: m.strobeHz,
        sectorPeriod_ms: m.sectorPeriod_ms,
        overallStatus: m.overallStatus,
      }}
      width={320}
      height={170}
    />
  )}
</div>
```

> If you’d like the panel to auto-size to its container, pass the container’s clientWidth/Height to the component (via a `ResizeObserver`) and it will redraw crisp at any size.

---

## What this gives you

* **One-glance panel** that never overflows its card.
* **Physically honest**: totalSectors is explicit; **sectorStrobing** and **tilesPerSector** drive the visuals.
* **Sweep animation** synced to your **strobeHz/currentSector**—you can literally *see* the Ford-Roman-safe time-slicing.
* A tiny **legend** showing sector count, tiles per sector, active fraction, and sweep frequency.

If you want, I can add:

* a “**heat trail**” length control (ms) hooked to `sectorPeriod_ms`,
* a small **spark** traveling across the active sector to hint at femtosecond bursts,
* and a **status tint** (NOMINAL/WARNING/CRITICAL) on the panel border.

Want me to wire those next?
