// client/src/components/SliceViewer.tsx
import React, { useEffect, useMemo, useRef } from "react";

/**
 * SliceViewer — true-to-scale equatorial curvature (ρ-space) viewer
 *
 * Matches your WarpEngine shader math:
 *  - Ellipsoidal normalization (a,b,c in meters → scene with long axis = 1)
 *  - York-time proxy θ ~ (x_s/ r_s) * d/dr_s [exp(-((r_s-1)^2)/w^2)]
 *  - Viewer-only amplitude chain: γ_geo^3 × ΔA/A × γ_VdB × (viewAvg? √(duty/sectors) : 1)
 *
 * Color: symmetric log/asinh diverging (blue↔white↔orange) with zero-stop.
 * Diff mode: compare current vs refParams to highlight operational mode deltas.
 */
export type SliceViewerProps = {
  hullAxes?: [number, number, number]; // meters [a,b,c]
  wallWidth_m?: number;                // meters (if omitted, falls back to ρ default via a_H)
  driveDir?: [number, number, number]; // [+1,0,0] by default
  vShip?: number;                      // ship-frame speed scale used in shader theta

  // amplitude chain (viewer-only)
  gammaGeo?: number;                   // γ_geo
  qSpoilingFactor?: number;            // ΔA/A in [0..1]
  gammaVdB?: number;                   // γ_VdB (dimensionless)
  dutyCycle?: number;                  // 0..1
  sectors?: number;                    // strobing sectors >=1
  viewAvg?: boolean;                   // average vs instantaneous

  // diff vs baseline
  diffMode?: boolean;
  refParams?: Partial<Pick<SliceViewerProps,
    "gammaGeo"|"qSpoilingFactor"|"gammaVdB"|"dutyCycle"|"sectors"|"viewAvg"
  >>;

  // visual controls
  sigmaRange?: number; // how many wall widths to show around ρ=1 (default 6)
  exposure?: number;   // log/asinh exposure (default 6)
  zeroStop?: number;   // deadband around zero for clean white (default 1e-7)
  showContours?: boolean;
  width?: number;      // canvas pixels
  height?: number;
};

const defaultAxes: [number, number, number] = [503.5, 132.0, 86.5];

function harmonicMean(a: number, b: number, c: number) {
  return 3 / (1 / a + 1 / b + 1 / c);
}

// Diverging color map (blue→white→orange), symmetric for ± values
function divergeColorSym(v: number) {
  // v in [-1,1]
  const x = Math.max(-1, Math.min(1, v));
  if (x >= 0) {
    // white → orange
    const t = x;
    const r = 1.0;
    const g = 1.0 - 0.55 * t;
    const b = 1.0 - 1.0 * t;
    return [r, g, b];
  } else {
    // blue → white
    const t = -x;
    const r = 1.0 - 0.85 * t;
    const g = 1.0 - 0.55 * t;
    const b = 1.0;
    return [r, g, b];
  }
}

function asinhNorm(x: number, k: number, zeroStop: number) {
  // symmetric asinh with a small zero deadband
  if (Math.abs(x) < zeroStop) return 0;
  const s = Math.sign(x);
  const y = Math.asinh(Math.abs(x) * k) / Math.asinh(k);
  return s * Math.min(1, Math.max(0, y));
}

export const SliceViewer: React.FC<SliceViewerProps> = ({
  hullAxes = defaultAxes,
  wallWidth_m,
  driveDir = [1, 0, 0],
  vShip = 1.0,

  gammaGeo = 26,
  qSpoilingFactor = 1,
  gammaVdB = 3.83e1,
  dutyCycle = 0.14,
  sectors = 1,
  viewAvg = true,

  diffMode = true,
  refParams,

  sigmaRange = 6,
  exposure = 6,
  zeroStop = 1e-7,
  showContours = true,
  width = 480,
  height = 240,
}) => {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  const prepared = useMemo(() => {
    const [a, b, c] = hullAxes;
    const aH = harmonicMean(a, b, c);
    const w_rho = wallWidth_m != null ? wallWidth_m / aH : 0.016; // default ρ width

    // scene axes where long axis = 1 scene unit, keep exact aspect
    const sceneScale = 1 / a;
    const axesScene: [number, number, number] = [a * sceneScale, b * sceneScale, c * sceneScale];

    // normalized drive direction in ellipsoidal coords
    const dN = (() => {
      const t: [number, number, number] = [
        driveDir[0] / axesScene[0],
        driveDir[1] / axesScene[1],
        driveDir[2] / axesScene[2],
      ];
      const m = Math.hypot(t[0], t[1], t[2]) || 1;
      return [t[0] / m, t[1] / m, t[2] / m] as [number, number, number];
    })();

    // equatorial slice in ship Y=0 plane; cover ±sigmaRange wall widths around ρ=1
    // Map canvas X→x_scene, Y→z_scene with aspect-correct scaling around the hull.
    const margin = sigmaRange * w_rho; // ρ-units around the shell
    const spanX = axesScene[0] * (1 + margin);
    const spanZ = axesScene[2] * (1 + margin);

    return { a, b, c, aH, w_rho, axesScene, dN, spanX, spanZ };
  }, [hullAxes, wallWidth_m, driveDir, sigmaRange]);

  const ampChain = useMemo(() => {
    const chain = (gG: number, dA: number, gV: number, duty: number, secs: number, avg: boolean) => {
      const geo = Math.pow(Math.max(1e-9, gG), 3); // γ_geo^3
      const spoil = Math.max(1e-9, dA);
      const vdb = Math.max(1.0, gV);
      const dutyTerm = avg ? Math.sqrt(Math.max(1e-12, duty) / Math.max(1, secs)) : 1.0;
      // No absolute scale; return relative amplitude
      return geo * spoil * vdb * dutyTerm;
    };

    const cur = chain(gammaGeo, qSpoilingFactor, gammaVdB, dutyCycle, sectors, !!viewAvg);
    const ref = chain(
      refParams?.gammaGeo ?? 26,
      refParams?.qSpoilingFactor ?? 1,
      refParams?.gammaVdB ?? 3.83e1,
      refParams?.dutyCycle ?? 0.14,
      Math.max(1, refParams?.sectors ?? 1),
      refParams?.viewAvg ?? true
    );
    return { cur, ref };
  }, [gammaGeo, qSpoilingFactor, gammaVdB, dutyCycle, sectors, viewAvg, refParams]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) return;

    // render at a lower internal res for speed, then scale up
    const sampleScale = Math.max(1, Math.floor(Math.min(width, height) / 240));
    const W = Math.floor(width / sampleScale);
    const H = Math.floor(height / sampleScale);

    const img = ctx.createImageData(W, H);
    const data = img.data;

    const { axesScene, w_rho, dN, spanX, spanZ } = prepared;
    const [ax, , az] = axesScene;

    // map pixel → scene coords centered at origin (equatorial plane y=0)
    const sx = (x: number) => ((x / (W - 1)) * 2 - 1) * spanX;
    const sz = (y: number) => ((y / (H - 1)) * 2 - 1) * spanZ;

    const thetaAt = (x: number, z: number) => {
      // Ellipsoidal normalized coordinates
      const pN = [x / ax, 0, z / az] as [number, number, number];
      const rs = Math.hypot(pN[0], pN[1], pN[2]) + 1e-9;
      const xs = pN[0] * dN[0] + pN[1] * dN[1] + pN[2] * dN[2];
      const w = Math.max(1e-4, w_rho);
      const f = Math.exp(-((rs - 1) * (rs - 1)) / (w * w));
      const dfdr = (-2 * (rs - 1) / (w * w)) * f;
      // matches shader proxy
      return vShip * (xs / rs) * dfdr;
    };

    const ampCur = ampChain.cur;
    const ampRef = diffMode ? ampChain.ref : 0;

    let ptr = 0;
    for (let j = 0; j < H; j++) {
      const z = sz(j);
      for (let i = 0; i < W; i++) {
        const x = sx(i);
        const theta = thetaAt(x, z);
        const val = diffMode ? theta * (ampCur - ampRef) : theta * ampCur;
        const n = asinhNorm(val, exposure, zeroStop); // [-1,1]
        const [r, g, b] = divergeColorSym(n);
        data[ptr++] = Math.round(255 * r);
        data[ptr++] = Math.round(255 * g);
        data[ptr++] = Math.round(255 * b);
        data[ptr++] = 255;
      }
    }

    // draw low-res, then scale up
    const off = document.createElement("canvas");
    off.width = W; off.height = H;
    const octx = off.getContext("2d")!;
    octx.putImageData(img, 0, 0);

    canvas.width = width; canvas.height = height;
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high" as any;
    ctx.drawImage(off, 0, 0, width, height);

    if (showContours) {
      // optional simple iso lines at a few symmetric asinh levels
      const levels = [ -0.6, -0.3, -0.15, 0.15, 0.3, 0.6 ];
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.lineWidth = 1;
      for (const L of levels) {
        ctx.strokeStyle = L < 0 ? "#7dd3fc" : "#fb923c"; // cyan/orange
        // marching-squares over the downscaled field would be ideal; draw quick rings near ρ≈1
        // Here we plot the ρ=1 circle in scene coords as a reference (good operator cue)
        const cx = width / 2; const cz = height / 2;
        const rx = (ax / (spanX * 2)) * width;
        const rz = (az / (spanZ * 2)) * height;
        ctx.beginPath();
        ctx.ellipse(cx, cz, rx, rz, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }, [prepared, ampChain, diffMode, exposure, zeroStop, width, height, showContours, vShip]);

  return (
    <div className="bg-slate-900/70 border border-cyan-500/30 rounded-xl p-3 shadow-inner">
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-xs font-mono text-cyan-300">Equatorial curvature (ρ-slice)</h3>
        <div className="text-[10px] text-slate-400 font-mono">
          {diffMode ? "diff vs baseline" : "absolute"} · exp {exposure}
        </div>
      </div>
      <canvas ref={canvasRef} style={{ width: "100%", height: "auto" }} />
      <div className="mt-2 grid grid-cols-3 gap-2 text-[10px] text-slate-400 font-mono">
        <div>axes: [{prepared.axesScene.map(n=>n.toFixed(3)).join(", ")}]</div>
        <div>w_ρ: {prepared.w_rho.toFixed(4)}</div>
        <div>sectors: {Math.max(1, (sectors||1))}</div>
      </div>
    </div>
  );
};

// ================= helix-core integration (patch snippet) =====================
// Paste the fragment below into client/src/pages/helix-core.tsx
// right next to your <WarpVisualizer/>. Adjust props wiring to your store as needed.

/*
import React from "react";
import { SliceViewer } from "@/components/SliceViewer";

// ... inside your HelixCore component render:
<SliceViewer
  hullAxes={uniforms.axesScene || [503.5, 132, 86.5]}
  wallWidth_m={uniforms.wallWidth_m ?? (uniforms.wallWidth ? uniforms.wallWidth * (3 / (1/503.5 + 1/132 + 1/86.5)) : undefined)}
  driveDir={uniforms.driveDir ?? [1,0,0]}
  vShip={uniforms.vShip ?? 1}

  gammaGeo={uniforms.gammaGeo ?? 26}
  qSpoilingFactor={uniforms.deltaAOverA ?? 1}
  gammaVdB={uniforms.gammaVdB ?? 3.83e1}
  dutyCycle={uniforms.dutyCycle ?? 0.14}
  sectors={uniforms.sectors ?? 1}
  viewAvg={true}

  diffMode={true}
  refParams={{ gammaGeo:26, qSpoilingFactor:1, gammaVdB:3.83e1, dutyCycle:0.14, sectors:1, viewAvg:true }}

  sigmaRange={6}
  exposure={6}
  zeroStop={1e-7}
  showContours={true}
  width={480}
  height={240}
/>
*/
