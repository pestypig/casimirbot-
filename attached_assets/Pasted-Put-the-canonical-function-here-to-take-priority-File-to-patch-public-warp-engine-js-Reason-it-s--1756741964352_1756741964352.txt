Put the canonical function here to take priority

File to patch: public/warp-engine.js
Reason: it’s the last writer of thetaScale into shader uniforms, so it beats every other source. Make it compute θ from first principles and ignore any incoming thetaScale.

Minimal authoritative patch (drop-in)
*** a/public/warp-engine.js
--- b/public/warp-engine.js
@@
-  _computeThetaScaleFromUniforms(u) {
-    const g    = +u.gammaGeo || +u.g_y || 26;
-    const q    = +u.qSpoilingFactor || +u.deltaAOverA || 1;
-    // Clamp gamma VdB to physically reasonable range (1-100, default 38.3)
-    const vRaw = +(u.gammaVanDenBroeck_mass ?? u.gammaVanDenBroeck_vis ?? u.gammaVanDenBroeck ?? u.gammaVdB ?? 38.3);
-    const v    = Number.isFinite(vRaw) ? Math.max(1, Math.min(100, vRaw)) : 38.3;
-    const dRaw = +u.dutyEffectiveFR;
-    const d    = Number.isFinite(dRaw) ? Math.max(1e-12, Math.min(1, dRaw)) : 2.5e-5;
-    return Math.pow(g, 3) * q * v * Math.sqrt(d);
-  }
+  // ---- Canonical physics θ (engine is the only authority) ----
+  _thetaCanonical(params) {
+    const {
+      gammaGeo, qSpoilingFactor,
+      gammaVanDenBroeck_mass, dutyLocal,
+      sectorsConcurrent, sectorsTotal,
+      viewAveraged = true, currentMode
+    } = params || {};
+    if (currentMode === 'standby') return 0;
+    const g = Math.max(1, Number(gammaGeo) || 26);
+    const q = Math.max(1e-12, Number(qSpoilingFactor) || 1);
+    // physics-only clamp on MASS pocket gamma (visual gamma never enters θ)
+    const v = Math.max(1, Math.min(1e2, Number(gammaVanDenBroeck_mass) || 38.3));
+    const sC = Math.max(1, Number(sectorsConcurrent) || 1);
+    const sT = Math.max(1, Number(sectorsTotal) || 400);
+    // Ford–Roman effective duty: d_FR = dutyLocal * (sC / sT)
+    const dFR = Math.max(1e-12, Math.min(1, (Number(dutyLocal) || 0) * (sC / sT)));
+    const dutyFactor = viewAveraged ? Math.sqrt(dFR) : 1;
+    return (g * g * g) * q * v * dutyFactor;
+  }
+
+  _computeThetaScaleFromUniforms(u) {
+    // Derive inputs for canonical θ from uniforms (never accept a param thetaScale here)
+    const parityREAL  = !!u.u_physicsParityMode;    // REAL physics pane?
+    const mode        = u.currentMode || 'hover';
+    const theta = this._thetaCanonical({
+      gammaGeo: u.gammaGeo ?? u.g_y,
+      qSpoilingFactor: u.qSpoilingFactor ?? u.deltaAOverA,
+      gammaVanDenBroeck_mass: (u.gammaVanDenBroeck_mass ?? u.gammaVanDenBroeck),
+      dutyLocal: (u.dutyCycle ?? 0.01),
+      sectorsConcurrent: (u.sectors ?? 1),
+      sectorsTotal: (u.sectorCount ?? 400),
+      viewAveraged: parityREAL,     // physics (REAL) averages, SHOW does not
+      currentMode: mode
+    });
+    return theta;
+  }
@@
-    // somewhere later you assign uniforms.thetaScale = ...
-    uniforms.thetaScale = Number.isFinite(params?.thetaScale) ? +params.thetaScale : this._computeThetaScaleFromUniforms(uniforms);
+    // Engine is authoritative: ignore incoming thetaScale and use canonical chain only
+    uniforms.thetaScale_actual = this._computeThetaScaleFromUniforms(uniforms);
+    uniforms.thetaScale = uniforms.thetaScale_actual;