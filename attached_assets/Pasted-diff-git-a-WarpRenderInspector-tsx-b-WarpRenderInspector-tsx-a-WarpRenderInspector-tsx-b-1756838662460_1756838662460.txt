diff --git a/WarpRenderInspector.tsx b/WarpRenderInspector.tsx
--- a/WarpRenderInspector.tsx
+++ b/WarpRenderInspector.tsx
@@ -520,6 +520,23 @@ export default function WarpRenderInspector(props: {
   const s = snap || {};
   const widthNm = Number.isFinite(s.w_m) ? s.w_m*1e9 : NaN;
 
+  // --- Derive wall widths for REAL/SHOW from live engine uniforms (safe) ---
+  // Use harmonic-mean radius to convert ρ → meters (matches engine/adapter).
+  const UL: any = leftEngine?.current?.uniforms || {};
+  const UR: any = rightEngine?.current?.uniforms || {};
+  const aHL = aHarmonic(
+    UL.hullAxes?.[0] ?? UL.axesHull?.[0],
+    UL.hullAxes?.[1] ?? UL.axesHull?.[1],
+    UL.hullAxes?.[2] ?? UL.axesHull?.[2]
+  );
+  const aHR = aHarmonic(
+    UR.hullAxes?.[0] ?? UR.axesHull?.[0],
+    UR.hullAxes?.[1] ?? UR.axesHull?.[1],
+    UR.hullAxes?.[2] ?? UR.axesHull?.[2]
+  );
+  const wL_rho = Number.isFinite(+UL.wallWidth_rho) ? +UL.wallWidth_rho : (Number.isFinite(+UL.wallWidth) ? +UL.wallWidth : NaN);
+  const wR_rho = Number.isFinite(+UR.wallWidth_rho) ? +UR.wallWidth_rho : (Number.isFinite(+UR.wallWidth) ? +UR.wallWidth : NaN);
+  const wL_m = (Number.isFinite(aHL) && Number.isFinite(wL_rho)) ? wL_rho * aHL : undefined;
+  const wR_m = (Number.isFinite(aHR) && Number.isFinite(wR_rho)) ? wR_rho * aHR : undefined;
   return (
     <div className="inspector">
-      <div>Wall (REAL): {Number.isFinite(wL_m) ? wL_m!.toFixed(3) : '—'} m</div>
-      <div>Wall (SHOW): {Number.isFinite(wR_m) ? wR_m!.toFixed(3) : '—'} m</div>
+      <div>Wall (REAL): {Number.isFinite(wL_m) ? wL_m.toFixed(3) : '—'} m</div>
+      <div>Wall (SHOW): {Number.isFinite(wR_m) ? wR_m.toFixed(3) : '—'} m</div>
       <div>θ (REAL, pipeline): {Number.isFinite(s.thetaUniform)? s.thetaUniform.toExponential(2):'—'}</div>
       <div>θ (SHOW, pipeline): {Number.isFinite(s.thetaPhys)? s.thetaPhys.toExponential(2):'—'}</div>
       <div>θ̂ (REAL, metric): {Number.isFinite(s.thetaMetric)? s.thetaMetric.toExponential(2):'—'}</div>
       <div>θ̂ (SHOW, metric): {Number.isFinite(s.thetaMetric)? s.thetaMetric.toExponential(2):'—'}</div>
-      <div>metric mode: {s.metricMode ? 'ON' : 'off'}</div>
-      { (engineLeft?.current?.uniforms?.__error || engineRight?.current?.uniforms?.__error) &&
-        <div style={{color:'#f55'}}>Engine error: {engineLeft?.current?.uniforms?.__error || engineRight?.current?.uniforms?.__error}</div>
+      <div>metric mode: {s.metricMode ? 'ON' : 'off'}</div>
+      { (leftEngine?.current?.uniforms?.__error || rightEngine?.current?.uniforms?.__error) &&
+        <div style={{color:'#f55'}}>Engine error: {leftEngine?.current?.uniforms?.__error || rightEngine?.current?.uniforms?.__error}</div>
       }
     </div>
   );