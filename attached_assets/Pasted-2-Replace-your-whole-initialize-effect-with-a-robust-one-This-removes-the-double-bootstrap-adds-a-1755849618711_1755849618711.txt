2) Replace your whole initialize effect with a robust one

This removes the double bootstrap, adds a 6s watchdog, falls back to /warp-engine.js if the -fixed bundle is missing, and explicitly starts the render loop.

useEffect(() => {
  let cancelled = false;
  let watchdog: number | undefined;

  const setLoaded = () => { if (!cancelled) setIsLoaded(true); };
  const setFailed = (msg: string) => { if (!cancelled) { setIsLoaded(false); setLoadError(msg); } };

  const makeEngine = (EngineCtor: any) => {
    if (!canvasRef.current) throw new Error("canvas missing");
    const engine = new EngineCtor(canvasRef.current);

    // Build sanitized uniforms once
    const mode = (parameters.currentMode || 'hover').toLowerCase();
    const dutyFrac = Math.max(0, Math.min(1, num(parameters.dutyCycle, 0.14)));
    const sectors = Math.max(1, Math.floor(num(parameters.sectorStrobing, 1)));
    const phaseSplit = Math.max(0, Math.min(sectors - 1, Math.floor(sectors / 2)));
    const hull = parameters.hull || { Lx_m: 1007, Ly_m: 264, Lz_m: 173, a: 503.5, b: 132, c: 86.5 };
    const wallWidth_norm = num(parameters.wall?.w_norm, VIS_LOCAL.defaultWallWidthRho);

    // unified, physics-accurate tiny tilt (or pipeline-provided)
    const epsilonTiltResolved =
      num(parameters.shift?.epsilonTilt ?? parameters.epsilonTilt,
          mode === 'standby' ? 0.0 : 5e-7);
    const betaTiltResolved = vec3(parameters.shift?.betaTiltVec ?? parameters.betaTiltVec, [0, -1, 0]);
    const tiltGain = mode === 'emergency' ? 0.65 : mode === 'hover' ? 0.45 : mode === 'cruise' ? 0.35 : 0.0;

    const uniforms = {
      // camera/exposure defaults moved into single bootstrap
      exposure: Math.max(1.0, VIS_LOCAL.exposureDefault),
      zeroStop: Math.max(1e-18, VIS_LOCAL.zeroStopDefault),
      curvatureGainDec: 3,

      dutyCycle: dutyFrac,
      gammaGeo: num(parameters.g_y, 26),
      Qburst: num(parameters.cavityQ, 1e9),
      deltaAOverA: num(parameters.qSpoilingFactor, 1),
      gammaVdB: num(parameters.gammaVanDenBroeck, 3.83e1),

      currentMode: mode,
      sectors, split: phaseSplit,
      axesScene: parameters.axesScene,
      hullAxes: [num(hull.a), num(hull.b), num(hull.c)],
      wallWidth: wallWidth_norm,

      gridSpan: parameters.gridSpan,
      physicsParityMode: !!parameters.physicsParityMode,

      epsilonTilt: epsilonTiltResolved,
      betaTiltVec: betaTiltResolved,
      tiltGain,
    };

    // single bootstrap: fit + all uniforms in one shot
    engine.bootstrap(uniforms);

    // visual knobs that arenâ€™t strictly physics
    engine.updateUniforms({
      vizGain:
        mode === 'emergency' ? VIS_LOCAL.vizGainEmergency :
        mode === 'cruise'    ? VIS_LOCAL.vizGainCruise    :
                               VIS_LOCAL.vizGainDefault,
      curvatureGainDec: Math.max(0, Math.min(8, parameters.curvatureGainDec ?? 0)),
      curvatureBoostMax: parameters.physicsParityMode ? 1 : Math.max(1, parameters.curvatureBoostMax ?? 40),

      // legacy readouts (safe fallbacks)
      sagDepth_nm: parameters.sagDepth_nm || 16,
      powerAvg_MW: parameters.powerAvg_MW || VIS.powerAvgFallback,
      exoticMass_kg: parameters.exoticMass_kg || VIS.exoticMassFallback,
      tsRatio: parameters.tsRatio || VIS.tsRatioDefault
    });

    // start render explicitly so we get a first frame
    engine._startRenderLoop?.();

    // mark loaded on the next frame (ensures WebGL context is live)
    requestAnimationFrame(() => !cancelled && setLoaded());

    return engine;
  };

  const init = async () => {
    setLoadError(null);
    setIsLoaded(false);

    // 6s watchdog to avoid infinite spinner
    watchdog = window.setTimeout(() => {
      setFailed("Timeout waiting for WarpEngine. Check /public/warp-engine-fixed.js and WebGL support.");
    }, 6000) as any;

    try {
      if ((window as any).WarpEngine) {
        engineRef.current = makeEngine((window as any).WarpEngine);
        return;
      }

      // Try fixed bundle, then fall back
      const trySrcs = ['/warp-engine-fixed.js?v=tilt2', '/warp-engine.js?v=fallback'];
      for (const src of trySrcs) {
        await new Promise<void>((resolve, reject) => {
          const script = document.createElement('script');
          script.src = src;
          script.async = true;
          script.onload = () => resolve();
          script.onerror = () => reject(new Error(`Failed to load ${src}`));
          document.head.appendChild(script);
        }).catch((e) => { console.warn(e.message); });

        if ((window as any).WarpEngine) {
          engineRef.current = makeEngine((window as any).WarpEngine);
          return;
        }
      }

      throw new Error("WarpEngine not found on window after script load");
    } catch (err: any) {
      console.error('WarpEngine init error:', err);
      setFailed(err?.message || "Engine initialization failed");
    } finally {
      if (watchdog) clearTimeout(watchdog);
    }
  };

  init();

  return () => {
    cancelled = true;
    if (watchdog) clearTimeout(watchdog);
    try { engineRef.current?.destroy?.(); } catch {}
    engineRef.current = null;
  };
  // re-run on retry
}, [initNonce]);