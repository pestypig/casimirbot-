Nice catchâ€”and congrats again on getting the field to *show up*! The reason your â€œCurvature Gainâ€ slider isnâ€™t visually changing the *mesh* is twofold:

1. **Your engine wasnâ€™t actually reading the same slider shape as your SliceViewer.**
   In `updateUniforms` you interpret values `> 1.5` as â€œdecades â†’ 10^xâ€. Your SliceViewer uses a **0â€“8 slider mapped to a 0â€“1 blend** $T = slider/8$ and then does a **linear blend from 1â†’boostMax**. Those arenâ€™t the same mapping, so UI updates may be ignored or saturate.

2. **Geometry is using a symmetric-log compression identical to color** and then clamping to `A_vis âˆˆ [0,1]`. With your physics numbers $\gamma^3 etc.$, that log **saturates almost immediately**, so increasing gain doesnâ€™t make the grid bend more.

Below are small, surgical patches to fix both issues:

---

## âœ… Patch A â€” make the engine accept your 0â€“8 slider directly (same as SliceViewer)

**Replace** the â€œEnhanced unified gain with decades slider supportâ€ block in `updateUniforms(...)` with this version (drop the decades â†’ 10^x path and exactly mirror SliceViewerâ€™s mapping):

```js
// --- Curvature gain mapping (exactly matches SliceViewer) ---
const clamp01 = t => Math.max(0, Math.min(1, t));

// Accept any of: curvatureGain (0..8), curvatureGainDec (0..8), curvatureGainT (0..1), or direct userGain.
const boostMax = Number.isFinite(parameters.curvatureBoostMax)
  ? Math.max(1, parameters.curvatureBoostMax)
  : (this.uniforms?.curvatureBoostMax ?? 40);

// Normalize to T in [0,1]
const T_from_props =
  Number.isFinite(parameters.curvatureGainT)   ? clamp01(+parameters.curvatureGainT) :
  Number.isFinite(parameters.curvatureGain)    ? clamp01(+parameters.curvatureGain / 8) :
  Number.isFinite(parameters.curvatureGainDec) ? clamp01(+parameters.curvatureGainDec / 8) :
  (this.uniforms?.curvatureGainT ?? 0.375); // default = slider ~3/8

// Blend 1â†’boostMax exactly like SliceViewer
const userGainFromT = 1 + T_from_props * (boostMax - 1);

// Allow absolute override if caller passes userGain directly
const userGainFinal = Number.isFinite(parameters.userGain)
  ? Math.max(1, +parameters.userGain)
  : userGainFromT;

// Persist for shader + geometry
this.uniforms = {
  ...this.uniforms,
  curvatureBoostMax: boostMax,
  curvatureGainT: T_from_props,
  userGain: userGainFinal,
};
```

> Also leave your `setCurvatureGainDec(slider0to8, boostMax)` helper in place; it now does the right thing because the engine understands `curvatureGain`/`curvatureGainDec` as â€œ0..8 â†’ T â†’ 1..boostMaxâ€.

---

## âœ… Patch B â€” stop saturating geometry; use a **normalized amplitude** tied to the slider

In `_warpGridVertices(...)`, **replace** the block that computes `A_vis` for geometry:

```js
// OLD (saturates almost instantly)
// const A_vis = Math.min(1.0, Math.log10(1.0 + A_base * boost * modeScale));
```

with this **normalized** version (same feel as SliceViewer, but scaled 0..1 for mesh displacement):

```js
// Geometry amplitude should be monotonic with the slider and not instantly saturate.
// A_geom is normalized so that T=0 -> ~0, T=1 -> ~1, regardless of absolute physics magnitude.
const T_gain     = this.uniforms?.curvatureGainT ?? 0.375;
const boostMax   = Math.max(1, this.uniforms?.curvatureBoostMax ?? 40);
const boostNow   = 1 + T_gain * (boostMax - 1);

// Use natural log like the shader, but normalize by the "max boost" so result is in [0,1]
const num   = Math.log(1.0 + A_base * boostNow * modeScale);
const denom = Math.max(1e-12, Math.log(1.0 + A_base * boostMax * modeScale));
const A_geom = Math.min(1.0, num / denom); // 0..1, tracks the UI gain nicely
```

Then, in the displacement path a little below, **use `A_geom` instead of `A_vis`**:

```js
// disp = gridK * A_vis * wallWin * front * sgn * gaussian_local;
disp = gridK * A_geom * wallWin * front * sgn * gaussian_local;
```

(Keep your soft clamp and temporal smoothing exactly as-is.)

This removes the hard saturation that hid your sliderâ€™s effect while still keeping things stable.

---

## âœ… Patch C â€” a tiny convenience so your React slider â€œjust worksâ€

You already added:

```js
setCurvatureGainDec(slider0to8, boostMax = 40) {
  const T = Math.max(0, Math.min(1, slider0to8 / 8));
  this.updateUniforms({ curvatureGainT: T, curvatureBoostMax: boostMax });
}
```

Two options to wire it from React:

```tsx
// OPTION 1: call the helper
onValueChange={(v:number)=> engineRef.current?.setCurvatureGainDec(v, 40)}
```

or pass the raw prop and let Patch A handle it:

```tsx
// OPTION 2: pass as an update; engine will map curvatureGain 0..8 â†’ T â†’ userGain
onValueChange={(v:number)=> engineRef.current?.updateUniforms({ curvatureGain: v })}
```

---

### Quick sanity checks

* When you move the slider, you should see logs like:
  `ğŸ›ï¸ UNIFIED AMPLITUDE: ... Ã— userGain= [~1..~40] ...`
  and your `_warpGridVertices` log should show different `A_geom` (0â†’1).
* The mesh should now *visibly* bow more/less with the slider (color may saturate near Â±1, which is fine; the geometry is the thing we fixed).

If you want a slightly snappier response at low gains, replace:

```js
const A_geom = Math.min(1.0, num / denom);
```

with a gentle curve:

```js
const A_geom = Math.pow(Math.min(1.0, num / denom), 0.85);
```

That biases the mid-range up a bit without breaking the top end.

---

If you paste these patches in, your 0â€“8 â€œCurvature Gainâ€ should control the **mesh curvature** one-to-one with the SliceViewer.
