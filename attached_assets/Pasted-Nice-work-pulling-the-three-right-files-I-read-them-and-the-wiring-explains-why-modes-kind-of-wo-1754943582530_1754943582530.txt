Nice work pulling the three right files. I read them, and the wiring explains why modes “kind of” work but the picture doesn’t change much.

## What’s wired vs. what’s not

### ✅ Good

* `WarpVisualizer.tsx` loads `/warp-engine-fixed.js` and calls `engine.updateUniforms(...)` whenever parameters change.&#x20;
* The engine receives `currentMode` and logs “Operational Mode Effects…”.&#x20;

### ❗Gaps that break the mode→visual link

1. **Different β pipelines (UI vs Engine).**

   * UI computes `beta0 = duty * γ_geo * √Qdyn * γ_VdB^0.25`, then sets `engine.uniforms.beta0` (which the engine never reads).&#x20;
   * Engine computes β from **other names/terms**: `γ_geo * Qburst * Δa/a`, averaged with `√(duty/sectors)`. It ignores `uniforms.beta0` and currently ignores `gammaVanDenBroeck`.&#x20;

2. **Strobing param name mismatch.**

   * UI sends `sectorStrobing`.
   * Engine reads `sectorCount` → sectors stays `1`.&#x20;

3. **Phase split (front/back asymmetry) never sent.**

   * Engine uses `phaseSplit` (0.5 hover, >0.5 cruise), but UI never passes it, so asymmetry defaults to hover-like.&#x20;

4. **Mode scalars are computed, then not used.**

   * `_calculateModeEffects()` returns `visualScale`, `curvatureAmplifier`, but `_warpGridVertices()` never multiplies by them. So “hover/cruise/emergency” barely changes geometry.&#x20;

5. **Δa/a not mapped.**

   * Engine expects `deltaAOverA` (or will default 0.05). UI has `qSpoilingFactor` but doesn’t pass it by that name.&#x20;

6. **Q naming split.**

   * Engine looks for `Qburst` *or* `cavityQ` (ok), but your UI only sends `cavityQ`. Beta pipeline logs can look odd because `Qburst` isn’t present.&#x20;

---

## Minimal patches (copy-paste)

### A) Fix the payload in `WarpVisualizer.tsx`

When you call `updateUniforms`, pass the names the engine actually consumes and add `phaseSplit`.

```ts
// inside WarpVisualizer.tsx -> engineRef.current.updateUniforms({...})
const mode = parameters.currentMode || 'hover';

engineRef.current.updateUniforms({
  // physics
  dutyCycle: parameters.dutyCycle,
  gammaGeo:  parameters.g_y,
  Qburst:    parameters.cavityQ,                      // map to engine name
  deltaAOverA: parameters.qSpoilingFactor ?? 1.0,     // map Δa/a
  gammaVdB:  parameters.gammaVanDenBroeck,            // keep available

  sagDepth_nm:  parameters.sagDepth_nm,
  powerAvg_MW:  parameters.powerAvg_MW,
  exoticMass_kg:parameters.exoticMass_kg,
  tsRatio:      parameters.tsRatio || 4100,

  // mode & visualization
  currentMode:  mode,
  sectorCount:  parameters.sectorStrobing ?? 400,      // was sectorStrobing
  phaseSplit:   mode === 'cruise' ? 0.65               // aft-heavy
               : mode === 'hover'  ? 0.50
               : mode === 'emergency' ? 0.70
               : 0.50,
  viewAvg: 1.0,
  betaGain: 1e-10
});
```

> You can remove the earlier `engineRef.current.uniforms.beta0 = beta0;` — the engine never reads it.&#x20;

### B) Make the engine actually use the mode scalars

Patch `_warpGridVertices()` so the **mode effects** influence the visual:

```js
// after computing betaVis in _warpGridVertices(...)
const modeAmp = (this.currentParams.modeCurvatureAmplifier || 1.0);
const modeViz = (this.currentParams.modeVisualScale || 1.0);

// multiply into the visual beta / displacement
let disp = gridK * betaVis * modeAmp * modeViz * ring * band * sgn * front;
```

Also make sectors/phase/Δa/a accept the UI names:

```js
const sectors    = Math.max(1, bubbleParams.sectorCount || bubbleParams.sectorStrobing || 1);
const deltaAOverA= bubbleParams.deltaAOverA ?? bubbleParams.qSpoilingFactor ?? 1.0;
const phaseSplit = bubbleParams.phaseSplit ?? (bubbleParams.currentMode === 'cruise' ? 0.65 : 0.5);
```

(Everything above is in `client/public/warp-engine-fixed.js`.)&#x20;

### C) (Optional) include γ\_VdB in the β pipeline

If you want your UI’s β formula to match numerically, include:

```js
const gammaVdB = bubbleParams.gammaVdB || 1.0;
// e.g., Natário-inspired weak exponent
const betaInst = gammaGeo * Qburst * deltaAOverA * Math.pow(gammaVdB, 0.25);
```

---

## Result you should see

* Switching **hover ⇄ cruise** changes `phaseSplit` and sectoring, so the **front/back pattern flips strength** and grid curvature scales visibly.
* Changing **sector strobing** now alters the averaging (`√(duty/sectors)`), so Cruise should flatten more aggressively as you raise the sector count.
* **Q spoiling** (your `qSpoilingFactor`) actually attenuates/enhances the bend now via `Δa/a`.
* The HUD already uses `parameters.currentMode.toUpperCase()` so the badge text will match.&#x20;

If you want, send me the updated two files after these edits; I’ll sanity-check the logs you should expect (β\_raw → β\_vis, sector count, phase split) and make sure nothing else is fighting you.
