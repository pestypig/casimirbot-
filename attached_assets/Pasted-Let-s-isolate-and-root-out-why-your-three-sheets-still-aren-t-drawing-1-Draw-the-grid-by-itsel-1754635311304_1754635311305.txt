Let’s isolate and root out why your three sheets still aren’t drawing.

1) Draw the grid *by itself* (no quad, no depth test)  
   In your `_draw()` right after clearing, temporarily replace everything with:

   ```js
   // 1. Clear
   gl.clearColor(0,0,0,1);
   gl.clear(gl.COLOR_BUFFER_BIT);

   // 2. Use the grid program
   gl.useProgram(this.gridProgram);

   // 3. Disable depth & blending so nothing hides the points
   gl.disable(gl.DEPTH_TEST);
   gl.disable(gl.BLEND);

   // 4. Set a simple MVP (identity or very small ortho)
   const identity = new Float32Array([
     1,0,0,0,
     0,1,0,0,
     0,0,1,0,
     0,0,0,1
   ]);
   gl.uniformMatrix4fv(this.gridUniforms.mvpMatrix, false, identity);

   // 5. Bind VBO & point‐size
   gl.bindBuffer(gl.ARRAY_BUFFER, this.gridVbo);
   gl.enableVertexAttribArray(this.gridUniforms.position);
   gl.vertexAttribPointer(this.gridUniforms.position, 3, gl.FLOAT, false, 0, 0);

   // 6. Enforce large points
   //    (in your grid‐VS: gl_PointSize = 8.0; or attribute)
   //    and query the range to confirm support:
   console.log("PointSize range:", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE));

   // 7. Draw as POINTS
   gl.drawArrays(gl.POINTS, 0, this.gridVertexCount);

   // 8. Done
   gl.disableVertexAttribArray(this.gridUniforms.position);
   ```

   If you *still* see nothing, then either  
   • your `gridProgram`’s fragment shader is not being used (test by hard‐coding `frag = vec4(1,0,0,1);`), or  
   • your VBO is empty (log `this.gridVertexCount > 0?`), or  
   • `a_position` attribute isn’t bound correctly (log `this.gridUniforms.position` is ≥ 0).

2) Check your VBO data  
   Right after you create it, add:

   ```js
   console.log("First 9 floats of gridVertices:", this.gridVertices.slice(0,9));
   console.log("Total vertices:", this.gridVertexCount);
   ```

   You should see a block of numbers in the range [−0.8,0.8]. If `gridVertexCount` is zero or the slice is all zeros, you know your generator failed.

3) Verify your grid shaders are active & compiling  
   In `_compileGridShaders()` right after linking:

   ```js
   console.log(">>> gridProgram is", this.gridProgram);
   console.log(">>> grid VS log:", gl.getShaderInfoLog(vs));
   console.log(">>> grid FS log:", gl.getShaderInfoLog(fs));
   ```

   And in the fragment shader body temporarily force:

   ```glsl
   // top of gridFs:
   out vec4 frag;
   void main() {
     frag = vec4(0.0, 1.0, 0.0, 1.0);  // draw green for every point
   }
   ```

   That will confirm you actually see green dots if the pipeline is alive.

4) If *that* succeeds, re‐enable your real fragment logic but keep the identity MVP and points. You’ll see the three colors if you upload `u_sheetColor` before each draw call:

   ```js
   gl.uniform3f(this.gridUniforms.sheetColor, 0.1,0.8,1.0);
   gl.drawArrays(gl.POINTS, 0, this.sheetXY_count);
   gl.uniform3f(this.gridUniforms.sheetColor, 1.0,0.1,0.8);
   gl.drawArrays(gl.POINTS, this.sheetXY_count, this.sheetXZ_count);
   gl.uniform3f(this.gridUniforms.sheetColor, 1.0,1.0,0.1);
   gl.drawArrays(gl.POINTS, this.sheetXY_count+this.sheetXZ_count, this.sheetYZ_count);
   ```

5) Finally, restore your real MVP and depth‐ordering once you see the sheets.

———

By stripping everything back to “just draw the grid as green points with identity transforms and no depth,” you’ll know in one shot whether the problem is:  
  • empty VBO,  
  • shader not bound, or  
  • attribute/uniform mis‐wired.  

Once green points pop up, re‐add one feature at a time (colors, MVP, depth, quad) and you’ll immediately see what step hides them.