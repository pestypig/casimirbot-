diff --git a/public/warp-engine.js b/public/warp-engine.js
--- a/public/warp-engine.js
+++ b/public/warp-engine.js
@@ -90,6 +90,16 @@ class WarpEngine {
     this._u = {};
     this._uniforms = {
       // existing …
+      // --- Light-crossing & strobing timeline (ms + indices) ---
+      tauLC_ms: undefined,
+      dwell_ms: undefined,
+      burst_ms: undefined,
+      phase: undefined,          // 0..1 within sector dwell
+      sectorIdx: undefined,      // 0..S-1
+      sectorCount: undefined,    // S (e.g., 400)
+      onWindow: undefined,       // 0/1: inside burst window
+      TS_ratio: undefined,       // optional: τ_LC / T_m for display/tuning
+      dutyUsed: undefined,       // the FR duty the renderer actually applies
     };
   }
 
@@ -165,6 +175,21 @@ class WarpEngine {
     return this;
   }
 
+  /** Update light-crossing timing & strobing gate (authoritative) */
+  setLightCrossing(info) {
+    if (!info) return this;
+    const U = this._uniforms;
+    U.tauLC_ms    = Number(info.tauLC_ms);
+    U.dwell_ms    = Number(info.dwell_ms);
+    U.burst_ms    = Number(info.burst_ms);
+    U.phase       = Number(info.phase);
+    U.sectorIdx   = Number(info.sectorIdx);
+    U.sectorCount = Number(info.sectorCount);
+    U.onWindow    = info.onWindow ? 1 : 0;
+    if (Number.isFinite(info.TS_ratio)) U.TS_ratio = Number(info.TS_ratio);
+    if (Number.isFinite(info.dutyEffectiveFR)) U.dutyUsed = Number(info.dutyEffectiveFR);
+    return this;
+  }
+
   /** Internal: bind locations lazily once per program */
   _lazyBindUniformLocations(gl, prog) {
     if (this._u.__bound) return;
@@ -182,6 +207,16 @@ class WarpEngine {
     // keep existing caches …
+    // LC timeline uniforms
+    this._u.u_tauLC_ms    = gl.getUniformLocation(prog, "u_tauLC_ms");
+    this._u.u_dwell_ms    = gl.getUniformLocation(prog, "u_dwell_ms");
+    this._u.u_burst_ms    = gl.getUniformLocation(prog, "u_burst_ms");
+    this._u.u_phase       = gl.getUniformLocation(prog, "u_phase");
+    this._u.u_sectorIdx   = gl.getUniformLocation(prog, "u_sectorIdx");
+    this._u.u_sectorCount = gl.getUniformLocation(prog, "u_sectorCount");
+    this._u.u_onWindow    = gl.getUniformLocation(prog, "u_onWindow");
+    this._u.u_TS_ratio    = gl.getUniformLocation(prog, "u_TS_ratio");
+    this._u.u_dutyUsed    = gl.getUniformLocation(prog, "u_dutyUsed");
     this._u.__bound = true;
   }
 
@@ -230,6 +265,20 @@ class WarpEngine {
     // existing uploads …
+    // --- Upload LC timeline (if provided) ---
+    if (this._u.u_tauLC_ms)    gl.uniform1f(this._u.u_tauLC_ms,    +U.tauLC_ms || 0.0);
+    if (this._u.u_dwell_ms)    gl.uniform1f(this._u.u_dwell_ms,    +U.dwell_ms || 0.0);
+    if (this._u.u_burst_ms)    gl.uniform1f(this._u.u_burst_ms,    +U.burst_ms || 0.0);
+    if (this._u.u_phase)       gl.uniform1f(this._u.u_phase,       Number.isFinite(+U.phase) ? +U.phase : 0.0);
+    if (this._u.u_sectorIdx)   gl.uniform1i(this._u.u_sectorIdx,   Number.isFinite(+U.sectorIdx) ? +U.sectorIdx : 0);
+    if (this._u.u_sectorCount) gl.uniform1i(this._u.u_sectorCount, Number.isFinite(+U.sectorCount) ? +U.sectorCount : 1);
+    if (this._u.u_onWindow)    gl.uniform1f(this._u.u_onWindow,    +U.onWindow ? 1.0 : 0.0);
+    if (this._u.u_TS_ratio)    gl.uniform1f(this._u.u_TS_ratio,    Number.isFinite(+U.TS_ratio) ? +U.TS_ratio : 0.0);
+    if (this._u.u_dutyUsed)    gl.uniform1f(this._u.u_dutyUsed,    Number.isFinite(+U.dutyUsed) ? +U.dutyUsed : 0.0);
   }
 }
 
 window.WarpEngine = window.WarpEngine || WarpEngine;
 export { WarpEngine };