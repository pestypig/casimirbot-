Nice progress. To make the renderer truly “metric-aware” (so lengths, projections, normals, and curvature cues use a general metric instead of the default Euclidean dot), here are focused patches for `warp-engine.js`. They add a covariant metric tensor `u_metric` (and its inverse) as shader uniforms, metric helpers in GLSL, and wiring in JS so you can pass a metric (or auto-derive one from your hull axes).

Below are unified diffs you can apply.

---

### 1) Inject metric uniforms + metric helpers in the shader, and use them for radius/normal/projections

```diff
diff --git a/warp-engine.js b/warp-engine.js
@@ class WarpEngine {
-    _injectUniforms(fsBody) {
+    _injectUniforms(fsBody) {
         // Inject common uniforms at top of FS
-        const header = `
+        const header = `
             precision highp float;
             uniform mat4 u_mvpMatrix;
             uniform vec3 u_axesScene;
             uniform float u_wallWidth;
             uniform vec3 u_driveDir;
             uniform float u_thetaScale;
             uniform float u_userGain;
             uniform float u_curvatureGainT;
             uniform float u_curvatureBoostMax;
             uniform int   u_cosmeticLevel;
             uniform vec3 u_sheetColor;
             uniform vec3 u_betaTiltVec;
             uniform float u_epsilonTilt;
+            // --- General metric tensor (covariant g_ij) and its inverse g^{ij} ---
+            uniform mat3 u_metric;
+            uniform mat3 u_metricInv;
+            uniform bool u_useMetric;
 
             varying vec3 v_pos;
         `;
 
-        const utils = `
+        const utils = `
             // Purple shift weighting along local "down" direction (beta tilt)
-            float purpleShiftWeight(vec3 n) {
-                float proj = dot(normalize(u_betaTiltVec), normalize(n));
+            // Metric-aware helpers
+            float dotG(vec3 a, vec3 b) { return dot(a, (u_metric * b)); }
+            float normG(vec3 v) { return sqrt(max(1e-12, dotG(v, v))); }
+            vec3  normalizeG(vec3 v) { float n = normG(v); return v / max(1e-12, n); }
+
+            float purpleShiftWeight(vec3 n) {
+                float proj = u_useMetric
+                    ? dotG(normalizeG(u_betaTiltVec), normalizeG(n))
+                    : dot(normalize(u_betaTiltVec), normalize(n));
                 float w = clamp(0.5 - 0.5 * proj, 0.0, 1.0);
                 return pow(w, 0.75);
             }
         `;
 
         // splice helpers into provided FS body
         return header + utils + fsBody;
     }
@@
-    _makeShaderSources() {
+    _makeShaderSources() {
         const vs = `
             attribute vec3 a_position;
             uniform mat4 u_mvpMatrix;
             varying vec3 v_pos;
             void main() {
               v_pos = a_position;
               gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
             }
         `;
 
-        const fsBody = `
+        const fsBody = `
             void main() {
                 // Axes in scene space for ellipsoidal shell
                 vec3 axes = u_axesScene;
 
                 // Position in "rho-space"
-                vec3 pN = v_pos / axes;
-                float rs = length(pN);
+                vec3 pN = v_pos / axes;
+                float rs = u_useMetric ? normG(pN) : length(pN);
 
                 // Drive direction in same space
-                vec3 dN = normalize(u_driveDir / axes);
-                float xs = dot(pN, dN);
+                vec3 dN = u_useMetric ? normalizeG(u_driveDir / axes)
+                                      : normalize(u_driveDir / axes);
+                float xs = u_useMetric ? dotG(pN, dN)
+                                       : dot(pN, dN);
 
                 // Canonical Natário bell (omitted here for brevity) ...
                 // ...
 
                 // World-space "normal" proxy (used by cosmetics/tilt)
-                vec3 normalWS = normalize(v_pos);
+                vec3 normalWS = u_useMetric ? normalizeG(v_pos) : normalize(v_pos);
 
                 float wPurple = purpleShiftWeight(normalWS);
                 vec3 baseCol = u_sheetColor * (0.55 + 0.45*wPurple);
 
                 // Curvature highlight (uses rs/xs already computed metric-aware)
                 float kBoost = pow(clamp(1.0 - abs(xs/ max(1e-3, rs)), 0.0, 1.0), 1.25);
                 kBoost *= (0.25 + 0.75*u_curvatureGainT);
                 kBoost = min(kBoost, u_curvatureBoostMax);
 
                 gl_FragColor = vec4(baseCol * (1.0 + kBoost), 1.0);
             }
         `;
 
         const fs = this._injectUniforms(fsBody);
         return { vs, fs };
     }
 }
```

(Where the previous FS already computed `rs`, `xs`, normals, and color—this patch makes those computations metric-aware.)
Cites for context: the existing tilt/curvature plumbing and FS structure live around the places shown in your file (e.g., uniforms and FS body assembly, and purple-shift usage). &#x20;

---

### 2) Cache new uniform locations for the metric tensors

```diff
diff --git a/warp-engine.js b/warp-engine.js
@@     _cacheGridLocations(program) {
         this.gridUniforms = {
             mvpMatrix:      gl.getUniformLocation(program, 'u_mvpMatrix'),
             axes:           gl.getUniformLocation(program, 'u_axesScene'),
             wallWidth:      gl.getUniformLocation(program, 'u_wallWidth'),
             driveDir:       gl.getUniformLocation(program, 'u_driveDir'),
             thetaScale:     gl.getUniformLocation(program, 'u_thetaScale'),
             userGain:       gl.getUniformLocation(program, 'u_userGain'),
             curvatureGainT: gl.getUniformLocation(program, 'u_curvatureGainT'),
             curvatureBoostMax: gl.getUniformLocation(program, 'u_curvatureBoostMax'),
             cosmeticLevel:  gl.getUniformLocation(program, 'u_cosmeticLevel'),
             sheetColor:     gl.getUniformLocation(program, 'u_sheetColor'),
             betaTiltVec:    gl.getUniformLocation(program, 'u_betaTiltVec'),
             epsilonTilt:    gl.getUniformLocation(program, 'u_epsilonTilt'),
+            metric:         gl.getUniformLocation(program, 'u_metric'),
+            metricInv:      gl.getUniformLocation(program, 'u_metricInv'),
+            useMetric:      gl.getUniformLocation(program, 'u_useMetric'),
         };
     }
```

(Uniform caching follows the same pattern as the existing ones.)&#x20;

---

### 3) Bind the metric uniforms during render

```diff
diff --git a/warp-engine.js b/warp-engine.js
@@     _render() {
         const U = this.gridUniforms;
         const gl = this.gl;
         gl.useProgram(this.gridProgram);
         gl.uniformMatrix4fv(U.mvpMatrix, false, this.mvpMatrix);
         gl.uniform3fv(U.axes, this.uniforms.axesClip);
         gl.uniform1f(U.wallWidth, this.uniforms.wallWidth);
         gl.uniform3fv(U.driveDir, this.uniforms.driveDir);
         gl.uniform1f(U.thetaScale, this.uniforms.thetaScale);
         gl.uniform1f(U.userGain, this.uniforms.userGain);
         gl.uniform1f(U.curvatureGainT, this.uniforms.curvatureGainT);
         gl.uniform1f(U.curvatureBoostMax, this.uniforms.curvatureBoostMax);
         gl.uniform1i(U.cosmeticLevel, this.uniforms.cosmeticLevel|0);
         gl.uniform3fv(U.sheetColor, this.uniforms.sheetColor);
         gl.uniform3fv(U.betaTiltVec, this.uniforms.betaTiltVec);
         gl.uniform1f(U.epsilonTilt, this.uniforms.epsilonTilt);
+        // --- Metric bindings (defaults = identity) ----------------------------
+        const g    = (this.uniforms.metric    && this.uniforms.metric.length===9)
+                     ? this.uniforms.metric    : [1,0,0, 0,1,0, 0,0,1];
+        const gInv = (this.uniforms.metricInv && this.uniforms.metricInv.length===9)
+                     ? this.uniforms.metricInv : [1,0,0, 0,1,0, 0,0,1];
+        gl.uniformMatrix3fv(U.metric, false, new Float32Array(g));
+        gl.uniformMatrix3fv(U.metricInv, false, new Float32Array(gInv));
+        gl.uniform1i(U.useMetric, this.uniforms.useMetric ? 1 : 0);
 
         // ... existing attribute/buffer draws follow
     }
```

(Uniform set placement matches where your other uniforms are applied in `_render()`.) &#x20;

---

### 4) Accept metric parameters in `updateUniforms` and derive a sensible default from hull axes

This lets callers pass a metric explicitly, or opt into an “ellipsoidal cometric” (inverse metric) derived from the clip-space axes—very handy if you want ρ, projections, and normals to respect the same anisotropy you use for your ellipsoidal shell.

```diff
diff --git a/warp-engine.js b/warp-engine.js
@@     _applyUniformsNow(parameters) {
-        const a = N(parameters?.hull?.a ?? parameters?.hullAxes?.[0] ?? prev?.hullAxes?.[0], 503.5);
-        const b = N(parameters?.hull?.b ?? parameters?.hullAxes?.[1] ?? prev?.hullAxes?.[1], 132.0);
-        const c = N(parameters?.hull?.c ?? parameters?.hullAxes?.[2] ?? prev?.hullAxes?.[2], 86.5);
+        const a = N(parameters?.hull?.a ?? parameters?.hullAxes?.[0] ?? prev?.hullAxes?.[0], 503.5);
+        const b = N(parameters?.hull?.b ?? parameters?.hullAxes?.[1] ?? prev?.hullAxes?.[1], 132.0);
+        const c = N(parameters?.hull?.c ?? parameters?.hullAxes?.[2] ?? prev?.hullAxes?.[2], 86.5);
         const s = 1 / Math.max(a, b, c, 1e-9);
         const axesScene = [a*s, b*s, c*s];
         this.uniforms.axesClip = axesScene;
@@
+        // --- Metric tensor wiring --------------------------------------------
+        // Accept either explicit metric(s) or derive an ellipsoidal cometric.
+        // metricMode: 'identity' | 'ellipsoid' | 'custom'
+        const metricMode = String(parameters?.metricMode ?? prev?.metricMode ?? 'identity');
+        let metric    = parameters?.metric    ?? prev?.metric    ?? null;
+        let metricInv = parameters?.metricInv ?? prev?.metricInv ?? null;
+        let useMetric = (parameters?.useMetric ?? prev?.useMetric ?? false) ? true : false;
+
+        if (!metric) {
+            if (metricMode === 'ellipsoid') {
+                // covariant g_ij in clip space, aligned to axesClip:
+                // g = diag(1/a^2, 1/b^2, 1/c^2)
+                const ga = 1.0 / Math.max(axesScene[0], 1e-9);
+                const gb = 1.0 / Math.max(axesScene[1], 1e-9);
+                const gc = 1.0 / Math.max(axesScene[2], 1e-9);
+                metric    = [ga*ga,0,0, 0,gb*gb,0, 0,0,gc*gc];
+                metricInv = [1.0/(ga*ga),0,0, 0,1.0/(gb*gb),0, 0,0,1.0/(gc*gc)];
+                useMetric = true;
+            } else {
+                // Identity (Euclidean)
+                metric    = [1,0,0, 0,1,0, 0,0,1];
+                metricInv = [1,0,0, 0,1,0, 0,0,1];
+            }
+        }
+        this.uniforms.metricMode = metricMode;
+        this.uniforms.metric     = metric;
+        this.uniforms.metricInv  = metricInv;
+        this.uniforms.useMetric  = !!useMetric;
```

(Placing this right after axes computation keeps the “derive from hull” path simple.)&#x20;

---

### 5) (Optional but recommended) Metric-aware geometry warp on the CPU path

If you use `_warpGridVertices` to pre-displace vertices for the “curvature drawing,” make its internal length/projection also metric-aware so CPU and shader agree:

```diff
diff --git a/warp-engine.js b/warp-engine.js
@@     _warpGridVertices(vtx, bubbleParams) {
-        const axesScene =
+        const axesScene =
           (this.uniforms?.axesClip && this.uniforms.axesClip.length === 3)
             ? this.uniforms.axesClip
             : (() => {
                 const aMax = Math.max(a, b, c);
                 const s    = 1.0 / Math.max(aMax, 1e-9);
                 return [a * s, b * s, c * s];
               })();
+        // Metric (covariant) for CPU-side ops (defaults to identity)
+        const G = (this.uniforms?.metric && this.uniforms.metric.length===9)
+                    ? this.uniforms.metric
+                    : [1,0,0, 0,1,0, 0,0,1];
+        const dotG = (ax, ay, az, bx, by, bz) =>
+            ax*(G[0]*bx + G[3]*by + G[6]*bz) +
+            ay*(G[1]*bx + G[4]*by + G[7]*bz) +
+            az*(G[2]*bx + G[5]*by + G[8]*bz);
+        const normG = (x,y,z) => Math.sqrt(Math.max(1e-12, dotG(x,y,z, x,y,z)));
 
         // ... wherever you compute rho/projections:
-        // vec3 pN = v / axesScene; float rs = length(pN); float xs = dot(pN, dN);
+        // vec3 pN = v / axesScene; float rs = normG(pN.x, pN.y, pN.z); float xs = dotG(pN.x, pN.y, pN.z, dN.x, dN.y, dN.z);
         // and use rs/xs consistently downstream.
```

(You already have the ellipsoidal shell/axes logic in here; these lines make rho/projection match the shader’s metric.)&#x20;

---

## How to use

* Keep Euclidean default (no visual change):

```js
engine.updateUniforms({ useMetric: false, metricMode: 'identity' });
```

* Turn on metric with a cometric derived from the hull ellipsoid (good default):

```js
engine.updateUniforms({ metricMode: 'ellipsoid', useMetric: true });
```

* Supply a fully custom metric (covariant `g_ij` as a flat 3×3):

```js
engine.updateUniforms({
  useMetric: true,
  metricMode: 'custom',
  metric:    [gxx, gxy, gxz,  gyx, gyy, gyz,  gzx, gzy, gzz],
  metricInv: [ /* optional; if omitted, identity will be used */ ]
});
```

With these patches, the “graph” (field lines/curvature bands, purple shift shading, and the CPU warp) all reflect your chosen metric—not just Euclidean vectors—so what you see aligns with generalized (co/contra-variant) geometry.

If you want, I can also drop a tiny utility to build `metricInv` from `metric` on the CPU when it’s omitted (3×3 inversion), but the above is sufficient to get you metric-aware rendering right away.&#x20;
