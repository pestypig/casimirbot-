Heck yes—let’s wire your **existing 0–8 Curvature Gain slider** to the WebGL engine so it drives both the **colors** (shader) and the **geometry bend** (vertex displacement), using the same blend you already use in `SliceViewer`.

Your engine already supports two inputs for this:

* `curvatureGainT` — normalized 0..1
* `curvatureBoostMax` — max boost multiplier (defaults to 40)
* (It then computes `userGain` for the shader/geometry.)

So we just need to pass `curvatureGainT = slider/8` into `engine.updateUniforms(...)` whenever the slider moves.

---

### 1) Minimal hook-up from the slider → engine

```tsx
// inside your WarpVisualizer (or parent) that owns the WarpEngine instance
const [curvGain, setCurvGain] = useState(6);           // existing 0..8 slider
const engineRef = useRef<WarpEngine | null>(null);     // where you keep the instance

const applyCurvatureGain = (v: number) => {
  const T = Math.max(0, Math.min(1, v / 8));           // 0..1
  const boostMax = 40;                                  // keep in sync with SliceViewer
  engineRef.current?.updateUniforms({
    curvatureGainT: T,
    curvatureBoostMax: boostMax,
    // do NOT pass userGain directly; let updateUniforms derive it from T+boostMax
  });
};

// your slider onChange
const onCurvSlider = (v: number) => {
  setCurvGain(v);
  applyCurvatureGain(v);
};
```

Also pass the same value into `SliceViewer` so both views stay consistent:

```tsx
<SliceViewer
  hullAxes={hullAxes}
  wallWidth_m={wallWidth_m}
  curvatureGain={curvGain}            // 0..8
  curvatureBoostMax={40}
/>
```

That’s it—no engine code changes required. Your `updateUniforms` already maps:

* `curvatureGainT` + `curvatureBoostMax` → `userGain`
* then both the **shader** (`u_userGain`) and the **geometry** (`_warpGridVertices`’ `val = ... * userGain`) respond.

---

### 2) (Optional) Make this super explicit with a tiny helper on the engine

If you like a clean API, you can add a convenience method to `WarpEngine`:

```js
// in class WarpEngine
setCurvatureGainDec(slider0to8, boostMax = 40) {
  const T = Math.max(0, Math.min(1, slider0to8 / 8));
  this.updateUniforms({ curvatureGainT: T, curvatureBoostMax: boostMax });
}
```

Then your handler is just:

```ts
engineRef.current?.setCurvatureGainDec(v);
```

---

### 3) A couple quick sanity checks if you still don’t see response

* Ensure `updateUniforms` is called from the slider’s **onChange** (not only on mount).
* Confirm you’re **not** also passing a conflicting `userGain` value elsewhere. (Let the engine compute it from `curvatureGainT`.)
* In the fragment shader path you already bind:

  ```js
  gl.uniform1f(gridUniforms.userGain, uniforms?.userGain || 1.0);
  ```

  and the geometry uses the same `userGain`—so both should move together.
* If the effect feels subtle at the low end, try `curvatureBoostMax = 60` (still honest, just a bit punchier).

---

If you paste the handler above, your **Curvature Gain** slider will drive the bend you’re seeing in the screenshot in real time, and the 2D `SliceViewer` will match it exactly.
