diff --git a/warp-engine.js b/warp-engine.js
index 3b6c1a9..f2a77e4 100644
--- a/warp-engine.js
+++ b/warp-engine.js
@@ -1,3 +1,39 @@
+// --- helpers (local) ---------------------------------------------------------
+function _norm3(v) {
+  const x = +v[0] || 0, y = +v[1] || 0, z = +v[2] || 0;
+  const m = Math.hypot(x, y, z) || 1;
+  return [x / m, y / m, z / m];
+}
+function _dotE(a, b) {
+  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
+}
+function _dotG_diag(invG, a, b) {
+  // Fast path for diagonal metric inverse (3x3 stored as 9 numbers or [gxx,gyy,gzz])
+  // Accepts [gxx,0,0, 0,gyy,0, 0,0,gzz] or [gxx, gyy, gzz]
+  const gxx = invG?.[0] ?? invG?.[0] ?? 1;
+  const gyy = invG?.[4] ?? invG?.[1] ?? 1;
+  const gzz = invG?.[8] ?? invG?.[2] ?? 1;
+  return gxx * (a[0] || 0) * (b[0] || 0) + gyy * (a[1] || 0) * (b[1] || 0) + gzz * (a[2] || 0) * (b[2] || 0);
+}
+function _normG(invG, v) {
+  const d = Math.sqrt(Math.max(1e-18, _dotG_diag(invG, v, v)));
+  return [(v[0] || 0) / d, (v[1] || 0) / d, (v[2] || 0) / d];
+}
+// -----------------------------------------------------------------------------
+
@@ -28,12 +64,36 @@ class WarpEngine {
     // ... existing render prep ...
 
-    // NEW: interior tilt displacement (CPU side, gentle Natário tilt)
-    const betaTilt = this.uniforms?.betaTiltVec || [0, -1, 0];
-    const n = normalAt(p); // scene-space surface normal
-    const downDot = (n[0]*betaTilt[0] + n[1]*betaTilt[1] + n[2]*betaTilt[2]);
-    const w_int = Math.max(3.0 * (this.uniforms?.wallWidth || 0.016), 0.02);
+    // Interior tilt displacement (CPU side)
+    // Normalize β to avoid scale leakage; respect metric if in use so CPU == shader
+    const betaRaw  = this.uniforms?.betaTiltVec || [0, -1, 0];
+    const betaUnit = _norm3(betaRaw);
+    const n        = normalAt(p); // scene-space surface normal (may not be unit)
+    const useMetric = !!this.uniforms?.useMetric;
+    const invG      = this.uniforms?.metricInv; // optional diagonal inverse metric
+    const nUnit   = useMetric ? _normG(invG, n)       : _norm3(n);
+    const bUnit   = useMetric ? _normG(invG, betaUnit): betaUnit;
+    const downDot = useMetric ? _dotG_diag(invG, nUnit, bUnit) : _dotE(nUnit, bUnit);
+    // Allow explicit interior width override via `intWidth`; else derive from wall
+    const w_int = Number.isFinite(this.uniforms?.intWidth)
+      ? Math.max(0.002, +this.uniforms.intWidth)
+      : Math.max(3.0 * (this.uniforms?.wallWidth || 0.016), 0.02);
     const inside = isInside(p, w_int);
     if (inside) {
       displaceBy(-this.uniforms.epsilonTilt * downDot);
     }
 
     // ... rest of render loop ...
   }
@@ -110,14 +170,28 @@ class WarpEngine {
   updateUniforms(parameters) {
     const U = this.uniforms || (this.uniforms = {});
-    // q alias (accept qSpoilingFactor)
-    if (Number.isFinite(parameters.qSpoilingFactor)) {
-      U.deltaAOverA = parameters.qSpoilingFactor;
-    }
+    // q alias: accept either qSpoilingFactor or deltaAOverA; keep both for UI parity
+    if (Number.isFinite(parameters.qSpoilingFactor)) U.deltaAOverA = parameters.qSpoilingFactor;
+    if (Number.isFinite(parameters.deltaAOverA))     U.deltaAOverA = parameters.deltaAOverA;
+    if (Number.isFinite(U.deltaAOverA)) U.qSpoilingFactor = U.deltaAOverA;
 
     // γ_VdB with REAL/SHOW clamp; also expose raw for diagnostics
-    U.gammaVanDenBroeck = clampByParity(parameters.gammaVanDenBroeck, this.physicsParityMode);
+    const gammaVdB_raw = Number.isFinite(parameters.gammaVanDenBroeck)
+      ? parameters.gammaVanDenBroeck
+      : (U.gammaVanDenBroeck ?? 1);
+    U.gammaVdBRaw = gammaVdB_raw;
+    U.gammaVanDenBroeck = clampByParity(gammaVdB_raw, this.physicsParityMode);
 
-    // Duty: prefer FR if provided, else local × S_live/S_total
-    const FR = Number.isFinite(parameters.dutyEffectiveFR) ? parameters.dutyEffectiveFR : null;
-    const local = clamp(parameters.dutyCycle, 0, 1);
-    const S_total = Math.max(1, parameters.sectorCount|0);
-    const S_live  = Math.max(1, (parameters.sectorStrobing|0) || 1);
-    U.dutyEffectiveFR = FR ?? (local * (S_live / S_total));
+    // Duty: prefer FR if provided, else derive from local × S_live/S_total
+    const FR       = Number.isFinite(parameters.dutyEffectiveFR) ? parameters.dutyEffectiveFR : null;
+    const local    = clamp(parameters.dutyCycle, 0, 1);
+    const S_total  = Math.max(1, parameters.sectorCount|0);
+    const S_live   = Math.max(1, (parameters.sectorStrobing|0) || 1);
+    U.dutyEffectiveFR = FR ?? (local * (S_live / S_total));
+
+    // Interior gravity uniforms
+    if (Array.isArray(parameters.betaTiltVec)) U.betaTiltVec = parameters.betaTiltVec.slice(0,3);
+    if (Number.isFinite(parameters.epsilonTilt)) U.epsilonTilt = parameters.epsilonTilt;
+    if (Number.isFinite(parameters.intWidth)) U.intWidth = parameters.intWidth;
+
+    // θ: host-provided wins; else compute chain with FR duty
+    if (Number.isFinite(parameters.thetaScale)) {
+      U.thetaScale = parameters.thetaScale;
+    } else {
+      const duty = U.dutyEffectiveFR ?? 0;
+      const ggeo = U.gammaGeo ?? 1, q = U.deltaAOverA ?? 1, gvdB = U.gammaVanDenBroeck ?? 1;
+      U.thetaScale = Math.pow(ggeo, 3) * q * gvdB * Math.sqrt(Math.max(1e-12, duty));
+    }
   }
 }