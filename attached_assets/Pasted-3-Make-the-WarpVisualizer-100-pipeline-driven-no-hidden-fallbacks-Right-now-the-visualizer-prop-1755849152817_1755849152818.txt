3) Make the WarpVisualizer 100% pipeline-driven (no hidden fallbacks)

Right now the visualizer props include “nice” defaults (e.g., 83.3 MW, 5.03e4) that can mask missing data. Build a params object that only passes values when the pipeline/metrics provide finite numbers — the engine already has sane internal defaults.

Replace the inline parameters={(() => { ... })()} block with:

const num = (v: unknown) => (typeof v === "number" && Number.isFinite(v) ? v : undefined);

// Build viz params purely from live pipeline / metrics
const vizParams: any = {
  currentMode: effectiveMode,
  sectorStrobing: sectorsUI,
  cosmeticLevel,
  physicsParityMode: localStorage.getItem("physics-parity-mode") === "true",
  // geometry from live hull if present
  hull: (hullMetrics && hullMetrics.hull) ? {
    a: hullMetrics.hull.a ?? hullMetrics.hull.Lx_m / 2,
    b: hullMetrics.hull.b ?? hullMetrics.hull.Ly_m / 2,
    c: hullMetrics.hull.c ?? hullMetrics.hull.Lz_m / 2
  } : undefined,
  wallWidth_m: 6.0, // protocol constant in your codebase
  epsilonTilt: systemMetrics?.shiftVector?.epsilonTilt ?? epsilonTilt,
  betaTiltVec: (systemMetrics?.shiftVector?.betaTiltVec ?? [0, -1, 0]) as [number, number, number],
  gridScale: 1.6
};

// Only pass numeric fields if the pipeline actually provided them
const maybe = {
  dutyCycle: num(pipeline?.dutyCycle),
  g_y:       num(pipeline?.gammaGeo),
  cavityQ:   num(pipeline?.qCavity),
  sagDepth_nm: num(pipeline?.sagDepth_nm),
  tsRatio:   num(pipeline?.TS_ratio),
  powerAvg_MW: num(pipeline?.P_avg),
  exoticMass_kg: num(pipeline?.M_exotic),
  qSpoilingFactor: num(pipeline?.qSpoilingFactor),
  gammaVanDenBroeck: num(pipeline?.gammaVanDenBroeck),
  curvatureBoostMax: 1,         // neutral (visual), but explicit
  curvatureGainDec:  0          // neutral (visual), but explicit
};

for (const k of Object.keys(maybe) as (keyof typeof maybe)[]) {
  if (maybe[k] !== undefined) vizParams[k] = maybe[k];
}


…and then pass it:

<WarpVisualizer
  key={`mode-${effectiveMode}-v${modeVersion}-parity-${localStorage.getItem('physics-parity-mode')}`}
  parameters={vizParams}
/>


This keeps the visualizer honest: if HELIX-CORE doesn’t return a number for a field, the engine uses its own internal default instead of a UI hard-coded guess. (Your HUD still shows user-friendly placeholders elsewhere — that’s fine.)