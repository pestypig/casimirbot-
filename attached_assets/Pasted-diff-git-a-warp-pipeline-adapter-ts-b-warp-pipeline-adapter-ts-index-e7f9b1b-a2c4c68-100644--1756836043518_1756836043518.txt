diff --git a/warp-pipeline-adapter.ts b/warp-pipeline-adapter.ts
index e7f9b1b..a2c4c68 100644
--- a/warp-pipeline-adapter.ts
+++ b/warp-pipeline-adapter.ts
@@ -1,15 +1,72 @@
 // Pipeline â†’ WarpEngine Adapter
-// Drives renderer uniforms from pipeline state (renderer-safe subset)
+// Drives renderer uniforms from pipeline state (single source of truth, strict)
 
+function aHarmonic(ax: number, ay: number, az: number) {
+  const a = +ax || 0, b = +ay || 0, c = +az || 0;
+  const d = (a>0?1/a:0) + (b>0?1/b:0) + (c>0?1/c:0);
+  return d > 0 ? 3 / d : NaN;
+}
+function req(cond: any, msg: string) {
+  if (!cond) throw new Error(`adapter: ${msg}`);
+}
+
 export interface EnergyPipelineState {
   // ... existing fields ...
+  // strongly recommended fields (strict mode)
+  axesHull?: [number,number,number];
+  wallWidth_m?: number;
+  wallWidth_rho?: number;
+  sectorCount?: number;
+  sectorStrobing?: number;
+  dutyLocal?: number;
+  dutyEffectiveFR?: number;
+  gammaGeo?: number;
+  gammaVanDenBroeck?: number;
+  qSpoilingFactor?: number;
+  thetaScale?: number;
 }
 
 export function driveWarpFromPipeline(engine: any, s: EnergyPipelineState): void {
-  // ... legacy organizing ...
-  gatedUpdateUniforms(engine, {/* ... */}, "server");
+  // Resolve axes
+  const ax = +(s.axesHull?.[0] ?? s.hull?.a ?? s.hull?.Lx_m ?? NaN);
+  const ay = +(s.axesHull?.[1] ?? s.hull?.b ?? s.hull?.Ly_m ?? NaN);
+  const az = +(s.axesHull?.[2] ?? s.hull?.c ?? s.hull?.Lz_m ?? NaN);
+  req(Number.isFinite(ax)&&Number.isFinite(ay)&&Number.isFinite(az), 'missing axesHull[a,b,c]');
+  const axesHull: [number,number,number] = [ax,ay,az];
+  const aH = aHarmonic(ax,ay,az);
+  req(Number.isFinite(aH), 'bad harmonic radius (axes)");
+
+  // Wall width (prefer meters; compute rho)
+  const w_m  = Number.isFinite(s.wallWidth_m)   ? +s.wallWidth_m   : (Number.isFinite(s.wallWidth_rho) ? +s.wallWidth_rho * aH : NaN);
+  const w_rho= Number.isFinite(s.wallWidth_rho) ? +s.wallWidth_rho : (Number.isFinite(s.wallWidth_m)   ? +s.wallWidth_m / aH   : NaN);
+  req(Number.isFinite(w_m) && Number.isFinite(w_rho), 'missing wallWidth_m or wallWidth_rho');
+
+  // Sectors / duty
+  const S_total = s.sectorCount ?? (s.sectorsTotal as any);
+  const S_live  = s.sectorStrobing ?? (s.sectorsConcurrent as any);
+  req(Number.isFinite(S_total)&&Number.isFinite(S_live)&&S_total>=1&&S_live>=1, 'missing sectorCount/sectorStrobing');
+  const dutyLocal = Number.isFinite(s.dutyLocal) ? +s.dutyLocal : (Number.isFinite((s as any).dutyCycle) ? +(s as any).dutyCycle : NaN);
+  req(Number.isFinite(dutyLocal), 'missing dutyLocal/dutyCycle');
+  const dutyEffectiveFR = Number.isFinite(s.dutyEffectiveFR) ? +s.dutyEffectiveFR : (dutyLocal * (S_live/S_total));
+
+  // Physics gains
+  const gammaGeo  = +s.gammaGeo!;
+  const gammaVdB  = +(s.gammaVanDenBroeck ?? (s as any).gammaVanDenBroeck_vis ?? NaN);
+  const qSpoil    = +(s.qSpoilingFactor ?? (s as any).deltaAOverA ?? NaN);
+  req(Number.isFinite(gammaGeo)&&Number.isFinite(gammaVdB)&&Number.isFinite(qSpoil), 'missing gammaGeo/gammaVdB/qSpoilingFactor');
+
+  // Optional authoritative theta
+  const thetaScale = Number.isFinite(s.thetaScale) ? +s.thetaScale : undefined;
+
+  gatedUpdateUniforms(engine, {
+    strictPhysics: true,
+    axesHull,
+    // keep axesScene derived in engine
+    wallWidth: w_rho,
+    wallWidth_rho: w_rho,
+    wallWidth_m: w_m,
+    sectorCount: S_total|0,
+    sectorStrobing: S_live|0,
+    dutyEffectiveFR,
+    gammaGeo,
+    gammaVanDenBroeck: gammaVdB,
+    qSpoilingFactor: qSpoil,
+    lockFraming: true,
+    ...(Number.isFinite(thetaScale) ? { thetaScale } : {})
+  }, "server");
 }