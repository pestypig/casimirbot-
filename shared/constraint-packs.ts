import type { ConstraintPack } from "./schema";

export const repoConvergencePack: ConstraintPack = {
  id: "repo-convergence",
  domain: "repo",
  version: 1,
  description:
    "Build/test convergence with contract + dependency coherence checks, plus time-to-green.",
  signalKinds: {
    diagnostic: "repo-diagnostic",
    certified: "repo-certified",
  },
  policy: {
    mode: "hard-only",
    unknownAsFail: true,
  },
  certificate: {
    issuer: "casimir-verifier",
    admissibleStatus: "GREEN",
    allowMarginalAsViable: false,
    treatMissingCertificateAsNotCertified: true,
  },
  constraints: [
    {
      id: "build_passed",
      severity: "HARD",
      description: "Build completes cleanly.",
      metric: "build.status",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "ci",
      note: "1=success, 0=fail",
    },
    {
      id: "tests_passed",
      severity: "HARD",
      description: "Tests complete with no failures.",
      metric: "tests.status",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "ci",
      note: "1=success, 0=fail",
    },
    {
      id: "schema_contracts_passed",
      severity: "HARD",
      description: "Schema contracts verified (API + types).",
      metric: "schema.contracts",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "schema",
      note: "1=green",
    },
    {
      id: "dependency_coherence_ok",
      severity: "HARD",
      description: "Lockfile + dependency graph coherence.",
      metric: "deps.coherence",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "deps",
      note: "1=green",
    },
    {
      id: "time_to_green_ms",
      severity: "SOFT",
      description: "Time-to-green under target ceiling.",
      metric: "time_to_green_ms",
      op: "<=",
      max: 1_200_000,
      units: "ms",
      source: "ci",
      note: "20 min target",
    },
  ],
  proxies: [
    {
      id: "lint_clean",
      severity: "SOFT",
      description: "Lint is clean (proxy signal).",
      metric: "lint.status",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "lint",
      proxy: true,
      note: "Proxy for build/test convergence.",
    },
    {
      id: "typecheck_clean",
      severity: "SOFT",
      description: "Typecheck is clean (proxy signal).",
      metric: "typecheck.status",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "typecheck",
      proxy: true,
      note: "Proxy for build/test convergence.",
    },
  ],
  traceMapping: {
    passRule: "All HARD constraints pass; SOFT constraints are diagnostic.",
    firstFailRule: "First HARD failure in list order.",
    signalKindRule: {
      certified: "pass + certificate hash + integrity OK",
      diagnostic: "otherwise",
    },
  },
  artifacts: {
    metricsRef: "repo-convergence:metrics",
    reportRef: "repo-convergence:report",
  },
};

export const toolUseBudgetPack: ConstraintPack = {
  id: "tool-use-budget",
  domain: "agent-runtime",
  version: 1,
  description:
    "Tool-use governance: step/cost limits, forbidden ops, approvals, provenance.",
  signalKinds: {
    diagnostic: "tool-budget-diagnostic",
    certified: "tool-budget-certified",
  },
  policy: {
    mode: "hard-only",
    unknownAsFail: true,
  },
  certificate: {
    issuer: "casimir-policy",
    admissibleStatus: "APPROVED",
    allowMarginalAsViable: false,
    treatMissingCertificateAsNotCertified: true,
  },
  constraints: [
    {
      id: "step_limit",
      severity: "HARD",
      description: "Step limit within policy.",
      metric: "steps.used",
      op: "<=",
      max: 32,
      units: "steps",
      source: "runtime",
    },
    {
      id: "cost_ceiling_usd",
      severity: "HARD",
      description: "Cost ceiling within policy.",
      metric: "cost.usd",
      op: "<=",
      max: 5,
      units: "usd",
      source: "billing",
    },
    {
      id: "forbidden_ops_count",
      severity: "HARD",
      description: "Forbidden operations executed.",
      metric: "ops.forbidden.count",
      op: "<=",
      max: 0,
      units: "count",
      source: "policy",
    },
    {
      id: "approval_required_missing",
      severity: "HARD",
      description: "Approval-required operations missing approval.",
      metric: "ops.approval_missing.count",
      op: "<=",
      max: 0,
      units: "count",
      source: "policy",
    },
    {
      id: "provenance_missing",
      severity: "HARD",
      description: "Missing provenance for external data/tools.",
      metric: "provenance.missing.count",
      op: "<=",
      max: 0,
      units: "count",
      source: "policy",
    },
    {
      id: "runtime_ms",
      severity: "SOFT",
      description: "Runtime under target ceiling.",
      metric: "runtime.ms",
      op: "<=",
      max: 120_000,
      units: "ms",
      source: "runtime",
    },
    {
      id: "tool_calls",
      severity: "SOFT",
      description: "Tool calls under target ceiling.",
      metric: "tools.calls",
      op: "<=",
      max: 16,
      units: "count",
      source: "runtime",
    },
  ],
  traceMapping: {
    passRule: "All HARD constraints pass; SOFT constraints are diagnostic.",
    firstFailRule: "First HARD failure in list order.",
    signalKindRule: {
      certified: "pass + certificate hash + integrity OK",
      diagnostic: "otherwise",
    },
  },
  artifacts: {
    metricsRef: "tool-use-budget:metrics",
    reportRef: "tool-use-budget:report",
  },
};

export const provenanceSafetyPack: ConstraintPack = {
  id: "provenance-safety",
  domain: "audit",
  version: 1,
  description:
    "Audit-tag safety: provenance + verification coverage for risky IO/security surfaces.",
  signalKinds: {
    diagnostic: "audit-diagnostic",
    certified: "audit-certified",
  },
  policy: {
    mode: "hard-only",
    unknownAsFail: true,
  },
  certificate: {
    issuer: "casimir-audit",
    admissibleStatus: "SAFE",
    allowMarginalAsViable: false,
    treatMissingCertificateAsNotCertified: true,
  },
  constraints: [
    {
      id: "unknown_audit_tags",
      severity: "HARD",
      description: "No unknown audit tags.",
      metric: "audit.unknown_tags.count",
      op: "<=",
      max: 0,
      units: "count",
      source: "audit",
    },
    {
      id: "audit_violations",
      severity: "HARD",
      description: "No explicit audit violations.",
      metric: "audit.violations.count",
      op: "<=",
      max: 0,
      units: "count",
      source: "audit",
    },
    {
      id: "provenance_coverage",
      severity: "HARD",
      description: "Provenance protocol present when risk tags exist.",
      metric: "audit.provenance.coverage",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "audit",
      note: "1=covered, 0=missing",
    },
    {
      id: "safety_coverage",
      severity: "HARD",
      description: "Verification checklist present when risk tags exist.",
      metric: "audit.safety.coverage",
      op: "eq",
      limit: 1,
      units: "boolean",
      source: "audit",
      note: "1=covered, 0=missing",
    },
    {
      id: "untagged_files",
      severity: "SOFT",
      description: "All files have at least one audit tag.",
      metric: "audit.untagged.count",
      op: "<=",
      max: 0,
      units: "count",
      source: "audit",
    },
  ],
  traceMapping: {
    passRule: "All HARD constraints pass; SOFT constraints are diagnostic.",
    firstFailRule: "First HARD failure in list order.",
    signalKindRule: {
      certified: "pass + certificate hash + integrity OK",
      diagnostic: "otherwise",
    },
  },
  artifacts: {
    metricsRef: "provenance-safety:metrics",
    reportRef: "provenance-safety:report",
  },
};

export const constraintPacks: ConstraintPack[] = [
  repoConvergencePack,
  toolUseBudgetPack,
  provenanceSafetyPack,
];

export const getConstraintPackById = (id: string): ConstraintPack | undefined =>
  constraintPacks.find((pack) => pack.id === id);
